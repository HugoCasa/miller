from .utils import generate_sample, parse_code, yaml_dump
from typing import TypedDict
from tqdm import tqdm
import yaml
import random


GEN_SYSTEM_PROMPT_DENO = """
You are helping a user create scripts for a developer platform from instructions related to a specific integration .

You have the following requirements:
You have to export a "main" function written TypeScript like this: "export async function main(...)" and specify the parameter types but do not call it.
You can import deno libraries or you can also import npm libraries like that: "import ... from "npm:{package}";". The fetch standard method is available globally.

You can take as parameters resources which are dictionaries containing credentials or configuration information. The name of the resource type has to be exactly the name of the integration, if not the script is useless. It it conflicts with the name of an imported method, you have to rename the imported method.
The resource type should only contain properties that are needed for authentication/configuration and should be relevant to any script related to this integration. Put the properties only specific to this script in the parameters of the function.
If the integration involves OAUTH2, do not implement the OAUTH2 flow, just assume the appropriate crendentials are included in the resource type.

The function has to be directly usable. If there is a value that needs to be defined by the user, define it as a parameter of the function.
Do not include comments that explain your process or that suggest additional modifications to be done by the user.

Try to think step by step how you would write the script and ensure that it respects the requirements.

Here's a script template to help you get started:
```typescript
// import any libraries you need here

type Example = {
    // any properties you want like credentials or configuration
}

export async function main(exampleResource: Example, /* any other params you think might be useful for the script purpose, define their types inline */) {
    // do something with the integration using the integration resource and any params you might need

    // always return the result
}
```

At the end of your answer, return the complete script in a code block.
"""

GEN_SYSTEM_PROMPT_PYTHON = """
You are helping a user create scripts for a developer platform from instructions related to a specific integration .

You have the following requirements:
You have to export a "main" function written in Python and specify the parameter types but do not call it.

You can take as parameters resources which are dictionaries containing credentials or configuration information. The name of the resource type has to be exactly the name of the integration and in lowercase, if not the script is useless. It it conflicts with the name of an imported method, you have to rename the imported method.
The resource type should only contain properties that are needed for authentication/configuration and should be relevant to any script related to this integration. Put the properties only specific to this script in the parameters of the function.
If the integration involves OAUTH2, do not implement the OAUTH2 flow, just assume the appropriate crendentials are included in the resource type.

The function has to be directly usable. If there is a value that needs to be defined by the user, define it as a parameter of the function.
Do not include comments that explain your process or that suggest additional modifications to be done by the user.

Try to think step by step how you would write the script and ensure that it respects the requirements.

Here's a script template to help you get started:
```python
from typing import TypedDict
// import any libraries you need here

class example(TypedDict):
    // any properties you want like credentials or configuration

def main(example_resource: example, /* any other params you think might be useful for the script purpose, define their types inline */):
    // do something with the integration using the integration resource and any params you might need

    // always return the result

```

At the end of your answer, return the complete script in a code block.
"""

GEN_PROMPT = """
Instructions: {name}
Integration: {integration}
"""

FINETUNING_SYSTEM_PROMPT_DENO = """
You are reviewing a script generated by an AI from instructions related to a specific integration for a developer platform. 

You have to make sure it respects the following requirements:
- the name of the resource type has to be exactly the name of the integration: {integration}, if not the script is useless. It it conflicts with the name of an imported method, you have to rename the imported method.
- the resource type should only contain properties that are needed for authentication/configuration and should be relevant to any script related to this integration. Put the properties only specific to this script in the parameters of the function.

If you think the script respects the requirements return the code block as is.
If the script does not respect the requirements, explain what is wrong with the script regarding the requirements, then fix it.
At the end of your answer, return the updated script in a code block.
Do not include comments that explain what you changed.
"""

FINETUNING_SYSTEM_PROMPT_PYTHON = """
You are reviewing a script generated by an AI from instructions related to a specific integration for a developer platform. 

You have to make sure it respects the following requirements:
- the name of the resource type has to be exactly the name of the integration: {integration}, if not the script is useless. It it conflicts with the name of an imported method, you have to rename the imported method.
- the resource type should only contain properties that are needed for authentication/configuration and should be relevant to any script related to this integration. Put the properties only specific to this script in the parameters of the function.

If you think the script respects the requirements return the code block as is.
If the script does not respect the requirements, explain what is wrong with the script regarding the requirements, then fix it.
At the end of your answer, return the updated script in a code block.
Do not include comments that explain what you changed.
"""


FINETUNING_PROMPT_DENO = """
Instructions: {name}
Integration: {integration}
Code:
```typescript
{code}
```
"""

FINETUNING_PROMPT_PYTHON = """
Instructions: {name}
Integration: {integration}
Code:
```python
{code}
```
"""


class Action(TypedDict):
    name: str
    description: str
    id: str
    integration: str


def generate_script(action: Action, lang: str):
    # integration to CamelCase for typescript
    resource_type = (
        "".join([word.capitalize() for word in action["integration"].split("_")])
        if lang == "deno"
        else action["integration"]
    )

    # first step
    prompt = GEN_PROMPT.format(name=action["name"], integration=resource_type)
    draft = generate_sample(
        [
            {
                "role": "system",
                "content": GEN_SYSTEM_PROMPT_PYTHON
                if lang == "python"
                else GEN_SYSTEM_PROMPT_DENO,
            },
            {
                "role": "user",
                "content": prompt,
            },
        ]
    )

    code = parse_code(draft)

    if code == "":
        raise Exception("Did not find code in draft answer")

    final_code = code
    # finetuning step
    prompt = (
        FINETUNING_PROMPT_DENO if lang == "deno" else FINETUNING_PROMPT_PYTHON
    ).format(name=action["name"], integration=resource_type, code=code)
    final = generate_sample(
        [
            {
                "role": "system",
                "content": (
                    FINETUNING_SYSTEM_PROMPT_DENO
                    if lang == "deno"
                    else FINETUNING_SYSTEM_PROMPT_PYTHON
                ).format(integration=resource_type),
            },
            {
                "role": "user",
                "content": prompt,
            },
        ]
    )

    print(final)

    final_code = parse_code(final)

    if final_code == "":
        raise Exception("Did not find code in final prompt")
    else:
        return code, final_code, resource_type


def generate_scripts(scripts: list[dict[str, str]], lang: str):
    generated_scripts = []
    for script in tqdm(scripts):
        code, final_code, resource_type = generate_script(script, lang)
        generated_scripts.append(
            {
                "name": script["name"],
                "description": script["description"],
                "id": script["id"],
                "integration": script["integration"],
                "first_code": code,
                "final_code": final_code,
                "lang": lang,
                "resource_type": resource_type,
            }
        )
        with open(f"./data/synthetic/pipedream_generated_{lang}.yaml", "w") as f:
            yaml_dump(generated_scripts, f)
    return generated_scripts


if __name__ == "__main__":
    with open("./data/utils/integrations.yaml") as f:
        scripts = yaml.safe_load(f)

        print(f"We have {len(scripts)} scripts to generate")

        # random sample 4 from scripts
        random.seed(42)
        random.shuffle(scripts)

        generate_scripts(scripts[1000:], "deno")
        generate_scripts(scripts[1000:], "python")
