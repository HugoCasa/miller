- bad: |-
    import { Lighthouse } from "npm:@lighthouse-web/api";

    type Lighthouse = {
        apiKey: string;
        projectId: string;
    }

    export async function main(lighthouseResource: Lighthouse, milestoneTitle: string, milestoneDescription: string, dueDate: string) {
        const lighthouseClient = new Lighthouse({ apiKey: lighthouseResource.apiKey });

        const result = await lighthouseClient.createMilestone({
            projectId: lighthouseResource.projectId,
            title: milestoneTitle,
            description: milestoneDescription,
            due_on: dueDate
        });

        return result;
    }
  good: |-
    import { Lighthouse as LighthouseClient } from "npm:@lighthouse/server";

    type Lighthouse = {
        apiKey: string;
        projectId: string;
    }

    export async function main(lighthouseResource: Lighthouse, milestoneTitle: string, milestoneDescription: string, dueDate: string) {
        const lighthouseClient = new LighthouseClient(lighthouseResource.apiKey);

        const newMilestone = await lighthouseClient.milestones.create({
            projectId: lighthouseResource.projectId,
            title: milestoneTitle,
            description: milestoneDescription,
            dueDate: dueDate
        });

        return newMilestone;
    }
  id: |-
    synthetic_create-milestone
  instructions: |-
    Creates a milestone in lighthouse
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lighthouse
  resource_type_def: |-
    type Lighthouse = {
        apiKey: string;
        projectId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    class bingx(TypedDict):
        api_key: str
        api_secret: str

    def main(bingx_resource: bingx, symbol: str) -> Any:
        base_url = "https://api.bingx.com/v1"
        endpoint = f"/market/fundingRate?symbol={symbol}"
        headers = {
            "X-BingX-APIKEY": bingx_resource['api_key'],
            "X-BingX-SECRET": bingx_resource['api_secret']
        }

        response = requests.get(base_url + endpoint, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to the BingX API

    class bingx(TypedDict):
        api_key: str
        api_secret: str
        # Add other authentication properties if needed

    def main(bingx_resource: bingx, symbol: str) -> float:
        # Assuming the BingX API requires an API key and secret for authentication
        # and that the current funding rate can be retrieved by making a GET request
        # to a specific endpoint with the symbol as a query parameter.

        # Define the endpoint URL
        url = f"https://api.bingx.com/v1/contract/fundingRate?symbol={symbol}"

        # Set up the headers with the API key
        headers = {
            "X-BingX-APIKEY": bingx_resource['api_key'],
            "X-BingX-SECRET": bingx_resource['api_secret']
        }

        # Make the GET request to the BingX API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            # Assuming the funding rate is in a field called 'currentFundingRate'
            funding_rate = data.get('currentFundingRate', None)
            if funding_rate is not None:
                return funding_rate
            else:
                raise ValueError("Current funding rate not found in the response.")
        else:
            # Handle errors
            raise ConnectionError(f"Failed to get current funding rate: {response.status_code} - {response.text}")

    # Note: The actual endpoint, headers, and response format should be replaced with the correct ones
    # according to the BingX API documentation.
  id: |-
    synthetic_market-get-latest-funding
  instructions: |-
    Current Funding Rate. in bingx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bingx
  resource_type_def: |-
    class bingx(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Client } from "npm:@giantcampaign/sdk"; // Assuming there's an SDK available on npm

    type Giantcampaign = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(giantcampaignResource: Giantcampaign, subscriberEmail: string, tags: string[]) {
        const client = new Client(giantcampaignResource.apiKey, giantcampaignResource.baseUrl);

        // Assuming the SDK has a method to add tags to a subscriber
        const result = await client.addTagsToSubscriber(subscriberEmail, tags);

        return result;
    }
  good: |-
    type Giantcampaign = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(giantcampaignResource: Giantcampaign, subscriberId: string, tags: string[]) {
        const url = `${giantcampaignResource.baseUrl}/subscribers/${subscriberId}/tags`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${giantcampaignResource.apiKey}`
            },
            body: JSON.stringify({ tags })
        });

        if (!response.ok) {
            throw new Error(`Failed to add tags to subscriber: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-tags-to-subscriber
  instructions: |-
    Add tags to a new subscriber. in giantcampaign
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Giantcampaign
  resource_type_def: |-
    type Giantcampaign = {
        apiKey: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import googleapiclient.discovery

    class google_analytics(TypedDict):
        api_key: str

    def main(google_analytics_resource: google_analytics, view_id: str, start_date: str, end_date: str, metrics: list[str], dimensions: list[str] = []) -> Any:
        analytics = googleapiclient.discovery.build('analytics', 'v3', developerKey=google_analytics_resource['api_key'])
        return analytics.data().ga().get(
            ids='ga:' + view_id,
            start_date=start_date,
            end_date=end_date,
            metrics=','.join(metrics),
            dimensions=','.join(dimensions)
        ).execute()
  good: |-
    from typing import TypedDict, Dict, Any
    import datetime
    # import any other libraries you might need

    class google_analytics(TypedDict):
        client_email: str
        private_key: str
        view_id: str

    def main(google_analytics_resource: google_analytics, start_date: datetime.date, end_date: datetime.date) -> Dict[str, Any]:
        # Assuming the Google Analytics API client is already set up and authenticated with the provided credentials
        from googleapiclient.discovery import build as google_build
        from google.oauth2.service_account import Credentials as ServiceAccountCredentials

        # Construct credentials
        credentials = ServiceAccountCredentials.from_service_account_info({
            'client_email': google_analytics_resource['client_email'],
            'private_key': google_analytics_resource['private_key'],
            'token_uri': 'https://oauth2.googleapis.com/token',
            'scopes': ['https://www.googleapis.com/auth/analytics.readonly'],
        })

        # Build the service object
        analytics = google_build('analyticsreporting', 'v4', credentials=credentials)

        # Create the report request
        report_request = {
            'viewId': google_analytics_resource['view_id'],
            'dateRanges': [{'startDate': start_date.isoformat(), 'endDate': end_date.isoformat()}],
            'metrics': [{'expression': 'ga:sessions'}, {'expression': 'ga:pageviews'}],
            # Add dimensions, filters, segments, etc. as needed
        }

        # Use the Analytics Reporting API V4 to get the report
        response = analytics.reports().batchGet(
            body={'reportRequests': [report_request]}
        ).execute()

        # Process the response object and return the desired metrics
        # This is a simplified example of processing. The actual implementation will depend on the response structure.
        report_metrics = {
            'sessions': 0,
            'pageviews': 0
        }
        for report in response.get('reports', []):
            columnHeader = report.get('columnHeader', {})
            metricHeaders = columnHeader.get('metricHeader', {}).get('metricHeaderEntries', [])
            rows = report.get('data', {}).get('rows', [])

            for row in rows:
                metrics = row.get('metrics', [])
                for i, values in enumerate(metrics[0].get('values', [])):
                    metric_name = metricHeaders[i].get('name').replace('ga:', '')
                    report_metrics[metric_name] += int(values)

        return report_metrics

    # Note: The function does not call itself, it's meant to be used by the user with the appropriate parameters.
  id: |-
    synthetic_run-report
  instructions: |-
    Return report metrics based on a start and end date in google analytics
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_analytics
  resource_type_def: |-
    class google_analytics(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        zoneId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, sslSetting: 'off' | 'flexible' | 'full' | 'strict') {
        const url = `https://api.cloudflare.com/client/v4/zones/${cloudflareResource.zoneId}/settings/ssl`;

        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'X-Auth-Email': cloudflareResource.email,
                'X-Auth-Key': cloudflareResource.apiKey,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ value: sslSetting }),
        });

        const data = await response.json();

        return data;
    }
  good: |-
    import { Cloudflare } from "npm:@cloudflare/client";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, zoneId: string, sslSetting: 'off' | 'flexible' | 'full' | 'strict') {
        const cloudflare = new Cloudflare({
            apiKey: cloudflareResource.apiKey,
            email: cloudflareResource.email
        });

        const result = await cloudflare.zones.editZoneSSLSetting(zoneId, { value: sslSetting });

        return result;
    }
  id: |-
    synthetic_change-ssl-setting
  instructions: |-
    Choose the appropriate SSL setting for your zone in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        apiKey: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:querystring";

    type Alpaca = {
        apiKey: string;
        apiSecret: string;
        baseUrl: string;
    }

    export async function main(alpacaResource: Alpaca, queryParams?: { [key: string]: string | number }) {
        const url = new URL('/v2/orders', alpacaResource.baseUrl);
        if (queryParams) {
            url.search = encode(queryParams);
        }

        const response = await fetch(url.toString(), {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': alpacaResource.apiKey,
                'APCA-API-SECRET-KEY': alpacaResource.apiSecret,
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching orders: ${response.statusText}`);
        }

        const orders = await response.json();
        return orders;
    }
  good: |-
    import { AlpacaClient } from "npm:@alpacahq/alpaca-trade-api";

    type Alpaca = {
        apiKeyId: string;
        secretKey: string;
        paper: boolean;
    }

    export async function main(alpacaResource: Alpaca, status?: string, limit?: number, after?: string, until?: string, direction?: 'asc' | 'desc') {
        const alpaca = new AlpacaClient({
            credentials: {
                keyId: alpacaResource.apiKeyId,
                secretKey: alpacaResource.secretKey,
                paper: alpacaResource.paper,
            },
        });

        const params = {
            status,
            limit,
            after,
            until,
            direction
        };

        const orders = await alpaca.orders.list(params);

        return orders;
    }
  id: |-
    synthetic_list-orders
  instructions: |-
    Retrieves a list of orders for the account, filtered by the supplied query parameters, if no filter given all will be returned, in alpaca
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Alpaca
  resource_type_def: |-
    type Alpaca = {
        apiKeyId: string;
        secretKey: string;
        paper: boolean;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to the Calendly API

    class calendly_v2(TypedDict):
        api_key: str

    def main(calendly_resource: calendly_v2, event_uri: str) -> dict:
        headers = {
            'Authorization': f"Bearer {calendly_resource['api_key']}"
        }
        response = requests.get(event_uri, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the calendly_v2 integration
    class calendly_v2(TypedDict):
        api_key: str

    def main(calendly_resource: calendly_v2, event_uuid: str) -> Dict[str, Any]:
        # Set up the headers for authentication
        headers = {
            'Authorization': f"Bearer {calendly_resource['api_key']}"
        }

        # Define the endpoint for getting an event
        endpoint = f"https://api.calendly.com/scheduled_events/{event_uuid}"

        # Make the HTTP request to get the event details
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the event details
            return response.json()
        else:
            # Return the error
            return {'error': response.json()}

    # Note: The function is not called here, it's just defined and ready to be exported.
  id: |-
    synthetic_get-event
  instructions: |-
    Gets information about an Event associated with a URI. in calendly v2
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    calendly_v2
  resource_type_def: |-
    class calendly_v2(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the 'livestorm' integration
    class livestorm(TypedDict):
        api_key: str

    # Define the main function that lists attendees from a specific event
    def main(livestorm_resource: livestorm, event_id: str) -> List[dict]:
        import requests  # Import requests or another HTTP library if needed

        # Define the base URL for the Livestorm API
        base_url = "https://api.livestorm.co"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {livestorm_resource['api_key']}"
        }

        # Define the endpoint for fetching attendees
        attendees_endpoint = f"/v1/events/{event_id}/attendees"

        # Make the request to the Livestorm API
        response = requests.get(f"{base_url}{attendees_endpoint}", headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the list of attendees
            return response.json()['data']
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the livestorm integration
    class livestorm(TypedDict):
        api_key: str
        event_id: str

    # Define the main function with the livestorm resource and any additional parameters
    def main(livestorm_resource: livestorm) -> List[dict]:
        # Base URL for Livestorm API
        base_url = "https://api.livestorm.co"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {livestorm_resource['api_key']}"
        }

        # Endpoint to list sessions of an event
        sessions_endpoint = f"{base_url}/v1/events/{livestorm_resource['event_id']}/sessions"

        # Make a request to get all sessions for the event
        sessions_response = requests.get(sessions_endpoint, headers=headers)
        sessions_response.raise_for_status()  # Raise an error for bad responses
        sessions = sessions_response.json()

        # List to hold all people linked to all sessions
        all_people = []

        # Iterate over each session to get the people linked to it
        for session in sessions:
            session_id = session['id']

            # Endpoint to list people for a session
            people_endpoint = f"{base_url}/v1/sessions/{session_id}/people"

            # Make a request to get all people for the session
            people_response = requests.get(people_endpoint, headers=headers)
            people_response.raise_for_status()  # Raise an error for bad responses
            people = people_response.json()

            # Add the people to the all_people list
            all_people.extend(people)

        # Return the list of all people linked to all sessions
        return all_people

    # Note: The function is not called here, it is just defined and ready to be exported.
  id: |-
    synthetic_list-attendees-from-event
  instructions: |-
    List all the people linked to all the sessions of an event in livestorm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    livestorm
  resource_type_def: |-
    class livestorm(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const timestamp = new Date().getTime();
        const params = `api_key=${bybitResource.apiKey}&symbol=${symbol}&timestamp=${timestamp}`;
        const signature = createHmac('sha256', bybitResource.apiSecret)
                          .update(params)
                          .digest('hex');
        const url = `${bybitResource.endpoint}/v2/private/order/list?${params}&sign=${signature}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    };

    export async function main(
        bybitResource: Bybit,
        symbol: string,
        limit?: number,
        orderStatus?: string
    ) {
        const { apiKey, apiSecret, endpoint } = bybitResource;
        const timestamp = new Date().getTime();
        const params = {
            api_key: apiKey,
            timestamp,
            symbol,
            limit,
            order_status: orderStatus,
        };

        // Remove undefined or null parameters
        Object.keys(params).forEach((key) => params[key] == null && delete params[key]);

        // Create the query string
        const queryString = Object.keys(params)
            .map((key) => `${key}=${encodeURIComponent(params[key])}`)
            .join('&');

        // Sign the request
        const signature = createHmac('sha256', apiSecret)
            .update(queryString)
            .digest('hex');

        // Append signature to the query string
        const signedQueryString = `${queryString}&sign=${signature}`;

        // Make the request to Bybit API
        const response = await fetch(`${endpoint}/v2/private/order/list?${signedQueryString}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
        });

        // Parse the response
        const data = await response.json();

        // Always return the result
        return data;
    }
  id: |-
    synthetic_linear-order-list
  instructions: |-
    List of active orders. in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Esputnik = {
        username: string;
        password: string;
        apiUrl: string;
    }

    export async function main(
        esputnikResource: Esputnik,
        contactId: number,
        updatedFields: { [key: string]: any }
    ) {
        // Encode credentials
        const credentials = encode(`${esputnikResource.username}:${esputnikResource.password}`);

        // Prepare the request headers
        const headers = new Headers({
            'Authorization': `Basic ${credentials}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        });

        // Prepare the request body
        const body = JSON.stringify({
            contacts: [
                {
                    id: contactId,
                    fields: updatedFields
                }
            ]
        });

        // Make the request to update the contact
        const response = await fetch(`${esputnikResource.apiUrl}/v1/contact/update`, {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Check for errors in the response
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Return the result
        return await response.json();
    }
  good: |-
    // Import necessary libraries
    import { Contact, Field } from "npm:@esputnik/api";

    type Esputnik = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(esputnikResource: Esputnik, contactId: number, updatedFields: Field[], contactEmail?: string) {
        // Construct the headers for the API request
        const headers = new Headers({
            'Authorization': `Basic ${btoa(esputnikResource.apiKey)}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        });

        // Construct the body of the request with the updated fields
        const body = JSON.stringify({
            id: contactId,
            fields: updatedFields,
            ...(contactEmail && { email: contactEmail }) // Include email if provided
        });

        // Make the API request to update the contact
        const response = await fetch(`${esputnikResource.apiUrl}/v1/contact`, {
            method: 'PUT',
            headers: headers,
            body: body
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`Failed to update contact: ${response.status} ${response.statusText}`);
        }

        // Return the result of the update operation
        return await response.json();
    }
  id: |-
    synthetic_update-contact
  instructions: |-
    Update an existing contact in eSputnik in esputnik
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Esputnik
  resource_type_def: |-
    type Esputnik = {
        username: string;
        password: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { LinearClient } from "npm:@linear/sdk";

    type LinearApp = {
        apiKey: string;
    }

    export async function main(linearResource: LinearApp, issueId: string) {
        const linearClient = new LinearClient({ apiKey: linearResource.apiKey });
        const issue = await linearClient.issue(issueId);

        return issue;
    }
  good: |-
    // Importing necessary libraries
    import { LinearClient } from "npm:@linear/sdk";

    type LinearApp = {
        apiKey: string;
    }

    export async function main(linearResource: LinearApp, issueId: string) {
        // Initialize the Linear client with the provided API key
        const linearClient = new LinearClient({ apiKey: linearResource.apiKey });

        // Fetch the issue by ID
        const issue = await linearClient.issue(issueId);

        // Return the issue details
        return issue;
    }
  id: |-
    synthetic_get-issue
  instructions: |-
    Get an issue by ID (API Key). See the docs in linear app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    LinearApp
  resource_type_def: |-
    type LinearApp = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { DNSRecord as CloudflareDNSRecord, zones } from "npm:@cloudflare/dns";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, zoneId: string, records: CloudflareDNSRecord[]) {
        const { apiKey, email } = cloudflareResource;

        const headers = new Headers({
            "X-Auth-Email": email,
            "X-Auth-Key": apiKey,
            "Content-Type": "application/json"
        });

        const baseUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/dns_records`;

        const results = [];

        for (const record of records) {
            const response = await fetch(baseUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(record)
            });

            const data = await response.json();
            results.push(data);
        }

        return results;
    }
  good: |-
    import { parseZoneFile } from "npm:zone-file";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        zoneId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, bindConfig: string) {
        const endpoint = `https://api.cloudflare.com/client/v4/zones/${cloudflareResource.zoneId}/dns_records`;
        const parsedZone = parseZoneFile(bindConfig);

        const headers = {
            "X-Auth-Email": cloudflareResource.email,
            "X-Auth-Key": cloudflareResource.apiKey,
            "Content-Type": "application/json"
        };

        const createDnsRecord = async (record: any) => {
            const body = JSON.stringify({
                type: record.type,
                name: record.name,
                content: record.content,
                ttl: record.ttl || 1,
                priority: record.priority || 0,
                proxied: record.proxied || false,
            });

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: headers,
                body: body
            });

            return response.json();
        };

        const results = [];
        for (const record of parsedZone) {
            const result = await createDnsRecord(record);
            results.push(result);
        }

        return results;
    }
  id: |-
    synthetic_import-dns-records
  instructions: |-
    Import a BIND config into a zone in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        apiKey: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for making HTTP requests
    import { HttpClient } from "npm:@angular/common/http";

    type Monkeylearn = {
        apiKey: string;
        classifierId: string;
    }

    export async function main(
        monkeylearnResource: Monkeylearn,
        data: { text: string; tags?: string[] }[],
        updateExisting: boolean = false
    ) {
        const httpClient = new HttpClient();

        // Endpoint for the Monkeylearn classifier
        const endpoint = `https://api.monkeylearn.com/v3/classifiers/${monkeylearnResource.classifierId}/upload/`;

        // Prepare the headers for the API request
        const headers = {
            'Authorization': `Token ${monkeylearnResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        // Prepare the body of the request
        const body = {
            data: data.map(item => ({
                text: item.text,
                tags: item.tags
            })),
            update_existing: updateExisting
        };

        // Make the POST request to upload data to the classifier
        try {
            const response = await httpClient.post(endpoint, body, { headers: headers }).toPromise();
            return response;
        } catch (error) {
            // Handle any errors that occur during the API request
            console.error('Error uploading data to Monkeylearn classifier:', error);
            throw error;
        }
    }
  good: |-
    import { FormData } from "npm:@deno/form-data";

    type Monkeylearn = {
        apiKey: string;
    }

    export async function main(monkeylearnResource: Monkeylearn, modelId: string, trainingData: { text: string, tags: string[] }[]) {
        const formData = new FormData();
        formData.append('data', JSON.stringify(trainingData));

        const response = await fetch(`https://api.monkeylearn.com/v3/classifiers/${modelId}/data/`, {
            method: 'POST',
            headers: {
                'Authorization': `Token ${monkeylearnResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Error uploading training data: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_upload-training-data
  instructions: |-
    Uploads data to a classifier. This component can be used to upload new data to a classifier, to update the tags of texts that have already been uploaded, or both in monkeylearn
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Monkeylearn
  resource_type_def: |-
    type Monkeylearn = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'chatbot' integration
    class chatbot(TypedDict):
        api_key: str
        api_secret: str

    # Main function to create a user for the chatbot integration
    def main(chatbot_resource: chatbot, username: str, email: str):
        # Assuming there's a library for the chatbot integration
        from chatbot_api import create_user

        # Use the chatbot resource to authenticate and create a user
        result = create_user(api_key=chatbot_resource['api_key'], api_secret=chatbot_resource['api_secret'], username=username, email=email)

        # Return the result of the user creation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'chatbot' integration
    class chatbot(TypedDict):
        api_key: str
        api_secret: str
        bot_id: str

    # Define the main function for creating a new user in the chatbot
    def main(chatbot_resource: chatbot, user_name: str, user_email: str):
        # Assuming there's a library to interact with the chatbot API
        from chatbot_api import create_user as create_chatbot_user

        # Use the chatbot resource credentials to authenticate with the chatbot API
        auth_credentials = {
            'api_key': chatbot_resource['api_key'],
            'api_secret': chatbot_resource['api_secret']
        }

        # Create a new user in the chatbot with the provided name and email
        result = create_chatbot_user(auth_credentials, chatbot_resource['bot_id'], user_name, user_email)

        # Return the result of the user creation process
        return result
  id: |-
    synthetic_create-user
  instructions: |-
    Creates new user in chatbot
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    chatbot
  resource_type_def: |-
    class chatbot(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Formstack = {
        apiKey: string,
        formId: string
    }

    export async function main(formstackResource: Formstack, submissionData: Record<string, any>) {
        const url = `https://www.formstack.com/api/v2/form/${formstackResource.formId}/submission.json`;
        const headers = {
            'Authorization': `Bearer ${formstackResource.apiKey}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };
        const body = JSON.stringify({
            data: submissionData
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { FormstackClient } from "npm:formstack";

    type Formstack = {
        apiKey: string,
        server: string
    }

    export async function main(formstackResource: Formstack, formId: string, submissionData: Record<string, any>) {
        const formstack = new FormstackClient(formstackResource.apiKey, formstackResource.server);

        const result = await formstack.submitForm(formId, submissionData);

        return result;
    }
  id: |-
    synthetic_create-form-submission
  instructions: |-
    Create a new submission for the specified form in formstack
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Formstack
  resource_type_def: |-
    type Formstack = {
        apiKey: string,
        server: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Mailchimp } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: Mailchimp) {
        Mailchimp.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        try {
            const response = await Mailchimp.lists.getAllLists();
            return response;
        } catch (error) {
            console.error('Error fetching lists from Mailchimp:', error);
            throw error;
        }
    }
  good: |-
    import { Lists } from "npm:mailchimp-api-v3"; // Assuming mailchimp-api-v3 is the npm package for Mailchimp

    type Mailchimp = {
        apiKey: string,
        serverPrefix: string // Mailchimp data centers are prefixed to the API key, e.g. 'us1', 'us2', etc.
    }

    export async function main(mailchimpResource: Mailchimp, searchQuery?: string) {
        const mailchimp = new Lists({
            apiKey: mailchimpResource.apiKey,
            serverPrefix: mailchimpResource.serverPrefix
        });

        const searchParams = searchQuery ? { fields: "lists.name,lists.id", query: searchQuery } : { fields: "lists.name,lists.id" };
        const lists = await mailchimp.getLists(searchParams);

        return lists;
    }
  id: |-
    synthetic_get-list
  instructions: |-
    Searches for lists in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Campayn API

    class campayn(TypedDict):
        api_key: str
        base_url: str

    def main(campayn_resource: campayn, first_name: str, last_name: str, email: str, list_id: int):
        headers = {
            'Authorization': f'Bearer {campayn_resource["api_key"]}',
            'Content-Type': 'application/json'
        }
        payload = {
            'first_name': first_name,
            'last_name': last_name,
            'email': email
        }
        response = requests.post(
            f'{campayn_resource["base_url"]}/lists/{list_id}/contacts',
            headers=headers,
            json=payload
        )
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'campayn' integration
    class campayn(TypedDict):
        api_key: str  # API key for authentication

    # Main function to create a contact in Campayn
    def main(campayn_resource: campayn, email: str, first_name: str = '', last_name: str = '', custom_fields: dict[str, Any] = None) -> dict:
        import requests  # Import requests or any other library if needed

        # Base URL for Campayn API
        base_url = "https://api.campayn.com/v1"

        # Endpoint for creating a contact
        contacts_endpoint = f"{base_url}/contacts"

        # Prepare the headers with the API key
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {campayn_resource['api_key']}"
        }

        # Prepare the data payload for the new contact
        contact_data = {
            "email": email,
            "first_name": first_name,
            "last_name": last_name,
            "custom_fields": custom_fields or {}
        }

        # Make the request to create a new contact
        response = requests.post(contacts_endpoint, json=contact_data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created contact information
        else:
            raise Exception(f"Error creating contact: {response.status_code} - {response.text}")

    # Note: The function does not call itself, it's ready to be exported and used with the required parameters.
  id: |-
    synthetic_create-contact
  instructions: |-
    Creates a new contact in campayn
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    campayn
  resource_type_def: |-
    class campayn(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the fraudlabs_pro integration
    class fraudlabs_pro(TypedDict):
        api_key: str

    def main(fraudlabs_pro_resource: fraudlabs_pro, transaction_id: str) -> dict:
        # Construct the API endpoint
        endpoint = f"https://api.fraudlabspro.com/v1/order/result/{transaction_id}?key={fraudlabs_pro_resource['api_key']}"

        # Make the API request to get the verification result
        response = requests.get(endpoint)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            result = response.json()
            return result
        else:
            # Handle the error case
            return {"error": f"Failed to get verification result, status code: {response.status_code}"}
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is needed for API interaction

    class fraudlabs_pro(TypedDict):
        api_key: str

    def main(fraudlabs_pro_resource: fraudlabs_pro, otp: str, phone_number: str) -> dict:
        verify_url = "https://api.fraudlabspro.com/v1/verification/result"
        payload = {
            'key': fraudlabs_pro_resource['api_key'],
            'otp': otp,
            'format': 'json'
        }
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        response = requests.post(verify_url, data=payload, headers=headers)
        result = response.json()

        # Assuming the user needs to know whether the OTP is valid or not
        is_valid = result.get('is_valid', None)

        return {
            'is_valid': is_valid,
            'result': result
        }
  id: |-
    synthetic_verify-otp
  instructions: |-
    Verify that an OTP sent by the Send SMS Verification API is valid. Please refer to the for the explanation of the result returned. in fraudlabs pro
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    fraudlabs_pro
  resource_type_def: |-
    class fraudlabs_pro(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'motion' integration
    class motion(TypedDict):
        api_key: str
        workspace_id: str

    def main(motion_resource: motion, target_workspace_id: str) -> str:
        # Assuming there's a library to interact with the 'motion' platform
        import motion_api_client as motion_client

        # Initialize the motion API client with the provided API key
        client = motion_client.Client(api_key=motion_resource['api_key'])

        # Move the workspace to the target workspace ID
        result = client.move_workspace(
            source_workspace_id=motion_resource['workspace_id'],
            target_workspace_id=target_workspace_id
        )

        # Return the result of the operation
        return result
  good: |-
    from typing import TypedDict, List

    # Assuming 'motion' is a task management platform and we have a library to interact with it
    import motion_api_client as motion_client

    # Renaming the imported method if it conflicts with the resource type name
    from motion_api_client import move_task as move_task_api

    class motion(TypedDict):
        api_key: str
        workspace_id: str

    def main(motion_resource: motion, task_id: str, target_workspace_id: str) -> dict:
        # Initialize the motion API client with the provided API key
        client = motion_client.Client(api_key=motion_resource['api_key'])

        # Move the task to the target workspace using the motion API client
        result = move_task_api(client, task_id, motion_resource['workspace_id'], target_workspace_id)

        # Return the result of the move operation
        return result

    # The script ends here, and the function is not called.
  id: |-
    synthetic_move-workspace
  instructions: |-
    Move a specific task to another workspace. When moving tasks from one workspace to another, the tasks project, status, and label(s) and assignee will all be reset in motion
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    motion
  resource_type_def: |-
    class motion(TypedDict):
        api_key: str
        workspace_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { admin_directory_v1, google } from "npm:googleapis";

    type GoogleDirectory = {
        clientEmail: string;
        privateKey: string;
        domain: string;
    }

    export async function main(
        googleDirectoryResource: GoogleDirectory,
        userEmail: string,
        givenName: string,
        familyName: string
    ) {
        const { clientEmail, privateKey, domain } = googleDirectoryResource;

        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            ['https://www.googleapis.com/auth/admin.directory.user']
        );

        await jwtClient.authorize();

        const admin = google.admin({ version: 'directory_v1', auth: jwtClient });

        const user = {
            primaryEmail: userEmail,
            name: {
                givenName: givenName,
                familyName: familyName,
            },
            password: 'initialPassword', // You should generate a secure password
            changePasswordAtNextLogin: true,
        };

        const result = await admin.users.insert({
            customer: 'my_customer',
            resource: user,
        });

        return result.data;
    }
  good: |-
    import { admin_directory_v1, google } from "npm:googleapis";

    type GoogleDirectory = {
        clientEmail: string;
        privateKey: string;
        domain: string;
    }

    export async function main(
        googleDirectoryResource: GoogleDirectory,
        userEmail: string,
        givenName: string,
        familyName: string,
        password: string,
        orgUnitPath: string = '/'
    ) {
        const { clientEmail, privateKey, domain } = googleDirectoryResource;

        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            ['https://www.googleapis.com/auth/admin.directory.user'],
            `admin@${domain}`
        );

        await jwtClient.authorize();

        const service = google.admin({ version: 'directory_v1', auth: jwtClient });

        const user = {
            primaryEmail: userEmail,
            name: {
                givenName: givenName,
                familyName: familyName,
            },
            password: password,
            orgUnitPath: orgUnitPath,
            changePasswordAtNextLogin: true,
        };

        const result = await service.users.insert({ requestBody: user });

        return result.data;
    }
  id: |-
    synthetic_create-user
  instructions: |-
    Creates a new user in google directory
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDirectory
  resource_type_def: |-
    type GoogleDirectory = {
        clientEmail: string;
        privateKey: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { CustomerIo as CustomerIoClient } from "npm:@customer.io/node"; // Renamed to avoid conflict with the resource type

    // Define the resource type for the CustomerIo integration
    type CustomerIo = {
        siteId: string;
        apiKey: string;
    };

    // Define the function signature with the CustomerIo and additional parameters
    export async function main(
        customerIo: CustomerIo,
        segmentId: string,
        customerEmails: string[]
    ) {
        // Initialize the Customer.io API client with the provided credentials
        const cio = new CustomerIoClient(customerIo.siteId, customerIo.apiKey);

        // Iterate over the customer emails and add each customer to the segment
        for (const email of customerEmails) {
            try {
                // Assuming the API client has a method to add a customer to a segment by email
                await cio.addCustomerToSegment(email, segmentId);
            } catch (error) {
                console.error(`Failed to add customer ${email} to segment ${segmentId}:`, error);
                // Depending on the requirements, you might want to handle the error differently
                // For example, you could collect all failed attempts and return them at the end
            }
        }

        // Return a success message or any other relevant result
        return `Added customers to segment ${segmentId}`;
    }
  good: |-
    // Import any libraries you need here
    import { CustomerIo } from 'npm:@customer.io/node'; // Assuming this is the correct npm package for Customer.io

    type CustomerIoResource = {
        siteId: string;
        apiKey: string;
    }

    export async function main(customerIoResource: CustomerIoResource, segmentId: number, customerIds: string[]) {
        if (customerIds.length > 1000) {
            throw new Error('You can only add up to 1000 customer IDs per request.');
        }

        const cio = new CustomerIo(customerIoResource.siteId, customerIoResource.apiKey);

        try {
            const response = await cio.addCustomersToSegment(segmentId, customerIds);
            return response;
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error('Failed to add customers to segment:', error);
            throw error;
        }
    }
  id: |-
    synthetic_add-customers-to-segment
  instructions: |-
    Add people to a manual segment by ID. You are limited to 1000 customer IDs per request in customer io
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CustomerIo
  resource_type_def: |-
    type CustomerIo = {
        siteId: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests library is used for HTTP requests

    # Define the resource type for the airtable_oauth integration
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str
        table_name: str

    def main(airtable_resource: airtable_oauth, record_data: Dict[str, Any]) -> Dict[str, Any]:
        # Endpoint for the Airtable API to create a record in a specific table
        endpoint = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{airtable_resource['table_name']}"

        # Headers to authenticate and specify the content type
        headers = {
            "Authorization": f"Bearer {airtable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Data to be sent in the request to create a new record
        data = {
            "records": [
                {
                    "fields": record_data
                }
            ]
        }

        # Make the POST request to Airtable API to add the record
        response = requests.post(endpoint, json=data, headers=headers)

        # Return the response from the Airtable API
        return response.json()

    # Example usage:
    # result = main(airtable_resource={'api_key': 'your_api_key', 'base_id': 'your_base_id', 'table_name': 'your_table_name'}, record_data={'Name': 'Example', 'Notes': 'This is a test record.'})
    # print(result)
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Airtable API

    # Define the resource type for the airtable_oauth integration
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str

    # Define the function to create a single record in an Airtable table
    def main(airtable_resource: airtable_oauth, table_name: str, record_data: Dict[str, Any]) -> Dict[str, Any]:
        # Endpoint for the Airtable API to create a record
        endpoint = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{table_name}"

        # Headers for authentication and content type
        headers = {
            "Authorization": f"Bearer {airtable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Data to be sent in the request to create a new record
        data = {
            "fields": record_data
        }

        # Make the POST request to create a new record
        response = requests.post(endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the created record
            return response.json()
        else:
            # Return the error
            return {"error": response.json()}
  id: |-
    synthetic_create-single-record
  instructions: |-
    Adds a record to a table. in airtable oauth
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    airtable_oauth
  resource_type_def: |-
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Dict, Any
    import fullcontact as fc  # Renamed the imported library to avoid conflict

    # Define the resource type for the full_contact integration
    class full_contact(TypedDict):
        api_key: str

    # Define the main function with the resource type and additional parameters
    def main(full_contact_resource: full_contact, person_email: str) -> Dict[str, Any]:
        # Initialize the FullContact client with the provided API key
        client = fc.FullContactClient(full_contact_resource['api_key'])

        # Enrich the person data using the email provided
        person_data = client.enrich_person(email=person_email)

        # Return the result
        return person_data
  good: |-
    from typing import TypedDict, Optional, Dict, Any
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the full_contact integration
    class full_contact(TypedDict):
        api_key: str

    def main(full_contact_resource: full_contact, email: str, phone: Optional[str] = None, name: Optional[str] = None) -> Dict[str, Any]:
        # Construct the headers for authentication
        headers = {
            'Authorization': f'Bearer {full_contact_resource["api_key"]}'
        }

        # Construct the payload with the provided parameters
        payload = {
            'email': email
        }
        if phone:
            payload['phone'] = phone
        if name:
            payload['name'] = name

        # Make the request to the FullContact API
        response = requests.post('https://api.fullcontact.com/v3/person.enrich', headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()
        else:
            # Handle error responses
            return {
                'error': response.text,
                'status_code': response.status_code
            }

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_enrich-person
  instructions: |-
    Enrich a person in full contact
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    full_contact
  resource_type_def: |-
    class full_contact(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, spreadsheetId: string, range: string) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.apiKey });

        const response = await sheets.spreadsheets.values.get({
            spreadsheetId,
            range,
            auth: googleSheetsResource.accessToken,
        });

        return response.data;
    }
  good: |-
    import { GoogleAuth } from "npm:google-auth-library";

    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, spreadsheetId: string, range: string) {
        const auth = new GoogleAuth({
            credentials: {
                client_email: googleSheetsResource.clientEmail,
                private_key: googleSheetsResource.privateKey,
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],
        });

        const client = await auth.getClient();
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(range)}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${(await client.getAccessToken()).token}`,
                'Accept': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Error fetching data: ${response.statusText}`);
        }

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_get-values
  instructions: |-
    Get all values from a sheet. in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type CiscoMeraki = {
        apiKey: string,
        baseUrl: string,
        organizationId: string
    }

    export async function main(
        ciscoMerakiResource: CiscoMeraki,
        networkId: string,
        updateData: { name?: string, timeZone?: string, tags?: string[], notes?: string }
    ) {
        const { apiKey, baseUrl, organizationId } = ciscoMerakiResource;
        const url = `${baseUrl}/organizations/${organizationId}/networks/${networkId}`;

        const response = await request('PUT', url, {
            headers: {
                'X-Cisco-Meraki-API-Key': apiKey,
                'Content-Type': 'application/json'
            },
            data: updateData
        });

        return response.data;
    }
  good: |-
    import { Meraki as MerakiDashboard } from "npm:@meraki/dashboard";

    type CiscoMeraki = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(ciscoMerakiResource: CiscoMeraki, networkId: string, updateData: { name?: string; timeZone?: string; tags?: string[]; }) {
        const meraki = new MerakiDashboard(ciscoMerakiResource.apiKey, ciscoMerakiResource.baseUrl);
        const result = await meraki.networks.updateNetwork(networkId, updateData);
        return result;
    }
  id: |-
    synthetic_update-network
  instructions: |-
    Updates a network. in cisco meraki
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CiscoMeraki
  resource_type_def: |-
    type CiscoMeraki = {
        apiKey: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string,
        privateKey: string,
        clientEmail: string,
        environment?: string
    }

    export async function main(dialogflowResource: GoogleDialogflow, sessionId: string) {
        const sessionClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail
            },
            projectId: dialogflowResource.projectId
        });

        const sessionPath = sessionClient.projectAgentSessionPath(
            dialogflowResource.projectId,
            sessionId
        );

        const request = {
            parent: sessionPath,
            // If you have an environment other than the default, uncomment the following line and specify the environment name
            // environment: dialogflowResource.environment,
        };

        const [response] = await sessionClient.listContexts(request);
        return response.contexts;
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(googleDialogflowResource: GoogleDialogflow, sessionId: string) {
        const dialogflowClient = new SessionsClient({
            credentials: {
                private_key: googleDialogflowResource.privateKey,
                client_email: googleDialogflowResource.clientEmail,
            },
            projectId: googleDialogflowResource.projectId,
        });

        const sessionPath = dialogflowClient.projectAgentSessionPath(
            googleDialogflowResource.projectId,
            sessionId
        );

        const contextPath = sessionPath + '/contexts';

        const request = {
            parent: contextPath,
        };

        try {
            const [contexts] = await dialogflowClient.listContexts(request);
            return contexts;
        } catch (error) {
            console.error(`Failed to list contexts: ${error}`);
            throw error;
        }
    }
  id: |-
    synthetic_list-contexts
  instructions: |-
    Retrieves the list of the contexts with the given session ID, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string,
        privateKey: string,
        clientEmail: string,
        environment?: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the kanbanize integration
    class kanbanize(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for the kanbanize integration
    def main(kanbanize_resource: kanbanize, board_id: int, task_id: int):
        # Assuming that the kanbanize integration requires an API key and subdomain for authentication
        # and that the script interacts with a specific task on a specific board.

        # Import the necessary library for HTTP requests
        import requests

        # Construct the API URL
        api_url = f"https://{kanbanize_resource['subdomain']}.kanbanize.com/index.php/api/kanbanize/get_task_details/format/json"

        # Set up the headers with the API key
        headers = {
            "apikey": kanbanize_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Set up the payload with the board ID and task ID
        payload = {
            "boardid": board_id,
            "taskid": task_id
        }

        # Make the API request
        response = requests.post(api_url, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the task details
            return response.json()
        else:
            # Handle errors
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the kanbanize integration
    class kanbanize(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for the kanbanize integration
    def main(kanbanize_resource: kanbanize, task_id: int, board_id: int, new_details: dict[str, Any]):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for editing a task
        url = f"https://{kanbanize_resource['subdomain']}.kanbanize.com/index.php/api/kanbanize/edit_task/format/json"

        # Set up the headers with the API key
        headers = {
            "apikey": kanbanize_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Prepare the payload with the task details to be updated
        payload = {
            "taskid": task_id,
            "boardid": board_id,
            **new_details  # Unpack additional task details from the function parameters
        }

        # Make the request to the Kanbanize API to edit the task
        response = requests.post(url, headers=headers, json=payload)

        # Check for a successful response and return the result
        if response.status_code == 200:
            return response.json()  # Return the JSON response if successful
        else:
            response.raise_for_status()  # Raise an exception if the call failed

    # The script ends here, with no call to the main function as per the instructions.
  id: |-
    synthetic_edit-task
  instructions: |-
    Edit Task in kanbanize
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanbanize
  resource_type_def: |-
    class kanbanize(TypedDict):
        api_key: str
        subdomain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import chartmogul as cm

    # Define the resource type for the ChartMogul integration
    class chartmogul(TypedDict):
        account_token: str
        secret_key: str

    # Define the main function to add tags to a customer via email
    def main(chartmogul_config: chartmogul, customer_email: str, tags_to_add: List[str]):
        # Configure ChartMogul API client
        config = cm.Config(
            account_token=chartmogul_config['account_token'],
            secret_key=chartmogul_config['secret_key']
        )

        # Retrieve the customer using the email
        try:
            customers = cm.Customer.all(
                config,
                email=customer_email
            ).get()
        except cm.errors.ChartMogulError as e:
            return {'error': str(e)}

        # Check if the customer exists
        if not customers or len(customers) == 0:
            return {'error': 'No customer found with the provided email.'}

        # Assuming the email is unique and retrieves only one customer
        customer = customers[0]

        # Add tags to the customer
        try:
            updated_customer = cm.Customer.add_tags(
                config,
                uuid=customer.uuid,
                data={'tags': tags_to_add}
            )
            return {'success': True, 'customer': updated_customer}
        except cm.errors.ChartMogulError as e:
            return {'error': str(e)}

    # The script ends here, with no calls to the main function, as per the instructions.
  good: |-
    from typing import TypedDict
    import chartmogul

    class chartmogul_resource(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_resource: chartmogul_resource, customer_email: str, tags: list[str]):
        # Configure ChartMogul API client
        config = chartmogul.Config(
            account_token=chartmogul_resource['account_token'],
            secret_key=chartmogul_resource['secret_key']
        )

        # Retrieve the customer using the email address
        try:
            search_result = chartmogul.Customer.all(
                config=config,
                email=customer_email
            )
        except chartmogul.exceptions.ChartMogulError as e:
            return {'error': str(e)}

        # Check if any customers were found
        if not search_result.entries:
            return {'error': 'No customers found with the provided email address.'}

        # Assuming we only tag the first customer found
        customer = search_result.entries[0]

        # Add tags to the customer
        try:
            updated_customer = chartmogul.Customer.add_tags(
                config=config,
                uuid=customer.uuid,
                data={'tags': tags}
            )
            return {'success': True, 'customer': updated_customer}
        except chartmogul.exceptions.ChartMogulError as e:
            return {'error': str(e)}
  id: |-
    synthetic_add-tags-via-email
  instructions: |-
    Adds tags to customers that have the specified email address in chartmogul
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    chartmogul
  resource_type_def: |-
    class chartmogul(TypedDict):
        account_token: str
        secret_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { compile } from "npm:handlebars";
    import { PDFDocument } from "npm:pdf-lib";

    type CroveApp = {
        apiKey: string;
    }

    export async function main(croveAppResource: CroveApp, templateId: string, templateData: Record<string, any>) {
        const { apiKey } = croveAppResource;
        const templateFetchUrl = `https://api.crove.app/v1/templates/${templateId}/download?apiKey=${apiKey}`;

        // Fetch the template from CroveApp
        const templateResponse = await fetch(templateFetchUrl);
        if (!templateResponse.ok) {
            throw new Error(`Failed to fetch template: ${templateResponse.statusText}`);
        }
        const templateContent = await templateResponse.text();

        // Compile the template with the provided data
        const template = compile(templateContent);
        const filledTemplate = template(templateData);

        // Create a PDF from the filled template
        const pdfDoc = await PDFDocument.create();
        const page = pdfDoc.addPage();
        const { width, height } = page.getSize();
        const fontSize = 12;
        page.drawText(filledTemplate, {
            x: 50,
            y: height - 4 * fontSize,
            size: fontSize,
        });

        // Serialize the PDF to bytes
        const pdfBytes = await pdfDoc.save();

        // Return the PDF file as a base64 string
        return Buffer.from(pdfBytes).toString('base64');
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type CroveApp = {
        apiKey: string;
        templateId: string;
    }

    export async function main(croveAppResource: CroveApp, documentData: Record<string, any>) {
        const apiUrl = `https://api.crove.app/v1/templates/${croveAppResource.templateId}/generate-pdf`;
        const headers = {
            "Authorization": `Bearer ${croveAppResource.apiKey}`,
            "Content-Type": "application/json"
        };
        const body = JSON.stringify({
            data: documentData
        });

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return {
            pdfBase64: result.pdfBase64,
            pdfUrl: result.pdfUrl
        };
    }
  id: |-
    synthetic_generate-template-pdf
  instructions: |-
    Generate PDF of a document created from the template in crove app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CroveApp
  resource_type_def: |-
    type CroveApp = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        oauthToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileName: string, mimeType: string, fileContent: string | Uint8Array, folderId?: string) {
        const drive = google.drive({ version: 'v3', auth: googleDriveResource.oauthToken });

        const fileMetadata = {
            'name': fileName,
            'mimeType': mimeType,
            ...(folderId && { 'parents': [folderId] }) // If folderId is provided, add it to the parents array
        };

        const media = {
            mimeType: mimeType,
            body: fileContent
        };

        try {
            const response = await drive.files.create({
                requestBody: fileMetadata,
                media: media,
                fields: 'id'
            });

            return response.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    };

    export async function main(
        googleDriveResource: GoogleDrive,
        fileUrl: string,
        fileName: string,
        mimeType: string,
        folderId?: string
    ) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;

        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        const fileMetadata = {
            name: fileName,
            mimeType: mimeType,
            parents: folderId ? [folderId] : [],
        };

        const response = await fetch(fileUrl);
        const fileContent = await response.blob();

        const media = {
            mimeType: mimeType,
            body: fileContent.stream(),
        };

        const createResponse = await drive.files.create({
            requestBody: fileMetadata,
            media: media,
            fields: 'id'
        });

        return createResponse.data;
    }
  id: |-
    synthetic_create-file
  instructions: |-
    Create a new file from a URL or /tmp/filepath for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        oauthToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mautic API

    class mautic(TypedDict):
        base_url: str
        username: str
        password: str

    def main(mautic_resource: mautic, first_name: str, last_name: str, email: str, company: str = None, phone: str = None):
        # Construct the API endpoint for creating a new contact
        api_endpoint = f"{mautic_resource['base_url']}/api/contacts/new"

        # Prepare the contact data
        contact_data = {
            'firstname': first_name,
            'lastname': last_name,
            'email': email,
            'ipAddress': '127.0.0.1',  # Assuming a default IP address; this could be parameterized if needed
            'overwriteWithBlank': True,
        }

        # Add optional fields if provided
        if company:
            contact_data['company'] = company
        if phone:
            contact_data['phone'] = phone

        # Prepare the authentication headers
        auth_headers = {
            'Authorization': f'Basic {mautic_resource["username"]}:{mautic_resource["password"]}'
        }

        # Make the request to create the new contact
        response = requests.post(api_endpoint, headers=auth_headers, json=contact_data)

        # Check for a successful response and return the result
        if response.status_code == 201:
            return response.json()  # Return the created contact information as JSON
        else:
            raise Exception(f"Error creating contact: {response.status_code} - {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the Mautic integration
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str

    # Define the main function for creating a contact in Mautic
    def main(mautic_resource: mautic, contact_details: Dict[str, Any]) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a contact
        endpoint = f"{mautic_resource['base_url']}/api/contacts/new"

        # Prepare the authentication data
        auth = (mautic_resource['username'], mautic_resource['password'])

        # Make the API request to create a new contact
        response = requests.post(endpoint, json=contact_details, auth=auth)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created contact details
        else:
            raise Exception(f"Error creating contact: {response.status_code} - {response.text}")

    # Example usage (do not include this in the script):
    # mautic_credentials = mautic(base_url='https://your-mautic-instance.com', username='your_username', password='your_password')
    # new_contact = {'firstname': 'John', 'lastname': 'Doe', 'email': 'john.doe@example.com'}
    # result = main(mautic_credentials, new_contact)
  id: |-
    synthetic_create-contact
  instructions: |-
    Creates a new contact in mautic
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mautic
  resource_type_def: |-
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { BrexStaging } from 'npm:@brex/api'; // Assuming @brex/api is the npm package for BrexStaging integration

    type BrexStaging = {
        apiKey: string;
        accountId: string;
    }

    export async function main(brexStagingResource: BrexStaging, startDate: string, endDate: string) {
        // Initialize the BrexStaging client with the provided API key
        const brexClient = new BrexStaging(brexStagingResource.apiKey);

        // Fetch the transactions for the primary card account within the specified date range
        const transactions = await brexClient.listTransactions({
            accountId: brexStagingResource.accountId,
            startDate: startDate,
            endDate: endDate
        });

        // Return the result
        return transactions;
    }
  good: |-
    // Import any libraries you might need here
    import { BrexStaging } from 'npm:@brex/brex-api'; // Assuming there's a package for Brex API

    type BrexStagingResource = {
        apiKey: string;
        accountId: string;
    }

    export async function main(brexStagingResource: BrexStagingResource) {
        // Initialize the Brex API client with the provided API key
        const brexClient = new BrexStaging({ apiKey: brexStagingResource.apiKey });

        // Fetch the list of settled transactions for the primary card account
        const transactions = await brexClient.getSettledTransactions(brexStagingResource.accountId);

        // Return the result
        return transactions;
    }
  id: |-
    synthetic_list-transactions-for-primary-card-account
  instructions: |-
    Lists all settled transactions for the primary card account. in brex staging
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BrexStaging
  resource_type_def: |-
    type BrexStaging = {
        apiKey: string;
        accountId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Lists } from "npm:@emailoctopus/api";

    type EmailOctopus = {
        apiKey: string;
    }

    export async function main(emailOctopusResource: EmailOctopus, listName: string) {
        const lists = new Lists(emailOctopusResource.apiKey);

        const newList = await lists.create({
            name: listName
        });

        return newList;
    }
  good: |-
    import { OctopusClient as EmailoctopusClient } from "npm:emailoctopus";

    type Emailoctopus = {
        apiKey: string;
    }

    export async function main(emailoctopusResource: Emailoctopus, listName: string, listDescription: string) {
        const client = new EmailoctopusClient(emailoctopusResource.apiKey);

        const newList = await client.lists.create({
            name: listName,
            description: listDescription
        });

        return newList;
    }
  id: |-
    synthetic_create-list
  instructions: |-
    Create a list, in emailoctopus
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Emailoctopus
  resource_type_def: |-
    type Emailoctopus = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MissiveClient } from "npm:@missive/missive-api";

    type Missive = {
        apiKey: string;
    }

    export async function main(missiveResource: Missive, contactId: string) {
        const client = new MissiveClient(missiveResource.apiKey);
        const contact = await client.contacts.get(contactId);
        return contact;
    }
  good: |-
    // Import any libraries you need here
    import { MissiveClient } from "npm:@missive/missive-api";

    type Missive = {
        apiKey: string;
    }

    export async function main(missiveResource: Missive, contactId: string) {
        const missiveClient = new MissiveClient({ apiKey: missiveResource.apiKey });
        const contact = await missiveClient.contacts.get(contactId);

        return contact;
    }
  id: |-
    synthetic_get-contact
  instructions: |-
    Get a contact in missive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Missive
  resource_type_def: |-
    type Missive = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Chatwork = {
        apiToken: string;
    }

    export async function main(chatworkResource: Chatwork, roomId: string, body: string) {
        const endpoint = `https://api.chatwork.com/v2/rooms/${roomId}/messages`;
        const headers = {
            "X-ChatWorkToken": chatworkResource.apiToken,
            "Content-Type": "application/x-www-form-urlencoded"
        };
        const data = `body=${encodeURIComponent(body)}`;

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: data
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Chatwork = {
        apiToken: string;
    }

    export async function main(chatworkResource: Chatwork, roomId: string, message: string) {
        const endpoint = `https://api.chatwork.com/v2/rooms/${roomId}/messages`;
        const headers = {
            "X-ChatWorkToken": chatworkResource.apiToken,
            "Content-Type": "application/x-www-form-urlencoded",
        };
        const body = `body=${encodeURIComponent(message)}`;

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-message
  instructions: |-
    Send a message to a specified room in chatwork
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Chatwork
  resource_type_def: |-
    type Chatwork = {
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import fetch from "npm:node-fetch";

    type CreditRepairCloud = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(creditRepairCloudResource: CreditRepairCloud, clientId: string): Promise<string> {
        const url = `${creditRepairCloudResource.baseUrl}/clients/${clientId}`;
        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${creditRepairCloudResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error deleting client: ${response.statusText}`);
        }

        return `Client with ID ${clientId} deleted successfully.`;
    }
  good: |-
    import { Client as CRCClient } from "npm:@creditrepaircloud/api";

    type CreditRepairCloud = {
        apiKey: string,
        apiUrl: string
    }

    export async function main(creditRepairCloudResource: CreditRepairCloud, clientId: string) {
        const crcClient = new CRCClient({
            apiKey: creditRepairCloudResource.apiKey,
            apiUrl: creditRepairCloudResource.apiUrl
        });

        const result = await crcClient.deleteClient(clientId);

        return result;
    }
  id: |-
    synthetic_delete-client
  instructions: |-
    Delete Client. in credit repair cloud
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CreditRepairCloud
  resource_type_def: |-
    type CreditRepairCloud = {
        apiKey: string,
        apiUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the kingsumo integration
    class kingsumo(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the kingsumo integration
    def main(kingsumo_resource: kingsumo, giveaway_id: str) -> Any:
        # Import the necessary library for HTTP requests
        import requests

        # Construct the URL for the giveaway details
        url = f"https://api.kingsumo.com/v1/giveaways/{giveaway_id}"

        # Set up the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {kingsumo_resource['api_key']}",
            "X-Secret-Key": kingsumo_resource['api_secret']
        }

        # Make the GET request to the KingSumo API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the giveaway details
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": "Failed to retrieve giveaway details", "status_code": response.status_code}

    # Note: The function does not call itself, it's ready to be exported and used with the required parameters.
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the kingsumo integration
    class kingsumo(TypedDict):
        api_key: str
        base_url: str

    def main(kingsumo_resource: kingsumo, giveaway_id: str) -> Any:
        # Construct the URL to access the giveaway
        url = f"{kingsumo_resource['base_url']}/giveaways/{giveaway_id}"

        # Set up the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {kingsumo_resource['api_key']}"
        }

        # Make the HTTP request to get the giveaway details
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the giveaway details
            return response.json()
        else:
            # Handle errors (e.g., giveaway not found, authentication error)
            return {
                'error': response.status_code,
                'message': response.text
            }

    # The script ends here, and the main function is not called.
  id: |-
    synthetic_get-giveaway
  instructions: |-
    Gets specified giveaway in kingsumo
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kingsumo
  resource_type_def: |-
    class kingsumo(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the badger_maps integration
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function with the resource type and any additional parameters
    def main(badger_maps_resource: badger_maps, start_date: str, end_date: str) -> List[Dict]:
        # Base URL for Badger Maps API
        base_url = "https://api.badgermaps.com/v1"

        # Endpoint for retrieving check-ins
        check_ins_endpoint = "/checkins"

        # Prepare headers for authentication
        headers = {
            "Authorization": f"Bearer {badger_maps_resource['api_key']}"
        }

        # Prepare parameters for the API call
        params = {
            "start_date": start_date,
            "end_date": end_date
        }

        # Make the API call to retrieve check-ins
        response = requests.get(f"{base_url}{check_ins_endpoint}", headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of check-ins
            return response.json()
        else:
            # Handle errors (you could raise an exception or return an empty list depending on your use case)
            response.raise_for_status()

    # Note: The function is not called here, it's just defined and ready to be exported.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the badger_maps integration
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for retrieving check-ins
    def main(badger_maps_resource: badger_maps, user_id: str, start_date: str, end_date: str) -> List[dict]:
        import requests  # Import requests or another HTTP library if needed

        # Define the endpoint for retrieving check-ins
        check_ins_endpoint = f"https://api.badgermaps.com/v1/users/{user_id}/checkins"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {badger_maps_resource['api_key']}"
        }

        # Set up the parameters for the date range
        params = {
            "start_date": start_date,
            "end_date": end_date
        }

        # Make the request to the Badger Maps API
        response = requests.get(check_ins_endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of check-ins
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # The main function is now defined and ready to be used with the specified parameters.
  id: |-
    synthetic_retrieve-check-ins
  instructions: |-
    Retrieves check-ins. in badger maps
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    badger_maps
  resource_type_def: |-
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    def main(mastodon_resource: mastodon, status_id: int) -> dict:
        headers = {
            'Authorization': f'Bearer {mastodon_resource["access_token"]}'
        }
        url = f'{mastodon_resource["api_base_url"].rstrip("/")}/api/v1/statuses/{status_id}/unfeature'
        response = requests.post(url, headers=headers)

        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the Mastodon integration
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    # Define the main function for unpinning a status from a profile
    def main(mastodon_resource: mastodon, status_id: str) -> bool:
        import requests

        # Construct the API endpoint for unpinning a status
        unpin_endpoint = f"{mastodon_resource['api_base_url'].rstrip('/')}/api/v1/statuses/{status_id}/unpin"

        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f'Bearer {mastodon_resource["access_token"]}'
        }

        # Make the request to unpin the status
        response = requests.post(unpin_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return True
        else:
            # Log or handle the error as needed
            response.raise_for_status()
            return False

    # Example usage:
    # result = main(mastodon_resource={'access_token': 'YOUR_ACCESS_TOKEN', 'api_base_url': 'https://mastodon.example'}, status_id='123456')
  id: |-
    synthetic_unpin-status
  instructions: |-
    Unfeature a status from the top of your profile in mastodon
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mastodon
  resource_type_def: |-
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the Discourse integration
    class discourse(TypedDict):
        api_key: str
        api_username: str
        forum_url: str

    def main(discourse_resource: discourse, title: str, content: str, category: int):
        import requests  # Import requests or any other library if needed

        # Construct the URL for creating a new post
        create_post_url = f"{discourse_resource['forum_url']}/posts.json"

        # Prepare the data for the new post
        post_data = {
            'title': title,
            'raw': content,
            'category': category,
            'api_key': discourse_resource['api_key'],
            'api_username': discourse_resource['api_username']
        }

        # Make the request to create a new post
        response = requests.post(create_post_url, data=post_data)

        # Return the response from the Discourse API
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is used for HTTP calls

    class discourse(TypedDict):
        api_key: str
        api_username: str
        forum_url: str

    def main(discourse_resource: discourse, title: str, content: str, category_id: int) -> Any:
        headers = {
            'Api-Key': discourse_resource['api_key'],
            'Api-Username': discourse_resource['api_username'],
            'Content-Type': 'application/json'
        }
        payload = {
            'title': title,
            'raw': content,
            'category': category_id
        }
        response = requests.post(f"{discourse_resource['forum_url']}/posts.json", headers=headers, json=payload)
        return response.json()
  id: |-
    synthetic_create-post
  instructions: |-
    Creates a post in discourse
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    discourse
  resource_type_def: |-
    class discourse(TypedDict):
        api_key: str
        api_username: str
        forum_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import monday_integration  # Assuming 'monday_integration' is the library for the 'monday' integration

    # Rename the imported method if it conflicts with the resource type name
    if hasattr(monday_integration, 'monday'):
        monday_integration_method = monday_integration.monday
    else:
        monday_integration_method = None

    class monday(TypedDict):
        api_key: str

    def main(monday_resource: monday, board_id: str, column_values: dict, item_ids: List[int]) -> List[bool]:
        monday_client = monday_integration_method(api_key=monday_resource['api_key'])
        results = []
        for item_id in item_ids:
            result = monday_client.change_column_values(board_id=board_id, item_id=item_id, column_values=column_values)
            results.append(result)
        return results
  good: |-
    from typing import TypedDict, List, Any
    import monday  # Assuming 'monday' is the name of the library for the Monday.com API

    # Rename the imported 'monday' module if it conflicts with the resource type name
    import monday as monday_api

    class monday(TypedDict):
        api_key: str
        board_id: int

    def main(monday_resource: monday, item_id: int, column_values: dict):
        # Initialize the Monday client with the API key
        client = monday_api.MondayClient(monday_resource['api_key'])

        # Update the item with the new column values
        result = client.items.change_multiple_column_values(
            board_id=monday_resource['board_id'],
            item_id=item_id,
            column_values=column_values
        )

        return result
  id: |-
    synthetic_update-column-values
  instructions: |-
    Update multiple column values of an item in monday
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    monday
  resource_type_def: |-
    class monday(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HttpClient } from "npm:@angular/common/http";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, listId: string): Promise<any> {
        const httpClient = new HttpClient();
        const url = `https://api.clickup.com/api/v2/list/${listId}`;

        const headers = {
            'Authorization': clickupResource.apiKey,
            'Content-Type': 'application/json'
        };

        try {
            const response = await httpClient.get(url, { headers: headers }).toPromise();
            return response;
        } catch (error) {
            console.error('Error fetching ClickUp list:', error);
            throw error;
        }
    }
  good: |-
    import { ClickUp as ClickUpClient } from "npm:@hubspot/api-client";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, listId: string) {
        const clickUpClient = new ClickUpClient(clickupResource.apiKey);

        const list = await clickUpClient.lists.getList(listId);

        return list;
    }
  id: |-
    synthetic_get-list
  instructions: |-
    Get a list. See the docs in **Lists / Get List** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the google_contacts integration
    class google_contacts(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the Google API client library, renaming the conflicting method if necessary
    from googleapiclient.discovery import build as build_service

    def main(google_contacts_resource: google_contacts, contact_id: str) -> Dict[str, Any]:
        # Create a service object for the Google Contacts API
        service = build_service('people', 'v1', credentials=None)

        # Set the authorization header for the request
        service._http.headers.update({'Authorization': f"Bearer {google_contacts_resource['access_token']}"})

        # Get the contact information using the contact_id
        results = service.people().get(resourceName=f'people/{contact_id}', personFields='names,emailAddresses').execute()

        # Return the contact information
        return results
  good: |-
    from typing import TypedDict, Any, Dict

    # Assuming 'google_contacts' integration requires 'access_token' for authentication
    class google_contacts(TypedDict):
        access_token: str

    def main(google_contacts_resource: google_contacts, contact_id: str) -> Dict[str, Any]:
        import requests  # Import here to avoid conflicts with any parameter names

        # Base URL for Google Contacts API
        base_url = "https://people.googleapis.com/v1/people"

        # Prepare the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {google_contacts_resource['access_token']}",
            "Accept": "application/json"
        }

        # Make the request to get the contact by ID
        response = requests.get(f"{base_url}/{contact_id}", headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact information as a dictionary
            return response.json()
        else:
            # Handle errors (e.g., contact not found, authentication error)
            response.raise_for_status()
  id: |-
    synthetic_get-contact
  instructions: |-
    Get information about a contact in google contacts
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_contacts
  resource_type_def: |-
    class google_contacts(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the drata integration
    class drata(TypedDict):
        api_key: str
        api_secret: str

    def main(drata_resource: drata, additional_param: str) -> str:
        # Example function body using the drata_resource and additional_param
        # This is a placeholder for the actual integration logic
        result = f"Using Drata with API key {drata_resource['api_key']} and additional parameter {additional_param}"

        # Return the result of the operation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'drata' integration
    class drata(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for updating a vendor in the Drata platform
    def main(drata_resource: drata, vendor_id: str, vendor_name: str, vendor_status: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a vendor
        api_endpoint = f"https://api.drata.com/vendors/{vendor_id}"

        # Set up the headers with the API key and secret
        headers = {
            "Authorization": f"Bearer {drata_resource['api_key']}",
            "X-Api-Secret": drata_resource['api_secret'],
            "Content-Type": "application/json"
        }

        # Construct the payload with the vendor details
        payload = {
            "name": vendor_name,
            "status": vendor_status
        }

        # Make the request to update the vendor
        response = requests.put(api_endpoint, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated vendor information
        else:
            raise Exception(f"Failed to update vendor: {response.status_code}, {response.text}")

    # The script ends here, with no call to the main function as per the instructions.
  id: |-
    synthetic_update-vendor
  instructions: |-
    The name of the vendor in drata
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    drata
  resource_type_def: |-
    class drata(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GmailCustomOauth = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(gmailCustomOauth: GmailCustomOauth, to: string, subject: string, messageText: string) {
        const { clientId, clientSecret, refreshToken, accessToken } = gmailCustomOauth;

        const oauth2Client = new google.auth.OAuth2(
            clientId,
            clientSecret
        );

        oauth2Client.setCredentials({
            refresh_token: refreshToken,
            access_token: accessToken,
        });

        const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

        const rawMessage = `From: me\nTo: ${to}\nSubject: ${subject}\n\n${messageText}`;
        const encodedMessage = Buffer.from(rawMessage).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

        const result = await gmail.users.messages.send({
            userId: 'me',
            requestBody: {
                raw: encodedMessage
            }
        });

        return result.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GmailCustomOauth = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(gmailCustomOauthResource: GmailCustomOauth, to: string, subject: string, messageText: string) {
        const { clientId, clientSecret, refreshToken, accessToken } = gmailCustomOauthResource;
        const gmail = google.gmail({ version: 'v1', auth: new google.auth.OAuth2(clientId, clientSecret) });

        // Set the credentials
        gmail.auth.setCredentials({
            refresh_token: refreshToken,
            access_token: accessToken,
        });

        // Create the email envelope (RFC 5322)
        const emailLines = [
            `To: ${to}`,
            `Subject: ${subject}`,
            'Content-type: text/plain;charset=utf-8',
            'MIME-Version: 1.0',
            '',
            messageText,
        ];

        const email = emailLines.join('\r\n').trim();
        const encodedMessage = Buffer.from(email).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

        // Create the draft
        const draft = await gmail.users.drafts.create({
            userId: 'me',
            requestBody: {
                message: {
                    raw: encodedMessage,
                },
            },
        });

        return draft.data;
    }
  id: |-
    synthetic_create-draft
  instructions: |-
    Create a draft from your Google Workspace email account in gmail custom oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GmailCustomOauth
  resource_type_def: |-
    type GmailCustomOauth = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the bingx integration
    class bingx(TypedDict):
        api_key: str
        api_secret: str
        # Add any other properties needed for authentication

    # Define the main function for placing a bracket order in bingx
    def main(bingx_resource: bingx, symbol: str, order_type: str, quantity: float, entry_price: float, take_profit_price: float, stop_loss_price: float):
        # Import the necessary library for the bingx API
        # If the library name conflicts with 'bingx', rename it accordingly
        import bingx_api as bx

        # Initialize the bingx client with the provided credentials
        client = bx.Client(api_key=bingx_resource['api_key'], api_secret=bingx_resource['api_secret'])

        # Place the bracket order using the bingx client
        # Assuming the bingx API has a method called 'place_bracket_order'
        result = client.place_bracket_order(
            symbol=symbol,
            order_type=order_type,
            quantity=quantity,
            entry_price=entry_price,
            take_profit_price=take_profit_price,
            stop_loss_price=stop_loss_price
        )

        # Return the result of the order placement
        return result
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to BingX API

    class bingx(TypedDict):
        api_key: str
        api_secret: str
        access_token: str  # Assuming OAuth2 is used and token is provided

    def main(bingx_resource: bingx, symbol: str, order_type: str, quantity: float, target_price: float, stop_loss_price: float):
        # Construct the request to BingX API for creating a custom bracket order
        endpoint = "https://api.bingx.com/v1/order"  # Example endpoint, replace with actual
        headers = {
            "Authorization": f"Bearer {bingx_resource['access_token']}",
            "Content-Type": "application/json"
        }
        payload = {
            "symbol": symbol,
            "order_type": order_type,
            "quantity": quantity,
            "target_price": target_price,
            "stop_loss_price": stop_loss_price
        }

        # Send the request to the BingX API
        response = requests.post(endpoint, headers=headers, json=payload)

        # Check for a successful response and return the result
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_custom-bracket-order
  instructions: |-
    Place bracket order in bingx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bingx
  resource_type_def: |-
    class bingx(TypedDict):
        api_key: str
        api_secret: str
        access_token: str  # Assuming OAuth2 is used and token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(amazonSesResource: AmazonSes, templateName: string, subjectPart: string, textPart: string, htmlPart: string) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Template: {
                TemplateName: templateName,
                SubjectPart: subjectPart,
                TextPart: textPart,
                HtmlPart: htmlPart,
            }
        };

        try {
            const updateTemplateResponse = await ses.updateTemplate(params);
            return updateTemplateResponse;
        } catch (error) {
            console.error("Error updating the email template:", error);
            throw error;
        }
    }
  good: |-
    import { SES as SESClient } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        templateName: string,
        subjectPart: string,
        textPart: string,
        htmlPart: string
    ) {
        const ses = new SESClient({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Template: {
                TemplateName: templateName,
                SubjectPart: subjectPart,
                TextPart: textPart,
                HtmlPart: htmlPart,
            }
        };

        try {
            const result = await ses.updateTemplate(params);
            return result;
        } catch (error) {
            console.error("Error updating the email template:", error);
            throw error;
        }
    }
  id: |-
    synthetic_update-email-template
  instructions: |-
    Update an email template in amazon ses
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AmazonSes
  resource_type_def: |-
    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Define the resource type for the jobnimbus integration
    class jobnimbus(TypedDict):
        api_key: str
        user_email: str
        account_id: str

    # Define the main function for the jobnimbus integration
    def main(jobnimbus_resource: jobnimbus, contact_id: str) -> Optional[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for finding a contact by ID
        endpoint = f"https://api.jobnimbus.com/v1/contacts/{contact_id}"

        # Set up the headers with the necessary authentication details
        headers = {
            "x-api-key": jobnimbus_resource['api_key'],
            "x-user-email": jobnimbus_resource['user_email'],
            "x-account-id": jobnimbus_resource['account_id'],
            "Content-Type": "application/json"
        }

        # Make the GET request to the JobNimbus API
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact details as a dictionary if found
            return response.json()
        else:
            # Return None if the contact was not found or if there was an error
            return None
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the jobnimbus integration
    class jobnimbus(TypedDict):
        api_key: str
        user_email: str

    # Import any libraries you need here
    import requests  # Assuming requests is needed to make API calls

    # Define the main function
    def main(jobnimbus_resource: jobnimbus, contact_id: str) -> Optional[dict]:
        # Base URL for the JobNimbus API
        base_url = "https://api.jobnimbus.com"

        # Endpoint to find a contact by ID
        endpoint = f"/v1/contacts/{contact_id}"

        # Headers for authentication
        headers = {
            "x-api-key": jobnimbus_resource['api_key'],
            "x-user-email": jobnimbus_resource['user_email']
        }

        # Make the API request
        response = requests.get(base_url + endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact data
            return response.json()
        else:
            # Return None if the contact was not found or if there was an error
            return None

    # Note: The function is not called here, it's just defined and ready to be used.
  id: |-
    synthetic_find-contact-by-id
  instructions: |-
    Finds contact by ID in jobnimbus
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jobnimbus
  resource_type_def: |-
    class jobnimbus(TypedDict):
        api_key: str
        user_email: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { BigML as BigMLClient } from "npm:bigml";

    type Bigml = {
        username: string;
        apiKey: string;
    }

    export async function main(bigml: Bigml, inputData: Record<string, any>, modelType: string = 'DecisionTree') {
        // Initialize BigML API connection
        const bigmlClient = new BigMLClient(bigml.username, bigml.apiKey);

        // Create the source from the input data
        const source = await bigmlClient.source.create(inputData);

        // Create the dataset from the source
        const dataset = await bigmlClient.dataset.create(source.resource);

        // Create the model based on the specified model type
        let model;
        switch (modelType.toLowerCase()) {
            case 'decisiontree':
                model = await bigmlClient.model.create(dataset.resource);
                break;
            case 'ensemble':
                model = await bigmlClient.ensemble.create(dataset.resource);
                break;
            // Add more cases for different model types if needed
            default:
                throw new Error(`Model type '${modelType}' is not supported.`);
        }

        // Return the model information
        return model;
    }
  good: |-
    import { BigML } from "npm:@bigml/io";

    type BigmlResource = {
        username: string;
        apiKey: string;
    }

    export async function main(bigmlResource: BigmlResource, sourceId?: string, datasetId?: string, modelId?: string) {
        const bigmlClient = new BigML(bigmlResource.username, bigmlResource.apiKey);

        let model;
        if (sourceId) {
            // Create a source, then a dataset, and finally a model
            const source = await bigmlClient.createSource(sourceId);
            const dataset = await bigmlClient.createDataset(source.resource);
            model = await bigmlClient.createModel(dataset.resource);
        } else if (datasetId) {
            // Create a model directly from an existing dataset
            model = await bigmlClient.createModel(datasetId);
        } else if (modelId) {
            // Clone an existing model
            model = await bigmlClient.cloneModel(modelId);
        } else {
            throw new Error("You must provide at least one of the following: sourceId, datasetId, or modelId.");
        }

        return model;
    }
  id: |-
    synthetic_create-model
  instructions: |-
    Create a model based on a given source ID, dataset ID, or model ID in bigml
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bigml
  resource_type_def: |-
    type Bigml = {
        username: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { BigML } from "npm:bigml";

    type BigmlResource = {
        username: string;
        apiKey: string;
    }

    export async function main(bigmlResource: BigmlResource, supervisedModelId: string, datasetId: string) {
        // Initialize BigML API connection
        const bigml = new BigML(bigmlResource.username, bigmlResource.apiKey);

        // Create a prediction using the supervised model ID and dataset ID
        const prediction = await bigml.createPrediction(supervisedModelId, datasetId);

        // Return the prediction result
        return prediction;
    }
  good: |-
    // Importing necessary libraries
    import { BigML } from "npm:bigml";

    type Bigml = {
        username: string;
        apiKey: string;
        // Add other necessary properties for BigML authentication/configuration
    }

    export async function main(
        bigmlResource: Bigml,
        modelId: string,
        inputData: any,
        outputDatasetId?: string // Optional parameter for the user to specify an output dataset ID
    ) {
        // Initialize BigML API with credentials
        const bigml = new BigML(bigmlResource.username, bigmlResource.apiKey);

        // Create the batch prediction
        const prediction = await bigml.createBatchPrediction(modelId, inputData, outputDatasetId);

        // Return the result of the batch prediction
        return prediction;
    }
  id: |-
    synthetic_create-batch-prediction
  instructions: |-
    Create a batch prediction given a Supervised Model ID and a Dataset ID in bigml
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bigml
  resource_type_def: |-
    type Bigml = {
        username: string;
        apiKey: string;
        // Add other necessary properties for BigML authentication/configuration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the 'firmao' integration
    class firmao(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for listing tasks from the 'firmao' integration
    def main(firmao_resource: firmao, user_id: int) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for listing tasks
        tasks_endpoint = f"{firmao_resource['base_url']}/tasks"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {firmao_resource['api_key']}"
        }

        # Make the API request to list tasks for the specified user
        response = requests.get(tasks_endpoint, headers=headers, params={"user_id": user_id})

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of tasks
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an empty list)
            response.raise_for_status()

    # The script ends here, with no call to the main function, as per the instructions.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the 'firmao' integration
    class firmao(TypedDict):
        api_key: str
        organization_id: str

    # Import any libraries you need here
    import requests

    # Define the main function
    def main(firmao_resource: firmao, status: str = 'all') -> List[dict]:
        # Construct the API endpoint for listing tasks
        endpoint = f"https://api.firmao.net/json/task/list/{firmao_resource['organization_id']}"

        # Set up the headers with the API key
        headers = {
            'Authorization': f"Bearer {firmao_resource['api_key']}"
        }

        # Set up the parameters for the request
        params = {
            'status': status
        }

        # Make the request to the Firmao API
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the tasks
            tasks = response.json().get('tasks', [])
            return tasks
        else:
            # Handle the error case
            response.raise_for_status()

    # The complete script is as follows:
  id: |-
    synthetic_list-tasks
  instructions: |-
    List tasks from the organization in firmao
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    firmao
  resource_type_def: |-
    class firmao(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HttpClient } from "npm:@angular/common/http";

    type Aweber = {
        accessToken: string,
        account_id: string,
        list_id: string
    }

    export async function main(aweberResource: Aweber, subscribers: Array<{email: string, name?: string}>) {
        const httpClient = new HttpClient();
        const apiUrl = `https://api.aweber.com/1.0/accounts/${aweberResource.account_id}/lists/${aweberResource.list_id}/subscribers`;

        const results = [];

        for (const subscriber of subscribers) {
            const body = {
                email: subscriber.email,
                name: subscriber.name
            };

            const response = await httpClient.post(apiUrl, body, {
                headers: {
                    "Authorization": `Bearer ${aweberResource.accessToken}`,
                    "Content-Type": "application/json"
                }
            }).toPromise();

            results.push(response);
        }

        return results;
    }
  good: |-
    import { AWeber as AWeberClient } from "npm:@aweber/aweber-js";

    type Aweber = {
        consumerKey: string;
        consumerSecret: string;
        accessToken: string;
        accessTokenSecret: string;
    }

    export async function main(aweberResource: Aweber, accountId: string, listId: string, subscriberEmail: string, name?: string) {
        const aweber = new AWeberClient(
            aweberResource.consumerKey,
            aweberResource.consumerSecret,
            {
                token: aweberResource.accessToken,
                tokenSecret: aweberResource.accessTokenSecret
            }
        );

        const account = await aweber.getAccount(accountId);
        const list = account.lists.find(l => l.id === listId);

        if (!list) {
            throw new Error(`List with ID ${listId} not found.`);
        }

        const subscriber = {
            email: subscriberEmail,
            name: name,
        };

        const result = await list.subscribers.create(subscriber);

        return result;
    }
  id: |-
    synthetic_add-subscriber
  instructions: |-
    Add subscribers to the specified account and list. in aweber
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aweber
  resource_type_def: |-
    type Aweber = {
        consumerKey: string;
        consumerSecret: string;
        accessToken: string;
        accessTokenSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import fetch from "npm:node-fetch";

    type Mixmax = {
        apiKey: string;
    }

    export async function main(mixmaxResource: Mixmax, searchTerm: string) {
        const url = `https://api.mixmax.com/v1/contacts/search?query=${encodeURIComponent(searchTerm)}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-API-Token': mixmaxResource.apiKey
            }
        });

        if (!response.ok) {
            throw new Error(`Error searching contacts: ${response.statusText}`);
        }

        const contacts = await response.json();
        return contacts;
    }
  good: |-
    // Import any libraries you need here
    import fetch from "npm:node-fetch";

    type Mixmax = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(mixmaxResource: Mixmax, searchTerm: string) {
        const url = `${mixmaxResource.apiUrl}/search?term=${encodeURIComponent(searchTerm)}`;
        const headers = {
            'Authorization': `Bearer ${mixmaxResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(url, { headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching contacts:', error);
            throw error;
        }
    }
  id: |-
    synthetic_search-contacts
  instructions: |-
    Search for matching contacts. This API queries across different sources including mixmax, google directory, and salesforce (contacts, leads, accounts, and opportunities) in mixmax
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mixmax
  resource_type_def: |-
    type Mixmax = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'devrev' integration
    class devrev(TypedDict):
        api_key: str

    # Main function to create an opportunity in the devrev platform
    def main(devrev_resource: devrev, opportunity_name: str, opportunity_value: float, opportunity_stage: str) -> Any:
        # Import the requests library here to avoid naming conflicts
        import requests as req

        # Construct the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {devrev_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Define the API endpoint for creating an opportunity
        create_opportunity_endpoint = "https://api.devrev.ai/opportunity"

        # Construct the payload with the opportunity details
        payload = {
            'name': opportunity_name,
            'value': opportunity_value,
            'stage': opportunity_stage
        }

        # Make the POST request to create the opportunity
        response = req.post(create_opportunity_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the created opportunity details
            return response.json()
        else:
            # Handle errors (e.g., display the error message)
            return {'error': response.text, 'status_code': response.status_code}
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'devrev' integration
    class devrev(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a new opportunity in DevRev
    def main(devrev_resource: devrev, opportunity_name: str, opportunity_description: str, opportunity_value: float):
        # Import the necessary library for HTTP requests
        import requests

        # Define the API endpoint for creating a new opportunity in DevRev
        create_opportunity_endpoint = "https://api.devrev.ai/opportunity"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {devrev_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data for the new opportunity
        opportunity_data = {
            "name": opportunity_name,
            "description": opportunity_description,
            "value": opportunity_value
        }

        # Make the HTTP POST request to create the new opportunity
        response = requests.post(create_opportunity_endpoint, headers=headers, json=opportunity_data)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the created opportunity details
            return response.json()
        else:
            # Return an error message if the request failed
            raise Exception(f"Failed to create opportunity: {response.status_code} - {response.text}")

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_create-opportunity
  instructions: |-
    Creates a new opportunity in DevRev in devrev
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    devrev
  resource_type_def: |-
    class devrev(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import asana as asana_client

    class asana(TypedDict):
        access_token: str

    def main(asana_resource: asana, task_list_gid: str) -> List[dict]:
        client = asana_client.Client.access_token(asana_resource['access_token'])
        tasks = client.tasks.find_by_project(project=task_list_gid, opt_fields=['name', 'completed'])
        return list(tasks)
  good: |-
    from typing import TypedDict, List
    import asana

    class asana(TypedDict):
        access_token: str

    def main(asana_resource: asana, user_gid: str) -> List[dict]:
        client = asana.Client.access_token(asana_resource['access_token'])
        tasks = client.tasks.find_all({'assignee': user_gid, 'completed_since': 'now', 'opt_fields': 'name,completed'})
        compact_tasks = [{'id': task['gid'], 'name': task['name']} for task in tasks if not task['completed']]
        return compact_tasks
  id: |-
    synthetic_get-tasks-from-task-list
  instructions: "Returns the compact list of tasks in a user\u2019s My Tasks list.\
    \ in asana"
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    asana
  resource_type_def: |-
    class asana(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'agile_crm' integration
    class agile_crm(TypedDict):
        api_key: str
        email: str
        domain: str

    # Define the main function for creating a deal note in Agile CRM
    def main(agile_crm_resource: agile_crm, deal_id: str, note_content: str, contact_id: str = None):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a note
        endpoint = f"https://{agile_crm_resource['domain']}.agilecrm.com/dev/api/notes"

        # Prepare the headers for the request
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {agile_crm_resource['api_key']}"
        }

        # Prepare the data payload for the note
        note_data = {
            "subject": "Deal Note",
            "description": note_content,
            "contact_ids": [contact_id] if contact_id else [],
            "deal_ids": [deal_id]
        }

        # Make the POST request to create the note
        response = requests.post(endpoint, json=note_data, headers=headers)

        # Check for successful response and return the result
        if response.status_code == 200:
            return response.json()  # Return the created note information
        else:
            response.raise_for_status()  # Raise an exception for any errors

    # The main function is now defined and can be used to create a deal note in Agile CRM.
  good: |-
    import requests
    from typing import TypedDict

    # Define the resource type for the agile_crm integration
    class agile_crm(TypedDict):
        domain: str
        email: str
        api_key: str

    # Define the main function for adding a note to a deal in Agile CRM
    def main(agile_crm_resource: agile_crm, deal_id: str, note_content: str):
        # Construct the API endpoint for adding a note to a deal
        endpoint = f"https://{agile_crm_resource['domain']}.agilecrm.com/dev/api/opportunity/{deal_id}/notes"

        # Prepare the headers and payload for the request
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {agile_crm_resource['api_key']}"
        }
        payload = {
            "subject": "Note added via API",
            "description": note_content,
            "contact_ids": [deal_id]
        }

        # Make the POST request to add the note to the deal
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful and return the result
        if response.status_code == 200:
            return {"success": True, "message": "Note added to the deal successfully.", "data": response.json()}
        else:
            return {"success": False, "message": "Failed to add note to the deal.", "error": response.text}

    # Note: The function is not called here, it is just defined and exported.
  id: |-
    synthetic_create-deal-note
  instructions: |-
    Adds a note to a deal in agile crm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    agile_crm
  resource_type_def: |-
    class agile_crm(TypedDict):
        api_key: str
        email: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the openai integration
    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, message_id: str, new_text: str) -> Any:
        import openai as openai_api

        # Configure the OpenAI library with the API key from the resource
        openai_api.api_key = openai_resource['api_key']

        # Modify the message with the given message_id and new_text
        response = openai_api.Message.update(
            id=message_id,
            text=new_text
        )

        # Return the response from the OpenAI API
        return response
  good: |-
    from typing import TypedDict
    import openai as openai_client

    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, message_id: str, thread_id: str, updated_message: str):
        openai_client.api_key = openai_resource['api_key']

        response = openai_client.Message.update(
            message_id=message_id,
            thread_id=thread_id,
            text=updated_message
        )

        return response
  id: |-
    synthetic_modify-message
  instructions: |-
    Modifies an existing message in a thread in openai
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    from google.cloud import language_v1 as language
    from google.oauth2 import service_account

    class google_palm_api(TypedDict):
        api_key: str

    def main(google_palm_api_credentials: google_palm_api, texts: List[str]) -> List[dict]:
        # Setup the client with the API key
        credentials = service_account.Credentials.from_service_account_info({
            'api_key': google_palm_api_credentials['api_key']
        })
        client = language.LanguageServiceClient(credentials=credentials)

        # Generate embeddings for the provided texts
        embeddings = []
        for text in texts:
            document = language.Document(content=text, type_=language.Document.Type.PLAIN_TEXT)
            response = client.analyze_entities(document=document)
            embeddings.append(response)

        return embeddings
  good: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed to make API calls to Google PaLM

    # Define the resource type for the google_palm_api integration
    class google_palm_api(TypedDict):
        api_key: str
        endpoint_url: str

    def main(google_palm_api_resource: google_palm_api, text: str) -> Dict[str, Any]:
        headers = {
            "Authorization": f"Bearer {google_palm_api_resource['api_key']}",
            "Content-Type": "application/json"
        }

        payload = {
            "text": text,
            # Add any additional parameters required by the API for generating embeddings
        }

        response = requests.post(
            google_palm_api_resource['endpoint_url'],
            headers=headers,
            json=payload
        )

        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()  # Return the embeddings or the complete response as a JSON object
  id: |-
    synthetic_generate-embeddings
  instructions: |-
    Generate embeddings using Google PaLM in google palm api
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_palm_api
  resource_type_def: |-
    class google_palm_api(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Missive } from "npm:@missive/missive-api";

    type MissiveResource = {
        apiKey: string;
    }

    export async function main(missiveResource: MissiveResource) {
        const missive = new Missive(missiveResource.apiKey);
        const contacts = await missive.contacts.list();
        return contacts;
    }
  good: |-
    // Import any libraries you need here
    import { MissiveClient } from "npm:@missive/missive-api";

    type Missive = {
        apiKey: string;
    }

    export async function main(missiveResource: Missive) {
        const client = new MissiveClient({ apiKey: missiveResource.apiKey });

        const contacts = await client.contacts.list();

        return contacts;
    }
  id: |-
    synthetic_list-contacts
  instructions: |-
    List all contacts in missive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Missive
  resource_type_def: |-
    type Missive = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Workbook } from "npm:@microsoft/microsoft-graph-types";
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftExcel = {
        accessToken: string;
    }

    export async function main(
        excelResource: MicrosoftExcel,
        workbookId: string,
        worksheetId: string,
        values: any[][]
    ) {
        const client = Client.init({
            authProvider: (done) => {
                done(null, excelResource.accessToken); // Provide the access token to the authProvider callback
            }
        });

        const url = `/me/drive/items/${workbookId}/workbook/worksheets/${worksheetId}/tables/0/rows/add`;
        const requestBody = {
            index: null, // This will add a new row at the end of the table
            values: values
        };

        const result = await client.api(url)
            .version('v1.0')
            .post(requestBody);

        return result;
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftExcel = {
        accessToken: string;
        siteId: string;
        workbookId: string;
    }

    export async function main(
        microsoftExcelResource: MicrosoftExcel,
        tableName: string,
        rows: any[][]
    ) {
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsoftExcelResource.accessToken); // Here we are providing the access token to the authProvider callback
            }
        });

        const siteId = microsoftExcelResource.siteId;
        const workbookId = microsoftExcelResource.workbookId;
        const endpoint = `/sites/${siteId}/drive/items/${workbookId}/workbook/tables/${tableName}/rows/add`;

        const result = await client.api(endpoint)
            .version('v1.0')
            .post({
                index: null, // This will add rows to the end of the table
                values: rows
            });

        return result;
    }
  id: |-
    synthetic_add-a-worksheet-tablerow
  instructions: |-
    Adds rows to the end of specific table in microsoft excel
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftExcel
  resource_type_def: |-
    type MicrosoftExcel = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Blob } from "npm:buffer";

    type FacebookGroups = {
        accessToken: string;
        groupId: string;
    }

    export async function main(facebookGroupsResource: FacebookGroups, photoBlob: Blob, caption: string) {
        const url = `https://graph.facebook.com/v14.0/${facebookGroupsResource.groupId}/photos`;
        const formData = new FormData();
        formData.append('access_token', facebookGroupsResource.accessToken);
        formData.append('caption', caption);
        formData.append('source', photoBlob);

        const response = await fetch(url, {
            method: 'POST',
            body: formData,
        });

        return response.json();
    }
  good: |-
    import { Blob } from "npm:buffer";

    type FacebookGroups = {
        accessToken: string;
        groupId: string;
    }

    export async function main(facebookGroupsResource: FacebookGroups, photo: Blob, caption: string) {
        const url = `https://graph.facebook.com/v14.0/${facebookGroupsResource.groupId}/photos`;
        const formData = new FormData();
        formData.append('access_token', facebookGroupsResource.accessToken);
        formData.append('caption', caption);
        formData.append('source', photo);

        const response = await fetch(url, {
            method: 'POST',
            body: formData,
        });

        return response.json();
    }
  id: |-
    synthetic_post-photo
  instructions: |-
    Post a photo in a group in facebook groups
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FacebookGroups
  resource_type_def: |-
    type FacebookGroups = {
        accessToken: string;
        groupId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import base64
    import boto3

    class aws(TypedDict):
        access_key_id: str
        secret_access_key: str
        session_token: str  # Optional, used for temporary credentials
        region_name: str

    def main(aws_resource: aws, base64_data: str = '', variable_name: str = '', bucket_name: str = '', object_key: str = ''):
        # Initialize AWS S3 client with the provided credentials
        s3_client = boto3.client(
            's3',
            aws_access_key_id=aws_resource['access_key_id'],
            aws_secret_access_key=aws_resource['secret_access_key'],
            aws_session_token=aws_resource.get('session_token'),
            region_name=aws_resource['region_name']
        )

        # If a variable name is provided, fetch the base64 string from AWS
        if variable_name:
            response = s3_client.get_object(Bucket=bucket_name, Key=variable_name)
            base64_data = response['Body'].read().decode('utf-8')

        # Decode the base64 string
        decoded_data = base64.b64decode(base64_data)

        # Upload the decoded data to the specified S3 bucket
        s3_client.put_object(Bucket=bucket_name, Key=object_key, Body=decoded_data)

        # Return a confirmation message
        return f"Data has been successfully uploaded to {bucket_name}/{object_key}"

    # Note: The function is not called here, it is just defined and exported.
  good: |-
    import base64
    import boto3
    from typing import TypedDict, Optional

    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str

    def main(aws_resource: aws, file_base64: str, bucket_name: str, object_name: str, aws_session_token: Optional[str] = None) -> dict:
        # Decode the base64 file content
        file_content = base64.b64decode(file_base64)

        # Initialize a boto3 client
        s3_client = boto3.client(
            's3',
            aws_access_key_id=aws_resource['aws_access_key_id'],
            aws_secret_access_key=aws_resource['aws_secret_access_key'],
            region_name=aws_resource['region_name'],
            aws_session_token=aws_session_token
        )

        # Upload the file to S3
        response = s3_client.put_object(Bucket=bucket_name, Key=object_name, Body=file_content)

        # Return the response from the S3 API
        return response
  id: |-
    synthetic_s3-upload-file
  instructions: |-
    A string of base64-encoded data, or a variable reference to that string in aws
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aws
  resource_type_def: |-
    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AgileCrmClient } from "npm:agilecrm";

    type AgileCrm = {
        domain: string;
        email: string;
        apiKey: string;
    }

    export async function main(agileCrmResource: AgileCrm, taskType: string, subject: string, dueDate: string, priority: string, contacts: string[]) {
        const client = new AgileCrmClient(agileCrmResource.domain, agileCrmResource.email, agileCrmResource.apiKey);

        const task = {
            type: taskType,
            subject: subject,
            due: dueDate,
            priority: priority,
            contacts: contacts
        };

        const result = await client.tasks.create(task);

        return result;
    }
  good: |-
    import { AgileCrmClient } from "npm:agile-crm-wrapper";

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, taskType: string, subject: string, dueDate: string, priority: string, contacts: string[]) {
        const client = new AgileCrmClient({
            apiKey: agileCrmResource.apiKey,
            domain: agileCrmResource.domain,
            email: agileCrmResource.email
        });

        const task = {
            type: taskType,
            subject: subject,
            due: dueDate,
            priority: priority,
            contacts: contacts
        };

        const result = await client.tasks.create(task);
        return result;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Create a new task in Agile CRM in agile crm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AgileCrm
  resource_type_def: |-
    type AgileCrm = {
        domain: string;
        email: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Clickup = {
        accessToken: string;
        teamId: string;
    }

    export async function main(
        clickupResource: Clickup,
        listId: string,
        taskName: string,
        taskDescription: string,
        assignees: string[],
        priority: number,
        dueDate: string | null
    ) {
        const endpoint = `https://api.clickup.com/api/v2/list/${listId}/task`;

        const taskData = {
            name: taskName,
            description: taskDescription,
            assignees: assignees,
            status: "to do",
            priority: priority,
            due_date: dueDate ? new Date(dueDate).getTime() : null,
            start_date: new Date().getTime(),
            unique_id: uuidv4()
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': clickupResource.accessToken
            },
            body: JSON.stringify(taskData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Clickup = {
        apiKey: string;
        teamId: string;
    }

    export async function main(
        clickupResource: Clickup,
        templateId: string,
        listId: string,
        taskName: string,
        assignees?: string[], // Optional array of user IDs to assign to the task
        dueDate?: string, // Optional due date in ISO 8601 format
        priority?: number // Optional priority (1-4)
    ) {
        const url = `https://api.clickup.com/api/v2/list/${listId}/taskTemplate/${templateId}`;
        const body = {
            name: taskName,
            assignees: assignees,
            due_date: dueDate,
            priority: priority,
            // Add any other properties that are needed to create a task from a template
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': clickupResource.apiKey
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-task-from-template
  instructions: |-
    Creates a new task from a template. See the docs in **Task Templates / Create Task From Template** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        accessToken: string;
        teamId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { LinkedInClient } from "npm:linkedin-client"; // Hypothetical npm package for LinkedIn API

    type Linkedin = {
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(linkedinResource: Linkedin, campaignId: string) {
        // Initialize the LinkedIn client with the provided credentials
        const linkedInClient = new LinkedInClient({
            accessToken: linkedinResource.accessToken,
            clientId: linkedinResource.clientId,
            clientSecret: linkedinResource.clientSecret
        });

        // Query the Analytics Finder for the specified Campaign
        const campaignAnalytics = await linkedInClient.getCampaignAnalytics(campaignId);

        // Return the result
        return campaignAnalytics;
    }
  good: |-
    // Import necessary libraries
    import { LinkedInClient } from "npm:linkedin-client"; // Example import, replace with actual library if different

    type Linkedin = {
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(linkedinResource: Linkedin, campaignId: string, startDate: string, endDate: string) {
        // Initialize the LinkedIn client with the provided credentials
        const linkedInClient = new LinkedInClient({
            accessToken: linkedinResource.accessToken,
            clientId: linkedinResource.clientId,
            clientSecret: linkedinResource.clientSecret
        });

        // Fetch analytics for the specified campaign within the date range
        const analytics = await linkedInClient.getAnalytics({
            campaignId: campaignId,
            timeRange: {
                startDate: startDate,
                endDate: endDate
            }
        });

        // Return the analytics data
        return analytics;
    }
  id: |-
    synthetic_analytics-finder-campaign-sample
  instructions: |-
    Sample query using analytics finder that gets analytics for a particular campaign in a date range starting in a given year in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string; // Assuming OAuth2 flow has been completed and we have an access token
    }

    export async function main(microsoft365PeopleResource: Microsoft365People, folderName: string) {
        // Initialize the Microsoft Graph client with the provided credentials
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsoft365PeopleResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Create a contact folder with the specified name
        const contactFolder = {
            DisplayName: folderName,
            ParentFolderId: "contacts"
        };

        try {
            const result = await client.api('/me/contactFolders')
                .version('v1.0')
                .post(contactFolder);

            return result;
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string; // Assuming the OAuth2 flow has been completed and we have an access token
    }

    export async function main(microsoft365PeopleResource: Microsoft365People, folderName: string) {
        // Initialize the Microsoft Graph client with the provided credentials
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsoft365PeopleResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Create a new contact folder with the specified name
        const newFolder = {
            DisplayName: folderName,
            ParentFolderId: null // Assuming we want to create the folder at the root level
        };

        try {
            const result = await client.api('/me/contactFolders')
                .version('v1.0')
                .post(newFolder);

            return result;
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_create-contact-folder
  instructions: |-
    Create a new contact folder in Microsoft 365 People in microsoft 365 people
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Microsoft365People
  resource_type_def: |-
    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string; // Assuming OAuth2 flow has been completed and we have an access token
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Airtable API

    # Define the resource type for the airtable_oauth integration
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str

    # Define the main function for creating or updating a single record in Airtable
    def main(airtable_resource: airtable_oauth, table_name: str, record_id: Optional[str], record_data: Dict[str, Any]):
        # Endpoint for the Airtable API
        endpoint = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{table_name}"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {airtable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # If record_id is provided, update the record, otherwise create a new one
        if record_id:
            # Update a record
            response = requests.patch(f"{endpoint}/{record_id}", headers=headers, json={"fields": record_data})
        else:
            # Create a new record
            response = requests.post(endpoint, headers=headers, json={"records": [{"fields": record_data}]})

        # Return the response from the Airtable API
        return response.json()
  good: |-
    from typing import TypedDict, Optional, Dict, Any
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the airtable_oauth integration
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str
        table_name: str

    def main(airtable_resource: airtable_oauth, record_data: Dict[str, Any], record_id: Optional[str] = None) -> Dict[str, Any]:
        headers = {
            'Authorization': f"Bearer {airtable_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{airtable_resource['table_name']}"

        if record_id:
            # Update a record
            response = requests.patch(f"{url}/{record_id}", headers=headers, json={"fields": record_data})
        else:
            # Create a new record
            response = requests.post(url, headers=headers, json={"fields": record_data})

        return response.json()
  id: |-
    synthetic_create-or-update-record
  instructions: |-
    Updates a record if `recordId` is provided or adds a record to a table. in airtable oauth
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    airtable_oauth
  resource_type_def: |-
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HttpClient } from "npm:@angular/common/http";

    type Awork = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(aworkResource: Awork, clientName: string, clientEmail: string, clientPhone?: string) {
        const httpClient = new HttpClient();
        const url = `https://api.awork.io/api/v1/workspaces/${aworkResource.workspaceId}/clients`;

        const headers = {
            'Authorization': `Bearer ${aworkResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        const body = {
            name: clientName,
            email: clientEmail,
            phone: clientPhone
        };

        try {
            const response = await httpClient.post(url, body, { headers });
            return response;
        } catch (error) {
            console.error('Error creating client in awork:', error);
            throw error;
        }
    }
  good: |-
    // Import necessary libraries
    import { Awork as AworkAPI } from 'npm:@awork-io/node-api-wrapper';

    type Awork = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(aworkResource: Awork, clientName: string, clientEmail: string, clientPhone?: string) {
        // Initialize the Awork API wrapper with the provided apiKey and workspaceId
        const aworkApi = new AworkAPI(aworkResource.apiKey, aworkResource.workspaceId);

        // Create a new client in Awork with the provided details
        const clientData = {
            name: clientName,
            email: clientEmail,
            phone: clientPhone
        };

        try {
            const newClient = await aworkApi.clients.create(clientData);
            return newClient; // Return the newly created client object
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error('Error creating client in Awork:', error);
            throw error; // Rethrow the error to be handled by the caller
        }
    }
  id: |-
    synthetic_create-client
  instructions: |-
    Creates a client in awork
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Awork
  resource_type_def: |-
    type Awork = {
        apiKey: string;
        workspaceId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the JustCall integration
    class justcall(TypedDict):
        account_sid: str
        auth_token: str
        sms_capable_number: str

    # Import the JustCall SDK or relevant library
    # If there's a conflict with the name 'justcall', rename the imported method
    # Assuming 'justcall_sdk' is the library that we need to use
    import justcall_sdk as jc_sdk

    def main(justcall_resource: justcall, recipient_number: str, message_body: str):
        # Initialize the JustCall client with the provided credentials
        client = jc_sdk.Client(justcall_resource['account_sid'], justcall_resource['auth_token'])

        # Send the SMS using the JustCall client
        sms_response = client.send_sms(
            from_=justcall_resource['sms_capable_number'],
            to=recipient_number,
            body=message_body
        )

        # Return the response from the SMS send attempt
        return sms_response
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'justcall' integration
    class justcall(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for sending a text message using the 'justcall' integration
    def main(justcall_resource: justcall, to_number: str, from_number: str, message_body: str):
        # Import the necessary library for making HTTP requests
        import requests

        # Define the JustCall API endpoint for sending text messages
        justcall_api_endpoint = "https://justcall.io/api/sms/send"

        # Prepare the headers and payload for the API request
        headers = {
            "Content-Type": "application/json",
            "api-key": justcall_resource['api_key'],
            "api-secret": justcall_resource['api_secret']
        }
        payload = {
            "to": to_number,
            "from": from_number,
            "body": message_body
        }

        # Make the API request to send the text message
        response = requests.post(justcall_api_endpoint, json=payload, headers=headers)

        # Return the API response
        return response.json()
  id: |-
    synthetic_send-text-message
  instructions: |-
    Send a text from your JustCall SMS capabled number in justcall
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    justcall
  resource_type_def: |-
    class justcall(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { create as createCertificate } from "npm:@cloudflare/ssl";

    type CloudflareApiKey = {
        email: string;
        apiKey: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, hostname: string, zoneId: string) {
        const { email, apiKey } = cloudflareResource;

        const certificateResponse = await createCertificate({
            email,
            apiKey,
            zoneId,
            hostnames: [hostname],
        });

        return certificateResponse;
    }
  good: |-
    import { createHash } from "npm:crypto";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, hostnames: string[], requestType: string = 'origin-rsa', expiresIn: number = 5475) {
        const url = 'https://api.cloudflare.com/client/v4/certificates';
        const body = {
            hostnames: hostnames,
            request_type: requestType,
            requested_validity: expiresIn
        };

        const headers = {
            'X-Auth-Email': cloudflareResource.email,
            'X-Auth-Key': cloudflareResource.apiKey,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`Cloudflare API responded with status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_create-certificate
  instructions: |-
    Creates an Origin CA certificate in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        email: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { MemClient } from "npm:@trymem/mem-node";

    type Mem = {
        apiKey: string;
    }

    export async function main(memResource: Mem, title: string, content: string) {
        const memClient = new MemClient({ apiKey: memResource.apiKey });
        const result = await memClient.createMem({
            title: title,
            content: content
        });

        return result;
    }
  good: |-
    type Mem = {
        apiKey: string;
    }

    export async function main(memResource: Mem, content: string, parentMemId?: string) {
        const response = await fetch('https://api.mem.ai/v1/mems', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${memResource.apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                content: content,
                parentMemId: parentMemId,
            }),
        });

        if (!response.ok) {
            throw new Error(`Failed to append Mem: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_append-mem
  instructions: |-
    Create a new mem in mem
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mem
  resource_type_def: |-
    type Mem = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AmiliaClient } from "npm:@my/amilia-api-wrapper"; // Hypothetical npm package for Amilia API

    type Amilia = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(amiliaResource: Amilia, accountId: string) {
        const client = new AmiliaClient(amiliaResource.apiKey, amiliaResource.apiUrl);
        const accountDetails = await client.getAccount(accountId);
        return accountDetails;
    }
  good: |-
    // Import necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Amilia = {
        apiKey: string;
        organizationId: string;
    }

    export async function main(amiliaResource: Amilia, clientId: string) {
        const baseUrl = `https://api.amilia.com/api/v3/organizations/${amiliaResource.organizationId}/accounts/${clientId}`;
        const headers = {
            'Authorization': `Basic ${encode(amiliaResource.apiKey + ':')}`,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(baseUrl, {
                method: 'GET',
                headers: headers
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching client account:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-account
  instructions: |-
    Get an (client) account in your organization in amilia
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amilia
  resource_type_def: |-
    type Amilia = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for HTTP requests
    import fetch from "npm:node-fetch";

    type Kvdb = {
        apiKey: string,
        bucketId: string
    }

    export async function main(kvdbResource: Kvdb, key: string, value: string) {
        const url = `https://kvdb.io/${kvdbResource.bucketId}/${key}`;
        const options = {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${kvdbResource.apiKey}`,
                'Content-Type': 'text/plain'
            },
            body: value
        };

        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.text();
        } catch (error) {
            console.error('Error writing to KVDB:', error);
            throw error;
        }
    }
  good: |-
    // Import any libraries you need here
    import { Bucket } from "npm:@kvdb.io";

    type Kvdb = {
        bucketId: string,
        accessToken: string
    }

    export async function main(kvdbResource: Kvdb, key: string): Promise<string | null> {
        const bucket = new Bucket(kvdbResource.bucketId, kvdbResource.accessToken);
        const value = await bucket.get(key);
        return value;
    }
  id: |-
    synthetic_get-key-value
  instructions: |-
    KVDB is designed for quick and easy integration into projects that need a globally accessible key-value database. To get started, create at API key at https://kvdb.io/ in kvdb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Kvdb
  resource_type_def: |-
    type Kvdb = {
        bucketId: string,
        accessToken: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import facebook  # Hypothetical library for Facebook integration

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Main function to list comments from a Facebook Group
    def main(facebook_groups_resource: facebook_groups, post_id: str) -> List[dict]:
        # Initialize the Facebook SDK client with the access token
        fb_client = facebook.GraphAPI(access_token=facebook_groups_resource['access_token'])

        # Fetch the comments for the given post_id
        comments_data = fb_client.get_connections(id=post_id, connection_name='comments')

        # Extract the list of comments
        comments = comments_data.get('data', [])

        # Return the list of comments
        return comments
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the resource type and additional parameters
    def main(facebook_groups_resource: facebook_groups, group_id: str, post_id: str) -> List[Dict]:
        # Construct the URL for the Facebook Graph API to get comments on a group post
        url = f"https://graph.facebook.com/{group_id}_{post_id}/comments"

        # Prepare the headers with the OAuth2 Access Token
        headers = {
            "Authorization": f"Bearer {facebook_groups_resource['access_token']}"
        }

        # Make the HTTP GET request to retrieve the comments
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the list of comments
            comments_data = response.json()
            return comments_data.get('data', [])
        else:
            # If the request failed, raise an exception with the error message
            response.raise_for_status()

    # The script ends here, with no call to the main function, as per the instructions.
  id: |-
    synthetic_list-comments
  instructions: |-
    Retrieves a list of comments on a group post in facebook groups
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    facebook_groups
  resource_type_def: |-
    class facebook_groups(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { EdenAi as EdenAiSDK } from "npm:@edenai/ai-api-sdk";

    type EdenAi = {
        apiKey: string;
    }

    export async function main(edenAiResource: EdenAi, textToTranslate: string, sourceLanguage: string, targetLanguage: string) {
        const edenAi = new EdenAiSDK(edenAiResource.apiKey);

        const translationResult = await edenAi.translation.translate({
            text: textToTranslate,
            source_language: sourceLanguage,
            target_language: targetLanguage
        });

        return translationResult;
    }
  good: |-
    // Importing necessary libraries
    import { readFile } from "npm:fs/promises";

    type EdenAi = {
        apiKey: string;
        endpoint: string;
    }

    export async function main(
        edenAiResource: EdenAi,
        sourceLanguage: string,
        targetLanguage: string,
        documentPath: string,
        isUrl: boolean
    ) {
        // Prepare the API URL
        const apiUrl = `${edenAiResource.endpoint}/v1/pretrained/translation`;

        // Prepare the headers
        const headers = {
            'Authorization': `Bearer ${edenAiResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        // Prepare the body
        let body: any;
        if (isUrl) {
            body = JSON.stringify({
                'source_language': sourceLanguage,
                'target_language': targetLanguage,
                'text': documentPath // Assuming the documentPath is the URL to the document
            });
        } else {
            // Read the local file content
            const documentContent = await readFile(documentPath, 'utf-8');
            body = JSON.stringify({
                'source_language': sourceLanguage,
                'target_language': targetLanguage,
                'text': documentContent
            });
        }

        // Make the API request
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Parse the response
        const result = await response.json();

        // Return the result
        return result;
    }
  id: |-
    synthetic_translate-document
  instructions: |-
    Translates a document from a local file or URL in eden ai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    EdenAi
  resource_type_def: |-
    type EdenAi = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'hostaway' integration
    class hostaway(TypedDict):
        api_key: str
        account_id: str

    # Define the main function for sending a message to a guest
    def main(hostaway_resource: hostaway, guest_id: int, message: str) -> Any:
        # Import the necessary library for making HTTP requests
        import requests

        # Define the endpoint for sending a message
        send_message_endpoint = f"https://api.hostaway.com/v1/listings/{hostaway_resource['account_id']}/reservations/{guest_id}/messages"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {hostaway_resource['api_key']}"
        }

        # Prepare the payload with the message
        payload = {
            "content": message
        }

        # Make the POST request to send the message
        response = requests.post(send_message_endpoint, headers=headers, json=payload)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    class hostaway(TypedDict):
        api_key: str
        account_id: str

    def main(hostaway_resource: hostaway, guest_id: int, message: str):
        url = f"https://api.hostaway.com/v1/conversations/{guest_id}/messages"
        headers = {
            "Authorization": f"Bearer {hostaway_resource['api_key']}",
            "X-Account-Id": hostaway_resource['account_id']
        }
        payload = {
            "content": message
        }
        response = requests.post(url, headers=headers, json=payload)
        return response.json()
  id: |-
    synthetic_send-message-to-guest
  instructions: |-
    Send a conversation message to a guest in Hostaway in hostaway
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hostaway
  resource_type_def: |-
    class hostaway(TypedDict):
        api_key: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import json

    class helper_functions(TypedDict):
        api_key: str

    def main(helper_functions_resource: helper_functions, data_object: Any) -> str:
        json_string = json.dumps(data_object)
        return json_string
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'helper_functions' integration
    class helper_functions(TypedDict):
        # Assuming the 'helper_functions' integration requires an API key for authentication
        api_key: str

    def main(helper_functions_resource: helper_functions, object_to_convert: Any) -> str:
        import json  # Importing here to avoid conflicts with the resource type name

        # Convert the JavaScript-like object (Python dictionary) to a JSON string
        json_string = json.dumps(object_to_convert)

        # Return the JSON string
        return json_string
  id: |-
    synthetic_convert-object-to-json-string
  instructions: |-
    Accepts a JavaScript object, returns that object converted to a JSON string in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        # Assuming the 'helper_functions' integration requires an API key for authentication
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client as AsanaClient } from "npm:@asana";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, taskListId: string) {
        const client = AsanaClient.create().useAccessToken(asanaResource.accessToken);
        const tasks = await client.tasks.findByProject(taskListId, { opt_fields: 'id,name,assignee,status,completed,due_on' }).then(tasks => tasks.data);

        return tasks;
    }
  good: |-
    import { Client } from "npm:@asana";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, workspaceId: string, userId: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);
        const result = await client.tasks.findAll({
            assignee: userId,
            workspace: workspaceId,
            opt_fields: 'name,completed,assignee_status',
            completed_since: 'now',
            limit: 100
        });

        const compactTasks = result.data.map(task => ({
            id: task.gid,
            name: task.name,
            completed: task.completed,
            assignee_status: task.assignee_status
        }));

        return compactTasks;
    }
  id: |-
    synthetic_get-tasks-from-task-list
  instructions: "Returns the compact list of tasks in a user\u2019s My Tasks list.\
    \ in asana"
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asana
  resource_type_def: |-
    type Asana = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests

    class megaventory(TypedDict):
        api_key: str
        endpoint_url: str

    def main(megaventory_resource: megaventory, purchase_order_id: Optional[int] = None, supplier_client_id: int, inventory_location_id: int, order_status: str, order_details: list):
        headers = {
            'ApiKey': megaventory_resource['api_key'],
            'Content-Type': 'application/json'
        }

        data = {
            'PurchaseOrder': {
                'PurchaseOrderID': purchase_order_id,
                'SupplierClientID': supplier_client_id,
                'InventoryLocationID': inventory_location_id,
                'PurchaseOrderStatus': order_status,
                'PurchaseOrderDetails': order_details
            }
        }

        if purchase_order_id is None:
            url = f"{megaventory_resource['endpoint_url']}/PurchaseOrder/Insert"
        else:
            url = f"{megaventory_resource['endpoint_url']}/PurchaseOrder/Update"

        response = requests.post(url, headers=headers, json=data)

        return response.json()
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the 'megaventory' integration
    class megaventory(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the function to insert or update a purchase order
    def main(
        megaventory_resource: megaventory,
        purchase_order_id: Optional[int],
        supplier_client_id: int,
        inventory_location_id: int,
        order_status: str,
        order_details: list,
        order_date: str,
        order_currency_code: str
    ):
        # Import the necessary library for HTTP requests
        import requests

        # Prepare the API URL for inserting or updating a purchase order
        url = f"{megaventory_resource['endpoint_url']}/PurchaseOrder/Save"

        # Prepare the data payload for the API request
        data = {
            "APIKEY": megaventory_resource['api_key'],
            "mvPurchaseOrder": {
                "PurchaseOrderID": purchase_order_id,
                "SupplierClientID": supplier_client_id,
                "InventoryLocationID": inventory_location_id,
                "PurchaseOrderStatus": order_status,
                "PurchaseOrderDetails": order_details,
                "PurchaseOrderDate": order_date,
                "PurchaseOrderCurrencyCode": order_currency_code
            }
        }

        # Make the API request to insert or update the purchase order
        response = requests.post(url, json=data)

        # Return the response from the API
        return response.json()
  id: |-
    synthetic_insert-or-update-purchase-order
  instructions: |-
    Insert or update a purchase order in the database. in megaventory
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    megaventory
  resource_type_def: |-
    class megaventory(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { v2 as cloudinary } from "npm:cloudinary";

    type Cloudinary = {
        cloudName: string;
        apiKey: string;
        apiSecret: string;
    }

    export async function main(
        cloudinaryResource: Cloudinary,
        publicId: string,
        transformationOptions: cloudinary.TransformationOptions
    ) {
        // Configure Cloudinary with the provided credentials
        cloudinary.config({
            cloud_name: cloudinaryResource.cloudName,
            api_key: cloudinaryResource.apiKey,
            api_secret: cloudinaryResource.apiSecret
        });

        // Apply the transformation to the specified resource
        try {
            const result = await cloudinary.uploader.explicit(publicId, {
                type: 'upload',
                transformation: transformationOptions
            });

            return result;
        } catch (error) {
            // Handle any errors that occur during the transformation
            console.error('Error transforming resource:', error);
            throw error;
        }
    }
  good: |-
    import { v2 as cloudinaryApi } from "npm:cloudinary";

    type Cloudinary = {
        cloudName: string;
        apiKey: string;
        apiSecret: string;
    }

    export async function main(cloudinaryResource: Cloudinary, imagePath: string, transformationOptions: cloudinaryApi.TransformationOptions) {
        cloudinaryApi.config({
            cloud_name: cloudinaryResource.cloudName,
            api_key: cloudinaryResource.apiKey,
            api_secret: cloudinaryResource.apiSecret,
        });

        try {
            const result = await cloudinaryApi.uploader.upload(imagePath, {
                transformation: transformationOptions
            });
            return result;
        } catch (error) {
            console.error('Error uploading and transforming image:', error);
            throw error;
        }
    }
  id: |-
    synthetic_resource-transformation
  instructions: |-
    Transforms image or video resources on-the-fly.  It allows transformation options for resource optimization (i.e. web viewing), resize and crop the resources, etc in cloudinary
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Cloudinary
  resource_type_def: |-
    type Cloudinary = {
        cloudName: string;
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the crove_app integration
    class crove_app(TypedDict):
        api_key: str
        base_url: str

    def main(crove_app_resource: crove_app, document_path: str, recipient_email: str) -> Any:
        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {crove_app_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the URL for sending the document
        url = f"{crove_app_resource['base_url']}/send-document"

        # Prepare the data payload for the POST request
        data = {
            'document_path': document_path,
            'recipient_email': recipient_email
        }

        # Make the POST request to send the document
        response = requests.post(url, headers=headers, json=data)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the crove_app integration
    class crove_app(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for sending an email invitation to fill and sign a document
    def main(crove_app_resource: crove_app, document_id: str, recipient_email: str, subject: str, message: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for sending the invitation
        endpoint = f"{crove_app_resource['base_url']}/send-invitation"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Bearer {crove_app_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "document_id": document_id,
            "recipient_email": recipient_email,
            "subject": subject,
            "message": message
        }

        # Make the API request to send the invitation
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check the response and return the result
        if response.status_code == 200:
            return {"success": True, "message": "Invitation sent successfully."}
        else:
            return {"success": False, "message": "Failed to send invitation.", "error": response.text}

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_send-document
  instructions: |-
    Send email invitation link to fill & sign the document.   in crove app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    crove_app
  resource_type_def: |-
    class crove_app(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { CustomerIoEvent } from "npm:@customer.io/messaging-apis";

    type CustomerIo = {
        siteId: string;
        apiKey: string;
    }

    export async function main(customerIoResource: CustomerIo, customerId: string, eventName: string, eventData: Record<string, any>) {
        const customerIoEvent = new CustomerIoEvent(customerIoResource.siteId, customerIoResource.apiKey);

        const response = await customerIoEvent.track(customerId, eventName, eventData);
        return response;
    }
  good: |-
    import { CustomerIo as CustomerIoClient } from "npm:@customer.io/node"; // Renamed imported class to avoid conflict

    type CustomerIo = {
        siteId: string;
        apiKey: string;
    };

    export async function main(
        customerIo: CustomerIo,
        customerId: string,
        eventName: string,
        eventData: Record<string, any>
    ) {
        const cio = new CustomerIoClient(customerIo.siteId, customerIo.apiKey);

        try {
            const response = await cio.track(customerId, eventName, eventData);
            return response;
        } catch (error) {
            // Handle error appropriately
            console.error('Failed to send event to Customer.io:', error);
            throw error;
        }
    }
  id: |-
    synthetic_send-event-to-customer-io
  instructions: |-
    Sends, tracks a customer event to Customer io in customer io
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CustomerIo
  resource_type_def: |-
    type CustomerIo = {
        siteId: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import googleapiclient.discovery

    class google_calendar(TypedDict):
        api_key: str
        calendar_id: str

    def main(google_calendar_resource: google_calendar,
             event_title: str,
             event_description: str,
             start_time: str,
             end_time: str,
             timezone: Optional[str] = 'UTC',
             location: Optional[str] = None,
             attendees: Optional[list[dict]] = None):

        service = googleapiclient.discovery.build('calendar', 'v3', developerKey=google_calendar_resource['api_key'])

        event = {
            'summary': event_title,
            'description': event_description,
            'start': {
                'dateTime': start_time,
                'timeZone': timezone,
            },
            'end': {
                'dateTime': end_time,
                'timeZone': timezone,
            },
            'location': location,
            'attendees': attendees,
        }

        created_event = service.events().insert(calendarId=google_calendar_resource['calendar_id'], body=event).execute()

        return created_event
  good: |-
    from typing import TypedDict
    import googleapiclient.discovery

    class google_calendar(TypedDict):
        api_key: str
        access_token: str

    def main(google_calendar_resource: google_calendar, event_details: dict):
        credentials = googleapiclient.credentials.Credentials(
            token=google_calendar_resource['access_token']
        )

        service = googleapiclient.discovery.build(
            'calendar', 'v3', credentials=credentials
        )

        event = service.events().insert(calendarId='primary', body=event_details).execute()

        return event
  id: |-
    synthetic_create-event
  instructions: |-
    Create an event to the Google Calendar in google calendar
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_calendar
  resource_type_def: |-
    class google_calendar(TypedDict):
        api_key: str
        calendar_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import frontapp as frontapp_lib  # Renamed the imported library to avoid conflict

    class frontapp(TypedDict):
        api_key: str

    def main(frontapp_resource: frontapp, message_id: str) -> frontapp_lib.Message:
        client = frontapp_lib.Client(frontapp_resource['api_key'])
        message = client.get_message(message_id)
        return message
  good: |-
    from typing import TypedDict
    import frontapp  # Assuming frontapp is a library for the Front App integration

    # Rename the imported method if it conflicts with the resource type name
    if 'frontapp' in dir(frontapp):
        frontapp_api = frontapp.frontapp
    else:
        frontapp_api = frontapp

    class frontapp(TypedDict):
        api_key: str

    def main(frontapp_resource: frontapp, inbox_id: str, sender: str, subject: str, body: str):
        client = frontapp_api(api_key=frontapp_resource['api_key'])
        message_data = {
            'sender': sender,
            'subject': subject,
            'body': body
        }
        result = client.append_message_to_inbox(inbox_id, message_data)
        return result
  id: |-
    synthetic_import-message
  instructions: |-
    Appends a new message into an inbox. in frontapp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    frontapp
  resource_type_def: |-
    class frontapp(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type HtmlCssToImage = {
        apiKey: string,
        apiSecret: string
    }

    export async function main(htmlCssToImageResource: HtmlCssToImage, htmlContent: string, cssContent: string, width: number, height: number) {
        const requestOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${btoa(`${htmlCssToImageResource.apiKey}:${htmlCssToImageResource.apiSecret}`)}`
            },
            body: JSON.stringify({
                html: htmlContent,
                css: cssContent,
                google_fonts: "Roboto",
                width: width,
                height: height
            })
        };

        const response = await fetch('https://hcti.io/v1/image', requestOptions);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data.url;
    }
  good: |-
    // Importing the npm library for making HTTP requests
    import axios from "npm:axios";

    type HtmlCssToImage = {
        userId: string;
        apiKey: string;
        apiUrl: string;
    }

    export async function main(htmlCssToImageResource: HtmlCssToImage, html: string, css: string, googleFonts?: string[]) {
        const { userId, apiKey, apiUrl } = htmlCssToImageResource;

        // Construct the request payload
        const payload = {
            html,
            css,
            google_fonts: googleFonts
        };

        // Set up the headers for the API request
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Basic ${Buffer.from(`${userId}:${apiKey}`).toString('base64')}`
        };

        try {
            // Make the POST request to the HtmlCssToImage API
            const response = await axios.post(`${apiUrl}/image`, payload, { headers });
            // Return the result which should be the URL to the image
            return response.data;
        } catch (error) {
            // Handle any errors that occur during the API request
            console.error('Error creating image from HTML/CSS:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-image-from-html
  instructions: |-
    Create Image From HTML. in html css to image
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HtmlCssToImage
  resource_type_def: |-
    type HtmlCssToImage = {
        apiKey: string,
        apiSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import gspread as gs
    from oauth2client.service_account import ServiceAccountCredentials

    # Define the resource type for the Google Sheets integration
    class google_sheets(TypedDict):
        type: str
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str

    def main(google_sheets_resource: google_sheets, spreadsheet_id: str, worksheet_name: str, rows: List[List[str]]):
        # Authenticate and open the Google Sheet
        credentials = ServiceAccountCredentials.from_json_keyfile_dict(google_sheets_resource)
        gc = gs.authorize(credentials)
        spreadsheet = gc.open_by_key(spreadsheet_id)
        worksheet = spreadsheet.worksheet(worksheet_name)

        # Add multiple rows to the worksheet
        worksheet.append_rows(rows, value_input_option='USER_ENTERED')

        # Return a confirmation message
        return f"Added {len(rows)} rows to the worksheet '{worksheet_name}' in the spreadsheet with ID '{spreadsheet_id}'."
  good: |-
    from typing import TypedDict, List
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials

    class google_sheets(TypedDict):
        type: str
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str

    def main(google_sheets_resource: google_sheets, spreadsheet_id: str, worksheet_name: str, rows_data: List[List[str]]):
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        credentials = ServiceAccountCredentials.from_json_keyfile_dict(google_sheets_resource, scope)
        gc = gspread.authorize(credentials)

        spreadsheet = gc.open_by_key(spreadsheet_id)
        worksheet = spreadsheet.worksheet(worksheet_name)

        worksheet.append_rows(rows_data, value_input_option='USER_ENTERED')

        return {"status": "success", "message": "Data added to Google Sheet successfully."}
  id: |-
    synthetic_add-multiple-rows
  instructions: |-
    Add multiple rows of data to a Google Sheet in google sheets
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_sheets
  resource_type_def: |-
    class google_sheets(TypedDict):
        type: str
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Mailchimp } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: Mailchimp, listId: string) {
        Mailchimp.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        try {
            const response = await Mailchimp.lists.getListMemberActivityFeed(listId);
            return response;
        } catch (error) {
            console.error('Error getting list activities:', error);
            throw error;
        }
    }
  good: |-
    import { DateTime } from "npm:luxon";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string; // Mailchimp API endpoints are prefixed with a server identifier (e.g., 'us1', 'us2', etc.)
    }

    export async function main(mailchimpResource: Mailchimp, listId: string, startDate?: string, endDate?: string) {
        const apiRoot = `https://${mailchimpResource.serverPrefix}.api.mailchimp.com/3.0`;
        const start = startDate || DateTime.now().minus({ days: 180 }).toISODate();
        const end = endDate || DateTime.now().toISODate();
        const url = `${apiRoot}/lists/${listId}/activity?since=${start}&until=${end}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${mailchimpResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching Mailchimp list activity: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-list-activities
  instructions: |-
    Retrieves up to the previous 180 days of daily detailed aggregated activity stats for a list in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type GooglePhotos = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    };

    export async function main(
        googlePhotosResource: GooglePhotos,
        mediaItemId: string
    ) {
        const oauth2Client = new OAuth2Client(
            googlePhotosResource.clientId,
            googlePhotosResource.clientSecret
        );

        oauth2Client.setCredentials({
            refresh_token: googlePhotosResource.refreshToken,
            access_token: googlePhotosResource.accessToken,
        });

        const response = await fetch(`https://photoslibrary.googleapis.com/v1/mediaItems/${mediaItemId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${googlePhotosResource.accessToken}`,
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Failed to get media item: ${response.status} ${response.statusText}`);
        }

        const mediaItem = await response.json();
        return mediaItem;
    }
  good: |-
    type GooglePhotos = {
        accessToken: string;
    }

    export async function main(googlePhotosResource: GooglePhotos, mediaItemId: string) {
        const response = await fetch(`https://photoslibrary.googleapis.com/v1/mediaItems/${mediaItemId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${googlePhotosResource.accessToken}`,
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Error fetching media item: ${response.statusText}`);
        }

        const mediaItem = await response.json();
        return mediaItem;
    }
  id: |-
    synthetic_get-media-item
  instructions: |-
    Retrieves a media item in google photos
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GooglePhotos
  resource_type_def: |-
    type GooglePhotos = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the microsoft_outlook integration
    class microsoft_outlook(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the resource type and any additional parameters
    def main(outlook_resource: microsoft_outlook, search_query: str = '', top: int = 10) -> List[dict]:
        # Set up the headers for the HTTP request to the Microsoft Outlook API
        headers = {
            'Authorization': f'Bearer {outlook_resource["access_token"]}',
            'Content-Type': 'application/json'
        }

        # Define the URL for the Microsoft Outlook API endpoint to find contacts
        url = f'https://graph.microsoft.com/v1.0/me/contacts?$search="{search_query}"&$top={top}'

        # Make the HTTP GET request to the Microsoft Outlook API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the contacts list
            contacts = response.json().get('value', [])
            return contacts
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function is not called here, it is only defined and exported.
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the microsoft_outlook integration
    class microsoft_outlook(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(microsoft_outlook_resource: microsoft_outlook, search_string: str) -> List[Dict]:
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f'Bearer {microsoft_outlook_resource["access_token"]}',
            'Content-Type': 'application/json'
        }

        # Define the URL for the Microsoft Graph API to search contacts
        url = 'https://graph.microsoft.com/v1.0/me/contacts'

        # Define the parameters for the search query
        params = {
            '$search': f'"{search_string}"'
        }

        # Make the HTTP GET request to the Microsoft Graph API
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON to get the list of contacts
            contacts = response.json().get('value', [])
            return contacts
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function is not called here, it is just defined and ready to be exported.
  id: |-
    synthetic_find-contacts
  instructions: |-
    Finds contacts with given search string in microsoft outlook
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_outlook
  resource_type_def: |-
    class microsoft_outlook(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type DataStores = {
        apiKey: string;
        storeId: string;
    }

    export async function main(dataStoresResource: DataStores) {
        const { apiKey, storeId } = dataStoresResource;
        const endpoint = `https://api.datastores.com/stores/${storeId}/records`;

        const response = await fetch(endpoint, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to delete records: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    type DataStores = {
        apiKey: string,
        storeId: string
    }

    export async function main(dataStoresResource: DataStores) {
        const baseUrl = `https://api.datastores.com/stores/${dataStoresResource.storeId}/records`;
        const headers = {
            'Authorization': `Bearer ${dataStoresResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(baseUrl, {
                method: 'DELETE',
                headers: headers
            });

            if (!response.ok) {
                throw new Error(`Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Failed to delete all records:', error);
            throw error;
        }
    }
  id: |-
    synthetic_delete-all-records
  instructions: |-
    Delete all records in your. in data stores
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DataStores
  resource_type_def: |-
    type DataStores = {
        apiKey: string,
        storeId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the microsoft_entra_id integration
    class microsoft_entra_id(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str

    # Define the main function for updating a user in Microsoft Entra Identity
    def main(microsoft_entra_id_resource: microsoft_entra_id, user_id: str, update_fields: dict) -> dict:
        # Assuming the use of the Microsoft Graph API to update a user
        import requests  # Importing here to avoid global namespace pollution

        # Construct the endpoint URL
        graph_api_endpoint = f"https://graph.microsoft.com/v1.0/users/{user_id}"

        # Prepare the headers with the authorization token (assumed to be part of the resource)
        headers = {
            'Authorization': f"Bearer {microsoft_entra_id_resource['client_secret']}",
            'Content-Type': 'application/json'
        }

        # Make the HTTP PATCH request to update the user
        response = requests.patch(graph_api_endpoint, headers=headers, json=update_fields)

        # Check for successful update
        if response.status_code == 204:
            return {'success': True, 'message': 'User updated successfully.'}
        else:
            # Return the error if the update was not successful
            return {'success': False, 'message': response.json().get('error', {}).get('message', 'Unknown error occurred.')}
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to Microsoft Entra ID API

    # Define the resource type for the microsoft_entra_id integration
    class MicrosoftEntraIdResource(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
        access_token: str  # Assuming OAUTH2 access token is provided

    def main(microsoft_entra_id_resource: MicrosoftEntraIdResource, user_id: str, update_fields: dict) -> Any:
        """
        Updates an existing user in Microsoft Entra ID.

        :param microsoft_entra_id_resource: A dictionary containing the necessary credentials.
        :param user_id: The unique identifier of the user to update.
        :param update_fields: A dictionary containing the fields to update.
        :return: The response from the Microsoft Entra ID API.
        """
        # Construct the API endpoint for updating a user
        url = f"https://graph.microsoft.com/v1.0/users/{user_id}"

        # Set up the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {microsoft_entra_id_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Make the HTTP PATCH request to update the user
        response = requests.patch(url, headers=headers, json=update_fields)

        # Return the response from the API
        return response.json()

    # Note: The function is not called here, it is just defined and ready to be exported.
  id: |-
    synthetic_update-user
  instructions: |-
    Updates an existing user in Microsoft Entra ID in microsoft entra id
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_entra_id
  resource_type_def: |-
    class microsoft_entra_id(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the BingX integration
    class bingx(TypedDict):
        api_key: str
        secret_key: str
        # Add any other properties needed for authentication

    # Define the main function for getting positions from a BingX account
    def main(bingx_resource: bingx, symbol: str) -> List[dict]:
        # Assuming that a library 'bingx_api' is used to interact with BingX
        from bingx_api import get_positions as bingx_get_positions  # Rename if 'get_positions' conflicts with another import

        # Use the credentials from the resource to authenticate with the BingX API
        api_key = bingx_resource['api_key']
        secret_key = bingx_resource['secret_key']

        # Call the BingX API to get the positions for the given symbol
        positions = bingx_get_positions(api_key=api_key, secret_key=secret_key, symbol=symbol)

        # Return the result
        return positions

    # The script ends here, with the main function ready to be exported and used with the appropriate parameters.
  good: |-
    from typing import TypedDict, Any, Dict

    # Assuming that requests or another HTTP library is needed to interact with the BingX API
    import requests

    # Define the TypedDict for BingX resource containing necessary authentication/configuration properties
    class bingx(TypedDict):
        api_key: str
        secret_key: str
        # Add other authentication properties if needed

    # The main function that will be exported and used for the integration
    def main(bingx_resource: bingx, symbol: str, position_side: str, leverage: float, position_size: float) -> Dict[str, Any]:
        # Assuming that the BingX API requires an API key and secret for authentication
        api_key = bingx_resource['api_key']
        secret_key = bingx_resource['secret_key']

        # Prepare the request to the BingX API to manage the perpetual swap positions
        # The exact details of the request will depend on the BingX API documentation
        # This is a placeholder for the actual API endpoint and parameters
        api_endpoint = "https://api.bingx.com/v1/swap/positions"
        headers = {
            'X-Api-Key': api_key,
            'X-Secret-Key': secret_key,
            # Add other necessary headers
        }
        payload = {
            'symbol': symbol,
            'positionSide': position_side,
            'leverage': leverage,
            'positionSize': position_size,
            # Add other necessary parameters
        }

        # Send the request to the BingX API
        response = requests.post(api_endpoint, headers=headers, json=payload)

        # Check the response and handle it accordingly
        if response.status_code == 200:
            # Assuming a successful response contains the position details in JSON format
            return response.json()
        else:
            # Handle error responses appropriately
            response.raise_for_status()

    # Note: The actual implementation details will depend on the BingX API documentation.
    # The above code is a template and may require adjustments to match the real API endpoints and parameters.
  id: |-
    synthetic_account-get-positions
  instructions: |-
    Perpetual Swap Positions. in bingx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bingx
  resource_type_def: |-
    class bingx(TypedDict):
        api_key: str
        secret_key: str
        # Add any other properties needed for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OpenAIAPI as AzureOpenAIAPI } from "npm:@azure/ai-text-analytics";

    type AzureOpenaiService = {
        apiKey: string,
        endpoint: string
    }

    export async function main(azureOpenaiService: AzureOpenaiService, items: string[], categories: string[]) {
        const openaiClient = new AzureOpenAIAPI({
            key: azureOpenaiService.apiKey,
            endpoint: azureOpenaiService.endpoint
        });

        const classificationInput = {
            documents: items.map((item, index) => ({
                id: index.toString(),
                text: item,
                language: "en"
            }))
        };

        const classificationResult = await openaiClient.classify({
            documents: classificationInput.documents,
            categories: categories
        });

        const categorizedItems = classificationResult.documents.map((doc) => ({
            item: items[parseInt(doc.id)],
            category: doc.categories[0].category
        }));

        return categorizedItems;
    }
  good: |-
    import { OpenAIAPI } from "npm:openai";

    type AzureOpenaiService = {
        apiKey: string,
        organization: string
    }

    export async function main(azureOpenaiService: AzureOpenaiService, items: string[], categories: string[]) {
        const openai = new OpenAIAPI({
            apiKey: azureOpenaiService.apiKey,
            organization: azureOpenaiService.organization
        });

        const classifications = await Promise.all(items.map(async (item) => {
            const response = await openai.createClassification({
                examples: categories.map(category => [item, category]),
                query: item,
                search_model: "ada",
                model: "curie",
                max_examples: categories.length
            });

            return {
                item,
                category: response.label
            };
        }));

        return classifications;
    }
  id: |-
    synthetic_classify-items-into-categories
  instructions: |-
    Classify items into specific categories in azure openai service
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AzureOpenaiService
  resource_type_def: |-
    type AzureOpenaiService = {
        apiKey: string,
        endpoint: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls to the Bybit API

    # Define the resource type for the Bybit integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # e.g., 'https://api.bybit.com'

    # Define the main function for the Bybit integration
    def main(bybit_resource: bybit, symbol: str, order_id: str, price: float, quantity: float):
        # Construct the URL for replacing the conditional order
        url = f"{bybit_resource['endpoint']}/v2/private/stop-order/replace"

        # Prepare the parameters for the API request
        params = {
            "api_key": bybit_resource['api_key'],
            "symbol": symbol,
            "order_id": order_id,
            "p_r_price": price,
            "p_r_qty": quantity,
            # Add any additional parameters required by the API for authentication or order replacement
        }

        # Make the HTTP request to replace the conditional order
        response = requests.post(url, params=params)

        # Return the result of the API call
        return response.json()

    # Example usage:
    # result = main(bybit_resource={'api_key': 'your_api_key', 'api_secret': 'your_api_secret', 'endpoint': 'https://api.bybit.com'}, symbol='BTCUSD', order_id='order123', price=50000.0, quantity=1.0)
    # print(result)
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to ByBit API

    # Define the resource type for the 'bybit' integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The ByBit API endpoint URL

    # Define the main function for the ByBit Linear Stop Order Replace script
    def main(bybit_resource: bybit, symbol: str, stop_order_id: str, price: float, quantity: float):
        # Construct the request to replace a linear stop order on ByBit
        url = f"{bybit_resource['endpoint']}/v2/private/stop-order/replace"
        params = {
            "api_key": bybit_resource['api_key'],
            "symbol": symbol,
            "stop_order_id": stop_order_id,
            "price": price,
            "qty": quantity,
            # Additional parameters like timestamp and signature will be required
            # for a real request. These should be generated as per ByBit's API
            # documentation, typically involving the api_secret for signing.
        }

        # Send the request to ByBit API
        response = requests.post(url, params=params)

        # Return the response from the API call
        return response.json()
  id: |-
    synthetic_linear-stop-order-replace
  instructions: |-
    Replace conditional order. in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The ByBit API endpoint URL
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Nango = {
        apiKey: string;
        // Add other necessary properties for Nango integration here
    }

    export async function main(nangoResource: Nango) {
        // Assuming that the connection process is handled internally by the Nango SDK
        // and that the apiKey is sufficient for authentication.

        // Import the Nango SDK
        const { NangoConnection } = await import("npm:nango");

        // Create a new connection using the Nango SDK
        const connection = new NangoConnection(nangoResource.apiKey);

        // Return the connection object
        return connection;
    }
  good: |-
    import { NangoConnection as NangoApiClient } from "npm:nango";

    type Nango = {
        apiKey: string;
    }

    export async function main(nangoResource: Nango, connectionId: string) {
        const nangoClient = new NangoApiClient(nangoResource.apiKey);
        const connectionDetails = await nangoClient.getConnection(connectionId);
        return connectionDetails;
    }
  id: |-
    synthetic_get-connection
  instructions: |-
    Returns a Connection in nango
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nango
  resource_type_def: |-
    type Nango = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Kanbanize as KanbanizeAPI } from "npm:kanbanize-api"; // Renamed imported Kanbanize class to avoid conflict

    type Kanbanize = {
        apiKey: string,
        apiUrl: string
    }

    export async function main(
        kanbanizeResource: Kanbanize,
        boardId: number, // Moved boardId to function parameters
        title: string,
        description: string,
        column: string,
        swimlane: string,
        priority: string,
        assignee: string
    ) {
        const kanbanize = new KanbanizeAPI({
            apiKey: kanbanizeResource.apiKey,
            apiUrl: kanbanizeResource.apiUrl
        });

        const taskData = {
            boardid: boardId, // Updated to use the parameter
            title: title,
            description: description,
            column: column,
            swimlane: swimlane,
            priority: priority,
            assignee: assignee
        };

        try {
            const result = await kanbanize.createTask(taskData);
            return result;
        } catch (error) {
            console.error('Failed to create a new task in Kanbanize:', error);
            throw error;
        }
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Kanbanize = {
        apiKey: string;
        subdomain: string;
    }

    export async function main(
        kanbanizeResource: Kanbanize,
        boardId: number,
        title: string,
        description: string,
        priority: string,
        assignee: string,
        color: string = "#FFFFFF",
        typeId: number | null = null,
        parentId: number | null = null
    ) {
        const url = `https://${kanbanizeResource.subdomain}.kanbanize.com/index.php/api/kanbanize/create_new_task/format/json`;
        const body = {
            boardid: boardId,
            title: title,
            description: description,
            priority: priority,
            assignee: assignee,
            color: color,
            typeid: typeId,
            parentid: parentId
        };

        const headers = new Headers({
            "Content-Type": "application/json",
            "Authorization": `Basic ${encode(kanbanizeResource.apiKey + ':')}`
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-new-task
  instructions: |-
    Create New Task in kanbanize
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Kanbanize
  resource_type_def: |-
    type Kanbanize = {
        apiKey: string,
        apiUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import googleapiclient.discovery

    class google_contacts(TypedDict):
        access_token: str

    def main(google_contacts_resource: google_contacts, contact_id: str, new_name: Optional[str] = None, new_email: Optional[str] = None, new_phone_number: Optional[str] = None):
        service = googleapiclient.discovery.build('people', 'v1', credentials=None, developerKey=google_contacts_resource['access_token'])

        update_fields = []
        contact_body = {
            'names': [],
            'emailAddresses': [],
            'phoneNumbers': []
        }

        if new_name:
            contact_body['names'].append({'givenName': new_name})
            update_fields.append('names')

        if new_email:
            contact_body['emailAddresses'].append({'value': new_email})
            update_fields.append('emailAddresses')

        if new_phone_number:
            contact_body['phoneNumbers'].append({'value': new_phone_number})
            update_fields.append('phoneNumbers')

        update_mask = ','.join(update_fields)

        result = service.people().updateContact(
            resourceName=f'people/{contact_id}',
            updatePersonFields=update_mask,
            body=contact_body
        ).execute()

        return result
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the google_contacts integration
    class google_contacts(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the Google People API client library, renaming the method if it conflicts with 'google_contacts'
    from googleapiclient.discovery import build as build_service

    def main(google_contacts_resource: google_contacts, contact_id: str, given_name: Optional[str] = None, family_name: Optional[str] = None, phone_number: Optional[str] = None, email_address: Optional[str] = None):
        # Create a service object for the Google People API
        service = build_service('people', 'v1', credentials=google_contacts_resource['access_token'])

        # Prepare the update mask based on the provided parameters
        update_mask = []
        contact_body = {
            'names': [],
            'phoneNumbers': [],
            'emailAddresses': []
        }

        if given_name or family_name:
            name = {}
            if given_name:
                name['givenName'] = given_name
                update_mask.append('names.givenName')
            if family_name:
                name['familyName'] = family_name
                update_mask.append('names.familyName')
            contact_body['names'].append(name)

        if phone_number:
            contact_body['phoneNumbers'].append({'value': phone_number})
            update_mask.append('phoneNumbers.value')

        if email_address:
            contact_body['emailAddresses'].append({'value': email_address})
            update_mask.append('emailAddresses.value')

        # Perform the update operation
        result = service.people().updateContact(
            resourceName=f'people/{contact_id}',
            updatePersonFields=','.join(update_mask),
            body=contact_body
        ).execute()

        # Return the result of the update operation
        return result
  id: |-
    synthetic_update-contact
  instructions: |-
    Updates a contact in google contacts
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_contacts
  resource_type_def: |-
    class google_contacts(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { validate as validateEmail } from "npm:email-validator";

    type Getemails = {
        apiKey: string;
    }

    export async function main(getemailsResource: Getemails, emailAddress: string) {
        // Validate the email format before making the API call
        if (!validateEmail(emailAddress)) {
            throw new Error("Invalid email format.");
        }

        // Prepare the API request
        const apiEndpoint = `https://api.getemails.com/verify?apiKey=${getemailsResource.apiKey}&email=${encodeURIComponent(emailAddress)}`;

        // Make the API call
        const response = await fetch(apiEndpoint);
        if (!response.ok) {
            throw new Error(`API request failed with status: ${response.status}`);
        }

        // Parse the response
        const result = await response.json();

        // Return the result
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { validate as validateEmail } from "npm:email-validator";

    type Getemails = {
        apiKey: string;
    }

    export async function main(getemailsResource: Getemails, emailAddress: string) {
        // Validate the email format before making an API call
        if (!validateEmail(emailAddress)) {
            throw new Error("Invalid email format.");
        }

        // Construct the API endpoint with the email address to verify
        const apiEndpoint = `https://api.getemails.com/verify?email=${encodeURIComponent(emailAddress)}`;

        // Set up the headers for the API request
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getemailsResource.apiKey}`
        };

        // Make the API request to verify the email
        const response = await fetch(apiEndpoint, { headers: headers });
        const result = await response.json();

        // Check if the API call was successful
        if (!response.ok) {
            throw new Error(`API call failed: ${result.message}`);
        }

        // Return the result of the email verification
        return result;
    }
  id: |-
    synthetic_verify-email
  instructions: |-
    The Api verifies your requested email address, whether it is a Good or Bad email address. in getemails
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Getemails
  resource_type_def: |-
    type Getemails = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the bybit integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str

    def main(bybit_resource: bybit, method: str, params: Dict[str, Any] = None) -> Any:
        # Construct the URL for the API call
        url = f"{bybit_resource['endpoint']}"

        # Set up headers or other authentication details
        headers = {
            "X-Api-Key": bybit_resource['api_key'],
            "X-Api-Secret": bybit_resource['api_secret']
        }

        # Make the API call
        if method.upper() == 'GET':
            response = requests.get(url, headers=headers, params=params)
        elif method.upper() == 'POST':
            response = requests.post(url, headers=headers, data=params)
        else:
            raise ValueError("Unsupported HTTP method. Use 'GET' or 'POST'.")

        # Return the response from the API call
        return response.json()
  good: |-
    import requests
    from typing import TypedDict, Any, Optional

    # Define the resource type for the bybit integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str

    def main(bybit_resource: bybit, method: str, endpoint: str, params: Optional[dict] = None) -> Any:
        """
        Make an API call to the Bybit API.

        :param bybit_resource: A dictionary containing the API key, API secret, and the base endpoint.
        :param method: The HTTP method to use for the API call ('GET', 'POST', etc.).
        :param endpoint: The specific API endpoint to call.
        :param params: Optional dictionary of parameters to include in the API call.
        :return: The response from the API call.
        """
        url = f"{bybit_resource['endpoint']}/{endpoint}"
        headers = {
            "Content-Type": "application/json",
            "X-Api-Key": bybit_resource['api_key'],
            "X-Api-Secret": bybit_resource['api_secret']
        }

        response = requests.request(method, url, headers=headers, params=params)

        return response.json()

    # Example usage:
    # result = main(bybit_resource={'api_key': 'your_api_key', 'api_secret': 'your_api_secret', 'endpoint': 'https://api.bybit.com'},
    #               method='GET',
    #               endpoint='v2/public/tickers',
    #               params={'symbol': 'BTCUSD'})
    # print(result)
  id: |-
    synthetic_generic-api-call
  instructions: |-
    Make any API call as per the documentation. in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the memberstack integration
    class memberstack(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function with the resource type and any additional parameters
    def main(memberstack_resource: memberstack) -> List[dict]:
        # Set up the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {memberstack_resource['api_key']}"
        }

        # Define the URL for the Memberstack API endpoint to retrieve members
        url = "https://api.memberstack.com/v1/members"

        # Make the API request to get the list of members
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of members
            return response.json()['members']
        else:
            # Handle errors (you could raise an exception or return an empty list)
            response.raise_for_status()

    # The script ends here, with no call to the main function as per the instructions.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the Memberstack integration
    class memberstack(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for listing members
    def main(memberstack_resource: memberstack, page: int = 1, limit: int = 10) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for listing members
        endpoint = f"https://{memberstack_resource['subdomain']}.memberstack.com/api/members"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {memberstack_resource['api_key']}"
        }

        # Set up the parameters for pagination
        params = {
            "page": page,
            "limit": limit
        }

        # Make the API request to list members
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of members
            return response.json()['members']
        else:
            # Handle errors (for simplicity, we just raise an exception)
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_list-members
  instructions: |-
    Retrieve a list of all members connected to your application in memberstack
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    memberstack
  resource_type_def: |-
    class memberstack(TypedDict):
        api_key: str
        subdomain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls to the craftmypdf API

    # Define the resource type for the craftmypdf integration
    class craftmypdf(TypedDict):
        api_key: str

    def main(craftmypdf_resource: craftmypdf, endpoint: str, template_id: str, data: Any, output_format: str = 'pdf') -> bytes:
        headers = {
            'Authorization': f"Bearer {craftmypdf_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'template_id': template_id,
            'data': data,
            'response_type': output_format,
        }
        response = requests.post(endpoint, json=payload, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.content
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed to interact with the craftmypdf API

    class craftmypdf(TypedDict):
        api_key: str

    def main(craftmypdf_resource: craftmypdf, template_id: str, data: Dict[str, Any], output_format: str = 'pdf') -> bytes:
        url = f"https://api.craftmypdf.com/v1/templates/{template_id}/render"
        headers = {
            "Authorization": f"Bearer {craftmypdf_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "data": data,
            "outputFormat": output_format
        }
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes
        return response.content
  id: |-
    synthetic_create-image
  instructions: |-
    Create a new image in craftmypdf
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    craftmypdf
  resource_type_def: |-
    class craftmypdf(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { hmac as createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit) {
        const { apiKey, apiSecret, endpoint } = bybitResource;

        const url = `${endpoint}/v2/public/symbols`;

        const timestamp = new Date().getTime();
        const params = `api_key=${apiKey}&timestamp=${timestamp}`;
        const signature = createHmac('sha256', apiSecret, params).toString();

        const response = await fetch(`${url}?${params}&sign=${signature}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you might need here
    import { hmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const timestamp = new Date().getTime();
        const params = `api_key=${bybitResource.apiKey}&symbol=${symbol}&timestamp=${timestamp}`;
        const signature = hmac('sha256', bybitResource.apiSecret, params).digest('hex');

        const url = `${bybitResource.endpoint}/v2/public/tickers?${params}&sign=${signature}`;

        const response = await fetch(url);
        const data = await response.json();

        return data;
    }
  id: |-
    synthetic_generic-market-symbols
  instructions: |-
    Get symbol info in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { stringify } from "npm:querystring";

    type LogglySendData = {
        token: string;
        subdomain: string;
    }

    export async function main(logglyResource: LogglySendData, eventData: any, tags: string[]) {
        const logglyUrl = `https://${logglyResource.subdomain}.loggly.com/inputs/${logglyResource.token}/tag/${tags.join(',')}`;

        const response = await fetch(logglyUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(eventData),
        });

        if (!response.ok) {
            throw new Error(`Failed to send data to Loggly: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { stringify } from "npm:querystring";

    type LogglySendData = {
        token: string;
        subdomain: string;
    }

    export async function main(logglyResource: LogglySendData, eventData: Record<string, any>, tags?: string[]) {
        const logglyUrl = `https://${logglyResource.subdomain}.loggly.com/inputs/${logglyResource.token}`;
        const queryString = tags ? `?${stringify({ tags: tags.join(',') })}` : '';
        const response = await fetch(logglyUrl + queryString, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(eventData),
        });

        if (!response.ok) {
            throw new Error(`Failed to send event to Loggly: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_send-event
  instructions: |-
    Send events to Loggly, with tags for more details in loggly send data
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    LogglySendData
  resource_type_def: |-
    type LogglySendData = {
        token: string;
        subdomain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { NexweaveAPI } from "npm:nexweave";

    type Nexweave = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(nexweaveResource: Nexweave, campaignTemplateId: string, variables: Record<string, any>, userEmail: string) {
        const nexweave = new NexweaveAPI(nexweaveResource.apiKey, nexweaveResource.apiSecret);

        const experienceData = {
            campaignTemplateId: campaignTemplateId,
            variables: variables,
            userEmail: userEmail
        };

        const result = await nexweave.createExperienceFromTemplate(experienceData);
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { NexweaveAPI } from "npm:nexweave";

    type Nexweave = {
        apiKey: string,
        apiSecret: string,
        campaignId: string
    }

    export async function main(nexweaveResource: Nexweave, templateId: string, variables: Record<string, any>, experienceName: string) {
        // Initialize Nexweave API client
        const nexweaveClient = new NexweaveAPI(nexweaveResource.apiKey, nexweaveResource.apiSecret);

        // Create a video experience from a template
        const result = await nexweaveClient.createExperienceFromTemplate(nexweaveResource.campaignId, templateId, variables, experienceName);

        // Return the result
        return result;
    }
  id: |-
    synthetic_create-video-experience-from-template
  instructions: |-
    Creates a video experience from a template in nexweave
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nexweave
  resource_type_def: |-
    type Nexweave = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import googleapiclient.discovery
    import googleapiclient.http

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, file_title: str, file_content: str, mime_type: str = 'text/plain'):
        credentials = googleapiclient.credentials.Credentials(
            token=google_drive_resource['access_token']
        )

        service = googleapiclient.discovery.build(
            'drive', 'v3', credentials=credentials
        )

        file_metadata = {
            'name': file_title,
            'mimeType': mime_type
        }

        media = googleapiclient.http.MediaIoBaseUpload(
            io.BytesIO(file_content.encode()),
            mimetype=mime_type
        )

        file = service.files().create(
            body=file_metadata,
            media_body=media,
            fields='id'
        ).execute()

        return file
  good: |-
    from typing import TypedDict
    from google.oauth2.credentials import Credentials
    import googleapiclient.discovery
    import googleapiclient.http

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, file_title: str, file_content: str, mime_type: str = 'text/plain'):
        credentials = Credentials(token=google_drive_resource['access_token'])
        service = googleapiclient.discovery.build('drive', 'v3', credentials=credentials)
        file_metadata = {
            'name': file_title,
            'mimeType': mime_type
        }
        media = googleapiclient.http.MediaInMemoryUpload(file_content, mimetype=mime_type)
        file = service.files().create(body=file_metadata, media_body=media, fields='id').execute()
        return file
  id: |-
    synthetic_create-file-from-text
  instructions: |-
    Create a new file from plain text for more information in google drive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_drive
  resource_type_def: |-
    class google_drive(TypedDict):
        api_key: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { ChatCompletionRequest, ChatCompletionResponse } from "npm:@openai/client";

    type Anthropic = {
        apiKey: string;
        organizationId: string;
    }

    export async function main(
        anthropicResource: Anthropic,
        messages: Array<{ role: string; content: string }>,
        maxTokens: number,
        temperature: number,
        topP: number,
        stopSequences?: string[],
        userId?: string
    ) {
        // Set up the headers for the API request
        const headers = {
            'Authorization': `Bearer ${anthropicResource.apiKey}`,
            'Content-Type': 'application/json',
            'OpenAI-Organization': anthropicResource.organizationId
        };

        // Construct the body of the request
        const body: ChatCompletionRequest = {
            messages: messages,
            max_tokens: maxTokens,
            temperature: temperature,
            top_p: topP,
            stop: stopSequences,
            user: userId
        };

        // Make the API request to the Chat API
        const response = await fetch('https://api.anthropic.com/chat/completions', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
        });

        // Parse the response as JSON
        const data: ChatCompletionResponse = await response.json();

        // Always return the result
        return data;
    }
  good: |-
    // Importing necessary libraries
    import { Client as AnthropicClient } from "npm:@anthropic/client";

    type Anthropic = {
        apiKey: string;
        organizationId: string;
    }

    export async function main(anthropicResource: Anthropic, prompt: string, model: string, temperature: number, maxTokens: number) {
        // Initialize the Anthropic client with the provided API key
        const client = new AnthropicClient({
            apiKey: anthropicResource.apiKey,
            organizationId: anthropicResource.organizationId,
        });

        // Generate a response from the Anthropic model
        const response = await client.complete({
            model: model,
            prompt: prompt,
            temperature: temperature,
            max_tokens: maxTokens,
        });

        // Return the response from the model
        return response;
    }
  id: |-
    synthetic_chat
  instructions: |-
    The Chat API in anthropic
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Anthropic
  resource_type_def: |-
    type Anthropic = {
        apiKey: string;
        organizationId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Clevertap = {
        accountId: string;
        passcode: string;
        regionValue: string;
    }

    export async function main(
        clevertapResource: Clevertap,
        events: any[], // Array of events to be uploaded
        identityField: string // Field used to identify the user for the events
    ) {
        const baseUrl = `https://${clevertapResource.regionValue}.api.clevertap.com/1/upload`;
        const authHeader = `Basic ${encode(`${clevertapResource.accountId}:${clevertapResource.passcode}`)}`;

        const body = {
            d: events.map(event => ({
                ...event,
                identity: event[identityField]
            }))
        };

        const response = await fetch(baseUrl, {
            method: 'POST',
            headers: {
                'X-CleverTap-Account-Id': clevertapResource.accountId,
                'X-CleverTap-Passcode': clevertapResource.passcode,
                'Content-Type': 'application/json',
                'Authorization': authHeader
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`Failed to upload events: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { CleverTap as CleverTapClient } from "npm:clevertap";

    type Clevertap = {
        accountId: string;
        passcode: string;
        regionValue: string;
    }

    export async function main(
        clevertap: Clevertap,
        events: any[],
        identityField: string
    ) {
        const clevertapClient = CleverTapClient.init({
            accountId: clevertap.accountId,
            passcode: clevertap.passcode,
            region: clevertap.regionValue
        });

        try {
            const response = await clevertapClient.uploadEvents(events, identityField);
            return response;
        } catch (error) {
            console.error('Failed to upload events to CleverTap:', error);
            throw error;
        }
    }
  id: |-
    synthetic_upload-events
  instructions: |-
    Upload events in clevertap
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clevertap
  resource_type_def: |-
    type Clevertap = {
        accountId: string;
        passcode: string;
        regionValue: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Bigml = {
        username: string;
        apiKey: string;
    }

    export async function main(bigmlResource: Bigml, remoteUrl: string) {
        const auth = `username=${bigmlResource.username};api_key=${bigmlResource.apiKey}`;
        const sourceCreationUrl = 'https://bigml.io/source?'+auth;

        const response = await fetch(sourceCreationUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ remote: remoteUrl })
        });

        const result = await response.json();
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { BigML } from 'npm:bigml';

    type BigmlResource = {
        username: string;
        apiKey: string;
    }

    export async function main(bigmlResource: BigmlResource, remoteUrl: string) {
        // Initialize BigML API with credentials
        const bigml = new BigML(bigmlResource.username, bigmlResource.apiKey);

        // Create a source in BigML with the provided remote URL
        const source = await bigml.createSource(remoteUrl);

        // Return the result which is the newly created source
        return source;
    }
  id: |-
    synthetic_create-source-remote-url
  instructions: |-
    Create a source with a provided remote URL that points to the data file that you want BigML to download for you in bigml
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bigml
  resource_type_def: |-
    type Bigml = {
        username: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import mastodon

    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    def main(mastodon_resource: mastodon, status_id: int):
        mastodon_api = mastodon.Mastodon(
            access_token=mastodon_resource['access_token'],
            api_base_url=mastodon_resource['api_base_url']
        )

        result = mastodon_api.status_unreblog(status_id)
        return result
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the Mastodon integration
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    def main(mastodon_resource: mastodon, status_id: int) -> dict:
        # Prepare the headers for authentication
        headers = {
            'Authorization': f'Bearer {mastodon_resource["access_token"]}'
        }

        # Prepare the API endpoint for undoing a status boost
        undo_boost_endpoint = f'{mastodon_resource["api_base_url"].rstrip("/")}/statuses/{status_id}/unreblog'

        # Make the POST request to undo the boost
        response = requests.post(undo_boost_endpoint, headers=headers)

        # Return the response as a JSON object
        return response.json()
  id: |-
    synthetic_unboost-status
  instructions: |-
    Undo a reshare of a status in mastodon
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mastodon
  resource_type_def: |-
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { generate } from "npm:@cohere/ai";

    type CoherePlatform = {
        apiKey: string;
    }

    export async function main(cohereResource: CoherePlatform, prompt: string, maxLength: number, temperature: number) {
        const cohere = generate({
            model: 'large',
            prompt: prompt,
            max_tokens: maxLength,
            temperature: temperature
        }, {
            headers: {
                'Authorization': `Bearer ${cohereResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        const response = await cohere;
        return response.data;
    }
  good: |-
    // Import the necessary library for Cohere
    import cohere from 'npm:cohere-ai';

    type CoherePlatform = {
        apiKey: string;
    }

    export async function main(cohereResource: CoherePlatform, prompt: string, model: string = 'large', temperature: number = 0.5, maxTokens: number = 50) {
        // Initialize the Cohere client with the provided API key
        cohere.init(cohereResource.apiKey);

        // Generate text using the Cohere API
        const response = await cohere.generate({
            model: model,
            prompt: prompt,
            temperature: temperature,
            max_tokens: maxTokens,
        });

        // Return the generated text
        return response.body.text;
    }
  id: |-
    synthetic_generate-text
  instructions: |-
    This action generates realistic text conditioned on a given input in cohere platform
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CoherePlatform
  resource_type_def: |-
    type CoherePlatform = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { Copper } from "npm:@copper/copper-sdk";

    type Copperx = {
        apiKey: string;
        email: string;
        environment: string; // e.g., 'sandbox' or 'production'
    }

    export async function main(copperxResource: Copperx, customerName: string, customerEmail: string, companyName: string, phone?: string) {
        // Initialize the Copper SDK with the provided credentials
        const copper = new Copper({
            apiKey: copperxResource.apiKey,
            email: copperxResource.email,
            environment: copperxResource.environment
        });

        // Create a new customer object
        const newCustomer = {
            name: customerName,
            email: customerEmail,
            company_name: companyName,
            phone: phone // Optional parameter
        };

        // Use the Copper SDK to create a new customer in Copperx
        const result = await copper.createCustomer(newCustomer);

        // Return the result of the customer creation
        return result;
    }
  good: |-
    // Import any libraries you might need here
    import { Copper } from "npm:@copper/sdk";

    type Copperx = {
        apiKey: string;
        email: string;
        environment: string; // e.g., 'sandbox' or 'production'
    }

    export async function main(copperxResource: Copperx, customerName: string, customerEmail: string, companyName?: string, phone?: string, address?: string) {
        // Initialize the Copper SDK with the provided credentials
        const copper = new Copper({
            apiKey: copperxResource.apiKey,
            email: copperxResource.email,
            environment: copperxResource.environment
        });

        // Create the customer object
        const customerData = {
            name: customerName,
            email: customerEmail,
            company_name: companyName,
            phone: phone,
            address: address
        };

        // Use the Copper SDK to create a new customer
        const result = await copper.createCustomer(customerData);

        // Return the result which should be the newly created customer object
        return result;
    }
  id: |-
    synthetic_create-customer
  instructions: |-
    Create a new customer in copperx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Copperx
  resource_type_def: |-
    type Copperx = {
        apiKey: string;
        email: string;
        environment: string; // e.g., 'sandbox' or 'production'
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(dialogflowResource: GoogleDialogflow, sessionId: string, intentName: string, intentView: string = 'INTENT_VIEW_FULL') {
        const sessionClient = new SessionsClient({
            credentials: {
                client_email: dialogflowResource.clientEmail,
                private_key: dialogflowResource.privateKey,
            },
            projectId: dialogflowResource.projectId,
        });

        const sessionPath = sessionClient.projectAgentSessionPath(dialogflowResource.projectId, sessionId);

        const request = {
            parent: sessionPath,
            intentView: intentView,
        };

        // Retrieve the list of intents
        const [response] = await sessionClient.intentsClient.listIntents(request);

        // Find the intent to delete
        const intentToDelete = response.find(intent => intent.displayName === intentName);

        if (!intentToDelete) {
            throw new Error(`Intent with name ${intentName} not found.`);
        }

        // Delete the intent
        await sessionClient.intentsClient.deleteIntent({ name: intentToDelete.name });

        return { status: 'Intent deleted successfully.' };
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(googleDialogflowResource: GoogleDialogflow, intentId: string) {
        const dialogflowClient = new SessionsClient({
            credentials: {
                client_email: googleDialogflowResource.clientEmail,
                private_key: googleDialogflowResource.privateKey,
            },
            projectId: googleDialogflowResource.projectId,
        });

        const intentPath = dialogflowClient.projectAgentIntentPath(googleDialogflowResource.projectId, intentId);

        try {
            const result = await dialogflowClient.deleteIntent({ name: intentPath });
            return result;
        } catch (error) {
            console.error("Failed to delete intent:", error);
            throw error;
        }
    }
  id: |-
    synthetic_delete-intent
  instructions: |-
    Deletes an intent, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Flutterwave as FlutterwaveClient } from "npm:@flutterwave/flutterwave-v3";

    type Flutterwave = {
        apiKey: string;
        encryptionKey: string;
    }

    export async function main(flutterwaveResource: Flutterwave, amount: number, currency: string, beneficiaryAccount: string, beneficiaryBankCode: string, narration: string, reference: string) {
        const flutterwave = new FlutterwaveClient(flutterwaveResource.apiKey, flutterwaveResource.encryptionKey);

        const transferPayload = {
            account_bank: beneficiaryBankCode,
            account_number: beneficiaryAccount,
            amount: amount,
            narration: narration,
            currency: currency,
            reference: reference,
            callback_url: 'https://webhook.site/xxxxx',
            debit_currency: currency
        };

        try {
            const response = await flutterwave.Transfer.initiate(transferPayload);
            return response;
        } catch (error) {
            console.error('Transfer initiation failed:', error);
            throw error;
        }
    }
  good: |-
    import { Flutterwave } from "npm:@flutterwave/flutterwave-node-v3";

    type FlutterwaveResource = {
        apiKey: string;
    }

    export async function main(flutterwaveResource: FlutterwaveResource, amount: number, currency: string, recipientAccount: string, recipientBankCode: string, senderName: string, senderAccount: string, senderBankCode: string, reference: string) {
        const flutterwave = new Flutterwave(flutterwaveResource.apiKey);

        const transferData = {
            account_bank: recipientBankCode,
            account_number: recipientAccount,
            amount: amount,
            currency: currency,
            reference: reference,
            beneficiary_name: senderName,
            sender: {
                name: senderName,
                account_number: senderAccount,
                bank_code: senderBankCode
            }
        };

        try {
            const response = await flutterwave.Transfers.initiate(transferData);
            return response;
        } catch (error) {
            // Handle the error appropriately in your application
            throw error;
        }
    }
  id: |-
    synthetic_create-transfer
  instructions: |-
    This action initiates a new transfer in flutterwave
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Flutterwave
  resource_type_def: |-
    type Flutterwave = {
        apiKey: string;
        encryptionKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls to GitHub API

    class github(TypedDict):
        access_token: str
        repository_owner: str
        repository_name: str

    def main(github_resource: github, state: str, keyword: str) -> List[dict]:
        headers = {
            'Authorization': f'token {github_resource["access_token"]}',
            'Accept': 'application/vnd.github.v3+json',
        }
        base_url = f"https://api.github.com/repos/{github_resource['repository_owner']}/{github_resource['repository_name']}"
        issues_url = f"{base_url}/issues"
        pulls_url = f"{base_url}/pulls"

        issues_params = {'state': state, 'q': keyword}
        pulls_params = {'state': state, 'q': keyword}

        issues_response = requests.get(issues_url, headers=headers, params=issues_params)
        pulls_response = requests.get(pulls_url, headers=headers, params=pulls_params)

        issues = issues_response.json()
        pulls = pulls_response.json()

        # Filter issues and pull requests by keyword
        filtered_issues = [issue for issue in issues if keyword.lower() in issue.get('title', '').lower()]
        filtered_pulls = [pull for pull in pulls if keyword.lower() in pull.get('title', '').lower()]

        return filtered_issues + filtered_pulls
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls to GitHub API

    class github(TypedDict):
        access_token: str

    def main(github_resource: github, repository_owner: str, repository_name: str, search_query: str, search_type: str = 'issues', state: str = 'open') -> List[dict]:
        base_url = "https://api.github.com/search/"
        headers = {
            "Authorization": f"token {github_resource['access_token']}",
            "Accept": "application/vnd.github.v3+json"
        }

        if search_type not in ['issues', 'pulls']:
            raise ValueError("search_type must be 'issues' or 'pulls'")

        search_type = 'issues' if search_type == 'issues' else 'pulls'
        query = f"{search_query}+repo:{repository_owner}/{repository_name}+type:{search_type}+state:{state}"
        response = requests.get(f"{base_url}{search_type}", headers=headers, params={'q': query})

        if response.status_code != 200:
            raise Exception(f"GitHub API Error: {response.status_code} - {response.json().get('message', 'Unknown error')}")

        return response.json().get('items', [])
  id: |-
    synthetic_search-issues-and-pull-requests
  instructions: |-
    Find issues and pull requests by state and keyword in github
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:querystring";

    type Megaventory = {
        APIKey: string,
        EndpointURL: string
    }

    export async function main(
        megaventoryResource: Megaventory,
        productDetails: {
            SKU: string,
            Description: string,
            SalesPrice: number,
            PurchasePrice: number,
            Category: string
        }
    ) {
        const requestBody = {
            APIKEY: megaventoryResource.APIKey,
            mvProduct: {
                ProductSKU: productDetails.SKU,
                ProductDescription: productDetails.Description,
                ProductSellingPrice: productDetails.SalesPrice,
                ProductPurchasePrice: productDetails.PurchasePrice,
                ProductCategory: productDetails.Category
            },
            mvRecordAction: "InsertOrUpdate"
        };

        const response = await fetch(`${megaventoryResource.EndpointURL}/Product/ProductUpdate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: encode(requestBody)
        });

        const result = await response.json();

        return result;
    }
  good: |-
    import { hmacSHA256, encBase64 } from "npm:crypto-js";

    type Megaventory = {
        apiKey: string,
        accountUrl: string
    }

    type Product = {
        SKU: string,
        Description: string,
        SalesPrice: number,
        PurchasePrice: number,
        Category: string
    }

    export async function main(megaventoryResource: Megaventory, product: Product) {
        const { apiKey, accountUrl } = megaventoryResource;
        const { SKU, Description, SalesPrice, PurchasePrice, Category } = product;

        const requestBody = {
            APIKEY: apiKey,
            mvProduct: {
                ProductSKU: SKU,
                ProductDescription: Description,
                ProductSellingPrice: SalesPrice,
                ProductPurchasePrice: PurchasePrice,
                ProductCategory: Category
            },
            mvRecordAction: "InsertOrUpdate"
        };

        const response = await fetch(`${accountUrl}/Product/ProductUpdate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();

        return data;
    }
  id: |-
    synthetic_insert-or-update-product
  instructions: |-
    Insert or update a product in the database. in megaventory
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Megaventory
  resource_type_def: |-
    type Megaventory = {
        apiKey: string,
        accountUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:airtable";

    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }

    export async function main(airtableResource: AirtableOauth, tableName: string) {
        const base = new Base({ apiKey: airtableResource.apiKey })(airtableResource.baseId);

        try {
            const createdTable = await base.createTable(tableName, [
                // Define the fields for the new table here. For example:
                { name: 'Name', type: 'text' },
                { name: 'Description', type: 'text' }
                // Add more fields as needed
            ]);

            return createdTable;
        } catch (error) {
            console.error('Error creating new table:', error);
            throw error;
        }
    }
  good: |-
    import { Base } from "npm:airtable";

    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, fields: { [key: string]: string | number }) {
        const base = new Base({ apiKey: airtableResource.apiKey })(airtableResource.baseId);

        try {
            const createdRecord = await base(tableName).create([{ fields }]);
            return createdRecord;
        } catch (error) {
            console.error('Error creating table in Airtable:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-table
  instructions: |-
    Create a new table in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { FormData } from "npm:@deno/form-data";

    type Meistertask = {
        apiKey: string;
    }

    export async function main(meistertaskResource: Meistertask, projectId: string, taskId: string, attachmentName: string, attachmentData: Blob) {
        const formData = new FormData();
        formData.append('file', attachmentData, attachmentName);

        const response = await fetch(`https://www.meistertask.com/api/tasks/${taskId}/attachments`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${meistertaskResource.apiKey}`,
                'Content-Type': 'multipart/form-data'
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Failed to create attachment: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { FormData } from "npm:@deno/form-data";

    type Meistertask = {
        apiKey: string;
    }

    export async function main(meistertaskResource: Meistertask, taskId: string, fileName: string, fileContent: Blob, mimeType: string) {
        const formData = new FormData();
        formData.append('file', fileContent, fileName);

        const response = await fetch(`https://api.meistertask.com/tasks/${taskId}/attachments`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${meistertaskResource.apiKey}`,
                'Content-Type': mimeType
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Failed to create attachment: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-attachment
  instructions: |-
    Create a new attachment in meistertask
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Meistertask
  resource_type_def: |-
    type Meistertask = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOutlookCalendar = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string;
    }

    export async function main(
        outlookCalendarResource: MicrosoftOutlookCalendar,
        eventId: string,
        updateDetails: {
            subject?: string;
            start?: { dateTime: string; timeZone: string; };
            end?: { dateTime: string; timeZone: string; };
            location?: { displayName: string; };
            attendees?: { emailAddress: { address: string; name?: string; }[]; };
            body?: { contentType: "HTML" | "Text"; content: string; };
        }
    ) {
        const client = Client.init({
            authProvider: (done) => {
                done(null, outlookCalendarResource.accessToken); // First parameter takes an error if there is one
            }
        });

        const result = await client.api(`/me/events/${eventId}`)
            .header("Content-Type", "application/json")
            .patch(updateDetails);

        return result;
    }
  good: |-
    import { CalendarEvent } from "npm:@microsoft/microsoft-graph-types";

    type MicrosoftOutlookCalendar = {
        accessToken: string;
    }

    export async function main(
        microsoftOutlookCalendarResource: MicrosoftOutlookCalendar,
        eventId: string,
        updatedEventDetails: Partial<CalendarEvent>
    ) {
        const graphEndpoint = `https://graph.microsoft.com/v1.0/me/events/${eventId}`;
        const response = await fetch(graphEndpoint, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${microsoftOutlookCalendarResource.accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updatedEventDetails)
        });

        if (!response.ok) {
            throw new Error(`Failed to update the event: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-calendar-event
  instructions: |-
    Update an event in the user's default calendar in microsoft outlook calendar
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftOutlookCalendar
  resource_type_def: |-
    type MicrosoftOutlookCalendar = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type CloudflareApiKey = {
        email: string;
        apiKey: string;
        accountId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, zoneId: string, since?: string, until?: string) {
        const endpoint = `https://api.cloudflare.com/client/v4/accounts/${cloudflareResource.accountId}/analytics/dashboard?zone_id=${zoneId}`;
        let queryParams = '';
        if (since) queryParams += `&since=${since}`;
        if (until) queryParams += `&until=${until}`;

        const response = await fetch(endpoint + queryParams, {
            method: 'GET',
            headers: {
                'X-Auth-Email': cloudflareResource.email,
                'X-Auth-Key': cloudflareResource.apiKey,
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Failed to fetch analytics: ${response.statusText}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type CloudflareApiKey = {
        accountId: string;
        apiKey: string;
        email: string;
    }

    export async function main(cloudflareApiKeyResource: CloudflareApiKey, since?: string, until?: string) {
        const url = `https://api.cloudflare.com/client/v4/accounts/${cloudflareApiKeyResource.accountId}/workers/kv/metrics`;
        const headers = {
            "X-Auth-Email": cloudflareApiKeyResource.email,
            "X-Auth-Key": cloudflareApiKeyResource.apiKey,
            "Content-Type": "application/json"
        };

        const queryParams = new URLSearchParams();
        if (since) queryParams.append('since', since);
        if (until) queryParams.append('until', until);

        const response = await fetch(`${url}?${queryParams}`, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Failed to retrieve KV request metrics: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_query-worker-analytics
  instructions: |-
    Retrieves Workers KV request metrics for the given account in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        email: string;
        apiKey: string;
        accountId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import hubspot

    class hubspot(TypedDict):
        api_key: str

    def main(hubspot_resource: hubspot, contact_id: str, deal_name: str, deal_stage: str, amount: Optional[float] = None, close_date: Optional[str] = None):
        hubspot_client = hubspot.Client.create(api_key=hubspot_resource['api_key'])

        # Create a new deal (engagement) associated with the contact
        deal_data = {
            "associations": {
                "associatedVids": [contact_id]
            },
            "properties": {
                "dealname": deal_name,
                "dealstage": deal_stage,
                "amount": amount,
                "closedate": close_date
            }
        }

        # Create the deal in HubSpot
        created_deal = hubspot_client.crm.deals.basic_api.create(deal_data)

        return created_deal
  good: |-
    from typing import TypedDict
    import requests as req  # Renamed to avoid conflict with the resource type name

    class hubspot(TypedDict):
        api_key: str

    def main(hubspot_resource: hubspot, engagement_type: str, contact_ids: list[int], company_ids: list[int], deal_ids: list[int], owner_id: int, engagement_body: str):
        url = "https://api.hubapi.com/engagements/v1/engagements"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {hubspot_resource['api_key']}"
        }
        payload = {
            "engagement": {
                "active": True,
                "type": engagement_type,
                "ownerId": owner_id
            },
            "associations": {
                "contactIds": contact_ids,
                "companyIds": company_ids,
                "dealIds": deal_ids
            },
            "metadata": {
                "body": engagement_body
            }
        }
        response = req.post(url, json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_create-engagement
  instructions: |-
    Create a new engagement for a contact in hubspot
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HarvestClient, Project as HarvestProject } from "npm:@harvest-profit/harvest-api";

    type Harvest = {
        accountId: string;
        accessToken: string;
    }

    export async function main(harvestResource: Harvest): Promise<HarvestProject[]> {
        const harvest = new HarvestClient({
            accountId: harvestResource.accountId,
            accessToken: harvestResource.accessToken,
        });

        const projects = await harvest.getProjects();
        return projects;
    }
  good: |-
    import { HarvestClient } from "npm:@tryghost/harvest";

    type Harvest = {
        accountId: string;
        accessToken: string;
    }

    export async function main(harvestResource: Harvest, projectId?: number) {
        const harvest = new HarvestClient({
            accountId: harvestResource.accountId,
            accessToken: harvestResource.accessToken
        });

        let result;
        if (projectId) {
            result = await harvest.projects.retrieve(projectId);
        } else {
            result = await harvest.projects.list();
        }

        return result;
    }
  id: |-
    synthetic_get-projects
  instructions: |-
    Retrieve data for a project or projects in harvest
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Harvest
  resource_type_def: |-
    type Harvest = {
        accountId: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GoogleSpreadsheet } from "npm:google-spreadsheet";

    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        sheetTitle: string,
        rowsToUpdate: { rowIndex: number, values: any }[]
    ) {
        const doc = new GoogleSpreadsheet(spreadsheetId);
        await doc.useServiceAccountAuth({
            client_email: googleSheetsResource.clientEmail,
            private_key: googleSheetsResource.privateKey.replace(/\\n/g, '\n'),
        });

        await doc.loadInfo(); // loads document properties and worksheets
        const sheet = doc.sheetsByTitle[sheetTitle];

        for (const rowUpdate of rowsToUpdate) {
            const row = await sheet.getRows({ offset: rowUpdate.rowIndex, limit: 1 });
            if (row.length === 0) {
                throw new Error(`Row at index ${rowUpdate.rowIndex} not found`);
            }

            Object.assign(row[0], rowUpdate.values);
            await row[0].save(); // saves the changes to the sheet
        }

        return { success: true, message: 'Rows updated successfully' };
    }
  good: |-
    import { Sheets } from "npm:@googleapis/sheets";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        range: string,
        values: any[][]
    ) {
        const sheets = new Sheets({ version: 'v4', auth: googleSheetsResource.apiKey });

        const response = await sheets.spreadsheets.values.update({
            spreadsheetId: spreadsheetId,
            range: range,
            valueInputOption: 'USER_ENTERED',
            requestBody: {
                values: values
            },
            auth: googleSheetsResource.accessToken
        });

        return response.data;
    }
  id: |-
    synthetic_update-rows
  instructions: |-
    Update multiple rows in a spreadsheet defined by a range in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Amara as AmaraClient } from 'npm:amara-api';

    type Amara = {
        apiKey: string;
    }

    export async function main(amaraResource: Amara, videoId: string, languageCode: string, newLanguageCode: string) {
        const amaraClient = new AmaraClient({ api_key: amaraResource.apiKey });

        // Fetch the current subtitles
        const subtitles = await amaraClient.subtitles.get({
            video_id: videoId,
            language: languageCode,
        });

        // Update the language code of the subtitles
        subtitles.language = newLanguageCode;

        // Save the updated subtitles back to Amara
        const result = await amaraClient.subtitles.update({
            video_id: videoId,
            language: languageCode,
            sub_format: subtitles.format,
            subtitles: subtitles.text,
            new_language_code: newLanguageCode,
        });

        return result;
    }
  good: |-
    // Import any libraries you need here
    import { Amara } from "npm:@types/amara-api"; // Assuming there's a type definition for Amara API

    type AmaraCredentials = {
        apiKey: string;
    }

    export async function main(amaraResource: AmaraCredentials, videoId: string, languageCode: string, newSubtitles: string) {
        // Assuming Amara API provides a method to update subtitles and it's imported from npm package
        const amara = new Amara({ apiKey: amaraResource.apiKey });

        // Update the subtitle language using the Amara API
        const result = await amara.subtitles.update({
            video_id: videoId,
            language: languageCode,
            subtitles: newSubtitles
        });

        // Always return the result
        return result;
    }
  id: |-
    synthetic_update-subtitle-language
  instructions: |-
    Update a subtitle language in amara
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amara
  resource_type_def: |-
    type Amara = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Discogs API

    class discogs(TypedDict):
        consumer_key: str
        consumer_secret: str
        token: str
        token_secret: str

    def main(discogs_resource: discogs, order_id: str, status: str) -> dict:
        # Prepare the authentication headers
        auth_headers = {
            'Authorization': f'OAuth oauth_consumer_key="{discogs_resource["consumer_key"]}",'
                             f'oauth_nonce="nonce", oauth_token="{discogs_resource["token"]}",'
                             f'oauth_signature="{discogs_resource["consumer_secret"]}&{discogs_resource["token_secret"]}",'
                             f'oauth_signature_method="PLAINTEXT", oauth_timestamp="timestamp"'
        }

        # Prepare the request URL and payload
        url = f'https://api.discogs.com/marketplace/orders/{order_id}'
        payload = {'status': status}

        # Make the request to update the order status
        response = requests.post(url, headers=auth_headers, data=payload)

        # Return the response as a JSON object
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'discogs' integration
    class discogs(TypedDict):
        consumer_key: str
        consumer_secret: str
        oauth_token: str
        oauth_token_secret: str

    # Define the main function for updating an order status on Discogs
    def main(discogs_resource: discogs, order_id: str, new_status: str) -> bool:
        # Import the Discogs client library, renaming it if it conflicts with 'discogs' resource type
        from discogs_client import Client as DiscogsClient

        # Initialize the Discogs client with the provided credentials
        client = DiscogsClient(
            'UserAgent/1.0',
            consumer_key=discogs_resource['consumer_key'],
            consumer_secret=discogs_resource['consumer_secret'],
            token=discogs_resource['oauth_token'],
            secret=discogs_resource['oauth_token_secret']
        )

        # Fetch the order using the order_id
        order = client.order(order_id)

        # Update the order status
        order.status = new_status
        order.save()

        # Return True to indicate the operation was successful
        return True
  id: |-
    synthetic_update-order
  instructions: |-
    Updates the status of an existing order on Discogs in discogs
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    discogs
  resource_type_def: |-
    class discogs(TypedDict):
        consumer_key: str
        consumer_secret: str
        oauth_token: str
        oauth_token_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import bybit as bybit_client  # Renamed to avoid conflict with the resource type

    class bybit(TypedDict):  # Renamed to match the integration name exactly
        api_key: str
        api_secret: str

    def main(bybit_config: bybit, symbol: str, leverage: int):  # Renamed the parameter to avoid conflict
        client = bybit_client.bybit(test=False, api_key=bybit_config['api_key'], api_secret=bybit_config['api_secret'])

        # Set leverage
        client.LinearPositions.LinearPositions_saveLeverage(symbol=symbol, leverage=str(leverage)).result()

        # Switch position mode
        result = client.LinearPositions.LinearPositions_switchIsolated(symbol=symbol).result()

        return result
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Bybit API

    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str

    def main(bybit_resource: bybit, symbol: str, is_isolated: bool, leverage: float = None):
        if is_isolated and leverage is None:
            raise ValueError("Leverage must be set when switching from Cross to Isolated.")

        url = f"{bybit_resource['endpoint']}/position/leverage/save"
        params = {
            "api_key": bybit_resource['api_key'],
            "symbol": symbol,
            "is_isolated": is_isolated,
            "leverage": leverage if is_isolated else None,
            # Add any additional required parameters like timestamp, signature, etc.
        }

        # Assuming the use of a function to generate a signature with the API secret
        # params['sign'] = generate_signature(bybit_resource['api_secret'], params)

        response = requests.post(url, params=params)

        return response.json()
  id: |-
    synthetic_linear-position-switch-isolated
  instructions: |-
    Switch Cross/Isolated; must set leverage value when switching from Cross to Isolated. in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):  # Renamed to match the integration name exactly
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str

    # Define the main function for creating a post in a Facebook group
    def main(facebook_groups_resource: facebook_groups, message: str):
        import requests  # Import requests or any other library if needed

        # Construct the URL for the Facebook Graph API
        url = f"https://graph.facebook.com/{facebook_groups_resource['group_id']}/feed"

        # Prepare the payload with the message to post
        payload = {
            'message': message,
            'access_token': facebook_groups_resource['access_token']
        }

        # Make a POST request to the Facebook Graph API to create the post
        response = requests.post(url, data=payload)

        # Return the response from the API call
        return response.json()

    # Note: The function is not called here, it's just defined and ready to be used.
  good: |-
    from typing import TypedDict

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Import the Facebook SDK for Python, renaming the conflicting method if necessary
    from facebook import GraphAPI as FacebookGraphAPI

    def main(facebook_groups_resource: facebook_groups, group_id: str, message: str):
        # Initialize the Facebook Graph API with the access token
        graph = FacebookGraphAPI(access_token=facebook_groups_resource['access_token'])

        # Create a new post in the specified Facebook group
        post = graph.put_object(parent_object=group_id, connection_name='feed', message=message)

        # Return the result which includes the ID of the new post
        return post
  id: |-
    synthetic_create-post
  instructions: |-
    Create a new post in a group in facebook groups
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    facebook_groups
  resource_type_def: |-
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the formstack_documents integration
    class formstack_documents(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for the formstack_documents integration
    def main(formstack_documents_resource: formstack_documents, document_id: str, data: Dict[str, Any]):
        # Import the requests library here to avoid potential naming conflicts
        import requests

        # Construct the API endpoint for getting a document
        api_endpoint = f"https://{formstack_documents_resource['subdomain']}.formstack.com/api/v2/documents/{document_id}.json"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {formstack_documents_resource['api_key']}"
        }

        # Make the GET request to retrieve the document
        response = requests.get(api_endpoint, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the document content
            return response.json()
        else:
            # Handle errors (e.g., document not found, authentication error)
            response.raise_for_status()

    # Example usage:
    # result = main(formstack_documents_resource={'api_key': 'your_api_key', 'subdomain': 'your_subdomain'}, document_id='your_document_id', data={'key1': 'value1', 'key2': 'value2'})
    # print(result)
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the formstack_documents integration
    class formstack_documents(TypedDict):
        api_key: str  # API Key for authentication

    # Import any additional libraries you might need
    import requests  # Used for making HTTP requests

    # Define the main function with the resource type and any additional parameters
    def main(formstack_documents_resource: formstack_documents, document_id: str) -> Dict[str, Any]:
        # Base URL for Formstack Documents API
        base_url = "https://www.formstack.com/api/v2"

        # Endpoint for getting the details of a specific document
        document_details_endpoint = f"{base_url}/document/{document_id}.json"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {formstack_documents_resource['api_key']}"
        }

        # Make the HTTP GET request to retrieve the document details
        response = requests.get(document_details_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # Example usage:
    # result = main(formstack_documents_resource={'api_key': 'your_api_key'}, document_id='your_document_id')
    # print(result)
  id: |-
    synthetic_get-document
  instructions: |-
    Get the details of the specified document in formstack documents
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    formstack_documents
  resource_type_def: |-
    class formstack_documents(TypedDict):
        api_key: str
        subdomain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the Bitbucket integration
    class bitbucket(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str

    def main(bitbucket_resource: bitbucket, base_url: str, repository_slug: str, owner_username: str, snippet_title: str, snippet_content: str, snippet_filename: str):
        import requests

        # Construct the URL for creating a snippet in Bitbucket
        url = f"{base_url}/2.0/snippets/{owner_username}"

        # Prepare the headers for the request
        headers = {
            "Authorization": f"Bearer {bitbucket_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Prepare the data for the snippet
        data = {
            "title": snippet_title,
            "is_private": True,
            "files": {
                snippet_filename: {
                    "content": snippet_content
                }
            }
        }

        # Make the request to create the snippet
        response = requests.post(url, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created snippet information
        else:
            raise Exception(f"Failed to create snippet: {response.status_code} {response.text}")

    # Example usage:
    # result = main(bitbucket_resource, 'https://api.bitbucket.org', 'my-repo', 'my-username', 'My Snippet', 'print("Hello, World!")', 'hello.py')
    # print(result)
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to Bitbucket API

    # Define the resource type for the bitbucket integration
    class bitbucket(TypedDict):
        api_base_url: str
        access_token: str

    def main(bitbucket_resource: bitbucket, repository_full_name: str, snippet_title: str, snippet_content: str, snippet_filename: str, is_private: Optional[bool] = True):
        headers = {
            'Authorization': f'Bearer {bitbucket_resource["access_token"]}',
            'Content-Type': 'application/json'
        }
        snippet_data = {
            'title': snippet_title,
            'is_private': is_private,
            'files': {
                snippet_filename: {
                    'content': snippet_content
                }
            }
        }
        url = f'{bitbucket_resource["api_base_url"]}/repositories/{repository_full_name}/snippets/'
        response = requests.post(url, json=snippet_data, headers=headers)

        if response.status_code == 201:
            return response.json()  # Successfully created snippet
        else:
            response.raise_for_status()  # Raise an HTTPError if the HTTP request returned an unsuccessful status code
  id: |-
    synthetic_create-snippet-comment
  instructions: |-
    Creates a new snippet comment in bitbucket
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitbucket
  resource_type_def: |-
    class bitbucket(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'noticeable' integration
    class noticeable(TypedDict):
        api_key: str
        project_id: str

    # Define the main function for updating email subscription
    def main(noticeable_resource: noticeable, subscriber_email: str, subscription_status: bool):
        # Import the requests library here to avoid conflicts with the resource type name
        import requests

        # Construct the API endpoint for updating the email subscription
        endpoint = f"https://api.noticeable.io/v1/projects/{noticeable_resource['project_id']}/subscribers"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {noticeable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the subscriber's email and subscription status
        payload = {
            "email": subscriber_email,
            "subscribed": subscription_status
        }

        # Make the request to update the email subscription
        response = requests.patch(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return {"success": True, "message": "Subscription updated successfully."}
        else:
            return {"success": False, "message": "Failed to update subscription.", "error": response.text}

    # Note: The function is not called here, it is only defined and ready to be used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'noticeable' integration
    class noticeable(TypedDict):
        api_key: str
        project_id: str

    # Define the main function for updating an email subscription in Noticeable
    def main(noticeable_resource: noticeable, subscriber_id: str, email: str, is_subscribed: bool):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a subscription
        url = f"https://api.noticeable.io/v1/projects/{noticeable_resource['project_id']}/subscribers/{subscriber_id}"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Bearer {noticeable_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "email": email,
            "is_subscribed": is_subscribed
        }

        # Make the API request to update the subscription
        response = requests.patch(url, json=payload, headers=headers)

        # Check for a successful response and return the result
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()  # Raise an exception for any HTTP errors

    # The main function is now defined and can be used with the required parameters
  id: |-
    synthetic_update-email-subscription
  instructions: |-
    Updates an email subscription, in noticeable
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    noticeable
  resource_type_def: |-
    class noticeable(TypedDict):
        api_key: str
        project_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the 'clearout' integration
    class clearout(TypedDict):
        api_key: str

    def main(clearout_resource: clearout, domain: str) -> List[str]:
        # Construct the API endpoint for getting MX records
        endpoint = f"https://api.clearout.io/domain_mx/{domain}"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {clearout_resource['api_key']}"
        }

        # Make the HTTP GET request to the Clearout API
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response to get the MX records
            mx_records = response.json().get('data', {}).get('mx_records', [])
            return mx_records
        else:
            # Handle error responses
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API interaction

    class clearout(TypedDict):
        api_key: str

    def main(clearout_resource: clearout, domain: str) -> List[str]:
        endpoint = f"https://api.clearout.io/v2/email_verify/mx_lookup/{domain}"
        headers = {
            "Authorization": f"Bearer {clearout_resource['api_key']}"
        }
        response = requests.get(endpoint, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        mx_records = response.json().get('data', {}).get('mx_records', [])
        return mx_records
  id: |-
    synthetic_get-domain-mx
  instructions: |-
    Get a domain MX in clearout
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clearout
  resource_type_def: |-
    class clearout(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Chat } from "npm:@googleapis/chat";

    type GoogleChat = {
        spaceId: string;
        accessToken: string;
    }

    export async function main(googleChatResource: GoogleChat, memberId: string) {
        const chat = new Chat({ auth: googleChatResource.accessToken });
        const result = await chat.spaces.members.get({
            parent: `spaces/${googleChatResource.spaceId}`,
            name: `spaces/${googleChatResource.spaceId}/members/${memberId}`
        });

        return result.data;
    }
  good: |-
    import { Chat } from "npm:@googleapis/chat";

    type GoogleChat = {
        accessToken: string;
    }

    export async function main(googleChatResource: GoogleChat, spaceId: string, memberId: string) {
        const chat = new Chat({ auth: googleChatResource.accessToken });

        try {
            const response = await chat.spaces.members.get({
                parent: spaceId,
                name: memberId,
            });

            return response.data;
        } catch (error) {
            console.error('Error fetching membership details:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-member
  instructions: |-
    Returns details about a membership in google chat
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleChat
  resource_type_def: |-
    type GoogleChat = {
        spaceId: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { LinkedInClient } from "npm:linkedin-client"; // Example import, replace with actual library if different

    type Linkedin = {
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(linkedinResource: Linkedin, accountId: string, startYear: number) {
        // Create a date range starting from the beginning of the given year until now
        const startDate = new Date(startYear, 0, 1).toISOString(); // January 1st of startYear
        const endDate = new Date().toISOString(); // Current date and time

        // Initialize the LinkedIn client with the provided credentials
        const client = new LinkedInClient({
            accessToken: linkedinResource.accessToken,
            clientId: linkedinResource.clientId,
            clientSecret: linkedinResource.clientSecret
        });

        // Fetch analytics for the specified account and date range
        const analytics = await client.getAnalytics({
            accountId: accountId,
            timeRange: {
                start: startDate,
                end: endDate
            }
        });

        // Return the analytics data
        return analytics;
    }
  good: |-
    import { Client as LinkedinClient } from "npm:@linkedin/restli-client";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, organizationId: string, startDate: string, endDate: string) {
        const client = new LinkedinClient({ credentials: { accessToken: linkedinResource.accessToken } });

        const analyticsFinderUrl = `https://api.linkedin.com/v2/organizationPageStatistics?q=organization&organization=${organizationId}&timeIntervals.timeGranularityType=DAY&timeIntervals.timeRange.start=${startDate}&timeIntervals.timeRange.end=${endDate}`;

        const response = await fetch(analyticsFinderUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${linkedinResource.accessToken}`,
                'Content-Type': 'application/json'
            }
        });

        const data = await response.json();

        return data;
    }
  id: |-
    synthetic_analytics-finder-account-sample
  instructions: |-
    Sample query using analytics finder that gets analytics for a particular account for date range starting in a given year in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the badger_maps integration
    class badger_maps(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for updating an account in Badger Maps
    def main(badger_maps_resource: badger_maps, account_id: int, update_data: dict) -> Any:
        headers = {
            'Authorization': f"Bearer {badger_maps_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"{badger_maps_resource['base_url']}/accounts/{account_id}"

        response = requests.put(url, json=update_data, headers=headers)

        return response.json()

    # Example usage (do not include this in the script):
    # update_data = {
    #     'name': 'New Account Name',
    #     'revenue': 100000,
    #     # ... other fields to update
    # }
    # result = main(badger_maps_resource={'api_key': 'your_api_key', 'base_url': 'https://api.badgermaps.com'}, account_id=123, update_data=update_data)
  good: |-
    from typing import TypedDict

    # Define the resource type for the badger_maps integration
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for updating an account in badger_maps
    def main(badger_maps_resource: badger_maps, account_id: str, new_account_data: dict) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating an account
        update_url = f"https://api.badgermaps.com/v1/account/{account_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {badger_maps_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to update the account with the new data
        response = requests.put(update_url, headers=headers, json=new_account_data)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated account data
        else:
            # Handle error cases appropriately
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_update-account
  instructions: |-
    Updates an account. in badger maps
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    badger_maps
  resource_type_def: |-
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'drata' integration
    class drata(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for the 'drata' integration
    def main(drata_resource: drata, applicant_id: str, background_check_report: Any):
        # Import the requests library here to avoid potential naming conflicts
        import requests

        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {drata_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the endpoint URL for uploading the background check
        url = f"{drata_resource['base_url']}/applicants/{applicant_id}/background-check"

        # Assume background_check_report is a dictionary that can be converted to JSON
        response = requests.post(url, headers=headers, json=background_check_report)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Drata API

    class drata(TypedDict):
        api_key: str
        base_url: str

    def main(drata_resource: drata, background_check_file_url: str) -> dict:
        headers = {
            'Authorization': f'Bearer {drata_resource["api_key"]}',
            'Content-Type': 'application/json'
        }

        response = requests.post(
            f'{drata_resource["base_url"]}/background-checks',
            headers=headers,
            json={'file_url': background_check_file_url}
        )

        return response.json()
  id: |-
    synthetic_upload-background-check
  instructions: |-
    The URL of the background check file. in drata
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    drata
  resource_type_def: |-
    class drata(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { OAuth2Client } from "npm:google-auth-library";

    type GoogleChat = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
        scope: string;
        tokenType: string;
        expiryDate: number;
    }

    export async function main(googleChatResource: GoogleChat) {
        // Initialize OAuth2Client with the credentials from GoogleChat resource
        const oAuth2Client = new OAuth2Client(
            googleChatResource.clientId,
            googleChatResource.clientSecret
        );

        // Set the credentials for the OAuth2Client
        oAuth2Client.setCredentials({
            refresh_token: googleChatResource.refreshToken,
            access_token: googleChatResource.accessToken,
            scope: googleChatResource.scope,
            token_type: googleChatResource.tokenType,
            expiry_date: googleChatResource.expiryDate
        });

        // Define the Google Chat API endpoint for listing spaces
        const googleChatApiEndpoint = 'https://chat.googleapis.com/v1/spaces';

        // Make an authorized request to the Google Chat API
        const response = await fetch(googleChatApiEndpoint, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${oAuth2Client.credentials.access_token}`,
                'Accept': 'application/json'
            }
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`Google Chat API responded with status: ${response.status}`);
        }

        // Parse the response body as JSON
        const spacesList = await response.json();

        // Return the list of spaces
        return spacesList;
    }
  good: |-
    // Importing necessary libraries
    import { Chat } from "npm:@googleapis/chat";

    type GoogleChat = {
        accessToken: string;
    }

    export async function main(googleChatResource: GoogleChat, pageSize: number = 10) {
        const chat = new Chat({ auth: googleChatResource.accessToken });

        try {
            const response = await chat.spaces.list({
                pageSize: pageSize
            });

            return response.data;
        } catch (error) {
            console.error('Error listing Google Chat spaces:', error);
            throw error;
        }
    }
  id: |-
    synthetic_list-spaces
  instructions: |-
    Lists spaces the caller is a member of. Group chats and DMs aren't listed until the first message is sent in google chat
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleChat
  resource_type_def: |-
    type GoogleChat = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:base-64";

    type Mautic = {
        baseUrl: string;
        username: string;
        password: string;
    }

    export async function main(mauticResource: Mautic, campaignId: number) {
        // Encode credentials
        const credentials = encode(`${mauticResource.username}:${mauticResource.password}`);

        // Prepare the request headers
        const headers = new Headers({
            'Authorization': `Basic ${credentials}`
        });

        // Construct the URL to access the campaign
        const url = `${mauticResource.baseUrl}/api/campaigns/${campaignId}`;

        // Make the HTTP request to get the campaign by ID
        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        // Parse the response as JSON
        const campaignData = await response.json();

        // Return the campaign data
        return campaignData;
    }
  good: |-
    import { MauticAuth } from "npm:@mautic/authentication"; // Assuming such a package exists for Mautic authentication

    type Mautic = {
        baseUrl: string;
        accessToken: string;
    }

    export async function main(mauticResource: Mautic, campaignId: number) {
        const authHeader = `Bearer ${mauticResource.accessToken}`;
        const campaignUrl = `${mauticResource.baseUrl}/api/campaigns/${campaignId}`;

        const response = await fetch(campaignUrl, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const campaignData = await response.json();
        return campaignData;
    }
  id: |-
    synthetic_get-campaign
  instructions: |-
    Gets an individual campaign by ID in mautic
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mautic
  resource_type_def: |-
    type Mautic = {
        baseUrl: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to asknicely

    class asknicely(TypedDict):
        api_key: str
        domain: str

    def main(asknicely_resource: asknicely, contact_email: str, survey_id: str):
        base_url = f"https://{asknicely_resource['domain']}.asknice.ly/api/v1"
        headers = {
            "X-Api-Key": asknicely_resource['api_key']
        }
        payload = {
            "email": contact_email,
            "survey_id": survey_id
        }

        response = requests.post(f"{base_url}/contacts/trigger", headers=headers, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to the asknicely API

    # Define the resource type for the asknicely integration
    class asknicely(TypedDict):
        api_key: str
        domain: str

    def main(asknicely_resource: asknicely, recipient_email: str, survey_id: int) -> Any:
        # Construct the API endpoint for sending a survey
        api_endpoint = f"https://{asknicely_resource['domain']}.asknice.ly/api/v1/survey/send"

        # Prepare the headers and payload for the API request
        headers = {
            "X-Api-Key": asknicely_resource['api_key'],
            "Content-Type": "application/json"
        }
        payload = {
            "email": recipient_email,
            "survey_id": survey_id
        }

        # Make the API request to send the survey
        response = requests.post(api_endpoint, json=payload, headers=headers)

        # Return the response from the API
        return response.json()
  id: |-
    synthetic_send-survey
  instructions: |-
    Trigger a survey to a contact in asknicely
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    asknicely
  resource_type_def: |-
    class asknicely(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Cisco Webex API

    # Define the resource type for the cisco_webex integration
    class cisco_webex(TypedDict):
        access_token: str
        base_url: str

    # Define the main function for sending a message using the Cisco Webex API
    def main(cisco_webex_resource: cisco_webex, room_id: str, message_text: str):
        headers = {
            'Authorization': f"Bearer {cisco_webex_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'roomId': room_id,
            'text': message_text
        }
        response = requests.post(
            url=f"{cisco_webex_resource['base_url']}/messages",
            headers=headers,
            json=payload
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP requests

    # Define the resource type for the cisco_webex integration
    class cisco_webex(TypedDict):
        access_token: str
        room_id: str

    def main(cisco_webex_resource: cisco_webex, message: str, markdown: str = None):
        # Construct the headers for the HTTP request
        headers = {
            "Authorization": f"Bearer {cisco_webex_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Construct the payload for the HTTP request
        payload = {
            "roomId": cisco_webex_resource['room_id'],
            "text": message
        }

        # If markdown is provided, add it to the payload
        if markdown:
            payload["markdown"] = markdown

        # Send the message to the specified Webex room
        response = requests.post(
            url="https://webexapis.com/v1/messages",
            headers=headers,
            json=payload
        )

        # Check for successful response
        if response.status_code == 200:
            return response.json()  # Return the response as JSON
        else:
            response.raise_for_status()  # Raise an exception for any HTTP errors
  id: |-
    synthetic_create-message
  instructions: |-
    Post a plain text or message, and optionally, a, to a room in cisco webex
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cisco_webex
  resource_type_def: |-
    class cisco_webex(TypedDict):
        access_token: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import notion as notion_api  # Renamed imported module to avoid conflict with the resource type name

    class notion(TypedDict):
        token: str  # Assuming the token is used for authentication

    def main(notion_resource: notion, search_query: str) -> Dict[str, Any]:
        # Initialize the Notion client with the provided token
        client = notion_api.Client(auth=notion_resource['token'])

        # Perform the search with the given query
        search_results = client.search(query=search_query)

        # Return the search results
        return search_results
  good: |-
    from typing import TypedDict, Optional
    import notion_client

    class notion(TypedDict):
        access_token: str

    def main(notion_resource: notion, query: str, start_cursor: Optional[str] = None):
        client = notion_client.Client(auth=notion_resource['access_token'])
        search_results = client.search(query=query, start_cursor=start_cursor)
        return search_results
  id: |-
    synthetic_search
  instructions: |-
    Searches for a page or database in notion
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str  # Assuming the token is used for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the apollo_io integration
    class apollo_io(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the People Enrichment script
    def main(apollo_io_resource: apollo_io, email: str) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Base URL for the Apollo.io API
        base_url = "https://api.apollo.io/v1/people/enrich"

        # Headers to include in the request
        headers = {
            "Authorization": f"Bearer {apollo_io_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Payload for the request
        payload = {
            "email": email
        }

        # Make the request to the Apollo.io API
        response = requests.post(base_url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # The main function is now defined and can be used with the required apollo_io resource and an email address.
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the apollo_io integration
    class apollo_io(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the apollo_io integration
    def main(apollo_io_resource: apollo_io,
             first_name: Optional[str] = None,
             last_name: Optional[str] = None,
             email: Optional[str] = None,
             company_name: Optional[str] = None):
        # Import the necessary library for HTTP requests
        import requests

        # Define the base URL for the Apollo API
        base_url = "https://api.apollo.io/v1/people/enrich"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {apollo_io_resource['api_key']}"
        }

        # Prepare the payload with the information provided
        payload = {
            "first_name": first_name,
            "last_name": last_name,
            "email": email,
            "company_name": company_name
        }

        # Remove None values from the payload
        payload = {k: v for k, v in payload.items() if v is not None}

        # Make the request to the Apollo API
        response = requests.post(base_url, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the enriched person information
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": response.text, "status_code": response.status_code}
  id: |-
    synthetic_people-enrichment
  instructions: |-
    Enriches a person's information, the more information you pass in, the more likely we can find a match in apollo io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    apollo_io
  resource_type_def: |-
    class apollo_io(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { KickofflabsClient } from "npm:@kickofflabs/kickofflabs-sdk";

    type Kickofflabs = {
        apiKey: string;
    }

    export async function main(kickofflabsResource: Kickofflabs, campaignId: number) {
        const kickofflabsClient = new KickofflabsClient(kickofflabsResource.apiKey);
        const campaignStatus = await kickofflabsClient.getCampaignStatus(campaignId);
        return campaignStatus;
    }
  good: |-
    import { encode } from "npm:querystring";

    type Kickofflabs = {
        apiKey: string;
        authToken: string;
    }

    export async function main(kickofflabsResource: Kickofflabs, campaignId: number) {
        const baseUrl = 'https://api.kickofflabs.com/v1';
        const campaignStatsEndpoint = `/campaigns/${campaignId}/stats`;

        const headers = new Headers({
            'Authorization': `Basic ${btoa(`${kickofflabsResource.apiKey}:${kickofflabsResource.authToken}`)}`,
            'Content-Type': 'application/json'
        });

        const response = await fetch(`${baseUrl}${campaignStatsEndpoint}`, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-campaign-status
  instructions: |-
    Fetches campaign overview stats. in kickofflabs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Kickofflabs
  resource_type_def: |-
    type Kickofflabs = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Configuration, OpenAIApi as OpenAI } from "npm:@openai/openai";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, prompt: string, maxTokens: number, temperature: number) {
        const configuration = new Configuration({
            apiKey: openaiResource.apiKey,
        });
        const openai = new OpenAI(configuration);

        const completion = await openai.createCompletion({
            model: "text-davinci-003",
            prompt: prompt,
            max_tokens: maxTokens,
            temperature: temperature,
        });

        return completion.data;
    }
  good: |-
    import { OpenAIApi } from "npm:openai";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, runId: string, model: string, prompt: string, maxTokens: number) {
        const openai = new OpenAIApi({
            apiKey: openaiResource.apiKey,
        });

        const response = await openai.createEdit({
            model: model,
            input: prompt,
            actions: [{
                action: "prepend",
                text: prompt,
            }],
            n: 1,
            temperature: 0,
            max_tokens: maxTokens,
        });

        return response.data;
    }
  id: |-
    synthetic_modify-run
  instructions: |-
    Modifies an existing run in openai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the neon_api_keys integration
    class neon_api_keys(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function with the resource type and additional parameters
    def main(neon_api_keys_resource: neon_api_keys, database_name: str):
        # Assuming the integration requires a library to interact with the Neon API
        import neon  # If 'neon' conflicts with 'neon_api_keys', rename it as follows:
        # import neon as neon_lib

        # Initialize the Neon API client with the provided API keys
        client = neon.Client(api_key=neon_api_keys_resource['api_key'], api_secret=neon_api_keys_resource['api_secret'])

        # Create the database using the Neon API client
        result = client.create_database(database_name)

        # Return the result of the database creation
        return result

    # The script ends here, and the main function is not called.
  good: |-
    from typing import TypedDict

    # Define the resource type for the neon_api_keys integration
    class neon_api_keys(TypedDict):
        api_key: str
        project_id: str

    # Define the main function for creating a database in the project using neon API keys
    def main(neon_api_keys_resource: neon_api_keys, database_name: str):
        # Import the requests library here to avoid naming conflicts
        import requests

        # Construct the API endpoint for creating a database
        api_endpoint = f"https://api.neon.tech/projects/{neon_api_keys_resource['project_id']}/databases"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {neon_api_keys_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Define the payload with the database name
        payload = {
            "name": database_name
        }

        # Make a POST request to create the database
        response = requests.post(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if the database was created successfully
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # The script ends here, with no calls to the main function, as per the instructions.
  id: |-
    synthetic_create-database
  instructions: |-
    Creates a database in the project in neon api keys
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    neon_api_keys
  resource_type_def: |-
    class neon_api_keys(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the cloudflare_api_key integration
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
        account_id: str

    # Define the main function for revoking a certificate
    def main(cloudflare_resource: cloudflare_api_key, zone_id: str, certificate_id: str) -> bool:
        import requests  # Import requests or any other library if needed

        # Construct the headers for authentication
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Construct the URL for the revoke certificate endpoint
        url = f"https://api.cloudflare.com/client/v4/accounts/{cloudflare_resource['account_id']}/zones/{zone_id}/custom_certificates/{certificate_id}/revoke"

        # Make the request to revoke the certificate
        response = requests.delete(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return True
        else:
            # Handle error (you could also raise an exception or return the response for more details)
            return False

    # The script ends here, and the main function can be exported and used with the specified parameters.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str
        account_id: str

    def main(cloudflare_resource: cloudflare_api_key, serial_number: str) -> dict:
        headers = {
            'X-Auth-Email': cloudflare_resource['email'],
            'X-Auth-Key': cloudflare_resource['api_key'],
            'Content-Type': 'application/json',
        }

        url = f"https://api.cloudflare.com/client/v4/accounts/{cloudflare_resource['account_id']}/certificates/{serial_number}/revoke"

        response = requests.delete(url, headers=headers)

        return response.json()
  id: |-
    synthetic_revoke-certificate
  instructions: |-
    Revoke an existing Origin CA certificate by its serial number in cloudflare api key
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudflare_api_key
  resource_type_def: |-
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import mailjet_rest  # Assuming mailjet_rest is the library for Mailjet API

    class mailjet(TypedDict):
        api_key: str
        api_secret: str

    def main(mailjet_resource: mailjet, limit: int = 10) -> List[Dict]:
        client = mailjet_rest.Client(auth=(mailjet_resource['api_key'], mailjet_resource['api_secret']), version='v3')
        result = client.contact.get(data={'Limit': limit})
        return result.json()

    # The main function can now be exported and used with the required mailjet resource and an optional limit parameter.
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP requests to the Mailjet API

    class mailjet(TypedDict):
        api_key: str
        api_secret: str

    def main(mailjet_resource: mailjet, status: str = 'alive') -> List[Dict[str, any]]:
        base_url = "https://api.mailjet.com/v3/REST/contactlist"
        headers = {
            "Authorization": f"Basic {mailjet_resource['api_key']}:{mailjet_resource['api_secret']}"
        }
        params = {
            "Status": status
        }
        response = requests.get(base_url, headers=headers, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        contact_lists = response.json().get('Data', [])
        result = [
            {
                "Name": contact_list.get("Name"),
                "SubscriberCount": contact_list.get("SubscriberCount"),
                "CreatedAt": contact_list.get("CreatedAt"),
                "IsDeleted": contact_list.get("IsDeleted")
            }
            for contact_list in contact_lists
        ]

        return result
  id: |-
    synthetic_list-contacts
  instructions: |-
    Retrieve details for all contact lists - name, subscriber count, creation timestamp, deletion status in mailjet
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailjet
  resource_type_def: |-
    class mailjet(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:base-64";

    type Accelo = {
        apiUrl: string;
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(
        acceloResource: Accelo,
        endpoint: string,
        method: string = 'GET',
        body: Record<string, any> | null = null,
        additionalHeaders: Record<string, string> | null = null
    ) {
        const url = `${acceloResource.apiUrl}/${endpoint}`;
        const headers = new Headers({
            'Authorization': `Bearer ${acceloResource.accessToken}`,
            'Content-Type': 'application/json',
            ...additionalHeaders
        });

        const response = await fetch(url, {
            method: method,
            headers: headers,
            body: body ? JSON.stringify(body) : null
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { stringify } from "npm:querystring";

    type Accelo = {
        apiUrl: string;
        accessToken: string;
    }

    export async function main(
        acceloResource: Accelo,
        title: string,
        description: string,
        typeId: number,
        standing: string,
        priorityId: number
    ) {
        const requestUrl = `${acceloResource.apiUrl}/api/v0/requests`;

        const requestBody = {
            _type: typeId,
            title: title,
            description: description,
            standing: standing,
            priority: priorityId
        };

        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${acceloResource.accessToken}`,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-request
  instructions: |-
    Creates a request in accelo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Accelo
  resource_type_def: |-
    type Accelo = {
        apiUrl: string;
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Contact, Tag } from "npm:@agilecrm/sdk"; // Assuming there's an Agile CRM SDK available on npm

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, contactId: string, tags: string[]) {
        // Initialize the Agile CRM client with the provided credentials
        const agileClient = new Contact({
            apiKey: agileCrmResource.apiKey,
            domain: agileCrmResource.domain,
            email: agileCrmResource.email
        });

        // Create a Tag instance to manage tags
        const tagManager = new Tag(agileClient);

        // Add tags to the contact
        const result = await tagManager.add(contactId, tags);

        // Return the result
        return result;
    }
  good: |-
    import { AgileCrmClient as AgileCrmApiClient } from "npm:agilecrm";

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, contactEmail: string, tagsToAdd: string[]) {
        const client = new AgileCrmApiClient({
            apiKey: agileCrmResource.apiKey,
            domain: agileCrmResource.domain,
            email: agileCrmResource.email
        });

        const contact = await client.contacts.getByEmail(contactEmail);

        if (!contact) {
            throw new Error(`Contact with email ${contactEmail} not found.`);
        }

        const updatedContact = await client.contacts.addTags(contact.id, tagsToAdd);

        return updatedContact;
    }
  id: |-
    synthetic_add-tags-to-contact
  instructions: |-
    Adds a tag or tags to an existing contact in agile crm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AgileCrm
  resource_type_def: |-
    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Jobnimbus = {
        apiKey: string,
        user: string
    }

    export async function main(jobnimbusResource: Jobnimbus, contactName: string, contactEmail: string, contactPhone?: string) {
        const authHeader = `Basic ${encode(`${jobnimbusResource.user}:${jobnimbusResource.apiKey}`)}`;
        const response = await fetch('https://api.jobnimbus.com/v1/contacts', {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                name: contactName,
                email: contactEmail,
                phone: contactPhone
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:base-64";

    type Jobnimbus = {
        apiKey: string;
        userToken: string;
    }

    export async function main(jobnimbusResource: Jobnimbus, contactName: string, contactEmail: string, contactPhone?: string) {
        const authHeader = `Basic ${encode(`${jobnimbusResource.apiKey}:${jobnimbusResource.userToken}`)}`;
        const contactData = {
            name: contactName,
            email: contactEmail,
            phone: contactPhone
        };

        const response = await fetch('https://api.jobnimbus.com/v1/contacts', {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(contactData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-contact
  instructions: |-
    Creates a contact in jobnimbus
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jobnimbus
  resource_type_def: |-
    type Jobnimbus = {
        apiKey: string;
        userToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { v4 as uuidv4 } from "npm:uuid";

    type IauditorBySafetyculture = {
        apiKey: string;
    }

    export async function main(
        iauditorBySafetycultureResource: IauditorBySafetyculture,
        title: string,
        templateId: string,
        startDate: string,
        endDate: string,
        timezone: string
    ) {
        const url = 'https://api.safetyculture.io/audits';
        const headers = {
            'Authorization': `Bearer ${iauditorBySafetycultureResource.apiKey}`,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            audit_id: uuidv4(),
            template_id: templateId,
            header_items: [
                {
                    item_id: uuidv4(),
                    label: 'Title',
                    type: 'textsingle',
                    responses: {
                        text: title
                    }
                },
                {
                    item_id: uuidv4(),
                    label: 'Start Date',
                    type: 'datetime',
                    responses: {
                        datetime: startDate
                    }
                },
                {
                    item_id: uuidv4(),
                    label: 'End Date',
                    type: 'datetime',
                    responses: {
                        datetime: endDate
                    }
                },
                {
                    item_id: uuidv4(),
                    label: 'Timezone',
                    type: 'textsingle',
                    responses: {
                        text: timezone
                    }
                }
            ]
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { IauditorBySafetyculture as IauditorClient } from "npm:@safetyculture/iauditor-exporter";

    type IauditorBySafetyculture = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(
        iauditorResource: IauditorBySafetyculture,
        inspectionTitle: string,
        templateId: string,
        auditData: object
    ) {
        const iauditorClient = new IauditorClient(iauditorResource.apiKey, iauditorResource.apiUrl);
        const inspectionResult = await iauditorClient.createInspection(inspectionTitle, templateId, auditData);
        return inspectionResult;
    }
  id: |-
    synthetic_create-inspection
  instructions: |-
    Create a new inspection in iAuditor by SafetyCulture in iauditor by safetyculture
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    IauditorBySafetyculture
  resource_type_def: |-
    type IauditorBySafetyculture = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Lead } from "npm:@close.io/closeio";

    type Close = {
        apiKey: string;
    }

    export async function main(closeResource: Close, leadId: string, updateFields: Partial<Lead>) {
        const closeIo = new Lead({ apiKey: closeResource.apiKey });

        const result = await closeIo.update(leadId, updateFields);

        return result;
    }
  good: |-
    // Import Close SDK from npm
    import CloseClient from "npm:close.io";

    type Close = {
        apiKey: string;
    }

    export async function main(closeResource: Close, leadId: string, updateFields: Record<string, any>) {
        const closeClient = new CloseClient(closeResource.apiKey);

        try {
            const response = await closeClient.lead.update(leadId, updateFields);
            return response;
        } catch (error) {
            console.error('Failed to update the lead:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-lead
  instructions: |-
    Updates a lead, in close
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Close
  resource_type_def: |-
    type Close = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str

    def main(facebook_groups_resource: facebook_groups, group_id: str, post_id: str) -> Dict[str, Any]:
        # Construct the URL for the Facebook Graph API to get the post details
        url = f"https://graph.facebook.com/v14.0/{group_id}/posts/{post_id}"

        # Prepare the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {facebook_groups_resource['access_token']}"
        }

        # Make the GET request to the Facebook Graph API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": f"Failed to get post: {response.text}"}
  good: |-
    from typing import TypedDict, List, Dict, Any
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str  # OAuth2 Access Token
        group_id: str      # ID of the Facebook Group

    def main(facebook_groups_resource: facebook_groups, limit: int = 10) -> List[Dict[str, Any]]:
        # Construct the URL for the Facebook Graph API to retrieve posts from a group
        url = f"https://graph.facebook.com/{facebook_groups_resource['group_id']}/feed"

        # Set up the parameters for the request
        params = {
            'access_token': facebook_groups_resource['access_token'],
            'limit': limit
        }

        # Make the HTTP GET request to the Facebook Graph API
        response = requests.get(url, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the data
            data = response.json()
            return data.get('data', [])
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Note: The function does not call itself, it's ready to be exported and used with the appropriate parameters.
  id: |-
    synthetic_get-post
  instructions: |-
    Retrieves post in a group in facebook groups
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    facebook_groups
  resource_type_def: |-
    class facebook_groups(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Buffer } from "npm:buffer";

    type IntellexerApi = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(intellexerApiResource: IntellexerApi, textStream: ReadableStream<Uint8Array>) {
        // Convert the text stream to a Buffer
        const chunks: Uint8Array[] = [];
        const reader = textStream.getReader();
        let readResult: ReadableStreamDefaultReadResult<Uint8Array>;
        while (!(readResult = await reader.read()).done) {
            chunks.push(readResult.value);
        }
        const buffer = Buffer.concat(chunks);

        // Prepare the request to the Intellexer API
        const url = `${intellexerApiResource.apiUrl}/recognizeLanguage`;
        const headers = {
            'Content-Type': 'application/octet-stream',
            'Authorization': `Bearer ${intellexerApiResource.apiKey}`
        };

        // Send the request to the Intellexer API
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: buffer
        });

        // Parse the response
        if (!response.ok) {
            throw new Error(`Intellexer API responded with status: ${response.status}`);
        }
        const result = await response.json();

        // Return the result
        return result;
    }
  good: |-
    import { LanguageDetector } from "npm:intellexer-api";

    type IntellexerApi = {
        apiKey: string;
    }

    export async function main(intellexerApiResource: IntellexerApi, text: string) {
        const languageDetector = new LanguageDetector(intellexerApiResource.apiKey);
        const result = await languageDetector.detect(text);
        return result;
    }
  id: |-
    synthetic_detect-language
  instructions: |-
    Recognize language and encoding of an input text stream in intellexer api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    IntellexerApi
  resource_type_def: |-
    type IntellexerApi = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type DiscordWebhook = {
        webhookUrl: string;
    }

    export async function main(discordWebhookResource: DiscordWebhook, message: string, fileName: string, fileContent: Uint8Array) {
        // Prepare the form data
        const formData = new FormData();
        formData.append('content', message);
        formData.append('file', new Blob([fileContent]), fileName);

        // Send the message with the file to the Discord webhook
        const response = await fetch(discordWebhookResource.webhookUrl, {
            method: 'POST',
            body: formData,
        });

        // Check the response
        if (!response.ok) {
            throw new Error(`Failed to send message: ${response.statusText}`);
        }

        // Return the result
        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { Buffer } from "npm:buffer";

    type DiscordWebhook = {
        webhookUrl: string;
    }

    export async function main(discordWebhookResource: DiscordWebhook, message: string, filePath: string, fileName: string) {
        // Prepare the form data for the request
        const formData = new FormData();
        formData.append('content', message);
        formData.append('file', new Blob([await Deno.readFile(filePath)], { type: 'application/octet-stream' }), fileName);

        // Send the message with the file to the Discord webhook
        const response = await fetch(discordWebhookResource.webhookUrl, {
            method: 'POST',
            body: formData,
        });

        // Check for a successful response
        if (!response.ok) {
            throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
        }

        // Return the result
        return await response.json();
    }
  id: |-
    synthetic_send-message-with-file
  instructions: |-
    Post a message with an attached file in discord webhook
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DiscordWebhook
  resource_type_def: |-
    type DiscordWebhook = {
        webhookUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { BigNumber } from "npm:bignumber.js";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, limit: number = 50) {
        const url = `${bybitResource.endpoint}/v2/public/big-deal?symbol=${symbol}&limit=${limit}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Api-Key': bybitResource.apiKey,
                'X-Api-Secret': bybitResource.apiSecret
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { hmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
    };

    interface Order {
        symbol: string;
        price: number;
        qty: number;
        side: string;
        order_type: string;
        time: number; // Unix timestamp of the order
    }

    export async function main(bybitResource: Bybit, symbol: string, minimumValueUSD: number = 500000) {
        const endpoint = 'https://api.bybit.com/v2/private/order/list';
        const params = {
            api_key: bybitResource.apiKey,
            symbol: symbol,
            timestamp: new Date().getTime(),
            limit: 50, // Adjust the limit as needed
        };

        // Create the query string and sign the request
        const query = Object.keys(params)
            .map(key => `${key}=${params[key]}`)
            .join('&');
        const signature = hmac('sha256', bybitResource.apiSecret, query).digest('hex');

        // Make the request to Bybit API
        const response = await fetch(`${endpoint}?${query}&sign=${signature}`, {
            method: 'GET',
        });

        if (!response.ok) {
            throw new Error(`Error fetching orders: ${response.statusText}`);
        }

        const data = await response.json();
        if (!data || data.ret_code !== 0) {
            throw new Error(`Error in API response: ${data.ret_msg}`);
        }

        // Filter orders that are filled and have a value greater than minimumValueUSD
        const filledOrders = data.result.data.filter((order: Order) => {
            const orderValue = order.price * order.qty;
            return order.order_status === 'Filled' && orderValue > minimumValueUSD;
        });

        // Return the result
        return filledOrders;
    }
  id: |-
    synthetic_generic-market-big-deal
  instructions: |-
    Obtain filled orders worth more than 500,000 USD within the last 24h.  in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { sendTransactionalEmail } from "npm:@loopsso/sdk"; // Assuming this is the correct import for the LoopsSo SDK

    type LoopsSo = {
        apiKey: string;
        domain: string;
    }

    export async function main(
        loopsSoResource: LoopsSo,
        recipientEmail: string,
        subject: string,
        message: string
    ) {
        // Configure the LoopsSo SDK with the provided API key and domain
        const loopsSoClient = new sendTransactionalEmail({
            apiKey: loopsSoResource.apiKey,
            domain: loopsSoResource.domain
        });

        // Send the transactional email
        const response = await loopsSoClient.sendEmail({
            to: recipientEmail,
            subject: subject,
            text: message
        });

        // Return the result
        return response;
    }
  good: |-
    import { sendEmail as sendEmailClient } from "npm:@loopsso/sdk"; // Renamed imported method to avoid conflict

    type LoopsSo = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(
        loopsSoResource: LoopsSo,
        to: string,
        from: string,
        subject: string,
        htmlContent: string,
        textContent?: string
    ) {
        // Configure the LoopsSo SDK with the provided credentials
        const loopsSoClient = new sendEmailClient.Client({
            apiKey: loopsSoResource.apiKey,
            apiSecret: loopsSoResource.apiSecret
        });

        // Prepare the email data
        const emailData = {
            to,
            from,
            subject,
            htmlContent,
            textContent: textContent || ''
        };

        // Send the email
        const response = await loopsSoClient.send(emailData);

        // Return the result of the email sending operation
        return response;
    }
  id: |-
    synthetic_send-transactional-email
  instructions: |-
    Send a transactional email in loops so
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    LoopsSo
  resource_type_def: |-
    type LoopsSo = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
        userId: number;
    }

    export async function main(kanbanToolResource: KanbanTool, subtaskId: number) {
        const url = `https://${kanbanToolResource.domain}.kanbantool.com/api/v1/boards/${kanbanToolResource.boardId}/tasks/${subtaskId}/soft_delete.json`;
        const headers = {
            "Authorization": `Basic ${encode(`${kanbanToolResource.apiKey}:x`)}`,
            "Content-Type": "application/json"
        };

        const response = await fetch(url, {
            method: 'PUT',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
    }

    export async function main(kanbanToolResource: KanbanTool, taskId: number, subtaskId: number) {
        const authHeader = `Basic ${encode(`${kanbanToolResource.apiKey}:x`)}`;
        const url = `https://${kanbanToolResource.domain}.kanbantool.com/api/v1/boards/${kanbanToolResource.boardId}/tasks/${taskId}/checklist_items/${subtaskId}.json`;

        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_delete-subtask
  instructions: |-
    Soft deletes a subtask in kanban tool
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    KanbanTool
  resource_type_def: |-
    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Clerk, UserResource } from "npm:@clerk/clerk-sdk-node";

    type ClerkResource = {
        apiKey: string;
    }

    export async function main(clerkResource: ClerkResource, email: string, firstName: string, lastName: string, password: string) {
        const clerk = new Clerk(clerkResource.apiKey);

        const newUser = await clerk.users.createUser({
            emailAddress: email,
            firstName: firstName,
            lastName: lastName,
            password: password
        });

        return newUser;
    }
  good: |-
    // Import necessary libraries
    import { Clerk as ClerkSDK, ClerkBackendAPI } from "npm:@clerk/clerk-sdk-node";

    type Clerk = {
        apiKey: string;
    }

    export async function main(clerkConfig: Clerk, email: string, firstName: string, lastName: string, password: string) {
        // Initialize Clerk with the provided API key
        const clerk = new ClerkSDK({ apiKey: clerkConfig.apiKey });

        // Create a new user with the provided details
        const newUser = await clerk.users.createUser({
            emailAddress: email,
            firstName: firstName,
            lastName: lastName,
            password: password
        });

        // Return the result
        return newUser;
    }
  id: |-
    synthetic_create-user
  instructions: |-
    Creates a new user. Your user management settings determine how you should setup your user model in clerk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clerk
  resource_type_def: |-
    type Clerk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Define the resource type for the loops_so integration
    class loops_so(TypedDict):
        api_key: str
        base_url: str

    def main(loops_so_resource: loops_so, contact_email: str) -> Optional[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for finding a contact
        endpoint = f"{loops_so_resource['base_url']}/contacts/search"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {loops_so_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Set up the search parameters
        search_params = {
            "email": contact_email
        }

        # Make the API request to find the contact
        response = requests.get(endpoint, headers=headers, params=search_params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact details if found
            return response.json()
        else:
            # Return None if the contact was not found or if there was an error
            return None
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the loops_so integration
    class loops_so(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for searching a contact by email address in loops_so
    def main(loops_so_resource: loops_so, email_address: str) -> Optional[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for searching contacts
        search_endpoint = f"{loops_so_resource['base_url']}/contacts/search"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {loops_so_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Set up the search parameters
        search_params = {
            "email": email_address
        }

        # Make the request to the loops_so API
        response = requests.get(search_endpoint, headers=headers, params=search_params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the contact data
            contact_data = response.json()
            return contact_data.get('data')  # Assuming the API returns contact data under a 'data' key
        else:
            # If the response was not successful, return None
            return None

    # The script ends here, with the main function defined and ready to be used.
  id: |-
    synthetic_find-contact
  instructions: |-
    Search for a contact by email address in loops so
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    loops_so
  resource_type_def: |-
    class loops_so(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Headers } from "npm:@deno/headers";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, timeEntryId: string) {
        const headers = new Headers({
            'Authorization': clickupResource.apiKey,
            'Content-Type': 'application/json'
        });

        const response = await fetch(`https://api.clickup.com/api/v2/time_entries/${timeEntryId}/stop`, {
            method: 'POST',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Error stopping time entry: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { ClickUp as ClickUpClient } from "npm:@/clickup";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, timeEntryId: string) {
        const clickUpClient = new ClickUpClient(clickupResource.apiKey);

        const result = await clickUpClient.TimeTracking.stopTimeEntry(timeEntryId);

        return result;
    }
  id: |-
    synthetic_stop-time-entry
  instructions: |-
    Stop time entry in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import the necessary AWS SDK library
    import { S3 } from "npm:@aws-sdk/client-s3";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string; // Optional for temporary credentials
        region: string;
        bucketName: string;
    }

    export async function main(awsResource: Aws, base64Data: string, objectKey: string) {
        // Initialize the AWS S3 client with the provided credentials
        const s3Client = new S3({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
                sessionToken: awsResource.sessionToken,
            },
            region: awsResource.region,
        });

        // Convert the base64-encoded data to a Buffer
        const buffer = Buffer.from(base64Data, 'base64');

        // Upload the buffer to the specified S3 bucket
        const uploadResult = await s3Client.putObject({
            Bucket: awsResource.bucketName,
            Key: objectKey,
            Body: buffer,
        });

        // Return the result of the upload
        return uploadResult;
    }
  good: |-
    import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }

    export async function main(awsResource: Aws, bucketName: string, fileKey: string, base64Content: string, contentType: string) {
        const s3Client = new S3Client({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
                sessionToken: awsResource.sessionToken,
            },
            region: awsResource.region,
        });

        const buffer = Buffer.from(base64Content, 'base64');

        const putObjectParams = {
            Bucket: bucketName,
            Key: fileKey,
            Body: buffer,
            ContentType: contentType,
        };

        const command = new PutObjectCommand(putObjectParams);

        const response = await s3Client.send(command);

        return response;
    }
  id: |-
    synthetic_s3-upload-file
  instructions: |-
    A string of base64-encoded data, or a variable reference to that string in aws
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aws
  resource_type_def: |-
    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type IpinfoIo = {
        accessToken: string;
    }

    export async function main(ipinfoIoResource: IpinfoIo, ipAddress: string) {
        const url = `https://ipinfo.io/${ipAddress}?token=${ipinfoIoResource.accessToken}`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to fetch IP information: ${response.statusText}`);
        }
        const data = await response.json();
        return data;
    }
  good: |-
    import { IPinfoWrapper } from "npm:node-ipinfo";

    type IpinfoIo = {
        accessToken: string;
    }

    export async function main(ipinfoIoResource: IpinfoIo, ipAddress: string) {
        const ipinfo = new IPinfoWrapper(ipinfoIoResource.accessToken);
        const ipDetails = await ipinfo.lookupIp(ipAddress);
        return ipDetails;
    }
  id: |-
    synthetic_lookup-ip
  instructions: |-
    Lookup an IP in ipinfo io
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    IpinfoIo
  resource_type_def: |-
    type IpinfoIo = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Renamed the imported helper_functions to avoid conflict with the TypedDict
    import helper_functions as hf_module

    class helper_functions(TypedDict):
        api_key: str

    def main(helper_functions_resource: helper_functions, html_content: str) -> str:
        slack_markdown = hf_module.convert_html_to_slack_markdown(html_content, helper_functions_resource['api_key'])
        return slack_markdown
  good: |-
    from typing import TypedDict

    # Assuming helper_functions is a module that contains a function that may conflict with our resource type name
    import helper_functions as hf

    class helper_functions(TypedDict):
        api_key: str

    def main(helper_functions_resource: helper_functions, html_content: str) -> str:
        # Assuming there is a function in helper_functions module that converts HTML to Slack markdown
        slack_mrkdwn = hf.convert_html_to_slack_mrkdwn(html_content, helper_functions_resource['api_key'])
        return slack_mrkdwn
  id: |-
    synthetic_convert-html-to-slack-mrkdwn
  instructions: |-
    Converts an HTML string to the Slack mrkdwn format using in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    # Define the resource type for the 'knorish' integration
    class knorish(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for creating a user in the 'knorish' platform
    def main(knorish_resource: knorish, user_email: str, user_first_name: str, user_last_name: str, password: str):
        # Construct the URL for the user creation endpoint
        url = f"{knorish_resource['base_url']}/users"

        # Prepare the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {knorish_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Prepare the payload with the user details
        payload = {
            'email': user_email,
            'first_name': user_first_name,
            'last_name': user_last_name,
            'password': password
        }

        # Make the POST request to create the user
        response = requests.post(url, json=payload, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Knorish API

    class knorish(TypedDict):
        api_key: str
        site_url: str

    def main(knorish_resource: knorish, user_email: str, user_first_name: str, user_last_name: str, password: str):
        headers = {
            'Authorization': f"Bearer {knorish_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'email': user_email,
            'first_name': user_first_name,
            'last_name': user_last_name,
            'password': password
        }
        response = requests.post(f"{knorish_resource['site_url']}/api/v1/users", json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_create-user
  instructions: |-
    Creates a new user on your Knorish site in knorish
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    knorish
  resource_type_def: |-
    class knorish(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
        graphEndpoint: string;
    }

    export async function main(microsoftTeamsResource: MicrosoftTeams, teamId: string) {
        // Initialize the Microsoft Graph client
        const client = Client.init({
            authProvider: async (done) => {
                // Here you would normally perform the OAUTH2 flow to get the access token
                // For this script, we assume that the access token is already included in the resource
                done(null, microsoftTeamsResource.clientSecret); // Replace with actual access token
            }
        });

        // List all channels in a Microsoft Team
        try {
            const result = await client.api(`/teams/${teamId}/channels`).get();
            return result;
        } catch (error) {
            // Handle error if the API call fails
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
        graphEndpoint: string;
    }

    export async function main(microsoftTeamsResource: MicrosoftTeams, teamId: string) {
        const client = Client.init({
            authProvider: async (done) => {
                const body = new URLSearchParams({
                    grant_type: 'client_credentials',
                    client_id: microsoftTeamsResource.clientId,
                    client_secret: microsoftTeamsResource.clientSecret,
                    scope: 'https://graph.microsoft.com/.default'
                });

                const response = await fetch(microsoftTeamsResource.tokenEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: body.toString()
                });

                if (response.ok) {
                    const responseBody = await response.json();
                    done(null, responseBody.access_token);
                } else {
                    done(response.statusText, null);
                }
            }
        });

        try {
            const result = await client.api(`/teams/${teamId}/channels`).get();
            return result;
        } catch (error) {
            throw error;
        }
    }
  id: |-
    synthetic_list-channels
  instructions: |-
    Lists all channels in a Microsoft Team in microsoft teams
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftTeams
  resource_type_def: |-
    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
        graphEndpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { HttpClient } from "npm:@angular/common/http";

    type Noticeable = {
        apiKey: string;
        projectId: string;
    }

    export async function main(noticeableResource: Noticeable, subscriptionId: string): Promise<void> {
        const httpClient = new HttpClient();
        const url = `https://api.noticeable.io/v1/projects/${noticeableResource.projectId}/subscriptions/${subscriptionId}`;

        const headers = {
            'Authorization': `Bearer ${noticeableResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        try {
            await httpClient.delete(url, { headers: headers });
            console.log(`Subscription with ID ${subscriptionId} deleted successfully.`);
        } catch (error) {
            console.error('Failed to delete the subscription:', error);
            throw error;
        }
    }
  good: |-
    type Noticeable = {
        apiKey: string;
        projectId: string;
    }

    export async function main(noticeableResource: Noticeable, emailAddress: string) {
        const apiUrl = `https://api.noticeable.io/v1/projects/${noticeableResource.projectId}/subscriptions`;

        const response = await fetch(apiUrl, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${noticeableResource.apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ email: emailAddress }),
        });

        if (!response.ok) {
            throw new Error(`Failed to delete email subscription: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_delete-email-subscription
  instructions: |-
    Deletes an email subscription, in noticeable
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Noticeable
  resource_type_def: |-
    type Noticeable = {
        apiKey: string;
        projectId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the 'amara' integration
    class amara(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for adding new subtitles
    def main(amara_resource: amara, video_id: str, language_code: str, subtitles: List[str], subtitle_format: str = 'srt'):
        # Import the necessary library for the Amara API
        from amara_api import Video as AmaraVideo  # Rename the imported method to avoid conflict

        # Initialize the Amara API client with the provided API key
        amara_api_client = AmaraVideo(api_key=amara_resource['api_key'])

        # Add new subtitles to the specified video
        result = amara_api_client.add_subtitles(video_id=video_id,
                                                language_code=language_code,
                                                subtitles=subtitles,
                                                format=subtitle_format)

        # Return the result of the operation
        return result
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the 'amara' integration
    class amara(TypedDict):
        api_key: str  # API key for authentication

    # Import any libraries you might need
    import requests

    # Define the main function for adding new subtitles in Amara
    def main(amara_resource: amara, video_id: str, language_code: str, subtitles: List[str], subtitle_format: str = 'srt'):
        # Construct the API endpoint
        api_endpoint = f"https://amara.org/api/videos/{video_id}/languages/{language_code}/subtitles/"

        # Prepare the headers for the request
        headers = {
            'X-api-key': amara_resource['api_key'],
            'Content-Type': 'application/json'
        }

        # Prepare the subtitles data
        subtitles_data = {
            'subtitles': "\n\n".join(subtitles),
            'format': subtitle_format
        }

        # Make the request to add subtitles
        response = requests.post(api_endpoint, json=subtitles_data, headers=headers)

        # Return the response from the API
        return response.json()

    # Example usage:
    # result = main(amara_resource={'api_key': 'your-api-key'}, video_id='video-id', language_code='en', subtitles=['1\n00:00:01,000 --> 00:00:02,000\nHello, world!'])
    # print(result)
  id: |-
    synthetic_add-new-subtitles
  instructions: |-
    Add new subtitles in amara
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    amara
  resource_type_def: |-
    class amara(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type MoreTrees = {
        apiKey: string;
    }

    export async function main(moreTreesResource: MoreTrees, treeType: string, quantity: number, location: string) {
        const response = await fetch('https://api.moretrees.com/plant', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${moreTreesResource.apiKey}`
            },
            body: JSON.stringify({
                treeType: treeType,
                quantity: quantity,
                location: location
            })
        });

        if (!response.ok) {
            throw new Error(`Failed to plant tree: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();
        return result;
    }
  good: |-
    import { MoreTrees } from 'npm:@more-trees/more-trees-sdk';

    type MoreTreesResource = {
        apiKey: string;
    }

    export async function main(moreTreesResource: MoreTreesResource, recipientEmail: string, treeCount: number, message?: string) {
        const moreTrees = new MoreTrees(moreTreesResource.apiKey);

        const plantingOptions = {
            email: recipientEmail,
            treeCount: treeCount,
            message: message,
        };

        const result = await moreTrees.plantTrees(plantingOptions);
        return result;
    }
  id: |-
    synthetic_plant-tree
  instructions: "Plant a tree for self or for others in more trees "
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MoreTrees
  resource_type_def: |-
    type MoreTrees = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode as base64Encode } from "npm:@stablelib/base64";

    type EchtpostPostcards = {
        apiKey: string;
    }

    export async function main(
        echtpostPostcardsResource: EchtpostPostcards,
        recipientName: string,
        recipientAddress: string,
        message: string,
        frontImageBase64: string,
        scheduledDeliveryDate: string // Format: YYYY-MM-DD
    ) {
        const url = 'https://api.echtpost.de/postcard';
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${echtpostPostcardsResource.apiKey}`
        };
        const body = JSON.stringify({
            recipient: {
                name: recipientName,
                address: recipientAddress
            },
            message: message,
            front: {
                image: frontImageBase64,
                encoding: 'base64'
            },
            sendDate: scheduledDeliveryDate
        });

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: body
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Error creating and scheduling postcard:', error);
            throw error;
        }
    }
  good: |-
    import { EchtpostClient } from "npm:@echtpost/client";

    type EchtpostPostcards = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(
        echtpostResource: EchtpostPostcards,
        recipientName: string,
        recipientAddress: string,
        message: string,
        frontImageUrl: string,
        sendDate: Date // ISO string format "YYYY-MM-DD"
    ) {
        const echtpost = new EchtpostClient(echtpostResource.apiKey, echtpostResource.apiUrl);

        const postcard = await echtpost.createPostcard({
            recipient: {
                name: recipientName,
                address: recipientAddress
            },
            message: message,
            frontImage: frontImageUrl,
            sendDate: sendDate
        });

        const scheduledPostcard = await echtpost.schedulePostcard(postcard.id, sendDate);

        return scheduledPostcard;
    }
  id: |-
    synthetic_create-card
  instructions: |-
    This action creates and schedules a postcard for delivery in echtpost postcards
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    EchtpostPostcards
  resource_type_def: |-
    type EchtpostPostcards = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Config, ChartMogul as ChartMogulAPI } from "npm:chartmogul-node";

    type Chartmogul = {
        accountToken: string;
        secretKey: string;
    };

    export async function main(
        chartmogulResource: Chartmogul,
        customerData: {
            dataSourceUuid: string;
            externalId: string;
            name: string;
            email: string;
            country?: string;
            city?: string;
        }
    ) {
        const config = new Config(chartmogulResource.accountToken, chartmogulResource.secretKey);
        try {
            const customer = await ChartMogulAPI.Customer.create(config, {
                data_source_uuid: customerData.dataSourceUuid,
                external_id: customerData.externalId,
                name: customerData.name,
                email: customerData.email,
                country: customerData.country,
                city: customerData.city,
            });
            return customer;
        } catch (error) {
            // Handle error appropriately; rethrow, return null, etc.
            throw error;
        }
    }
  good: |-
    // Import any libraries you need here
    import ChartMogul from 'npm:@chartmogul/chartmogul-node';

    type ChartMogulResource = {
        accountToken: string;
        secretKey: string;
    }

    export async function main(chartMogulResource: ChartMogulResource, dataSourceUuid: string, customerData: {
        external_id: string;
        name: string;
        email: string;
        country?: string;
        city?: string;
    }) {
        // Initialize ChartMogul API with credentials
        ChartMogul.Configuration.setApiKey(chartMogulResource.accountToken);
        ChartMogul.Configuration.setSecretKey(chartMogulResource.secretKey);

        // Create the customer object in ChartMogul
        try {
            const customer = await ChartMogul.Customer.create(dataSourceUuid, customerData);
            return customer;
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error('Error creating customer in ChartMogul:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-customer
  instructions: |-
    Creates a `customer` object in ChartMogul under the specified `data_source` in chartmogul
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Chartmogul
  resource_type_def: |-
    type Chartmogul = {
        accountToken: string;
        secretKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import firebase_admin
    from firebase_admin import credentials, db

    # Define the resource type for the firebase_admin_sdk integration
    class firebase_admin_sdk(TypedDict):
        databaseURL: str
        credential: credentials.Certificate

    # Initialize the Firebase app with the provided credentials
    # This should be done outside the main function to avoid reinitialization issues
    # However, for the purpose of this script, we will assume that initialization is handled elsewhere

    def main(firebase_resource: firebase_admin_sdk, data: Any, path: str) -> str:
        # Ensure the Firebase app is initialized
        if not firebase_admin._apps:
            firebase_admin.initialize_app(firebase_resource['credential'], {
                'databaseURL': firebase_resource['databaseURL']
            })

        # Reference the specified path in the database
        ref = db.reference(path)

        # Set the data at the specified path
        ref.set(data)

        # Return a confirmation message
        return f"Data set at path: {path}"
  good: |-
    from typing import TypedDict, Any
    import firebase_admin
    from firebase_admin import credentials, db

    # Define the resource type for the firebase_admin_sdk integration
    class firebase_admin_sdk(TypedDict):
        databaseURL: str
        credential: credentials.Certificate

    # Initialize the Firebase Admin SDK with the provided resource
    def initialize_firebase_admin_sdk(resource: firebase_admin_sdk):
        if not firebase_admin._apps:
            firebase_admin.initialize_app(resource['credential'], {
                'databaseURL': resource['databaseURL']
            })

    # Main function to create or replace a child object in Firebase Realtime Database
    def main(firebase_resource: firebase_admin_sdk, path: str, data: Any):
        # Initialize Firebase Admin SDK
        initialize_firebase_admin_sdk(firebase_resource)

        # Reference to the specified path in the database
        ref = db.reference(path)

        # Set the data at the specified path, creating or replacing the child object
        ref.set(data)

        # Return a confirmation message
        return f"Data at '{path}' has been updated."

    # Example usage:
    # firebase_resource = firebase_admin_sdk(
    #     databaseURL='https://your-database-url.firebaseio.com/',
    #     credential=credentials.Certificate('path/to/your/serviceAccountKey.json')
    # )
    # result = main(firebase_resource, '/path/to/child', {'key': 'value'})
    # print(result)
  id: |-
    synthetic_create-realtime-db-record
  instructions: |-
    Creates or replaces a child object within your Firebase Realtime Database in firebase admin sdk
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    firebase_admin_sdk
  resource_type_def: |-
    class firebase_admin_sdk(TypedDict):
        databaseURL: str
        credential: credentials.Certificate
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Mailchimp } from "npm:@mailchimp/mailchimp_marketing";

    type MailchimpResource = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: MailchimpResource, campaignId: string) {
        Mailchimp.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        try {
            const response = await Mailchimp.campaigns.get(campaignId);
            return response;
        } catch (error) {
            console.error('Error getting campaign metadata:', error);
            throw error;
        }
    }
  good: |-
    import { Mailchimp as MailchimpAPI } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimp: Mailchimp, campaignId: string) {
        MailchimpAPI.setConfig({
            apiKey: mailchimp.apiKey,
            server: mailchimp.serverPrefix,
        });

        try {
            const campaign = await MailchimpAPI.campaigns.get(campaignId);
            return campaign;
        } catch (error) {
            console.error('Error fetching campaign:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-campaign
  instructions: |-
    Gets metadata of a specific campaign in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str, member_email: str) -> List[str]:
        api_endpoint = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0/lists/{list_id}/members/{member_email}/tags"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        response = requests.get(api_endpoint, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        tags_data = response.json()
        tags = [tag['name'] for tag in tags_data.get('tags', [])]

        return tags
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str) -> List[str]:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        endpoint = f"/lists/{list_id}/segments"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        response = requests.get(f"{base_url}{endpoint}", headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        segments = response.json().get('segments', [])
        tags = [segment['name'] for segment in segments if segment['type'] == 'static']

        return tags
  id: |-
    synthetic_get-list-member-tags
  instructions: |-
    Retrieves a list of all member tags in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str

    # Define the main function for posting a photo to a Facebook group
    def main(facebook_groups_resource: facebook_groups, photo_url: str, message: str = "") -> Any:
        # Construct the API endpoint for posting a photo to a Facebook group
        api_endpoint = f"https://graph.facebook.com/{facebook_groups_resource['group_id']}/photos"

        # Prepare the payload for the POST request
        payload = {
            'url': photo_url,
            'message': message,
            'access_token': facebook_groups_resource['access_token']
        }

        # Make the POST request to the Facebook Graph API
        response = requests.post(api_endpoint, data=payload)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str

    def main(facebook_groups_resource: facebook_groups, photo_path: str, message: str = "") -> Any:
        url = f"https://graph.facebook.com/v14.0/{facebook_groups_resource['group_id']}/photos"
        headers = {
            "Authorization": f"Bearer {facebook_groups_resource['access_token']}"
        }
        data = {
            "message": message
        }
        files = {
            "source": open(photo_path, "rb")
        }
        response = requests.post(url, headers=headers, data=data, files=files)
        return response.json()
  id: |-
    synthetic_post-photo
  instructions: |-
    Post a photo in a group in facebook groups
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    facebook_groups
  resource_type_def: |-
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import aweber_api  # Assuming aweber_api is the library for Aweber integration

    # Rename the imported method if it conflicts with the resource type name
    from aweber_api import add_subscriber as add_subscriber_to_list

    class aweber(TypedDict):
        consumer_key: str
        consumer_secret: str
        access_token: str
        token_secret: str

    def main(aweber_resource: aweber, account_id: str, list_id: str, email: str, name: str = '', tags: list[str] = []):
        # Initialize the AWeber API with the credentials provided
        api = aweber_api.OAuth(consumer_key=aweber_resource['consumer_key'],
                               consumer_secret=aweber_resource['consumer_secret'],
                               access_token=aweber_resource['access_token'],
                               token_secret=aweber_resource['token_secret'])

        # Retrieve the account and list objects
        account = api.get_account(account_id)
        email_list = account.get_list(list_id)

        # Add the subscriber to the list
        subscriber = add_subscriber_to_list(email_list, email=email, name=name, tags=tags)

        # Return the result which is the newly added subscriber
        return subscriber
  good: |-
    from typing import TypedDict, List
    import aweber_api  # Assuming aweber_api is the library for AWeber integration

    class aweber(TypedDict):
        consumer_key: str
        consumer_secret: str
        access_token: str
        access_token_secret: str
        account_id: str
        list_id: str

    def main(aweber_resource: aweber, subscribers: List[dict]):
        # Initialize the AWeber API with the credentials provided in the resource
        api = aweber_api.OAuth(consumer_key=aweber_resource['consumer_key'],
                               consumer_secret=aweber_resource['consumer_secret'],
                               access_token=aweber_resource['access_token'],
                               access_token_secret=aweber_resource['access_token_secret'])

        # Retrieve the account and list objects
        account = api.get_account(aweber_resource['account_id'])
        list_obj = account.lists.find_by_id(aweber_resource['list_id'])

        # Add subscribers to the list
        added_subscribers = []
        for subscriber in subscribers:
            added_subscriber = list_obj.subscribers.create(subscriber)
            added_subscribers.append(added_subscriber)

        # Return the list of added subscribers
        return added_subscribers
  id: |-
    synthetic_add-subscriber
  instructions: |-
    Add subscribers to the specified account and list. in aweber
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aweber
  resource_type_def: |-
    class aweber(TypedDict):
        consumer_key: str
        consumer_secret: str
        access_token: str
        token_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { S3 } from "npm:@aws-sdk/client-s3";

    type DigitaloceanSpaces = {
        accessKeyId: string;
        secretAccessKey: string;
        endpoint: string;
        bucket: string;
        region: string;
    }

    export async function main(digitaloceanSpacesResource: DigitaloceanSpaces, base64Data: string, filename: string) {
        const s3Client = new S3({
            credentials: {
                accessKeyId: digitaloceanSpacesResource.accessKeyId,
                secretAccessKey: digitaloceanSpacesResource.secretAccessKey,
            },
            endpoint: digitaloceanSpacesResource.endpoint,
            region: digitaloceanSpacesResource.region,
        });

        const buffer = Buffer.from(base64Data, 'base64');

        const uploadParams = {
            Bucket: digitaloceanSpacesResource.bucket,
            Key: filename,
            Body: buffer,
            ACL: 'public-read', // or another ACL according to your requirements
        };

        try {
            const data = await s3Client.putObject(uploadParams);
            return data;
        } catch (err) {
            throw new Error(`Error uploading file: ${err.message}`);
        }
    }
  good: |-
    import { S3 } from "npm:@aws-sdk/client-s3";

    type DigitaloceanSpaces = {
        accessKeyId: string;
        secretAccessKey: string;
        endpoint: string;
        bucket: string;
        region: string;
    }

    export async function main(
        digitaloceanSpacesResource: DigitaloceanSpaces,
        fileBase64: string,
        fileName: string,
        contentType: string
    ) {
        const s3Client = new S3({
            credentials: {
                accessKeyId: digitaloceanSpacesResource.accessKeyId,
                secretAccessKey: digitaloceanSpacesResource.secretAccessKey,
            },
            endpoint: digitaloceanSpacesResource.endpoint,
            region: digitaloceanSpacesResource.region,
            forcePathStyle: true, // needed for DigitalOcean Spaces
        });

        const buffer = Buffer.from(fileBase64, 'base64');

        const uploadParams = {
            Bucket: digitaloceanSpacesResource.bucket,
            Key: fileName,
            Body: buffer,
            ContentType: contentType,
        };

        try {
            const data = await s3Client.putObject(uploadParams);
            return data;
        } catch (error) {
            console.error("Error uploading file: ", error);
            throw error;
        }
    }
  id: |-
    synthetic_upload-file-base64
  instructions: |-
    Accepts a base64-encoded string and a filename, then uploads as a file to DigitalOcean Spaces. in digitalocean spaces
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DigitaloceanSpaces
  resource_type_def: |-
    type DigitaloceanSpaces = {
        accessKeyId: string;
        secretAccessKey: string;
        endpoint: string;
        bucket: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is used for HTTP requests

    class dreamstudio(TypedDict):
        api_key: str

    def main(dreamstudio_resource: dreamstudio, prompt: str, num_images: int = 1) -> Any:
        url = "https://api.dreamstudio.ai/generate"
        headers = {
            "Authorization": f"Bearer {dreamstudio_resource['api_key']}"
        }
        data = {
            "prompt": prompt,
            "num_images": num_images
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()

    # Example usage:
    # result = main(dreamstudio_resource={'api_key': 'your_api_key'}, prompt='A futuristic city skyline at sunset')
    # print(result)
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the dreamstudio integration
    class dreamstudio(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for generating an image with dreamstudio
    def main(dreamstudio_resource: dreamstudio, prompt: str, num_images: int = 1, width: int = 512, height: int = 512) -> Any:
        import requests  # Import requests or any other library if needed

        # Dreamstudio API endpoint for image generation
        api_endpoint = "https://api.dreamstudio.ai/generate"

        # Prepare headers with the API key
        headers = {
            "Authorization": f"Bearer {dreamstudio_resource['api_key']}"
        }

        # Prepare the payload with the prompt and other parameters
        payload = {
            "prompt": prompt,
            "num_images": num_images,
            "width": width,
            "height": height
        }

        # Make the request to the Dreamstudio API
        response = requests.post(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response containing the generated images
            return response.json()
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {"error": response.text, "status_code": response.status_code}

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_generate-image
  instructions: |-
    Generate a new image from a text prompt in dreamstudio
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dreamstudio
  resource_type_def: |-
    class dreamstudio(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bannerbear as BannerbearAPI } from 'npm:@bannerbear/api';

    type Bannerbear = {
        apiKey: string;
    }

    export async function main(bannerbearResource: Bannerbear, collectionName: string) {
        const bb = new BannerbearAPI(bannerbearResource.apiKey);

        const collection = await bb.createCollection({ name: collectionName });

        return collection;
    }
  good: |-
    import { Bannerbear } from 'npm:@bannerbear/api';

    type Bannerbear = {
        apiKey: string;
    }

    export async function main(
        bannerbearResource: Bannerbear,
        templateId: string,
        modifications: Array<{ name: string; text: string; }>,
        webhookUrl?: string
    ) {
        const bb = new Bannerbear(bannerbearResource.apiKey);

        const images = [];
        for (const modification of modifications) {
            const image = await bb.createImage(templateId, {
                modifications: [
                    {
                        name: modification.name,
                        text: modification.text
                    }
                ],
                webhook_url: webhookUrl
            });
            images.push(image);
        }

        return images;
    }
  id: |-
    synthetic_create-collection
  instructions: |-
    Generates multiple Images based on a Template Set. in bannerbear
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bannerbear
  resource_type_def: |-
    type Bannerbear = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    # Define the resource type for the ActiveCampaign integration
    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign, contact_email: str, tag_id: int) -> dict:
        # Construct the endpoint URL for tagging a contact
        endpoint = f"{activecampaign_resource['api_url'].rstrip('/')}/api/3/contactTags"

        # Prepare the payload for the POST request to tag the contact
        payload = {
            "contactTag": {
                "contact": contact_email,
                "tag": tag_id
            }
        }

        # Prepare the headers for the POST request
        headers = {
            "Api-Token": activecampaign_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Make the POST request to tag the contact
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return {"status": "success", "data": response.json()}
        else:
            return {"status": "error", "message": response.text}

    # Note: The function does not call itself, it's meant to be called with the appropriate parameters.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign, contact_email: str, tag_name: str) -> dict:
        # Find the contact ID based on the email
        contact_search_url = f"{activecampaign_resource['api_url']}/api/3/contacts"
        search_params = {'email': contact_email}
        headers = {'Api-Token': activecampaign_resource['api_key']}

        contact_response = requests.get(contact_search_url, headers=headers, params=search_params)
        contact_response_data = contact_response.json()
        contacts = contact_response_data.get('contacts', [])

        if not contacts:
            return {'error': 'Contact not found'}

        contact_id = contacts[0]['id']

        # Find or create the tag based on the tag name
        tag_search_url = f"{activecampaign_resource['api_url']}/api/3/tags"
        tag_search_params = {'search': tag_name}

        tag_response = requests.get(tag_search_url, headers=headers, params=tag_search_params)
        tag_response_data = tag_response.json()
        tags = tag_response_data.get('tags', [])

        if tags:
            tag_id = tags[0]['id']
        else:
            # Create the tag if it doesn't exist
            tag_create_data = {'tag': {'tagType': 'contact', 'tag': tag_name}}
            tag_create_response = requests.post(tag_search_url, headers=headers, json=tag_create_data)
            tag_create_response_data = tag_create_response.json()
            tag_id = tag_create_response_data['tag']['id']

        # Tag the contact
        tag_link_url = f"{activecampaign_resource['api_url']}/api/3/contactTags"
        tag_link_data = {
            'contactTag': {
                'contact': contact_id,
                'tag': tag_id
            }
        }

        tag_link_response = requests.post(tag_link_url, headers=headers, json=tag_link_data)
        tag_link_response_data = tag_link_response.json()

        return tag_link_response_data
  id: |-
    synthetic_tag-contact
  instructions: |-
    Tags a contact. See the docs. in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import boto3
    from botocore.client import Config

    # Define the resource type for the digitalocean_spaces integration
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str

    def main(digitalocean_spaces_resource: digitalocean_spaces, bucket_name: str) -> List[str]:
        # Initialize a session using DigitalOcean Spaces credentials
        session = boto3.session.Session()
        client = session.client('s3',
                                region_name=digitalocean_spaces_resource['region_name'],
                                endpoint_url=digitalocean_spaces_resource['endpoint_url'],
                                aws_access_key_id=digitalocean_spaces_resource['access_key_id'],
                                aws_secret_access_key=digitalocean_spaces_resource['secret_access_key'],
                                config=Config(signature_version='s3v4'))

        # List objects within the specified bucket
        response = client.list_objects(Bucket=bucket_name)

        # Extract the file names from the response
        files = [obj['Key'] for obj in response.get('Contents', [])]

        return files
  good: |-
    from typing import TypedDict, List
    import boto3
    from botocore.client import Config

    # Define the resource type for the digitalocean_spaces integration
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str

    def main(digitalocean_spaces_resource: digitalocean_spaces, bucket_name: str) -> List[str]:
        # Initialize a session using DigitalOcean Spaces credentials
        session = boto3.session.Session()
        client = session.client('s3',
                                region_name=digitalocean_spaces_resource['region_name'],
                                endpoint_url=digitalocean_spaces_resource['endpoint_url'],
                                aws_access_key_id=digitalocean_spaces_resource['access_key_id'],
                                aws_secret_access_key=digitalocean_spaces_resource['secret_access_key'],
                                config=Config(signature_version='s3v4'))

        # List objects within the specified bucket
        response = client.list_objects(Bucket=bucket_name)

        # Extract the file names from the response
        file_names = [obj['Key'] for obj in response.get('Contents', [])]

        return file_names
  id: |-
    synthetic_list-files
  instructions: |-
    List files in a bucket. in digitalocean spaces
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    digitalocean_spaces
  resource_type_def: |-
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type CodeqNaturalLanguageProcessingApi = {
        apiKey: string;
    }

    export async function main(
        nlpResource: CodeqNaturalLanguageProcessingApi,
        text1: string,
        text2: string
    ) {
        const requestOptions = {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${nlpResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                documents: [text1, text2]
            })
        };

        const response = await fetch('https://api.codeq.com/v1/compare', requestOptions);
        const result = await response.json();

        return result;
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type CodeqNaturalLanguageProcessingApi = {
        apiKey: string;
        endpoint: string;
    }

    export async function main(
        codeqNLPResource: CodeqNaturalLanguageProcessingApi,
        text1: string,
        text2: string
    ) {
        // Prepare the request headers
        const headers = new Headers();
        headers.set('Authorization', `Basic ${encode(codeqNLPResource.apiKey)}`);
        headers.set('Content-Type', 'application/json');

        // Prepare the request body
        const body = JSON.stringify({
            text1: text1,
            text2: text2
        });

        // Send the request to the Codeq NLP API
        const response = await fetch(`${codeqNLPResource.endpoint}/similarity`, {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse the response body to JSON
        const result = await response.json();

        // Return the similarity score
        return result;
    }
  id: |-
    synthetic_check-similarity
  instructions: |-
    Receives two texts and returns a JSON object containing the text similarity score in codeq natural language processing api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CodeqNaturalLanguageProcessingApi
  resource_type_def: |-
    type CodeqNaturalLanguageProcessingApi = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(
        microsoftTeamsResource: MicrosoftTeams,
        teamId: string,
        channelName: string,
        channelDescription: string,
        authEndpoint: string,
        tokenEndpoint: string,
        graphEndpoint: string
    ) {
        // Initialize Microsoft Graph client
        const client = Client.init({
            authProvider: async (done) => {
                // Implement authentication logic here
                // For example, you might need to fetch an access token using the provided credentials
                // and then call the done callback with the token like this:
                // done(null, accessToken);
            }
        });

        // Create the channel
        const channel = {
            displayName: channelName,
            description: channelDescription,
            membershipType: "standard", // or "private", depending on the requirement
        };

        try {
            const result = await client.api(`${graphEndpoint}/teams/${teamId}/channels`)
                .version('v1.0')
                .post(channel);

            return result;
        } catch (error) {
            // Handle error (e.g., log it, throw it, etc.)
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { HttpClient } from "npm:@microsoft/teams-js";

    type MicrosoftTeams = {
        tenantId: string;
        groupId: string;
        accessToken: string;
    }

    export async function main(microsoftTeamsResource: MicrosoftTeams, channelName: string, channelDescription?: string) {
        const httpClient = new HttpClient();
        const createChannelUrl = `https://graph.microsoft.com/v1.0/teams/${microsoftTeamsResource.groupId}/channels`;

        const channelData = {
            displayName: channelName,
            description: channelDescription || "",
            membershipType: "standard", // Assuming a standard channel is to be created
        };

        const requestOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${microsoftTeamsResource.accessToken}`
            },
            body: JSON.stringify(channelData)
        };

        try {
            const response = await fetch(createChannelUrl, requestOptions);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            return result;
        } catch (error) {
            console.error("Failed to create a new channel in Microsoft Teams:", error);
            throw error;
        }
    }
  id: |-
    synthetic_create-channel
  instructions: |-
    Create a new channel in Microsoft Teams in microsoft teams
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftTeams
  resource_type_def: |-
    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Etsy API

    class etsy(TypedDict):
        api_key: str
        access_token: str
        shop_id: str

    def main(etsy_resource: etsy, listing_id: int) -> dict:
        url = f"https://openapi.etsy.com/v2/shops/{etsy_resource['shop_id']}/listings/{listing_id}"
        headers = {
            "x-api-key": etsy_resource['api_key'],
            "Authorization": f"Bearer {etsy_resource['access_token']}"
        }
        response = requests.delete(url, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is used for HTTP requests

    # Define the Etsy resource type with properties needed for authentication/configuration
    class etsy(TypedDict):
        api_key: str
        shop_id: str
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function with the Etsy resource and additional parameters
    def main(etsy_resource: etsy, listing_id: int, state: str, is_available: bool = False, seller_flags: list = None):
        # Define the endpoint URL for deleting a ShopListing
        endpoint_url = f"https://openapi.etsy.com/v3/application/shops/{etsy_resource['shop_id']}/listings/{listing_id}"

        # Define the headers for authentication
        headers = {
            "x-api-key": etsy_resource['api_key'],
            "Authorization": f"Bearer {etsy_resource['access_token']}"
        }

        # Check if the state is valid for deletion and if the additional conditions are met
        valid_states = ['SOLD_OUT', 'DRAFT', 'EXPIRED', 'INACTIVE', 'ACTIVE']
        valid_seller_flags = ['SUPRESSED', 'VACATION', 'CUSTOM_SHOPS', 'SELL_ON_FACEBOOK']

        if state not in valid_states or (state == 'ACTIVE' and not (is_available or (seller_flags and any(flag in valid_seller_flags for flag in seller_flags)))):
            raise ValueError("The ShopListing cannot be deleted due to its state or seller flags.")

        # Make the DELETE request to the Etsy API
        response = requests.delete(endpoint_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return {"success": True, "message": "ShopListing deleted successfully."}
        else:
            return {"success": False, "message": "Failed to delete ShopListing.", "error": response.json()}

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_delete-listing
  instructions: |-
    Open API V3 endpoint to delete a ShopListing. A ShopListing can be deleted only if the state is one of the following: `SOLD_OUT`, `DRAFT`, `EXPIRED`, `INACTIVE`, `ACTIVE` and `is_available` or `ACTIVE` and has seller flags: `SUPRESSED` (frozen), `VACATION`, `CUSTOM_SHOPS` (pattern), `SELL_ON_FACEBOOK` in etsy
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    etsy
  resource_type_def: |-
    class etsy(TypedDict):
        api_key: str
        access_token: str
        shop_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Listmonk = {
        host: string;
        apiKey: string;
    }

    export async function main(listmonkResource: Listmonk, listName: string, listDescription: string) {
        const url = `${listmonkResource.host}/api/lists`;
        const authHeader = `Basic ${encode(listmonkResource.apiKey + ":")}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader,
            },
            body: JSON.stringify({
                name: listName,
                description: listDescription,
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:base-64";

    type Listmonk = {
        adminUsername: string;
        adminPassword: string;
        apiUrl: string;
    }

    export async function main(listmonkResource: Listmonk, listName: string, listDescription: string) {
        const authHeader = `Basic ${encode(`${listmonkResource.adminUsername}:${listmonkResource.adminPassword}`)}`;
        const response = await fetch(`${listmonkResource.apiUrl}/api/lists`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader,
            },
            body: JSON.stringify({
                name: listName,
                description: listDescription,
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-list
  instructions: |-
    Creates a new list in Listmonk in listmonk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Listmonk
  resource_type_def: |-
    type Listmonk = {
        host: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Page } from "npm:@types/facebook-js-sdk";

    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }

    export async function main(facebookPagesResource: FacebookPages, postId: string) {
        const url = `https://graph.facebook.com/v14.0/${facebookPagesResource.pageId}_${postId}/comments?access_token=${facebookPagesResource.accessToken}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { Page } from "npm:@types/facebook-js-sdk";

    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }

    export async function main(facebookPagesResource: FacebookPages, postId: string) {
        const url = `https://graph.facebook.com/v14.0/${facebookPagesResource.pageId}_${postId}/comments?access_token=${facebookPagesResource.accessToken}`;

        const response = await fetch(url);
        const data = await response.json();

        if (!response.ok) {
            throw new Error(`Error fetching comments: ${data.error ? data.error.message : response.status}`);
        }

        return data.data; // Assuming the comments are in the 'data' field of the response
    }
  id: |-
    synthetic_list-comments
  instructions: |-
    Retrieves a list of comments on a post on a Facebook Page in facebook pages
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FacebookPages
  resource_type_def: |-
    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class discord_webhook(TypedDict):
        webhook_url: str

    def main(discord_webhook_resource: discord_webhook, message: str):
        webhook_url = discord_webhook_resource['webhook_url']
        payload = {
            "content": message
        }
        response = requests.post(webhook_url, json=payload)
        return response.status_code, response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to send the message

    # Define the resource type for the discord_webhook integration
    class discord_webhook(TypedDict):
        webhook_url: str

    def main(discord_webhook_resource: discord_webhook, message: str) -> requests.Response:
        # Send a message to the Discord webhook
        payload = {
            "content": message
        }
        response = requests.post(discord_webhook_resource['webhook_url'], json=payload)
        return response
  id: |-
    synthetic_send-message
  instructions: |-
    Send a simple message to a Discord channel in discord webhook
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    discord_webhook
  resource_type_def: |-
    class discord_webhook(TypedDict):
        webhook_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Meistertask = {
        apiKey: string;
    }

    export async function main(meistertaskResource: Meistertask, taskId: string) {
        const authHeader = `Basic ${encode(meistertaskResource.apiKey)}`;
        const response = await fetch(`https://api.meistertask.com/tasks/${taskId}`, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching task: ${response.statusText}`);
        }

        const taskInfo = await response.json();
        return taskInfo;
    }
  good: |-
    import { Meistertask as MeistertaskType } from "npm:@bitbucket/types-integrations.meistertask";

    type Meistertask = {
        apiKey: string;
    }

    export async function main(meistertask: Meistertask, taskId: string) {
        const headers = {
            'Authorization': `Bearer ${meistertask.apiKey}`,
            'Content-Type': 'application/json'
        };

        const url = `https://www.meistertask.com/api/tasks/${taskId}`;

        const response = await fetch(url, { headers: headers });

        if (!response.ok) {
            throw new Error(`Error fetching task: ${response.status} ${response.statusText}`);
        }

        const taskDetails = await response.json();

        return taskDetails;
    }
  id: |-
    synthetic_get-task
  instructions: |-
    Retrieves information about a task in meistertask
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Meistertask
  resource_type_def: |-
    type Meistertask = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(amazonSesResource: AmazonSes, templateName: string) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        try {
            const { Template } = await ses.getTemplate({ TemplateName: templateName });
            return Template;
        } catch (error) {
            // Handle error appropriately; rethrow, return a default value, etc.
            throw error;
        }
    }
  good: |-
    import { SESClient, GetTemplateCommand } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(amazonSesResource: AmazonSes, templateName: string) {
        const sesClient = new SESClient({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const getTemplateCommand = new GetTemplateCommand({ TemplateName: templateName });

        try {
            const response = await sesClient.send(getTemplateCommand);
            return response.Template;
        } catch (error) {
            // Handle error appropriately
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_get-email-template
  instructions: |-
    Get an email template in amazon ses
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AmazonSes
  resource_type_def: |-
    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Onenote = {
        accessToken: string;
    }

    export async function main(onenoteResource: Onenote, notebookName: string) {
        // Initialize the Microsoft Graph client with the provided access token
        const client = Client.init({
            authProvider: (done) => {
                done(null, onenoteResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Create a new notebook with the specified name
        const notebook = await client.api('/me/onenote/notebooks')
            .post({ displayName: notebookName });

        // Return the created notebook object
        return notebook;
    }
  good: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Onenote = {
        accessToken: string;
    }

    export async function main(onenoteResource: Onenote, notebookName: string) {
        const createNotebookUrl = 'https://graph.microsoft.com/v1.0/me/onenote/notebooks';
        const requestBody = JSON.stringify({
            displayName: notebookName
        });

        const response = await fetch(createNotebookUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${onenoteResource.accessToken}`,
                'Content-Type': 'application/json',
                'Content-Length': requestBody.length.toString()
            },
            body: requestBody
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-notebook
  instructions: |-
    Creates a notebook in onenote
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Onenote
  resource_type_def: |-
    type Onenote = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the hostaway integration
    class hostaway(TypedDict):
        api_key: str
        account_id: str

    # Define the main function with the resource type and additional parameters
    def main(hostaway_resource: hostaway, task_id: int, task_data: dict) -> Any:
        # Hostaway API endpoint to update a task
        endpoint = f"https://api.hostaway.com/tasks/{task_id}"

        # Headers for authentication
        headers = {
            "X-Hostaway-APIKey": hostaway_resource['api_key'],
            "X-Hostaway-AccountId": hostaway_resource['account_id']
        }

        # Make the request to update the task
        response = requests.put(endpoint, headers=headers, json=task_data)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'hostaway' integration
    class hostaway(TypedDict):
        api_key: str
        secret_key: str

    # Define the main function for the 'hostaway' integration script
    def main(hostaway_resource: hostaway, task_id: int, status: str, priority: str):
        # Assuming that the 'hostaway' integration provides an API client library
        # If not, you would use requests or another HTTP library to make API calls
        from hostaway_api_client import TaskApi, ApiException as HostawayApiException

        # Initialize the API client with the credentials from the resource
        api_client = TaskApi(api_key=hostaway_resource['api_key'], secret_key=hostaway_resource['secret_key'])

        # Prepare the data for updating the task
        update_data = {
            'status': status,
            'priority': priority
        }

        try:
            # Call the API to update the task with the given task_id and update_data
            response = api_client.update_task(task_id, update_data)
            return response
        except HostawayApiException as e:
            # Handle the exception if the API call fails
            print(f"An error occurred when updating the task: {e}")
            return None
  id: |-
    synthetic_update-task
  instructions: |-
    Updates an existing task in Hostaway in hostaway
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hostaway
  resource_type_def: |-
    class hostaway(TypedDict):
        api_key: str
        secret_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    from pymongo import MongoClient  # Assuming pymongo is the MongoDB library to be used

    class mongodb(TypedDict):
        host: str
        port: int
        username: str
        password: str
        authSource: str  # The database to authenticate against
        # Include any other properties necessary for MongoDB authentication

    def main(mongodb_resource: mongodb, database_name: str, collection_name: str, document_data: dict) -> Any:
        client = MongoClient(
            host=mongodb_resource['host'],
            port=mongodb_resource['port'],
            username=mongodb_resource['username'],
            password=mongodb_resource['password'],
            authSource=mongodb_resource['authSource']
        )

        db = client[database_name]
        collection = db[collection_name]

        result = collection.insert_one(document_data)

        # Close the connection
        client.close()

        return result.inserted_id
  good: |-
    from typing import TypedDict
    from pymongo import MongoClient
    from pymongo.collection import Collection

    class mongodb(TypedDict):
        uri: str
        database_name: str

    def main(mongodb_resource: mongodb, collection_name: str, document_data: dict) -> dict:
        client = MongoClient(mongodb_resource['uri'])
        database = client[mongodb_resource['database_name']]
        collection: Collection = database[collection_name]

        result = collection.insert_one(document_data)

        return {'inserted_id': result.inserted_id}
  id: |-
    synthetic_create-new-document
  instructions: |-
    Create a new document in a collection of your choice in mongodb
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mongodb
  resource_type_def: |-
    class mongodb(TypedDict):
        host: str
        port: int
        username: str
        password: str
        authSource: str  # The database to authenticate against
        # Include any other properties necessary for MongoDB authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Noco as NocoClient } from "npm:@nocodb/sdk"; // Importing NocoDB SDK from npm and renaming the imported method to avoid conflict

    // Define the Nocodb resource type with properties needed for authentication/configuration
    type Nocodb = {
        apiUrl: string; // The base URL of the NocoDB API
        apiKey: string; // The API key for authenticating with the NocoDB API
    }

    // The main function to get a record from a NocoDB table by row number
    export async function main(nocodb: Nocodb, tableName: string, rowNumber: number) {
        // Initialize the NocoDB client with the provided API URL and API key
        const noco = new NocoClient(nocodb.apiUrl, nocodb.apiKey);

        // Construct the endpoint URL for the specific table and row
        const endpoint = `/api/v1/db/data/${encodeURIComponent(tableName)}/${rowNumber}`;

        // Perform the GET request to retrieve the record
        const response = await fetch(nocodb.apiUrl + endpoint, {
            method: 'GET',
            headers: {
                'xc-auth': nocodb.apiKey,
                'Content-Type': 'application/json'
            }
        });

        // Check if the response is successful
        if (!response.ok) {
            throw new Error(`Failed to get record: ${response.status} ${response.statusText}`);
        }

        // Parse the response body as JSON
        const record = await response.json();

        // Return the retrieved record
        return record;
    }
  good: |-
    // Importing necessary libraries
    import { Noco } from "npm:@nocodb/sdk";

    type Nocodb = {
        apiKey: string,
        baseUrl: string,
        tableName: string,
        projectId: string
    }

    export async function main(nocodbResource: Nocodb, rowId: string) {
        // Initialize NocoDB client
        const noco = new Noco(nocodbResource.baseUrl, nocodbResource.apiKey);

        // Fetch the row by rowId from the specified table
        const response = await noco.table(nocodbResource.projectId, nocodbResource.tableName).row(rowId).get();

        // Return the result
        return response;
    }
  id: |-
    synthetic_get-record
  instructions: |-
    This action gets a row by row Id in nocodb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nocodb
  resource_type_def: |-
    type Nocodb = {
        apiUrl: string; // The base URL of the NocoDB API
        apiKey: string; // The API key for authenticating with the NocoDB API
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type JudgeMe = {
        apiKey: string;
        token: string;
    }

    export async function main(judgeMeResource: JudgeMe, shopDomain: string, productId: string, reviewBody: string, reviewerName: string, reviewerEmail: string, rating: number) {
        const url = `https://judge.me/api/v1/reviews`;

        const reviewData = {
            shop_domain: shopDomain,
            product_id: productId,
            body: reviewBody,
            rating: rating,
            reviewer_name: reviewerName,
            reviewer_email: reviewerEmail,
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${encode(`${judgeMeResource.apiKey}:${judgeMeResource.token}`)}`
            },
            body: JSON.stringify(reviewData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    type JudgeMeResource = {
        apiKey: string,
        token: string
    }

    export async function main(judgeMeResource: JudgeMeResource, reviewId: number, replyContent: string) {
        const url = `https://judge.me/api/v1/reviews/${reviewId}/public_reply`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${judgeMeResource.token}`
            },
            body: JSON.stringify({
                shop_domain: 'your-shop-domain.myshopify.com',
                reply: replyContent
            })
        });

        if (!response.ok) {
            throw new Error(`Error posting public reply: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_reply
  instructions: |-
    Create a public reply for a review on behalf of the shop. Public replies are shown publicly on the widgets in judge me
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    JudgeMe
  resource_type_def: |-
    type JudgeMe = {
        apiKey: string;
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { hmac } from "npm:crypto";

    type Bingx = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(bingxResource: Bingx, symbol: string, period: number, size: number) {
        const apiPath = '/openapi/quote/v1/kline';
        const baseUrl = 'https://api.bingx.com';
        const timestamp = Date.now();
        const queryString = `symbol=${symbol}&period=${period}&size=${size}&timestamp=${timestamp}`;
        const signature = hmac('sha256', bingxResource.apiSecret, queryString).digest('hex');

        const url = `${baseUrl}${apiPath}?${queryString}&signature=${signature}`;

        const headers = {
            'X-BX-APIKEY': bingxResource.apiKey,
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers,
        });

        const data = await response.json();

        return data;
    }
  good: |-
    import { BingX as BingXClient } from 'npm:bingx'; // Renamed the imported BingX to avoid conflict

    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties required for BingX authentication
    }

    export async function main(bingx: Bingx, symbol: string, period: string, size: number) {
        // Initialize the BingX client with the provided credentials
        const bingxClient = new BingXClient(bingx.apiKey, bingx.secretKey);

        // Fetch the latest Kline data for the given symbol, period, and size
        const klineData = await bingxClient.getKline(symbol, period, size);

        // Return the result
        return klineData;
    }
  id: |-
    synthetic_market-get-kline
  instructions: |-
    Get K-Line Data. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties required for BingX authentication
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is used for HTTP calls

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_config: activecampaign, limit: int = 20) -> List[dict]:
        endpoint = f"{activecampaign_config['api_url']}/api/3/campaigns"
        headers = {
            "Api-Token": activecampaign_config['api_key']
        }
        params = {
            "limit": limit
        }
        response = requests.get(endpoint, headers=headers, params=params)
        response.raise_for_status()  # This will raise an error if the request fails
        return response.json().get('campaigns', [])
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    # Define the resource type for the activecampaign integration
    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    # Define the main function for listing campaigns in ActiveCampaign
    def main(activecampaign_resource: activecampaign, status: str = 'active') -> List[Dict]:
        # Construct the API endpoint for listing campaigns
        endpoint = f"{activecampaign_resource['api_url'].rstrip('/')}/api/3/campaigns"
        headers = {
            'Api-Token': activecampaign_resource['api_key']
        }
        params = {
            'status': status
        }

        # Make the HTTP GET request to the ActiveCampaign API
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the campaigns
            campaigns = response.json().get('campaigns', [])
            return campaigns
        else:
            # Handle error cases (e.g., log the error, raise an exception, etc.)
            response.raise_for_status()

    # Example usage (do not include this in the script):
    # campaigns = main(activecampaign_resource={'api_url': 'https://youraccount.api-us1.com', 'api_key': 'YOUR_API_KEY'})
    # print(campaigns)
  id: |-
    synthetic_list-campaigns
  instructions: |-
    List Campaigns. See the docs. in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the google_photos integration
    class google_photos(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function for adding items to an album
    def main(google_photos_resource: google_photos, album_id: str, photo_urls: List[str]) -> dict:
        import requests  # Import requests or any other library if needed

        # Endpoint for adding items to an album in Google Photos
        add_items_endpoint = "https://photoslibrary.googleapis.com/v1/albums/{}/batchAddMediaItems".format(album_id)

        # Prepare headers with the authorization token
        headers = {
            "Authorization": "Bearer {}".format(google_photos_resource['access_token']),
            "Content-type": "application/json"
        }

        # Prepare the request body with the photo URLs
        body = {
            "mediaItemIds": photo_urls  # Assuming photo_urls are the IDs of the media items to be added
        }

        # Make the POST request to add items to the album
        response = requests.post(add_items_endpoint, json=body, headers=headers)

        # Return the response from the Google Photos API
        return response.json()
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the google_photos integration
    class google_photos(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function for adding items to an album in Google Photos
    def main(google_photos_resource: google_photos, album_id: str, item_ids: List[str]) -> dict:
        import requests  # Import requests or any other library if needed

        # Endpoint for adding items to an album in Google Photos
        add_items_url = f"https://photoslibrary.googleapis.com/v1/albums/{album_id}:batchAddMediaItems"

        # Prepare the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {google_photos_resource['access_token']}",
            "Content-type": "application/json"
        }

        # Prepare the body of the request with the item IDs
        body = {
            "mediaItemIds": item_ids
        }

        # Make the POST request to add items to the album
        response = requests.post(add_items_url, json=body, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return {"success": True, "message": "Items added to album successfully."}
        else:
            return {"success": False, "message": "Failed to add items to album.", "error": response.json()}

    # Note: The function does not call itself, it's meant to be used by the user with the appropriate parameters.
  id: |-
    synthetic_add-items-to-album
  instructions: |-
    Adds selected items to the selected album in google photos
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_photos
  resource_type_def: |-
    class google_photos(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict

    # Define the resource type for the 'missive' integration
    class missive(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function to list all contacts in Missive
    def main(missive_resource: missive) -> List[Dict]:
        import requests  # Import requests or any other library if needed

        # Base URL for Missive API
        base_url = "https://missiveapp.com/api"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {missive_resource['api_key']}"
        }

        # Endpoint for listing contacts
        contacts_endpoint = f"{base_url}/contacts"

        # Make the API request to list contacts
        response = requests.get(contacts_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of contacts
            return response.json()
        else:
            # Handle errors (you could raise an exception or return an empty list)
            return []

    # The script ends here, with the definition of the main function.
  good: |-
    from typing import TypedDict, List, Dict

    # Define the resource type for the 'missive' integration
    class missive(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for listing contacts
    def main(missive_resource: missive, page: int = 1, per_page: int = 20) -> List[Dict]:
        import requests  # Import requests or any other library if needed

        # Base URL for Missive API
        base_url = "https://missiveapp.com/api"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {missive_resource['api_key']}"
        }

        # Prepare the parameters for pagination
        params = {
            "page": page,
            "per_page": per_page
        }

        # Make the request to the Missive API to list contacts
        response = requests.get(f"{base_url}/contacts", headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of contacts
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an empty list)
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_list-contacts
  instructions: |-
    List all contacts in missive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    missive
  resource_type_def: |-
    class missive(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Realtime as AblyRealtime } from "npm:ably";

    type Ably = {
        apiKey: string;
    }

    export async function main(ablyResource: Ably, channelName: string, messageData: Record<string, any>) {
        const realtime = new AblyRealtime(ablyResource.apiKey);
        const channel = realtime.channels.get(channelName);

        await new Promise<void>((resolve, reject) => {
            channel.publish('notification', messageData, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });

        return { success: true, message: 'Push notification published successfully.' };
    }
  good: |-
    import { Realtime } from "npm:ably";

    type Ably = {
        apiKey: string;
    }

    export async function main(ablyResource: Ably, channelName: string, messageData: any) {
        const realtime = new Realtime(ablyResource.apiKey);
        const channel = realtime.channels.get(channelName);

        await new Promise<void>((resolve, reject) => {
            channel.publish('notification', messageData, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });

        return { success: true, message: `Notification published to channel ${channelName}` };
    }
  id: |-
    synthetic_publish-push-notification
  instructions: |-
    Publish a push notification for a channel in ably
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ably
  resource_type_def: |-
    type Ably = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { AgileCrmClient } from "npm:agilecrm";

    type AgileCrm = {
        apiKey: string;
        email: string;
        domain: string;
    }

    export async function main(agileCrmResource: AgileCrm, dealId: string, noteContent: string) {
        // Initialize the Agile CRM client with the provided credentials
        const client = new AgileCrmClient({
            apiKey: agileCrmResource.apiKey,
            email: agileCrmResource.email,
            domain: agileCrmResource.domain,
        });

        // Update the deal note
        const result = await client.deals.updateNote({
            id: dealId,
            note: noteContent
        });

        // Return the result
        return result;
    }
  good: |-
    import { AgileCrmClient } from "npm:agile-crm-wrapper";

    type AgileCrm = {
        apiKey: string;
        email: string;
        domain: string;
    }

    export async function main(agileCrmResource: AgileCrm, dealId: string, noteId: string, noteContent: string) {
        const client = new AgileCrmClient({
            apiKey: agileCrmResource.apiKey,
            email: agileCrmResource.email,
            domain: agileCrmResource.domain
        });

        const updatedNote = await client.deals.updateNote({
            id: noteId,
            deal_id: dealId,
            note_text: noteContent
        });

        return updatedNote;
    }
  id: |-
    synthetic_update-deal-note
  instructions: |-
    Update a note attached to a deal in agile crm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AgileCrm
  resource_type_def: |-
    type AgileCrm = {
        apiKey: string;
        email: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the Webex API

    class cisco_webex(TypedDict):
        access_token: str
        room_id: str

    def main(webex_resource: cisco_webex, max_messages: int = 10) -> List[dict]:
        headers = {
            'Authorization': f"Bearer {webex_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        url = f"https://webexapis.com/v1/messages?roomId={webex_resource['room_id']}&max={max_messages}"
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        messages = response.json().get('items', [])
        return messages
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the cisco_webex integration
    class cisco_webex(TypedDict):
        access_token: str
        host: str

    # Define the main function with the resource type and any additional parameters
    def main(cisco_webex_resource: cisco_webex, room_id: str, max_messages: int = 50) -> List[dict]:
        # Prepare the headers for the HTTP request
        headers = {
            'Authorization': f"Bearer {cisco_webex_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Prepare the API endpoint for listing messages
        url = f"{cisco_webex_resource['host']}/v1/messages"

        # Prepare the query parameters
        params = {
            'roomId': room_id,
            'max': max_messages
        }

        # Make the HTTP GET request to list messages
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of messages
            return response.json().get('items', [])
        else:
            # Handle errors (e.g., by raising an exception or returning an empty list)
            response.raise_for_status()
            return []

    # Note: The function is not called here, it is just defined and ready to be used.
  id: |-
    synthetic_list-messages
  instructions: |-
    Retrieve messages in a specific room in cisco webex
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cisco_webex
  resource_type_def: |-
    class cisco_webex(TypedDict):
        access_token: str
        host: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BrexStaging as BrexStagingClient } from 'npm:@brex/brex-api'; // Rename the imported method to avoid conflict

    type BrexStaging = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(brexStaging: BrexStaging, userEmail: string, userFirstName: string, userLastName: string, roleName: string) {
        const brexClient = new BrexStagingClient({
            apiKey: brexStaging.apiKey,
            apiSecret: brexStaging.apiSecret,
            endpoint: brexStaging.endpoint
        });

        const userPayload = {
            email: userEmail,
            first_name: userFirstName,
            last_name: userLastName,
            role: roleName
        };

        const response = await brexClient.inviteUser(userPayload);

        return response;
    }
  good: |-
    // Import any libraries you need here
    import { BrexStaging } from 'npm:@brex/brex-api'; // Assuming this is the npm package for Brex API

    type BrexStagingResource = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(brexStagingResource: BrexStagingResource, userEmail: string, userFirstName: string, userLastName: string, roleName: string) {
        // Initialize the BrexStaging API client with the provided credentials
        const brexClient = new BrexStaging({
            apiKey: brexStagingResource.apiKey,
            apiSecret: brexStagingResource.apiSecret,
            endpoint: brexStagingResource.endpoint
        });

        // Construct the payload for inviting a new user
        const invitePayload = {
            email: userEmail,
            first_name: userFirstName,
            last_name: userLastName,
            role: roleName
        };

        // Send the invite request to the Brex API
        try {
            const response = await brexClient.inviteUser(invitePayload);
            return response; // Return the result of the invite operation
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error('Error inviting new user to BrexStaging:', error);
            throw error; // Rethrow the error to be handled by the caller
        }
    }
  id: |-
    synthetic_invite-user
  instructions: |-
    Invites a new user as an employee. in brex staging
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BrexStaging
  resource_type_def: |-
    type BrexStaging = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import google.auth  # Assuming google.auth is used for authentication
    from google.cloud import dialogflow_v2 as dialogflow  # Assuming Dialogflow V2 API

    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str

    def main(dialogflow_resource: google_dialogflow, session_id: str, text: str, language_code: str = 'en-US'):
        credentials = google.auth.credentials.Credentials.from_service_account_info({
            'type': 'service_account',
            'project_id': dialogflow_resource['project_id'],
            'private_key': dialogflow_resource['private_key'],
            'client_email': dialogflow_resource['client_email'],
            'client_id': '',
            'auth_uri': 'https://accounts.google.com/o/oauth2/auth',
            'token_uri': 'https://oauth2.googleapis.com/token',
            'auth_provider_x509_cert_url': 'https://www.googleapis.com/oauth2/v1/certs',
            'client_x509_cert_url': ''
        })

        session_client = dialogflow.SessionsClient(credentials=credentials)
        session = session_client.session_path(dialogflow_resource['project_id'], session_id)

        text_input = dialogflow.types.TextInput(text=text, language_code=language_code)
        query_input = dialogflow.types.QueryInput(text=text_input)
        response = session_client.detect_intent(session=session, query_input=query_input)

        return response.query_result
  good: |-
    from typing import TypedDict, Any
    import google.auth  # Assuming google.auth is used for authentication
    from google.cloud import dialogflow_v2 as dialogflow  # Import Dialogflow library

    # Define the resource type for the google_dialogflow integration
    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str

    # Define the main function with the resource type and additional parameters
    def main(dialogflow_resource: google_dialogflow, session_id: str, context_id: str, parameters: dict, lifespan_count: int):
        # Set up authentication using the service account key from the resource
        credentials = google.auth.credentials.Credentials.from_service_account_info({
            'client_email': dialogflow_resource['client_email'],
            'private_key': dialogflow_resource['private_key'],
            'token_uri': 'https://oauth2.googleapis.com/token',
        })

        # Create a session client
        session_client = dialogflow.SessionsClient(credentials=credentials)

        # Define the session path
        session_path = session_client.session_path(dialogflow_resource['project_id'], session_id)

        # Define the context path
        context_name = f"projects/{dialogflow_resource['project_id']}/agent/sessions/{session_id}/contexts/{context_id}"

        # Create a context with the provided parameters and lifespan count
        context = dialogflow.types.Context(
            name=context_name,
            parameters=parameters,
            lifespan_count=lifespan_count
        )

        # Update the context
        response = session_client.contexts_client.update_context(context)

        # Return the response
        return response
  id: |-
    synthetic_update-context
  instructions: |-
    Updates a context, and in google dialogflow
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_dialogflow
  resource_type_def: |-
    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { verify } from "npm:emailable";

    type Emailable = {
        apiKey: string;
    }

    export async function main(emailableResource: Emailable, emails: string[]) {
        if (!emails.length) {
            throw new Error("No emails provided for verification.");
        }

        const results = await Promise.all(emails.map(email => verify(email, { apiKey: emailableResource.apiKey })));

        return results;
    }
  good: |-
    import { verifyBatch } from "npm:emailable";

    type Emailable = {
        apiKey: string;
    }

    export async function main(emailableResource: Emailable, emails: string[]) {
        if (emails.length > 50000) {
            throw new Error("Batch size exceeds the maximum limit of 50,000 emails.");
        }

        const result = await verifyBatch(emailableResource.apiKey, emails);
        return result;
    }
  id: |-
    synthetic_verify-batch-of-emails
  instructions: |-
    Verifies a batch of emails, up to 50,000 per batch in emailable
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Emailable
  resource_type_def: |-
    type Emailable = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the google_forms integration
    class google_forms(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the script
    def main(google_forms_resource: google_forms, form_id: str) -> Dict[str, Any]:
        # Construct the URL to access the Google Form
        url = f"https://forms.googleapis.com/v1/forms/{form_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {google_forms_resource['api_key']}"
        }

        # Make the GET request to retrieve the form
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the form data as a dictionary
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": f"Failed to get form with status code {response.status_code}"}

    # Note: The function is not called here, as per the instructions.
  good: |-
    from typing import TypedDict, Any
    import googleapiclient.discovery  # Assuming Google API client library is used

    # Rename the imported method if it conflicts with the resource type name
    from googleapiclient.discovery import build as build_service

    class google_forms(TypedDict):
        api_key: str
        access_token: str

    def main(google_forms_resource: google_forms, form_id: str) -> Any:
        service = build_service('forms', 'v1', developerKey=google_forms_resource['api_key'])
        service._http.headers['Authorization'] = f"Bearer {google_forms_resource['access_token']}"

        # Retrieve the Google Form information
        form = service.forms().get(formId=form_id).execute()

        return form
  id: |-
    synthetic_get-form
  instructions: |-
    Get information about a Google Form in google forms
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_forms
  resource_type_def: |-
    class google_forms(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GoogleSpreadsheet } from "npm:google-spreadsheet";

    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        sheetTitle: string,
        searchColumn: string,
        searchValue: string
    ) {
        // Initialize the Google Spreadsheet client
        const doc = new GoogleSpreadsheet(spreadsheetId);

        // Authenticate with the Google Sheets API
        await doc.useServiceAccountAuth({
            client_email: googleSheetsResource.clientEmail,
            private_key: googleSheetsResource.privateKey.replace(/\\n/g, '\n'),
        });

        // Load the spreadsheet
        await doc.loadInfo();

        // Get the specific sheet by title
        const sheet = doc.sheetsByTitle[sheetTitle];

        // Load the rows in the sheet
        await sheet.loadCells();

        // Find the row that contains the search value in the specified column
        const column = sheet.headerValues.indexOf(searchColumn);
        if (column === -1) {
            throw new Error(`Column "${searchColumn}" not found.`);
        }

        const rows = await sheet.getRows();
        const foundRow = rows.find(row => row[searchColumn] === searchValue);

        // Return the found row or null if not found
        return foundRow ? foundRow._rawData : null;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, spreadsheetId: string, range: string, searchColumn: string, searchValue: string) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.apiKey });

        try {
            // Fetch the rows from the specified range in the sheet
            const response = await sheets.spreadsheets.values.get({
                spreadsheetId,
                range,
                key: googleSheetsResource.apiKey
            });

            const rows = response.data.values;
            if (!rows || rows.length === 0) {
                return 'No data found.';
            }

            // Find the index of the searchColumn
            const columnIndex = rows[0].indexOf(searchColumn);
            if (columnIndex === -1) {
                return `Column "${searchColumn}" not found.`;
            }

            // Filter rows that match the searchValue in the specified column
            const matchingRows = rows.filter((row) => row[columnIndex] === searchValue);

            return matchingRows;
        } catch (err) {
            // Handle errors here
            console.error('The API returned an error: ' + err);
            throw err;
        }
    }
  id: |-
    synthetic_find-row
  instructions: |-
    Find one or more rows by a column and value in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { initializeApp, credential, firestore } from "npm:@firebase/admin";

    type FirebaseAdminSdk = {
        type: string;
        projectId: string;
        privateKeyId: string;
        privateKey: string;
        clientEmail: string;
        clientId: string;
        authUri: string;
        tokenUri: string;
        authProviderX509CertUrl: string;
        clientX509CertUrl: string;
    }

    export async function main(
        firebaseAdminSdkResource: FirebaseAdminSdk,
        collectionPath: string,
        documentData: firestore.DocumentData
    ) {
        // Initialize the Firebase Admin SDK
        initializeApp({
            credential: credential.cert({
                projectId: firebaseAdminSdkResource.projectId,
                clientEmail: firebaseAdminSdkResource.clientEmail,
                privateKey: firebaseAdminSdkResource.privateKey.replace(/\\n/g, '\n'),
            }),
            databaseURL: `https://${firebaseAdminSdkResource.projectId}.firebaseio.com`
        });

        // Get a Firestore database instance
        const db = firestore();

        // Create a new document in the specified collection with the provided data
        const documentReference = db.collection(collectionPath).doc();
        await documentReference.set(documentData);

        // Return the ID of the newly created document
        return documentReference.id;
    }
  good: |-
    import { initializeApp, credential as firebaseCredential, firestore } from "npm:@firebase/admin";

    type FirebaseAdminSdk = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
    }

    export async function main(firebaseAdminSdkResource: FirebaseAdminSdk, collectionPath: string, documentData: firestore.DocumentData) {
        // Initialize the Firebase Admin SDK with the provided credentials
        initializeApp({
            credential: firebaseCredential.cert({
                projectId: firebaseAdminSdkResource.projectId,
                clientEmail: firebaseAdminSdkResource.clientEmail,
                privateKey: firebaseAdminSdkResource.privateKey.replace(/\\n/g, '\n'),
            }),
        });

        // Get a Firestore instance
        const db = firestore();

        // Add a new document with a generated id to the specified collection
        const documentReference = await db.collection(collectionPath).add(documentData);

        // Return the document reference (id)
        return documentReference.id;
    }
  id: |-
    synthetic_create-document
  instructions: |-
    Creates a New Document in firebase admin sdk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FirebaseAdminSdk
  resource_type_def: |-
    type FirebaseAdminSdk = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class generated_photos(TypedDict):
        api_key: str

    def main(generated_photos_resource: generated_photos, image_url: str, number_of_faces: int = 1):
        headers = {
            'Authorization': f"API-Key {generated_photos_resource['api_key']}"
        }
        payload = {
            'template_url': image_url,
            'amount': number_of_faces
        }
        response = requests.post('https://api.generated.photos/api/v1/faces', headers=headers, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the 'generated_photos' integration
    class generated_photos(TypedDict):
        api_key: str

    # Define the main function with the resource type and additional parameters
    def main(generated_photos_resource: generated_photos, image_url: str, number_of_faces: int = 1):
        # API endpoint for generating similar faces
        api_endpoint = "https://api.generated.photos/api/v1/faces/similar"

        # Prepare headers with the API key
        headers = {
            "Authorization": f"API-Key {generated_photos_resource['api_key']}"
        }

        # Prepare the payload with the image URL and the number of faces to generate
        payload = {
            "image_url": image_url,
            "number_of_faces": number_of_faces
        }

        # Make the request to the API
        response = requests.post(api_endpoint, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response containing the generated faces
            return response.json()
        else:
            # Handle errors (e.g., invalid API key, bad request, etc.)
            response.raise_for_status()
  id: |-
    synthetic_generate-similar-faces-by-url
  instructions: |-
    Generates faces similar to an image URL with the Generated Photos API in generated photos
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    generated_photos
  resource_type_def: |-
    class generated_photos(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { OAuth2Client } from "npm:@googleapis/oauth2";

    type Enedis = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }

    export async function main(enedisResource: Enedis, usagePointId: string) {
        const oauth2Client = new OAuth2Client(
            enedisResource.clientId,
            enedisResource.clientSecret
        );

        oauth2Client.setCredentials({
            access_token: enedisResource.accessToken,
            refresh_token: enedisResource.refreshToken
        });

        const url = `https://api.enedis.fr/v3/customers/usage_points/${usagePointId}/identity`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${enedisResource.accessToken}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { encode as base64Encode } from "npm:@stablelib/base64";

    type Enedis = {
        clientId: string;
        clientSecret: string;
        accessToken: string;
    }

    export async function main(enedisResource: Enedis, usagePointId: string) {
        const url = `https://api.enedis.fr/customers/identity?usage_point_id=${encodeURIComponent(usagePointId)}`;
        const authorizationHeader = `Bearer ${enedisResource.accessToken}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': authorizationHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_get-identity
  instructions: |-
    Returns the identity of a client in enedis
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Enedis
  resource_type_def: |-
    type Enedis = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import google.cloud.dialogflow_v2 as dialogflow

    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str

    def main(dialogflow_resource: google_dialogflow, language_code: str = 'en') -> List[str]:
        client = dialogflow.EntityTypesClient.from_service_account_json({
            "type": "service_account",
            "project_id": dialogflow_resource['project_id'],
            "private_key_id": "some_private_key_id",
            "private_key": dialogflow_resource['private_key'],
            "client_email": dialogflow_resource['client_email'],
            "client_id": "",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": ""
        })

        parent = client.common_project_path(dialogflow_resource['project_id'])
        entity_types = client.list_entity_types(parent, language_code=language_code)

        entity_type_names = [entity_type.name for entity_type in entity_types]
        return entity_type_names
  good: |-
    from typing import TypedDict, List
    import google.cloud.dialogflow_v2 as dialogflow

    # Rename the imported method if it conflicts with the integration name
    from google.cloud.dialogflow_v2 import types as dialogflow_types

    class google_dialogflow(TypedDict):
        project_id: str
        credentials: dict

    def main(google_dialogflow_resource: google_dialogflow, language_code: str = 'en') -> List[dialogflow_types.EntityType]:
        client = dialogflow.EntityTypesClient(credentials=google_dialogflow_resource['credentials'])
        parent = client.project_agent_path(google_dialogflow_resource['project_id'])

        entity_types = client.list_entity_types(parent, language_code=language_code)

        return list(entity_types)

    # The function does not need to be called here, as per the instructions.
  id: |-
    synthetic_list-entity-types
  instructions: |-
    Retrieves list of entity types, and in google dialogflow
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_dialogflow
  resource_type_def: |-
    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import formstack_sdk

    class formstack(TypedDict):
        access_token: str
        account_url: str

    def main(formstack_resource: formstack, form_title: str, fields: list[dict[str, Any]]):
        client = formstack_sdk.Client(formstack_resource['access_token'], formstack_resource['account_url'])

        form_data = {
            'name': form_title,
            'fields': fields
        }

        new_form = client.create_form(form_data)
        return new_form
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the formstack integration
    class formstack(TypedDict):
        api_key: str
        server_url: str

    # Define the main function for creating a form in formstack
    def main(formstack_resource: formstack, form_name: str, fields: Dict[str, Any]):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a form
        create_form_endpoint = f"{formstack_resource['server_url']}/form.json"

        # Prepare the headers for authentication
        headers = {
            "Authorization": f"Bearer {formstack_resource['api_key']}"
        }

        # Prepare the data for the new form
        form_data = {
            "name": form_name,
            "fields": fields
        }

        # Make the request to create the form
        response = requests.post(create_form_endpoint, headers=headers, json=form_data)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created form details
        else:
            raise Exception(f"Error creating form: {response.text}")  # Raise an exception if there was an error

    # Example usage:
    # result = main(formstack_resource={'api_key': 'your_api_key', 'server_url': 'https://www.formstack.com/api'}, form_name='My Form', fields=[{'label': 'Email', 'type': 'email'}, {'label': 'Name', 'type': 'text'}])
    # print(result)
  id: |-
    synthetic_create-form
  instructions: |-
    Create a new form in your account in formstack
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    formstack
  resource_type_def: |-
    class formstack(TypedDict):
        api_key: str
        server_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'adalo' integration
    class adalo(TypedDict):
        api_key: str
        app_id: str

    # Define the main function for creating a record in an Adalo database
    def main(adalo_resource: adalo, table_name: str, record_data: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a record
        api_endpoint = f"https://api.adalo.com/apps/{adalo_resource['app_id']}/collections/{table_name}"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {adalo_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the POST request to create the record
        response = requests.post(api_endpoint, json=record_data, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the Adalo integration
    class adalo(TypedDict):
        app_id: str
        api_key: str
        collection_id: str

    # Import requests but rename it to avoid conflicts with any parameter named 'requests'
    import requests as http_requests

    def main(adalo_resource: adalo, record_data: dict) -> Any:
        # Construct the URL for the Adalo API endpoint
        url = f"https://api.adalo.com/apps/{adalo_resource['app_id']}/collections/{adalo_resource['collection_id']}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {adalo_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make a POST request to create a new record in the specified Adalo collection
        response = http_requests.post(url, json=record_data, headers=headers)

        # Return the response from the API call
        return response.json()
  id: |-
    synthetic_create-record
  instructions: |-
    Create a new record in adalo
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    adalo
  resource_type_def: |-
    class adalo(TypedDict):
        api_key: str
        app_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Dict, Any
    import edenai as edenai_client  # Renamed the imported module to avoid conflict

    # Define the resource type for the eden_ai integration
    class eden_ai(TypedDict):
        api_key: str

    def main(eden_ai_resource: eden_ai, text: str, source_language: str, target_language: str) -> Dict[str, Any]:
        # Initialize the Eden AI client with the provided API key
        client = edenai_client.Language(client_key=eden_ai_resource['api_key'])

        # Translate the document
        result = client.translation(
            text=text,
            source_language=source_language,
            target_language=target_language
        )

        # Return the translation result
        return result
  good: |-
    from typing import TypedDict, Optional
    import edenai  # Assuming edenai is the library we need to import

    # Rename the imported method if it conflicts with the resource type name
    from edenai import Translation as EdenaiTranslation

    class eden_ai(TypedDict):
        api_key: str

    def main(eden_ai_resource: eden_ai, source_language: str, target_language: str, text: Optional[str] = None, file_url: Optional[str] = None):
        # Initialize the eden_ai API client with the provided API key
        client = edenai.Translation(eden_ai_resource['api_key'])

        # Check if text is provided, if not, assume file_url is provided
        if text:
            # Translate the provided text
            result = client.translate(text=text, source_language=source_language, target_language=target_language)
        elif file_url:
            # Translate the document at the provided URL
            result = client.translate(file_url=file_url, source_language=source_language, target_language=target_language)
        else:
            raise ValueError("Either text or file_url must be provided.")

        # Return the translation result
        return result
  id: |-
    synthetic_translate-document
  instructions: |-
    Translates a document from a local file or URL in eden ai
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    eden_ai
  resource_type_def: |-
    class eden_ai(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftEntraId = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        groupId: string;
    }

    export async function main(microsoftEntraIdResource: MicrosoftEntraId, memberId: string) {
        // Initialize Microsoft Graph client with the credentials
        const client = Client.init({
            authProvider: (done) => {
                // Here you would normally perform the OAUTH2 flow to get the token
                // For this script, we assume that the token is already provided in the resource
                done(null, microsoftEntraIdResource.clientSecret); // This is not the actual implementation
            }
        });

        // Construct the URL for adding a member to the group
        const addMemberUrl = `https://graph.microsoft.com/v1.0/groups/${microsoftEntraIdResource.groupId}/members/$ref`;

        // Create the HTTP request body
        const requestBody = {
            "@odata.id": `https://graph.microsoft.com/v1.0/directoryObjects/${memberId}`
        };

        // Make the HTTP request to add the member to the group
        const result = await client.api(addMemberUrl)
            .version('v1.0')
            .post(requestBody);

        // Return the result of the operation
        return result;
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftEntraId = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(microsoftEntraIdResource: MicrosoftEntraId, groupId: string, userId: string, authority: string, scope: string) {
        const client = Client.init({
            authProvider: async (done) => {
                // Here you would implement the logic to get a token using the provided credentials
                // For the purpose of this example, we'll assume the token is already available
                const token = 'YOUR_ACCESS_TOKEN'; // The user of the script should replace this with the actual token
                done(null, token);
            }
        });

        const member = {
            '@odata.id': `https://graph.microsoft.com/v1.0/directoryObjects/${userId}`
        };

        try {
            const result = await client.api(`/groups/${groupId}/members/$ref`).post(member);
            return result;
        } catch (error) {
            // Handle error appropriately
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_add-member-to-group
  instructions: |-
    Adds a member to a group Microsoft Entra ID in microsoft entra id
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftEntraId
  resource_type_def: |-
    type MicrosoftEntraId = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, engagementBody: object) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });

        const result = await hubspotClient.crm.engagements.basicApi.create(engagementBody);

        return result;
    }
  good: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, contactId: string, engagementType: string, engagementBody: string) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });

        const engagementData = {
            engagement: {
                type: engagementType,
            },
            associations: {
                contactIds: [contactId],
            },
            metadata: {
                body: engagementBody
            }
        };

        try {
            const result = await hubspotClient.crm.engagements.basicApi.create(engagementData);
            return result;
        } catch (error) {
            console.error('Error creating engagement:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-engagement
  instructions: |-
    Create a new engagement for a contact in hubspot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library to make HTTP requests
    import fetch from "npm:node-fetch";

    type Ipbase = {
        apiKey: string;
    }

    export async function main(ipbaseResource: Ipbase, ipAddress: string) {
        const url = `https://api.ipbase.com/v2/info?ip=${encodeURIComponent(ipAddress)}`;
        const headers = {
            "Authorization": `Bearer ${ipbaseResource.apiKey}`
        };

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { IpbaseResponse } from "npm:@ipbase/client"; // Assuming @ipbase/client is the npm package for ipbase

    type Ipbase = {
        apiKey: string;
    }

    export async function main(ipbaseResource: Ipbase, ipAddress: string): Promise<IpbaseResponse> {
        const ipbaseApiUrl = `https://api.ipbase.com/v2/info?ip=${encodeURIComponent(ipAddress)}`;
        const response = await fetch(ipbaseApiUrl, {
            headers: {
                'Authorization': `Bearer ${ipbaseResource.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_check-ip-address
  instructions: |-
    Checks the provided IP address (both `v4` & `v6` formats) and returns all available information in ipbase
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ipbase
  resource_type_def: |-
    type Ipbase = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client, query as faunaQuery } from "npm:faunadb";

    type Faunadb = {
        secret: string;
    }

    export async function main(faunadbResource: Faunadb, gqlQuery: string) {
        const client = new Client({ secret: faunadbResource.secret });
        const result = await client.query(faunaQuery.Call(faunaQuery.Function("executeGraphQL"), gqlQuery));
        return result;
    }
  good: |-
    import { Client, query as q } from "npm:faunadb";

    type Faunadb = {
        secret: string;
    }

    export async function main(faunadbResource: Faunadb, gqlQuery: string) {
        const client = new Client({ secret: faunadbResource.secret });

        try {
            const result = await client.query(q.Call(q.Function("graphql"), gqlQuery));
            return result;
        } catch (error) {
            console.error('Error performing GraphQL query in FaunaDB:', error);
            throw error;
        }
    }
  id: |-
    synthetic_execute-graphql-query
  instructions: |-
    Performs an arbitrary authorized GraphQL query in faunadb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Faunadb
  resource_type_def: |-
    type Faunadb = {
        secret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'clientify' integration
    class clientify(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for creating a task in Clientify
    def main(clientify_resource: clientify, task_name: str, task_description: str, due_date: str, assigned_to: int):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a task
        endpoint = f"{clientify_resource['base_url']}/tasks"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Bearer {clientify_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "name": task_name,
            "description": task_description,
            "due_date": due_date,
            "assigned_to": assigned_to
        }

        # Make the API request to create a task
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful and return the result
        if response.status_code == 201:
            return response.json()  # Return the created task information
        else:
            raise Exception(f"Failed to create task: {response.status_code} - {response.text}")

    # Note: The function does not call itself, it's meant to be called with the appropriate parameters.
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'clientify' integration
    class clientify(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for adding a new task in Clientify
    def main(clientify_resource: clientify, task_name: str, task_description: str, due_date: str, assigned_to: str, project_id: int) -> Any:
        import requests  # Import here to avoid conflicts with parameter names

        # Construct the API endpoint for creating a new task
        endpoint = f"{clientify_resource['base_url']}/tasks"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Bearer {clientify_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "name": task_name,
            "description": task_description,
            "due_date": due_date,
            "assigned_to": assigned_to,
            "project_id": project_id
        }

        # Make the API request to create a new task
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful and return the result
        if response.status_code == 201:
            return response.json()
        else:
            raise Exception(f"Failed to create task: {response.status_code} {response.text}")

    # The script ends here, the function is not called and is ready to be exported and used with the appropriate parameters.
  id: |-
    synthetic_create-task
  instructions: |-
    Add a new task in clientify
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clientify
  resource_type_def: |-
    class clientify(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the 'bybit' integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The API endpoint, e.g., "https://api.bybit.com"

    # Define the main function with the resource type and any additional parameters
    def main(bybit_resource: bybit, symbol: str):
        # Construct the URL for the Linear Position List endpoint
        url = f"{bybit_resource['endpoint']}/private/linear/position/list"

        # Prepare the headers and parameters for the API request
        headers = {
            "Content-Type": "application/json",
            "X-Api-Key": bybit_resource['api_key'],
            "X-Api-Secret": bybit_resource['api_secret']
        }
        params = {
            "symbol": symbol  # The trading pair symbol, e.g., "BTCUSD"
        }

        # Make the HTTP GET request to the ByBit API
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            # Return the result
            return data
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Example usage:
    # result = main(bybit_resource={'api_key': 'your_api_key', 'api_secret': 'your_api_secret', 'endpoint': 'https://api.bybit.com'}, symbol='BTCUSD')
    # print(result)
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the bybit API

    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # e.g., 'https://api.bybit.com'

    def main(bybit_resource: bybit, symbol: str) -> List[dict]:
        url = f"{bybit_resource['endpoint']}/v2/private/position/list"
        params = {
            "api_key": bybit_resource['api_key'],
            "symbol": symbol
            # Additional parameters like timestamp and signature for authentication
            # would be added here. Assume that the user has a method to generate
            # the signature using the api_secret and the rest of the parameters.
        }

        # Assuming the user has a method to add the signature to the params
        params['sign'] = generate_signature(bybit_resource['api_secret'], params)

        response = requests.get(url, params=params)
        if response.status_code == 200:
            return response.json().get('result', [])
        else:
            response.raise_for_status()
  id: |-
    synthetic_linear-position-list
  instructions: |-
    Get Positions List in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The API endpoint, e.g., "https://api.bybit.com"
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { LinearClient } from "npm:@linear/sdk";

    type LinearApp = {
        apiKey: string;
    }

    export async function main(linearResource: LinearApp) {
        const linearClient = new LinearClient({ apiKey: linearResource.apiKey });

        const teams = await linearClient.teams();
        return teams.nodes;
    }
  good: |-
    import { LinearClient } from "npm:@linear/sdk";

    type LinearApp = {
        apiKey: string;
    }

    export async function main(linearResource: LinearApp) {
        const linearClient = new LinearClient({ apiKey: linearResource.apiKey });

        const teams = await linearClient.teams();
        const teamList = teams.nodes.map(team => ({
            id: team.id,
            name: team.name,
            key: team.key
        }));

        return teamList;
    }
  id: |-
    synthetic_get-teams
  instructions: |-
    Get all the teams (API Key). See the docs in linear app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    LinearApp
  resource_type_def: |-
    type LinearApp = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Assemblyai as AssemblyaiClient } from "npm:@assemblyai/client";

    type Assemblyai = {
        apiKey: string;
    }

    export async function main(assemblyaiResource: Assemblyai, audioUrl: string) {
        const assemblyaiClient = new AssemblyaiClient(assemblyaiResource.apiKey);

        const transcription = await assemblyaiClient.transcribe(audioUrl);

        return transcription;
    }
  good: |-
    import { Assemblyai } from "npm:@assemblyai/sdk";

    type Assemblyai = {
        apiKey: string;
    }

    export async function main(assemblyaiResource: Assemblyai, audioUrl: string) {
        const assemblyai = new Assemblyai(assemblyaiResource.apiKey);

        const transcription = await assemblyai.transcribe(audioUrl);

        return transcription;
    }
  id: |-
    synthetic_transcribe-audio
  instructions: |-
    Causes the API to start transcribing a given audio file in assemblyai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Assemblyai
  resource_type_def: |-
    type Assemblyai = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type Clickup = {
        accessToken: string;
    }

    export async function main(clickupResource: Clickup, taskId: string) {
        const response = await fetch(`https://api.clickup.com/api/v2/task/${taskId}`, {
            method: 'GET',
            headers: {
                'Authorization': clickupResource.accessToken,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching task: ${response.statusText}`);
        }

        const task = await response.json();
        return task;
    }
  good: |-
    import { Task } from "npm:@/types/clickup.js";

    type Clickup = {
        accessToken: string;
    }

    export async function main(clickupResource: Clickup, taskId: string): Promise<Task> {
        const response = await fetch(`https://api.clickup.com/api/v2/task/${taskId}`, {
            method: 'GET',
            headers: {
                'Authorization': clickupResource.accessToken,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching task: ${response.status} ${response.statusText}`);
        }

        const task: Task = await response.json();
        return task;
    }
  id: |-
    synthetic_get-task
  instructions: |-
    Get a task. See the docs in **Tasks / Get Task** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BooqableClient } from "npm:@booqable/api";

    type Booqable = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(booqableResource: Booqable, customerId: string, updatedCustomerData: { name?: string, email?: string, phone?: string }) {
        const client = new BooqableClient({
            apiKey: booqableResource.apiKey,
            apiUrl: booqableResource.apiUrl,
        });

        const result = await client.customers.update(customerId, updatedCustomerData);

        return result;
    }
  good: |-
    import { encode } from "npm:querystring";

    type Booqable = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(booqableResource: Booqable, customerId: string, customerDetails: { [key: string]: any }) {
        const url = `${booqableResource.apiUrl}/customers/${customerId}`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${booqableResource.apiKey}`
        };
        const body = JSON.stringify({ customer: customerDetails });

        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error updating customer: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-customer
  instructions: |-
    Updates the details of an existing customer in Booqable in booqable
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Booqable
  resource_type_def: |-
    type Booqable = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailgun API

    class mailgun(TypedDict):
        api_key: str
        domain: str

    def main(mailgun_resource: mailgun, member_address: str):
        api_base_url = f"https://api.mailgun.net/v3/lists/{mailgun_resource['domain']}"
        member_endpoint = f"{api_base_url}/members/{member_address}"

        response = requests.get(
            member_endpoint,
            auth=("api", mailgun_resource['api_key'])
        )

        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailgun API

    # Define the resource type for the mailgun integration
    class mailgun(TypedDict):
        api_key: str
        domain: str

    def main(mailgun_resource: mailgun, mailing_list: str, member_address: str) -> dict:
        # Construct the API endpoint for retrieving a mailing list member
        api_endpoint = f"https://api.mailgun.net/v3/lists/{mailing_list}@{mailgun_resource['domain']}/members/{member_address}"

        # Make the HTTP GET request to Mailgun API to retrieve the member
        response = requests.get(
            api_endpoint,
            auth=("api", mailgun_resource['api_key'])
        )

        # Return the JSON response which contains the member information
        return response.json()
  id: |-
    synthetic_retrieve-mailinglist-member
  instructions: |-
    Retrieve a mailing list member by address in mailgun
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailgun
  resource_type_def: |-
    class mailgun(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createBranch } from "npm:@gitbeaker/node";

    type Gitlab = {
        host: string;
        token: string;
    }

    export async function main(gitlabResource: Gitlab, projectId: string | number, branchName: string, ref: string) {
        const { host, token } = gitlabResource;
        const service = createBranch({ host, token });

        const result = await service.create(projectId, branchName, ref);
        return result;
    }
  good: |-
    import { createBranch } from "npm:@gitbeaker/node";

    type Gitlab = {
        host: string;
        token: string;
    }

    export async function main(gitlabResource: Gitlab, projectId: string | number, branchName: string, ref: string) {
        const { host, token } = gitlabResource;
        const api = createBranch({ host, token });

        const result = await api.Branches.create(projectId, branchName, ref);
        return result;
    }
  id: |-
    synthetic_create-branch
  instructions: |-
    Create a new branch in the repository in gitlab
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
        host: string;
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { tasks_v1, google } from "npm:googleapis";

    type GoogleTasks = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(googleTasksResource: GoogleTasks, taskListId: string, taskTitle: string, taskNotes?: string) {
        const { clientId, clientSecret, refreshToken, accessToken } = googleTasksResource;

        const auth = new google.auth.OAuth2(clientId, clientSecret);
        auth.setCredentials({
            refresh_token: refreshToken,
            access_token: accessToken,
        });

        const tasksApi = google.tasks({ version: 'v1', auth });

        const newTask: tasks_v1.Schema$Task = {
            title: taskTitle,
        };

        if (taskNotes) {
            newTask.notes = taskNotes;
        }

        try {
            const result = await tasksApi.tasks.insert({
                tasklist: taskListId,
                requestBody: newTask,
            });

            return result.data;
        } catch (error) {
            console.error('Error creating task:', error);
            throw error;
        }
    }
  good: |-
    type GoogleTasks = {
        accessToken: string;
    }

    export async function main(
        googleTasksResource: GoogleTasks,
        taskListId: string,
        updatedTitle: string
    ) {
        const url = `https://tasks.googleapis.com/tasks/v1/users/@me/lists/${taskListId}`;
        const headers = {
            Authorization: `Bearer ${googleTasksResource.accessToken}`,
            'Content-Type': 'application/json',
        };
        const body = JSON.stringify({
            title: updatedTitle
        });

        const response = await fetch(url, {
            method: 'PATCH',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error updating task list: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-task-list
  instructions: |-
    Updates the authenticated user's specified task list in google tasks
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleTasks
  resource_type_def: |-
    type GoogleTasks = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { DateTime } from "npm:luxon";

    type Demio = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(demioResource: Demio, startDate: string, endDate: string) {
        const apiUrl = 'https://my.demio.com/api/v1/events';
        const authHeader = `Basic ${Buffer.from(`${demioResource.apiKey}:${demioResource.apiSecret}`).toString('base64')}`;

        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const events = await response.json();

        // Filter events by date range
        const start = DateTime.fromISO(startDate);
        const end = DateTime.fromISO(endDate);
        const filteredEvents = events.filter((event: any) => {
            const eventDate = DateTime.fromISO(event.datetime);
            return eventDate >= start && eventDate <= end;
        });

        return filteredEvents;
    }
  good: |-
    import { encode } from "npm:base-64";

    type Demio = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(demioResource: Demio, eventType: string) {
        const authHeader = `Basic ${encode(`${demioResource.apiKey}:${demioResource.apiSecret}`)}`;
        const response = await fetch(`https://my.demio.com/api/v1/events?type=${eventType}`, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching events: ${response.status} ${response.statusText}`);
        }

        const events = await response.json();
        return events;
    }
  id: |-
    synthetic_get-events
  instructions: |-
    Get all events by type in demio
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Demio
  resource_type_def: |-
    type Demio = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'curated' integration
    class curated(TypedDict):
        api_key: str  # Assuming API key is needed for the 'curated' integration

    # Define the main function with the resource type and additional parameters
    def main(curated_resource: curated, title: str, url: str, description: str = ""):
        # Assuming a function to create a link in the 'curated' integration
        # The function would use the API key from the resource and the provided parameters
        # Since the OAUTH2 flow is not to be implemented, we assume that the api_key is valid

        # Here you would have the code to interact with the 'curated' integration API
        # For example, making an HTTP POST request to create a link with the given title, url, and description
        # This is a placeholder for the actual API call, which would be integration-specific
        result = {
            "title": title,
            "url": url,
            "description": description,
            "status": "success",  # This would be the actual response status from the API
        }

        # Return the result of the operation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'curated' integration
    class curated(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the 'curated' integration
    def main(curated_resource: curated, title: str, url: str, description: str = ""):
        # Assuming there's a library to interact with the Curated API
        import curated_api_client as client

        # Configure the client with the API key from the resource
        curated_client = client.Client(api_key=curated_resource['api_key'])

        # Create a link in Curated
        result = curated_client.create_link(title=title, url=url, description=description)

        # Return the result of the link creation
        return result
  id: |-
    synthetic_create-link
  instructions: |-
    Creates a link in curated
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    curated
  resource_type_def: |-
    class curated(TypedDict):
        api_key: str  # Assuming API key is needed for the 'curated' integration
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Fibery } from "npm:@fibery/unofficial";

    type FiberyResource = {
        apiToken: string;
        workspace: string;
    }

    export async function main(fiberyResource: FiberyResource, typeName: string) {
        const fibery = new Fibery({
            token: fiberyResource.apiToken,
            workspace: fiberyResource.workspace
        });

        const types = await fibery.getSchema();
        const typeInfo = types.entities.find(type => type.name === typeName);

        if (!typeInfo) {
            throw new Error(`Type "${typeName}" not found in Fibery account.`);
        }

        return typeInfo.fields.map(field => field.name);
    }
  good: |-
    // Import any libraries you need here
    import { Fibery as FiberyClient } from "npm:@fibery/unofficial";

    type Fibery = {
        apiToken: string;
        spaceId: string;
    }

    export async function main(fibery: Fibery, entityType: string) {
        const fiberyClient = new FiberyClient({
            token: fibery.apiToken,
            spaceId: fibery.spaceId
        });

        try {
            const types = await fiberyClient.schema.getEntityTypes();
            const filteredTypes = types.filter(type => type.name === entityType);
            return filteredTypes;
        } catch (error) {
            console.error('Failed to list types in Fibery:', error);
            throw error;
        }
    }
  id: |-
    synthetic_list-types
  instructions: |-
    Lists types in account in fibery
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Fibery
  resource_type_def: |-
    type Fibery = {
        apiToken: string;
        spaceId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client, query as q } from "npm:faunadb";

    type Faunadb = {
        secret: string;
    }

    export async function main(faunadbResource: Faunadb, collectionName: string) {
        const client = new Client({ secret: faunadbResource.secret });
        const result = await client.query(
            q.Map(
                q.Paginate(q.Documents(q.Collection(collectionName))),
                q.Lambda("X", q.Get(q.Var("X")))
            )
        );
        return result;
    }
  good: |-
    import { Client, query as q } from "npm:faunadb";

    type Faunadb = {
        secret: string;
    }

    export async function main(faunadbResource: Faunadb, collectionName: string) {
        const client = new Client({ secret: faunadbResource.secret });
        const result = await client.query(
            q.Map(
                q.Paginate(q.Documents(q.Collection(collectionName))),
                q.Lambda("X", q.Get(q.Var("X")))
            )
        );
        return result;
    }
  id: |-
    synthetic_read-from-collection
  instructions: |-
    Reads all documents from a given Fauna collection in faunadb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Faunadb
  resource_type_def: |-
    type Faunadb = {
        secret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(
        googleDialogflowResource: GoogleDialogflow,
        sessionId: string,
        languageCode: string = 'en-US'
    ) {
        const dialogflowClient = new SessionsClient({
            credentials: {
                private_key: googleDialogflowResource.privateKey,
                client_email: googleDialogflowResource.clientEmail,
            },
            projectId: googleDialogflowResource.projectId,
        });

        const sessionPath = dialogflowClient.projectAgentSessionPath(
            googleDialogflowResource.projectId,
            sessionId
        );

        const request = {
            session: sessionPath,
            queryInput: {
                text: {
                    text: '', // The query text will be an empty string as we are fetching the agent details, not sending a user query.
                    languageCode: languageCode,
                },
            },
        };

        try {
            const responses = await dialogflowClient.detectIntent(request);
            const result = responses[0].queryResult;
            return result;
        } catch (error) {
            console.error('Dialogflow API error:', error);
            throw error;
        }
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(googleDialogflowResource: GoogleDialogflow, sessionId: string, languageCode: string = 'en-US') {
        const dialogflowClient = new SessionsClient({
            credentials: {
                private_key: googleDialogflowResource.privateKey,
                client_email: googleDialogflowResource.clientEmail,
            },
            projectId: googleDialogflowResource.projectId,
        });

        const sessionPath = dialogflowClient.projectAgentSessionPath(
            googleDialogflowResource.projectId,
            sessionId
        );

        const request = {
            session: sessionPath,
            queryInput: {
                text: {
                    text: '', // The query text will be an empty string as we are retrieving the agent, not sending a query.
                    languageCode: languageCode,
                },
            },
        };

        try {
            const responses = await dialogflowClient.detectIntent(request);
            const result = responses[0].queryResult;
            return result;
        } catch (error) {
            console.error('Dialogflow API Error:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-agent
  instructions: |-
    Retrieves an agent, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    # import any libraries you need here

    # Assuming 'helper_functions' is the name of the integration and it contains a method that conflicts with 'schedule_task'
    from helper_functions import schedule_task as schedule_task_helper

    class helper_functions(TypedDict):
        # Assuming the helper_functions integration requires an API key for authentication
        api_key: str

    def main(helper_functions_resource: helper_functions, task_name: str, cron_expression: str):
        # Use the 'schedule_task_helper' method from the 'helper_functions' integration to schedule a task
        result = schedule_task_helper(
            api_key=helper_functions_resource['api_key'],
            task_name=task_name,
            cron_expression=cron_expression
        )

        # Return the result of the scheduling operation
        return result
  good: |-
    from typing import TypedDict, Any
    # import any libraries you need here

    # Define the resource type for the 'helper_functions' integration
    class helper_functions(TypedDict):
        api_key: str
        scheduler_url: str

    # Define the main function with the resource type and any additional parameters
    def main(helper_functions_resource: helper_functions, task_name: str, task_data: Any, schedule_time: str):
        # Assuming there is a function in the helper_functions integration to schedule a task
        from helper_functions import schedule_task as schedule_task_integration

        # Use the schedule_task function from the helper_functions integration
        result = schedule_task_integration(
            api_key=helper_functions_resource['api_key'],
            scheduler_url=helper_functions_resource['scheduler_url'],
            task_name=task_name,
            task_data=task_data,
            schedule_time=schedule_time
        )

        # Return the result of the scheduling operation
        return result

    # The complete script is as follows:
    # Note: The user must provide the 'task_name', 'task_data', and 'schedule_time' when calling the main function.
  id: |-
    synthetic_schedule-task-in-future
  instructions: |-
    Schedule a task with an existing task scheduler source. See for more details. in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        # Assuming the helper_functions integration requires an API key for authentication
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { CloudTablesClient } from "npm:@cloudtables/client";

    type CloudTables = {
        apiKey: string;
        databaseId: string;
        tableId: string;
    }

    export async function main(cloudTablesResource: CloudTables, rowId: string) {
        // Initialize the CloudTables client with the provided API key
        const client = new CloudTablesClient({
            apiKey: cloudTablesResource.apiKey,
        });

        // Construct the endpoint URL for deleting a row
        const endpoint = `https://api.cloudtables.com/v1/databases/${cloudTablesResource.databaseId}/tables/${cloudTablesResource.tableId}/rows/${rowId}`;

        // Make the DELETE request to the CloudTables API to delete the row
        const response = await fetch(endpoint, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${cloudTablesResource.apiKey}`
            }
        });

        // Check if the deletion was successful
        if (!response.ok) {
            throw new Error(`Failed to delete row: ${response.status} ${response.statusText}`);
        }

        // Return the result
        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { CloudTablesClient } from "npm:@cloudtables/client";

    type Cloudtables = {
        apiKey: string,
        baseId: string,
        tableId: string
    }

    export async function main(cloudtablesResource: Cloudtables, rowId: string) {
        const client = new CloudTablesClient({
            apiKey: cloudtablesResource.apiKey,
            baseId: cloudtablesResource.baseId,
        });

        const table = client.table(cloudtablesResource.tableId);
        const result = await table.deleteRow(rowId);

        return result;
    }
  id: |-
    synthetic_delete-row
  instructions: |-
    Delete a row in a CloudTable data set in cloudtables
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Cloudtables
  resource_type_def: |-
    type Cloudtables = {
        apiKey: string,
        baseId: string,
        tableId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { CoinbaseClient } from "npm:@coinbase/wallet-sdk";

    type Coinbase = {
        apiKey: string;
        apiSecret: string;
        apiVersion: string;
    }

    export async function main(coinbaseResource: Coinbase, amount: string, currency: string, cryptoAddress: string) {
        // Initialize Coinbase client
        const client = new CoinbaseClient({
            apiKey: coinbaseResource.apiKey,
            apiSecret: coinbaseResource.apiSecret,
            version: coinbaseResource.apiVersion,
        });

        // Withdraw funds to the specified crypto address
        const withdrawal = await client.withdrawals.sendMoney({
            amount: amount,
            currency: currency,
            crypto_address: cryptoAddress
        });

        // Return the result of the withdrawal
        return withdrawal;
    }
  good: |-
    import { CoinbaseClient } from "npm:@coinbase/wallet-sdk";

    type Coinbase = {
        apiKey: string;
        apiSecret: string;
        passphrase: string;
        accountId: string;
    }

    export async function main(coinbaseResource: Coinbase, amount: string, currency: string, cryptoAddress: string) {
        const client = new CoinbaseClient({
            apiKey: coinbaseResource.apiKey,
            apiSecret: coinbaseResource.apiSecret,
            passphrase: coinbaseResource.passphrase,
            useSandbox: false // Assuming production environment, set to true for sandbox testing
        });

        const account = await client.getAccount(coinbaseResource.accountId);
        const withdrawal = await account.withdraw({
            amount: amount,
            currency: currency,
            crypto_address: cryptoAddress
        });

        return withdrawal;
    }
  id: |-
    synthetic_withdraw-funds
  instructions: |-
    Withdraw funds in coinbase
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coinbase
  resource_type_def: |-
    type Coinbase = {
        apiKey: string;
        apiSecret: string;
        apiVersion: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import imagekit  # Assuming imagekit is the library for the imagekit.io integration

    # Define the resource type for the imagekit_io integration
    class imagekit_io(TypedDict):
        public_key: str
        private_key: str
        url_endpoint: str

    # Define the main function with the resource type and additional parameters
    def main(imagekit_resource: imagekit_io, search_query: str, file_type: str = None, tags: List[str] = None):
        # Initialize the ImageKit instance with the provided credentials
        imagekit_instance = imagekit.ImageKit(
            public_key=imagekit_resource['public_key'],
            private_key=imagekit_resource['private_key'],
            url_endpoint=imagekit_resource['url_endpoint']
        )

        # Prepare the search options
        search_options = {
            "query": search_query,
            "fileType": file_type,
            "tags": tags
        }

        # Filter out None values from search_options
        search_options = {k: v for k, v in search_options.items() if v is not None}

        # Perform the search using the ImageKit instance
        result = imagekit_instance.search_files(search_options)

        # Return the search result
        return result
  good: |-
    from typing import TypedDict
    import imagekitio

    class imagekit_io(TypedDict):
        public_key: str
        private_key: str
        url_endpoint: str

    def main(imagekit_io_resource: imagekit_io):
        imagekit = imagekitio.ImageKit(
            public_key=imagekit_io_resource['public_key'],
            private_key=imagekit_io_resource['private_key'],
            url_endpoint=imagekit_io_resource['url_endpoint']
        )

        list_options = {
            "skip": 0,
            "limit": 100  # You can adjust the limit as per your requirement
        }

        # Fetch the list of all files
        file_list = imagekit.list_files(list_options)
        return file_list

    # The main function is not called here, as per the instructions.
  id: |-
    synthetic_search-files
  instructions: |-
    List all the uploaded files and folders in your ImageKit.io media library in imagekit io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    imagekit_io
  resource_type_def: |-
    class imagekit_io(TypedDict):
        public_key: str
        private_key: str
        url_endpoint: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Gitlab } from "npm:@gitbeaker/node";

    type Gitlab = {
        host: string;
        token: string;
    }

    export async function main(gitlabResource: Gitlab, projectId: number, issueIid: number, issueUpdateData: Record<string, unknown>) {
        const gitlabApi = new Gitlab({
            host: gitlabResource.host,
            token: gitlabResource.token,
        });

        const updatedIssue = await gitlabApi.Issues.edit(projectId, issueIid, issueUpdateData);

        return updatedIssue;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Gitlab = {
        apiToken: string;
        projectId: string;
    }

    export async function main(gitlabResource: Gitlab, issueId: number, updatedFields: { title?: string; description?: string; state_event?: string; labels?: string; }) {
        const url = `https://gitlab.com/api/v4/projects/${encodeURIComponent(gitlabResource.projectId)}/issues/${issueId}`;
        const headers = {
            "Authorization": `Bearer ${gitlabResource.apiToken}`,
            "Content-Type": "application/json"
        };
        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(updatedFields)
        });

        if (!response.ok) {
            throw new Error(`Failed to update issue: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-issue
  instructions: |-
    Updates an existing project issue in gitlab
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
        host: string;
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Gryd } from "npm:@gryd/api"; // Assuming @gryd/api is the npm package for Gryd API

    // Define the resource type for Gryd integration
    type GrydResource = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(grydResource: GrydResource, vehicleId: string) {
        // Initialize the Gryd API client with the provided credentials
        const grydClient = new Gryd(grydResource.apiKey, grydResource.apiUrl);

        // Fetch data for the specific vehicle
        const vehicleData = await grydClient.getVehicleData(vehicleId);

        // Return the result
        return vehicleData;
    }
  good: |-
    import { GrydAPI as GrydApiClient } from "npm:gryd-client";

    type Gryd = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(grydResource: Gryd, vehicleId: string) {
        const grydClient = new GrydApiClient(grydResource.apiKey, grydResource.apiSecret);
        const vehicleData = await grydClient.getVehicleData(vehicleId);
        return vehicleData;
    }
  id: |-
    synthetic_get-vehicle-data
  instructions: |-
    Fetches data for a specific vehicle from the Gryd API in gryd
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gryd
  resource_type_def: |-
    type Gryd = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Hostaway } from "npm:hostaway"; // Assuming 'hostaway' is the npm package name

    type HostawayResource = {
        apiKey: string,
        accountId: string
    }

    export async function main(hostawayResource: HostawayResource, taskTitle: string, taskDescription: string, propertyId: number, dueDate: string) {
        const hostaway = new Hostaway(hostawayResource.apiKey, hostawayResource.accountId);

        const newTask = {
            title: taskTitle,
            description: taskDescription,
            propertyId: propertyId,
            dueDate: dueDate
        };

        const result = await hostaway.createTask(newTask);

        return result;
    }
  good: |-
    import { HostawayApi as HostawayApiClient } from "npm:hostaway";

    type Hostaway = {
        apiKey: string;
        accountId: string;
    }

    type CreateTaskParams = {
        listingId: number;
        title: string;
        description: string;
        dueDate: string;
    }

    export async function main(hostawayResource: Hostaway, taskParams: CreateTaskParams) {
        const hostawayClient = new HostawayApiClient(hostawayResource.apiKey, hostawayResource.accountId);

        const result = await hostawayClient.createTask({
            listingId: taskParams.listingId,
            title: taskParams.title,
            description: taskParams.description,
            dueDate: taskParams.dueDate,
        });

        return result;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a new task in Hostaway in hostaway
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hostaway
  resource_type_def: |-
    type Hostaway = {
        apiKey: string;
        accountId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class giphy(TypedDict):
        api_key: str

    def main(giphy_resource: giphy, word: str) -> str:
        base_url = "http://api.giphy.com/v1/gifs/translate"
        params = {
            "s": word,
            "api_key": giphy_resource['api_key']
        }
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        gif_url = response.json()['data']['images']['original']['url']
        return gif_url
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to interact with the GIPHY API

    # Define the resource type for the giphy integration
    class giphy(TypedDict):
        api_key: str

    def main(giphy_resource: giphy, query: str, limit: int = 1, rating: str = 'G', lang: str = 'en', media_type: str = 'gif') -> dict:
        # Construct the URL for the GIPHY API call
        base_url = f"https://api.giphy.com/v1/{media_type}s/search"
        params = {
            "api_key": giphy_resource['api_key'],
            "q": query,
            "limit": limit,
            "rating": rating,
            "lang": lang
        }

        # Make the request to the GIPHY API
        response = requests.get(base_url, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            # Return the results
            return data
        else:
            # Handle errors
            return {"error": "Failed to retrieve data from GIPHY", "status_code": response.status_code}

    # Example usage:
    # result = main(giphy_resource={'api_key': 'your_api_key'}, query='happy birthday')
    # print(result)
  id: |-
    synthetic_translate-term-to-a-gif-sticker
  instructions: |-
    Translates or convert a word or phrase to the perfect Gif or Sticker using GIPHY's special sauce algorithm. in giphy
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    giphy
  resource_type_def: |-
    class giphy(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bannerbear as BannerbearClient } from 'npm:@bannerbear/mod';

    type Bannerbear = {
        apiKey: string;
    }

    export async function main(bannerbearResource: Bannerbear, templateId: string, modifications: Array<{ name: string; text: string; }>, animationOptions: { fps: number; duration: number; }) {
        const bb = new BannerbearClient(bannerbearResource.apiKey);

        // Create an array of image modification promises
        const imagePromises = modifications.map(mod => bb.create_image(templateId, { modifications: [mod] }));

        // Wait for all images to be created
        const images = await Promise.all(imagePromises);

        // Extract the image URLs
        const imageUrls = images.map(image => image.image_url);

        // Create the animated GIF
        const animatedGif = await bb.create_animated_gif({
            fps: animationOptions.fps,
            duration: animationOptions.duration,
            frames: imageUrls.map(url => ({ image_url: url }))
        });

        return animatedGif;
    }
  good: |-
    import { Bannerbear } from 'npm:@bannerbear/bannerbear';

    type Bannerbear = {
        apiKey: string;
    }

    export async function main(bannerbearResource: Bannerbear, templateId: string, modifications: Array<{name: string, text: string}>, webhookUrl?: string) {
        const bb = new Bannerbear(bannerbearResource.apiKey);

        try {
            const response = await bb.createAnimatedGif(templateId, modifications, webhookUrl);
            return response;
        } catch (error) {
            console.error('Error creating animated GIF:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-animated-gif
  instructions: |-
    Creates an Animated Gif. in bannerbear
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bannerbear
  resource_type_def: |-
    type Bannerbear = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the Bitly API

    class bitly(TypedDict):
        access_token: str
        group_guid: str

    def main(bitly_resource: bitly, limit: int = 10) -> List[dict]:
        headers = {
            'Authorization': f"Bearer {bitly_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        response = requests.get(
            f"https://api-ssl.bitly.com/v4/groups/{bitly_resource['group_guid']}/bitlinks",
            headers=headers,
            params={'limit': limit}
        )
        response.raise_for_status()  # This will raise an exception for HTTP error codes
        return response.json()['links']
  good: |-
    from typing import TypedDict

    # Define the resource type for the bitly integration
    class bitly(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the requests library, which is commonly used for making HTTP requests in Python
    import requests

    # Define the main function with the resource type and any additional parameters
    def main(bitly_resource: bitly, group_name: str) -> str:
        # Set up the headers with the authorization token
        headers = {
            'Authorization': f"Bearer {bitly_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Define the Bitly API endpoint for retrieving groups
        groups_endpoint = "https://api-ssl.bitly.com/v4/groups"

        # Make a GET request to the Bitly API to retrieve the list of groups
        response = requests.get(groups_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            groups_data = response.json()

            # Look for the group with the specified name
            for group in groups_data.get('groups', []):
                if group.get('name') == group_name:
                    # Return the GUID of the matching group
                    return group.get('guid')

            # If no matching group is found, return an informative message
            return "Group not found."
        else:
            # If the request failed, return the error message
            return f"Error: {response.text}"

    # Note: The function is not called here, as per the instructions.
  id: |-
    synthetic_list-bitlink-by-group
  instructions: |-
    A GUID for a Bitly group in bitly
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitly
  resource_type_def: |-
    class bitly(TypedDict):
        access_token: str
        group_guid: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        apiKey: string;
        oauthToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileName: string, fileContent: string, mimeType: string = 'text/plain') {
        const { apiKey, oauthToken } = googleDriveResource;
        const drive = google.drive({ version: 'v3', auth: apiKey });

        const fileMetadata = {
            'name': fileName,
            'mimeType': mimeType
        };

        const media = {
            mimeType: mimeType,
            body: fileContent
        };

        try {
            const response = await drive.files.create({
                requestBody: fileMetadata,
                media: media,
                fields: 'id',
                oauth_token: oauthToken
            });

            return response.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        apiKey: string;
        oauthToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileName: string, fileContent: string, mimeType: string = 'text/plain') {
        const { oauthToken } = googleDriveResource;
        const driveService = google.drive({ version: 'v3', auth: oauthToken });

        const fileMetadata = {
            'name': fileName,
            'mimeType': mimeType
        };

        const media = {
            mimeType: mimeType,
            body: fileContent
        };

        try {
            const response = await driveService.files.create({
                requestBody: fileMetadata,
                media: media,
                fields: 'id',
                oauth_token: oauthToken
            });

            return response.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  id: |-
    synthetic_create-file-from-text
  instructions: |-
    Create a new file from plain text for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        apiKey: string;
        oauthToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    class automatic_data_extraction(TypedDict):
        api_key: str

    def main(api_key: str, url: str) -> dict:
        from urllib.parse import urlparse, parse_qs

        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)

        extracted_data = {
            'scheme': parsed_url.scheme,
            'netloc': parsed_url.netloc,
            'path': parsed_url.path,
            'params': parsed_url.params,
            'query': query_params,
            'fragment': parsed_url.fragment,
            'api_key_used': api_key
        }

        return extracted_data
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the 'automatic_data_extraction' integration
    class automatic_data_extraction(TypedDict):
        api_key: str
        endpoint_url: str

    def main(automatic_data_extraction_resource: automatic_data_extraction, url_to_extract: str) -> Any:
        headers = {
            'Authorization': f"Bearer {automatic_data_extraction_resource['api_key']}"
        }

        # Assuming the API expects a JSON with the URL to extract data from
        payload = {
            'url': url_to_extract
        }

        # Send a POST request to the endpoint to extract data from the specified URL
        response = requests.post(automatic_data_extraction_resource['endpoint_url'], json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the extracted data as JSON
        else:
            response.raise_for_status()  # Raise an exception if there was an error with the request

    # The script ends here, and the 'main' function is ready to be exported and used with the specified parameters.
  id: |-
    synthetic_extract-data-from-url
  instructions: |-
    Extract data from a specified URL in automatic data extraction
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    automatic_data_extraction
  resource_type_def: |-
    class automatic_data_extraction(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Define the resource type for the 'baselinker' integration
    class baselinker(TypedDict):
        api_token: str

    # Define the main function for creating or updating an inventory product
    def main(baselinker_resource: baselinker, product_id: Optional[int] = None, name: str = '', sku: str = '', quantity: int = 0, price: float = 0.0):
        # Import the necessary library for making HTTP requests
        import requests

        # Define the endpoint for creating or updating an inventory product
        endpoint = "https://api.baselinker.com/connector.php"

        # Prepare the request payload
        payload = {
            'token': baselinker_resource['api_token'],
            'method': 'addInventoryProduct' if product_id is None else 'updateInventoryProduct',
            'parameters': {
                'name': name,
                'sku': sku,
                'quantity': quantity,
                'price': price
            }
        }

        # If updating, include the product_id in the parameters
        if product_id is not None:
            payload['parameters']['product_id'] = product_id

        # Make the request to Baselinker API
        response = requests.post(endpoint, json=payload)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the baselinker integration
    class baselinker(TypedDict):
        api_token: str
        endpoint: str

    # Define the main function for adding or updating a product in the BaseLinker catalog
    def main(baselinker_resource: baselinker, product_id: Optional[int], name: str, price: float, quantity: int, description: Optional[str] = None):
        # Construct the API URL
        url = f"{baselinker_resource['endpoint']}/api/addOrUpdateProduct"

        # Prepare the payload for the API request
        payload = {
            'token': baselinker_resource['api_token'],
            'product_id': product_id,
            'name': name,
            'price': price,
            'quantity': quantity,
            'description': description,
        }

        # Remove None values from the payload
        payload = {k: v for k, v in payload.items() if v is not None}

        # Make the API request to add or update the product
        response = requests.post(url, json=payload)

        # Check for a successful response and return the result
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()  # Raise an exception for any HTTP errors

    # Note: The function is ready to use and does not call itself. It assumes that the user will provide the necessary parameters.
  id: |-
    synthetic_create-or-update-inventory-product
  instructions: |-
    It allows you to add a new product to BaseLinker catalog. Entering the product with the ID updates previously saved product. in baselinker
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    baselinker
  resource_type_def: |-
    class baselinker(TypedDict):
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GigasheetClient as GigasheetApiClient } from "npm:gigasheet";

    type Gigasheet = {
        apiKey: string;
        // Add other properties relevant to Gigasheet authentication/configuration
    }

    export async function main(gigasheetResource: Gigasheet, fileId: string, sheetName: string) {
        const client = new GigasheetApiClient(gigasheetResource.apiKey);

        const data = await client.getSheetData(fileId, sheetName);

        return data;
    }
  good: |-
    import { stringify } from "npm:csv-stringify";

    type Gigasheet = {
        apiKey: string,
        baseUrl: string,
        datasetId: string
    }

    export async function main(gigasheetResource: Gigasheet, fileName: string) {
        const { apiKey, baseUrl, datasetId } = gigasheetResource;
        const url = `${baseUrl}/datasets/${datasetId}/export`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Accept': 'text/csv'
            }
        });

        if (!response.ok) {
            throw new Error(`Error exporting dataset: ${response.statusText}`);
        }

        const csvData = await response.text();

        // Assuming the environment where the script runs has a way to handle file creation
        await Deno.writeTextFile(fileName, csvData);

        return { message: `Exported dataset to ${fileName}` };
    }
  id: |-
    synthetic_create-export
  instructions: |-
    Creates an export for a gigasheet dataset in gigasheet
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gigasheet
  resource_type_def: |-
    type Gigasheet = {
        apiKey: string;
        // Add other properties relevant to Gigasheet authentication/configuration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:@std/encoding/base64";

    type Onedesk = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(onedeskResource: Onedesk, userEmail: string, userName: string, userRole: string) {
        // Construct the basic auth header using the API key and secret
        const credentials = `${onedeskResource.apiKey}:${onedeskResource.apiSecret}`;
        const encodedCredentials = encode(credentials);

        // Define the Onedesk API endpoint for creating a user
        const onedeskApiUrl = 'https://api.onedesk.com/users';

        // Prepare the request payload
        const payload = {
            email: userEmail,
            name: userName,
            role: userRole
        };

        // Make the request to Onedesk API to create a user
        const response = await fetch(onedeskApiUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        // Parse the response
        const result = await response.json();

        // Always return the result
        return result;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Onedesk = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(onedeskResource: Onedesk, userEmail: string, userName: string, userRoles: string[]) {
        const authHeader = `Basic ${encode(`${onedeskResource.apiKey}:${onedeskResource.apiSecret}`)}`;
        const response = await fetch('https://api.onedesk.com/users', {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                email: userEmail,
                name: userName,
                roles: userRoles,
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-user
  instructions: |-
    Creates a user or a customer in onedesk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Onedesk
  resource_type_def: |-
    type Onedesk = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bot, GatewayIntentBits } from "npm:discord.js";

    type DiscordBot = {
        token: string;
    }

    export async function main(discordBotResource: DiscordBot, guildId: string, roleName: string, roleColor: string, intents: GatewayIntentBits[]) {
        const bot = new Bot({
            token: discordBotResource.token,
            intents: intents
        });

        try {
            await bot.login();

            const guild = await bot.guilds.fetch(guildId);
            if (!guild) {
                throw new Error(`Guild with ID ${guildId} not found.`);
            }

            const role = await guild.roles.create({
                name: roleName,
                color: roleColor,
                reason: `Role ${roleName} created by script.`,
            });

            return { success: true, roleId: role.id };
        } catch (error) {
            return { success: false, error: error.message };
        } finally {
            bot.destroy();
        }
    }
  good: |-
    // Import any libraries you need here
    import { GatewayIntentBits, Partials, REST, Routes } from "npm:discord.js";

    type DiscordBot = {
        token: string,
        clientId: string,
        guildId: string
    }

    export async function main(discordBotResource: DiscordBot, userId: string, roleId: string) {
        // Initialize Discord REST client with the bot token
        const rest = new REST({ version: '10' }).setToken(discordBotResource.token);

        // Add the role to the user in the guild
        try {
            await rest.put(Routes.guildMemberRole(discordBotResource.guildId, userId, roleId));
            return { success: true, message: `Role ${roleId} has been assigned to user ${userId}.` };
        } catch (error) {
            return { success: false, message: `Failed to assign role: ${error}` };
        }
    }
  id: |-
    synthetic_add-role
  instructions: |-
    Assign a role to a user. Remember that your bot requires the `MANAGE_ROLES` permission in discord bot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DiscordBot
  resource_type_def: |-
    type DiscordBot = {
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode as base64Encode } from "npm:@stablelib/base64";

    type Baselinker = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(
        baselinkerResource: Baselinker,
        orderId: number,
        newStatusId: number
    ) {
        const { apiKey, apiUrl } = baselinkerResource;

        const requestBody = {
            token: apiKey,
            method: 'setOrderStatus',
            parameters: JSON.stringify({
                order_id: orderId,
                status_id: newStatusId
            })
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams(requestBody).toString()
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        return result;
    }
  good: |-
    // Import any libraries you need here
    import fetch from "npm:node-fetch";

    type Baselinker = {
        token: string;
    }

    export async function main(baselinkerResource: Baselinker, orderId: number, newStatusId: number) {
        const baseUrl = 'https://api.baselinker.com/connector.php';

        const requestBody = {
            token: baselinkerResource.token,
            method: 'setOrderStatus',
            parameters: JSON.stringify({
                order_id: orderId,
                status_id: newStatusId
            })
        };

        const response = await fetch(baseUrl, {
            method: 'POST',
            body: new URLSearchParams(requestBody),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_update-order-status
  instructions: |-
    It allows you to change order status. in baselinker
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Baselinker
  resource_type_def: |-
    type Baselinker = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Buffer } from "npm:buffer";

    type Gigasheet = {
        apiKey: string,
        sheetId: string
    }

    export async function main(gigasheetResource: Gigasheet, dataUrl: string) {
        // Fetch the data from the provided URL
        const response = await fetch(dataUrl);
        if (!response.ok) {
            throw new Error(`Failed to fetch data from URL: ${dataUrl}`);
        }
        const data = await response.arrayBuffer();

        // Convert the data to a Buffer for Gigasheet API
        const buffer = Buffer.from(data);

        // Prepare the request for Gigasheet API
        const uploadUrl = `https://api.gigasheet.com/v1/sheets/${gigasheetResource.sheetId}/import`;
        const options = {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${gigasheetResource.apiKey}`,
                'Content-Type': 'text/csv'
            },
            body: buffer
        };

        // Send the request to Gigasheet API
        const uploadResponse = await fetch(uploadUrl, options);
        if (!uploadResponse.ok) {
            throw new Error(`Failed to upload data to Gigasheet: ${await uploadResponse.text()}`);
        }

        // Return the result of the upload
        return await uploadResponse.json();
    }
  good: |-
    import { Buffer } from "npm:buffer";

    type Gigasheet = {
        apiKey: string,
        sheetId: string
    }

    export async function main(gigasheetResource: Gigasheet, dataUrl: string, contentType: string = 'text/csv') {
        const { apiKey, sheetId } = gigasheetResource;

        // Fetch the data from the provided URL
        const response = await fetch(dataUrl);
        if (!response.ok) {
            throw new Error(`Failed to fetch data from URL: ${dataUrl}`);
        }
        const data = await response.arrayBuffer();

        // Prepare the request to upload data to Gigasheet
        const uploadUrl = `https://api.gigasheet.com/v1/sheets/${sheetId}/import`;
        const headers = {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': contentType
        };
        const body = Buffer.from(data);

        // Upload the data to Gigasheet
        const uploadResponse = await fetch(uploadUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!uploadResponse.ok) {
            throw new Error(`Failed to upload data to Gigasheet: ${uploadResponse.statusText}`);
        }

        // Return the result of the upload operation
        return await uploadResponse.json();
    }
  id: |-
    synthetic_upload-data-from-url
  instructions: |-
    Uploads data from a URL to Gigasheet in gigasheet
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gigasheet
  resource_type_def: |-
    type Gigasheet = {
        apiKey: string,
        sheetId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Client } from "npm:@supabase/supabase-js";

    type Dbt = {
        supabaseUrl: string;
        supabaseKey: string;
    }

    export async function main(dbtResource: Dbt, jobId: string) {
        // Initialize Supabase client
        const supabase = new Client(dbtResource.supabaseUrl, dbtResource.supabaseKey);

        // Fetch the run details from the Supabase job table
        const { data, error } = await supabase
            .from('dbt_runs')
            .select('*')
            .eq('id', jobId)
            .single();

        if (error) {
            throw error;
        }

        // Return the run details
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Dbt = {
        account_id: string;
        job_id: string;
        run_id: string;
        personal_access_token: string;
    }

    export async function main(dbtResource: Dbt) {
        const url = `https://cloud.getdbt.com/api/v2/accounts/${dbtResource.account_id}/runs/${dbtResource.run_id}/`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Token ${dbtResource.personal_access_token}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-run
  instructions: |-
    Retrieve information about a run in dbt
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dbt
  resource_type_def: |-
    type Dbt = {
        supabaseUrl: string;
        supabaseKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Client } from "npm:@linkedin/restli-client";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, organizationName: string) {
        // Initialize the LinkedIn client with the access token
        const client = new Client({ accessToken: linkedinResource.accessToken });

        // Define the endpoint for organization search
        const endpoint = 'https://api.linkedin.com/v2/organizations';

        // Set up the parameters for the search query
        const params = {
            q: 'universalName',
            universalName: organizationName,
            projection: '(elements*(organization))'
        };

        // Perform the search using the LinkedIn client
        const response = await client.request({
            method: 'GET',
            url: endpoint,
            params: params
        });

        // Return the search results
        return response.data;
    }
  good: |-
    import { Client } from "npm:@linkedin/rest-api-client";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, vanityName: string, emailDomain: string) {
        const client = new Client({ accessToken: linkedinResource.accessToken });

        let organization;

        if (vanityName) {
            organization = await client.organization.getOrganizationByVanityName(vanityName);
        } else if (emailDomain) {
            organization = await client.organization.getOrganizationByEmailDomain(emailDomain);
        } else {
            throw new Error("Either vanityName or emailDomain must be provided.");
        }

        return organization;
    }
  id: |-
    synthetic_search-organization
  instructions: |-
    Searches for an organization by vanity name or email domain in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed to make HTTP calls to Adalo API

    class adalo(TypedDict):
        app_id: str
        api_key: str

    def main(adalo_resource: adalo, collection_name: str) -> List[Any]:
        base_url = "https://api.adalo.com/apps"
        headers = {
            "Authorization": f"Bearer {adalo_resource['api_key']}"
        }

        response = requests.get(f"{base_url}/{adalo_resource['app_id']}/collections/{collection_name}", headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json()
  good: |-
    from typing import TypedDict, List, Any

    # Define the resource type for the 'adalo' integration
    class adalo(TypedDict):
        api_key: str
        app_id: str

    # Define the main function for the 'adalo' integration
    def main(adalo_resource: adalo, table_name: str, filters: dict = None) -> List[Any]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for fetching records from a specific table
        endpoint = f"https://api.adalo.com/apps/{adalo_resource['app_id']}/collections/{table_name}"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {adalo_resource['api_key']}"
        }

        # Prepare the parameters for filtering if provided
        params = filters if filters else {}

        # Make the GET request to the Adalo API to fetch records
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of records
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Example usage:
    # records = main(adalo_resource={'api_key': 'your_api_key', 'app_id': 'your_app_id'}, table_name='your_table_name')
    # print(records)
  id: |-
    synthetic_get-records
  instructions: |-
    Get all records from a collection in adalo
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    adalo
  resource_type_def: |-
    class adalo(TypedDict):
        api_key: str
        app_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleCalendar = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(
        googleCalendarResource: GoogleCalendar,
        calendarId: string,
        timeMin: string,
        timeMax: string
    ) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleCalendarResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

        const response = await calendar.freebusy.query({
            requestBody: {
                timeMin: timeMin,
                timeMax: timeMax,
                items: [{ id: calendarId }],
            },
        });

        return response.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleCalendar = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(
        googleCalendarResource: GoogleCalendar,
        calendarId: string,
        timeMin: string,
        timeMax: string
    ) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleCalendarResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const calendar = google.calendar({ version: 'v3', auth: oauth2Client });
        const response = await calendar.freebusy.query({
            requestBody: {
                timeMin: timeMin,
                timeMax: timeMax,
                items: [{ id: calendarId }],
            },
        });

        return response.data;
    }
  id: |-
    synthetic_query-free-busy-calendars
  instructions: |-
    Retrieve free/busy calendar details from Google Calendar in google calendar
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleCalendar
  resource_type_def: |-
    type GoogleCalendar = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type Bitbucket = {
        username: string;
        appPassword: string;
        repoSlug: string;
        workspace: string;
    }

    export async function main(bitbucketResource: Bitbucket, issueId: number) {
        const { username, appPassword, repoSlug, workspace } = bitbucketResource;
        const authString = Buffer.from(`${username}:${appPassword}`).toString('base64');

        const response = await request('GET /2.0/repositories/{workspace}/{repo_slug}/issues/{issue_id}', {
            headers: {
                Authorization: `Basic ${authString}`
            },
            workspace: workspace,
            repo_slug: repoSlug,
            issue_id: issueId
        });

        return response.data;
    }
  good: |-
    import { Bitbucket as BitbucketClient } from "npm:@bitbucket/client";

    type Bitbucket = {
        username: string;
        password: string;
    }

    export async function main(bitbucketConfig: Bitbucket, workspace: string, repoSlug: string, issueId: number) {
        const bitbucket = new BitbucketClient({
            auth: {
                username: bitbucketConfig.username,
                password: bitbucketConfig.password,
            },
        });

        const response = await bitbucket.issues.get({
            repo_slug: repoSlug,
            workspace: workspace,
            issue_id: issueId,
        });

        return response.data;
    }
  id: |-
    synthetic_get-issue
  instructions: |-
    Get a issue in bitbucket
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bitbucket
  resource_type_def: |-
    type Bitbucket = {
        username: string;
        password: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Storage } from "npm:@google-cloud/storage";

    type GoogleCloud = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(googleCloudResource: GoogleCloud) {
        const storage = new Storage({
            projectId: googleCloudResource.projectId,
            credentials: {
                client_email: googleCloudResource.clientEmail,
                private_key: googleCloudResource.privateKey,
            },
        });

        try {
            const [buckets] = await storage.getBuckets();
            return buckets.map(bucket => bucket.name);
        } catch (error) {
            console.error('Error fetching buckets:', error);
            throw error;
        }
    }
  good: |-
    import { Storage } from "npm:@google-cloud/storage";

    type GoogleCloud = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(googleCloudResource: GoogleCloud) {
        const storage = new Storage({
            projectId: googleCloudResource.projectId,
            credentials: {
                client_email: googleCloudResource.clientEmail,
                private_key: googleCloudResource.privateKey,
            },
        });

        try {
            const [buckets] = await storage.getBuckets();
            return buckets.map(bucket => bucket.name);
        } catch (error) {
            console.error('Error fetching buckets:', error);
            throw error;
        }
    }
  id: |-
    synthetic_list-buckets
  instructions: |-
    List Google Cloud Storage buckets, in google cloud
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleCloud
  resource_type_def: |-
    type GoogleCloud = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOutlook = {
        clientId: string;
        clientSecret: string;
        tenantId: string;
        accessToken: string;
    }

    export async function main(outlookResource: MicrosoftOutlook, contactId: string, updateFields: { [key: string]: any }) {
        const client = Client.init({
            authProvider: (done) => {
                done(null, outlookResource.accessToken); // Here we are providing the access token to the Microsoft Graph client
            }
        });

        try {
            const updatedContact = await client.api(`/me/contacts/${contactId}`)
                .header("Content-Type", "application/json")
                .update(updateFields);

            return updatedContact;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOutlook = {
        clientId: string;
        tenantId: string;
        clientSecret: string;
        accessToken: string; // Assuming OAuth2 flow has been completed and we have an access token
    }

    export async function main(outlookResource: MicrosoftOutlook, givenName: string, surname: string, emailAddresses: { address: string, name?: string }[], businessPhones?: string[], jobTitle?: string, companyName?: string) {
        // Initialize the Microsoft Graph client
        const client = Client.init({
            authProvider: (done) => {
                done(null, outlookResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Create a contact object
        const newContact = {
            givenName: givenName,
            surname: surname,
            emailAddresses: emailAddresses,
            businessPhones: businessPhones,
            jobTitle: jobTitle,
            companyName: companyName
        };

        // Add the contact to the root Contacts folder
        const result = await client.api('/me/contacts').post(newContact);

        // Return the result which is the newly created contact
        return result;
    }
  id: |-
    synthetic_update-contact
  instructions: |-
    Add a contact to the root Contacts folder, in microsoft outlook
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftOutlook
  resource_type_def: |-
    type MicrosoftOutlook = {
        clientId: string;
        clientSecret: string;
        tenantId: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed to make HTTP calls to Jira's API

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, user_account_id: str) -> Any:
        # Construct the API endpoint for getting user details
        api_endpoint = f"{jira_resource['base_url']}/rest/api/3/user?accountId={user_account_id}"

        # Set up the headers with authorization
        headers = {
            "Accept": "application/json",
            "Authorization": f"Basic {jira_resource['api_token']}"
        }

        # Make the request to Jira's API
        response = requests.get(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the user details
            return response.json()
        else:
            # Handle errors (e.g., user not found, bad credentials, etc.)
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP calls to Jira

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, user_account_id: str) -> Dict[str, Any]:
        # Construct the API endpoint for getting user information
        endpoint = f"{jira_resource['base_url']}/rest/api/3/user"
        headers = {
            "Accept": "application/json",
            "Authorization": f"Basic {jira_resource['api_token']}"
        }
        params = {
            "accountId": user_account_id
        }

        # Make the HTTP request to Jira to get the user information
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the user information as a dictionary
        else:
            response.raise_for_status()  # Raise an HTTPError if the call to Jira failed

    # Note: The main function is not called here, as per the instructions.
  id: |-
    synthetic_get-user
  instructions: |-
    Gets details of user, in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import askyourpdf_client  # hypothetical library for askyourpdf integration

    # Rename the imported method if it conflicts with the resource type name
    askyourpdf_api = askyourpdf_client.askyourpdf

    class askyourpdf(TypedDict):
        api_key: str
        api_secret: str

    def main(askyourpdf_resource: askyourpdf, document_id: str, query: str) -> Any:
        client = askyourpdf_api(api_key=askyourpdf_resource['api_key'], api_secret=askyourpdf_resource['api_secret'])
        chat_response = client.chat_with_document(document_id=document_id, query=query)
        return chat_response
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'askyourpdf' integration
    class askyourpdf(TypedDict):
        api_key: str  # Assuming API key is needed for authentication

    # Define the main function with the resource type and additional parameters
    def main(askyourpdf_resource: askyourpdf, document_path: str, question: str):
        # Import the necessary library for handling HTTP requests
        import requests

        # Define the endpoint for the 'askyourpdf' integration
        endpoint = "https://api.askyourpdf.com/v1/query"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {askyourpdf_resource['api_key']}"
        }

        # Prepare the data payload with the document and the question
        data = {
            "document_path": document_path,
            "question": question
        }

        # Make the HTTP POST request to the 'askyourpdf' API
        response = requests.post(endpoint, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # Note: The function is not called here, it is only defined for use elsewhere.
  id: |-
    synthetic_chat-with-document
  instructions: |-
    Chat with a document in askyourpdf
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    askyourpdf
  resource_type_def: |-
    class askyourpdf(TypedDict):
        api_key: str  # Assuming API key is needed for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Ipdata } from "npm:ipdata";

    type IpdataCo = {
        apiKey: string;
    }

    export async function main(ipdataResource: IpdataCo, ipAddress: string) {
        const ipdata = new Ipdata(ipdataResource.apiKey);
        const response = await ipdata.lookup(ipAddress);
        return response;
    }
  good: |-
    import { fetch } from "npm:@deno/fetch";

    type IpdataCo = {
        apiKey: string;
    }

    export async function main(ipdataCoResource: IpdataCo, ipAddress: string) {
        const url = `https://api.ipdata.co/${encodeURIComponent(ipAddress)}`;
        const response = await fetch(url, {
            headers: {
                "Authorization": `Bearer ${ipdataCoResource.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-ip-data
  instructions: |-
    Lookup a specific IP Address in ipdata co
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    IpdataCo
  resource_type_def: |-
    type IpdataCo = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    class fibery(TypedDict):
        api_token: str
        workspace_id: str

    def main(fibery_resource: fibery, entity_type: str, fields: List[str]) -> List[dict]:
        import requests  # Import here to avoid conflicts with parameter names

        base_url = f"https://{fibery_resource['workspace_id']}.fibery.io/api/"
        headers = {
            "Authorization": f"Token {fibery_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Construct the API endpoint for listing entities of a specific type
        list_entities_url = f"{base_url}commands/entity/query"

        # Prepare the payload for the request
        payload = {
            "q": {
                "select": fields,
                "from": entity_type
            }
        }

        # Make the request to list entities
        response = requests.post(list_entities_url, json=payload, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP error responses

        # Return the list of entities
        return response.json()

    # Example usage:
    # result = main(fibery_resource={'api_token': 'your_api_token', 'workspace_id': 'your_workspace_id'}, entity_type='EntityType', fields=['field1', 'field2'])
    # print(result)
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the fibery integration
    class fibery(TypedDict):
        api_token: str
        workspace_id: str

    # Import any libraries needed for the integration
    import requests

    def main(fibery_resource: fibery, entity_type: str) -> List[str]:
        # Construct the API endpoint for listing types in Fibery account
        api_url = f"https://api.fibery.io/v1/{fibery_resource['workspace_id']}/types"

        # Set up the headers with the API token for authentication
        headers = {
            "Authorization": f"Token {fibery_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Make the request to the Fibery API
        response = requests.get(api_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON to get the list of types
            types_data = response.json()
            # Filter the types based on the entity_type parameter
            filtered_types = [t['name'] for t in types_data if entity_type in t['name']]
            # Return the filtered list of types
            return filtered_types
        else:
            # If the request failed, raise an exception with the error message
            raise Exception(f"Failed to list types in Fibery account: {response.text}")

    # Example usage:
    # result = main(fibery_resource={'api_token': 'your_api_token', 'workspace_id': 'your_workspace_id'}, entity_type='your_entity_type')
    # print(result)
  id: |-
    synthetic_list-types
  instructions: |-
    Lists types in account in fibery
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    fibery
  resource_type_def: |-
    class fibery(TypedDict):
        api_token: str
        workspace_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the lemlist integration
    class lemlist(TypedDict):
        api_key: str

    # Define the main function for resuming leads from all campaigns
    def main(lemlist_resource: lemlist, campaign_ids: List[str]):
        import requests  # Import requests or any other library if needed

        # Base URL for lemlist API
        base_url = "https://api.lemlist.com/api"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {lemlist_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Iterate over each campaign ID and resume leads
        for campaign_id in campaign_ids:
            # Endpoint to resume leads for a campaign
            resume_leads_endpoint = f"{base_url}/campaigns/{campaign_id}/actions/resume-leads"

            # Make the POST request to resume leads
            response = requests.post(resume_leads_endpoint, headers=headers)

            # Check if the request was successful
            if response.status_code != 200:
                raise Exception(f"Failed to resume leads for campaign {campaign_id}: {response.text}")

        # Return a success message
        return "Successfully resumed leads for all specified campaigns."

    # Example usage:
    # result = main(lemlist_resource={'api_key': 'your_api_key'}, campaign_ids=['campaign_id_1', 'campaign_id_2'])
    # print(result)
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to lemlist API

    class lemlist(TypedDict):
        api_key: str

    def main(lemlist_resource: lemlist, lead_email: str, campaign_ids: List[str]) -> List[dict]:
        base_url = "https://api.lemlist.com/api"
        headers = {
            "Authorization": f"Bearer {lemlist_resource['api_key']}",
            "Content-Type": "application/json"
        }

        results = []
        for campaign_id in campaign_ids:
            url = f"{base_url}/campaigns/{campaign_id}/actions/start"
            payload = {"email": lead_email}
            response = requests.post(url, json=payload, headers=headers)
            results.append(response.json())

        return results
  id: |-
    synthetic_resume-lead-from-all-campaigns
  instructions: |-
    This action starts a specific lead using its email in all campaigns in lemlist
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    lemlist
  resource_type_def: |-
    class lemlist(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the brex integration
    class brex(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for setting the monthly limit for a user in brex
    def main(brex_resource: brex, user_id: str, monthly_limit: float) -> dict:
        # Assuming there is a library to interact with brex API
        import brex_api_client as brex_client

        # Initialize the brex API client with the provided credentials
        client = brex_client.Client(api_key=brex_resource['api_key'], api_secret=brex_resource['api_secret'])

        # Set the monthly limit for the user
        result = client.set_user_monthly_limit(user_id=user_id, limit=monthly_limit)

        # Return the result of the operation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'brex' integration
    class brex(TypedDict):
        api_key: str
        account_id: str

    def main(brex_resource: brex, user_id: str, limit_amount: float) -> dict:
        # Assuming 'requests' is needed for HTTP requests
        import requests as http_requests

        # Construct the API endpoint for setting a user limit
        endpoint = f"https://api.brex.com/cards/users/{user_id}/limits"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {brex_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the limit amount
        payload = {
            "limit_amount": limit_amount,
            "currency": "USD"  # Assuming the currency is USD
        }

        # Make the HTTP request to set the limit for the user
        response = http_requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return {"success": True, "message": "Limit set successfully", "data": response.json()}
        else:
            return {"success": False, "message": "Failed to set limit", "error": response.text}

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_set-limit-for-user
  instructions: |-
    Sets the monthly limit for a user. in brex
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    brex
  resource_type_def: |-
    class brex(TypedDict):
        api_key: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import os
    from helper_functions import download_file as download_file_helper

    class helper_functions(TypedDict):
        api_key: str
        base_url: str

    def main(helper_functions_resource: helper_functions, file_url: str, destination: str = '/tmp'):
        file_path = os.path.join(destination, os.path.basename(file_url))
        download_file_helper(file_url, file_path, helper_functions_resource['api_key'], helper_functions_resource['base_url'])
        return file_path
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to download the file

    # Define the resource type for the 'helper_functions' integration
    class helper_functions(TypedDict):
        api_key: str
        base_url: str

    def main(helper_functions_resource: helper_functions, file_url: str, destination_path: str) -> bool:
        headers = {
            'Authorization': f"Bearer {helper_functions_resource['api_key']}"
        }
        response = requests.get(f"{helper_functions_resource['base_url']}/{file_url}", headers=headers)

        if response.status_code == 200:
            with open(destination_path, 'wb') as file:
                file.write(response.content)
            return True
        else:
            return False
  id: |-
    synthetic_download-file-to-tmp
  instructions: |-
    Downloads a file to in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        toAddresses: string[],
        fromAddress: string,
        subject: string,
        bodyHtml: string,
        bodyText: string
    ) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Destination: {
                ToAddresses: toAddresses,
            },
            Message: {
                Body: {
                    Html: {
                        Charset: "UTF-8",
                        Data: bodyHtml,
                    },
                    Text: {
                        Charset: "UTF-8",
                        Data: bodyText,
                    },
                },
                Subject: {
                    Charset: 'UTF-8',
                    Data: subject,
                },
            },
            Source: fromAddress,
        };

        try {
            const data = await ses.sendEmail(params);
            return data;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        templateName: string,
        subjectPart: string,
        textPart: string,
        htmlPart: string
    ) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Template: {
                TemplateName: templateName,
                SubjectPart: subjectPart,
                TextPart: textPart,
                HtmlPart: htmlPart,
            }
        };

        try {
            const result = await ses.createTemplate(params);
            return result;
        } catch (error) {
            console.error("Error creating email template:", error);
            throw error;
        }
    }
  id: |-
    synthetic_create-email-template
  instructions: |-
    Create a HTML or a plain text email template in amazon ses
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AmazonSes
  resource_type_def: |-
    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the nocrm_io integration
    class nocrm_io(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for the nocrm_io integration
    def main(nocrm_io_resource: nocrm_io, lead_id: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for getting a lead
        api_endpoint = f"https://{nocrm_io_resource['subdomain']}.nocrm.io/api/v2/leads/{lead_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Token {nocrm_io_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the GET request to retrieve the lead information
        response = requests.get(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the lead information as a dictionary
            return response.json()
        else:
            # Handle errors (e.g., lead not found, authentication error)
            response.raise_for_status()

    # The main function is now defined and can be used with the required parameters.
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the nocrm_io integration
    class nocrm_io(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the nocrm_io integration
    def main(nocrm_io_resource: nocrm_io, lead_id: str) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for getting a lead
        api_endpoint = f"https://api.nocrm.io/v1/leads/{lead_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Token {nocrm_io_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the API request to get the lead information
        response = requests.get(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the lead information as a dictionary
            return response.json()
        else:
            # Handle errors (e.g., lead not found, authentication error)
            response.raise_for_status()

    # The main function is not called here, as per the instructions.
  id: |-
    synthetic_get-lead
  instructions: |-
    Get a lead in nocrm io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nocrm_io
  resource_type_def: |-
    class nocrm_io(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { InstagramBusiness as InstagramBusinessAPI } from 'npm:@types/instagram-private-api'; // Renamed to avoid conflict

    // Define the resource type for InstagramBusiness integration
    type InstagramBusiness = {
        accessToken: string; // OAuth2 access token
        clientId: string;    // Instagram App client ID
        clientSecret: string;// Instagram App client secret
    };

    // Define the main function to list media comments
    export async function main(instagramResource: InstagramBusiness, mediaId: string) {
        // Initialize the Instagram Business API client with the provided credentials
        const instagramClient = new InstagramBusinessAPI({
            accessToken: instagramResource.accessToken,
            clientId: instagramResource.clientId,
            clientSecret: instagramResource.clientSecret,
        });

        // Fetch the comments for the specified media ID
        const comments = await instagramClient.getMediaComments(mediaId);

        // Return the comments
        return comments;
    }
  good: |-
    import { InstagramBusiness } from 'npm:@types/instagram-private-api';

    type InstagramBusinessResource = {
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(instagramResource: InstagramBusinessResource, mediaObjectId: string) {
        const url = `https://graph.facebook.com/v14.0/${mediaObjectId}/comments?access_token=${instagramResource.accessToken}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_list-media-comments
  instructions: |-
    List comments on a media object in instagram business
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    InstagramBusiness
  resource_type_def: |-
    type InstagramBusiness = {
        accessToken: string; // OAuth2 access token
        clientId: string;    // Instagram App client ID
        clientSecret: string;// Instagram App client secret
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to the Moosend API

    # Define the resource type for the Moosend integration
    class moosend(TypedDict):
        api_key: str  # API key for authentication

    def main(moosend_resource: moosend, email: str, name: str, list_id: str) -> Any:
        # Construct the API endpoint for adding a subscriber
        url = f"https://api.moosend.com/v3/subscribers/{list_id}/subscribe.json"

        # Prepare the payload with the subscriber's details
        payload = {
            'Email': email,
            'Name': name,
            'HasExternalDoubleOptIn': False,  # Assuming we don't want double opt-in for this script
        }

        # Prepare the headers including the API key for authentication
        headers = {
            'Content-Type': 'application/json',
            'apikey': moosend_resource['api_key']
        }

        # Make the POST request to add the subscriber
        response = requests.post(url, json=payload, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests library is used for HTTP requests

    # Define the resource type for the moosend integration
    class moosend(TypedDict):
        api_key: str
        mailing_list_id: str

    # Define the main function for adding or updating a subscriber in a moosend mailing list
    def main(moosend_resource: moosend, email: str, name: Optional[str] = None):
        # Construct the API endpoint for adding/updating a subscriber
        url = f"https://api.moosend.com/v3/subscribers/{moosend_resource['mailing_list_id']}/subscribe.json"

        # Prepare the payload with the subscriber's details
        payload = {
            'Email': email,
            'Name': name,
            'ApiKey': moosend_resource['api_key']
        }

        # Make the POST request to the moosend API
        response = requests.post(url, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # Example usage (do not include this in the script):
    # result = main(moosend_resource={'api_key': 'your_api_key', 'mailing_list_id': 'your_mailing_list_id'}, email='subscriber_email', name='subscriber_name')
  id: |-
    synthetic_add-subscriber
  instructions: |-
    Adds a new subscriber to the specified mailing list. If there is already a subscriber with the specified email address in the list, an update will be performed instead. The rate limit for this request is 10 requests per 10 seconds (*per API key). See the for more info. in moosend
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    moosend
  resource_type_def: |-
    class moosend(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SafeBrowsingClient } from "npm:@google-cloud/safebrowsing";

    type GoogleSafebrowsing = {
        apiKey: string;
    }

    export async function main(googleSafebrowsingResource: GoogleSafebrowsing, urls: string[]) {
        const client = new SafeBrowsingClient({ apiKey: googleSafebrowsingResource.apiKey });

        const threatMatches = await client.searchThreatLists({ urls });

        return threatMatches;
    }
  good: |-
    import { SafeBrowsingClient } from "npm:@google-cloud/safebrowsing";

    type GoogleSafebrowsing = {
        apiKey: string;
    }

    export async function main(googleSafebrowsingResource: GoogleSafebrowsing, urlToCheck: string) {
        const client = new SafeBrowsingClient({ apiKey: googleSafebrowsingResource.apiKey });
        const threatInfo = {
            threatTypes: ['MALWARE', 'SOCIAL_ENGINEERING'],
            platformTypes: ['ANY_PLATFORM'],
            threatEntryTypes: ['URL'],
            threatEntries: [{ url: urlToCheck }],
        };

        try {
            const { threatMatches } = await client.searchThreatLists({ threatInfo });
            return {
                isSafe: threatMatches.length === 0,
                threatMatches: threatMatches,
            };
        } catch (error) {
            throw new Error(`Error checking URL safety: ${error.message}`);
        }
    }
  id: |-
    synthetic_check-url-safety
  instructions: |-
    Scan a given URL or URLs for potential security threats in google safebrowsing
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSafebrowsing
  resource_type_def: |-
    type GoogleSafebrowsing = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import databox  # Assuming databox is a library for the integration

    class databox(TypedDict):
        token: str

    def main(databox_resource: databox, custom_data: Dict[str, Any]):
        # Assuming there is a Databox client that uses the token for authentication
        # and a method to send custom data
        client = databox.Client(databox_resource['token'])
        result = client.insert_all(custom_data)
        return result
  good: |-
    from typing import TypedDict, Any, Dict
    import databox as dbx  # Renamed imported databox to dbx to avoid conflict

    class databox(TypedDict):
        token: str

    def main(databox_resource: databox, custom_data: Dict[str, Any]):
        client = dbx.Client(databox_resource['token'])
        result = client.insert_all(custom_data)
        return result
  id: |-
    synthetic_send-custom-data
  instructions: |-
    Sends custom data in databox
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    databox
  resource_type_def: |-
    class databox(TypedDict):
        token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { NLP as LettriaNLP } from "npm:@lettria/nlp";

    type Lettria = {
        apiKey: string;
    }

    export async function main(lettriaResource: Lettria, textToClassify: string) {
        const nlp = new LettriaNLP(lettriaResource.apiKey);

        const classification = await nlp.classify(textToClassify);

        return classification;
    }
  good: |-
    // Importing the required npm library for Lettria
    import { NLP } from "npm:@lettria/nlp";

    type Lettria = {
        apiKey: string;
    }

    export async function main(lettriaResource: Lettria, textToClassify: string) {
        // Initialize the Lettria NLP client with the provided API key
        const nlp = new NLP(lettriaResource.apiKey);

        // Classify the provided text
        const classificationResult = await nlp.classify(textToClassify);

        // Return the classification result
        return classificationResult;
    }
  id: |-
    synthetic_classify-text
  instructions: |-
    Classify one text. in lettria
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lettria
  resource_type_def: |-
    type Lettria = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Memberspot = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(memberspotResource: Memberspot, memberId: string) {
        const credentials = `${memberspotResource.apiKey}:${memberspotResource.apiSecret}`;
        const encodedCredentials = encode(credentials);

        const response = await fetch(`https://api.memberspot.com/v1/members/${memberId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error deleting member: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Memberspot = {
        apiKey: string;
        organizationId: string;
    }

    export async function main(memberspotResource: Memberspot, userEmail: string) {
        const url = `https://api.memberspot.com/v1/organizations/${memberspotResource.organizationId}/users`;

        // Fetch the list of users to find the user ID associated with the email
        const usersResponse = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${memberspotResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!usersResponse.ok) {
            throw new Error(`Failed to retrieve users: ${usersResponse.statusText}`);
        }

        const users = await usersResponse.json();
        const user = users.find((u: any) => u.email === userEmail);

        if (!user) {
            throw new Error(`User with email ${userEmail} not found.`);
        }

        // Delete the user by ID
        const deleteResponse = await fetch(`${url}/${user.id}`, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${memberspotResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!deleteResponse.ok) {
            throw new Error(`Failed to delete user: ${deleteResponse.statusText}`);
        }

        return { message: `User with email ${userEmail} has been deleted successfully.` };
    }
  id: |-
    synthetic_delete-access
  instructions: |-
    Delete access of a user by email in memberspot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Memberspot
  resource_type_def: |-
    type Memberspot = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OpenAI as OpenAIClient } from "npm:openai";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, directory: string) {
        const openai = new OpenAIClient(openaiResource.apiKey);

        const response = await openai.files.list({
            purpose: 'answers',
            user_provided_metadata: directory
        });

        return response.data;
    }
  good: |-
    // Import any libraries you need here
    import { GPT3 } from "npm:@openai/sdk";

    type Openai = {
        apiKey: string;
        organization: string;
    }

    export async function main(openaiResource: Openai) {
        // Initialize the OpenAI SDK with the provided API key and organization
        const openai = new GPT3({
            apiKey: openaiResource.apiKey,
            organization: openaiResource.organization
        });

        // Fetch the list of files
        const response = await openai.files.list();

        // Filter the files that belong to the user's organization
        const organizationFiles = response.data.filter(file => file.organization === openaiResource.organization);

        // Return the list of files
        return organizationFiles;
    }
  id: |-
    synthetic_list-files
  instructions: |-
    Returns a list of files that belong to the user's organization in openai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import alpaca_trade_api as tradeapi

    # Rename the imported method if it conflicts with the resource type name
    AlpacaAPI = tradeapi.REST

    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca, symbol: str = None):
        api = AlpacaAPI(alpaca_resource['api_key'], alpaca_resource['api_secret'], alpaca_resource['base_url'])

        if symbol:
            orders = api.list_orders(status='open', after=None, until=None, limit=None, direction=None, nested=None, symbols=[symbol])
        else:
            orders = api.list_orders(status='open')

        results = []
        for order in orders:
            result = api.cancel_order(order.id)
            results.append(result)

        return results
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the Alpaca API

    # Define the resource type for the Alpaca integration
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca) -> List[dict]:
        # Set up the headers for authentication
        headers = {
            'APCA-API-KEY-ID': alpaca_resource['api_key'],
            'APCA-API-SECRET-KEY': alpaca_resource['api_secret']
        }

        # Define the endpoint for canceling all orders
        endpoint = f"{alpaca_resource['base_url']}/v2/orders"

        # Send a DELETE request to cancel all open orders
        response = requests.delete(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response as a list of dictionaries, one for each order
            return response.json()
        else:
            # If the request was not successful, raise an exception with the error
            raise Exception(f"Failed to cancel orders: {response.status_code} - {response.text}")

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_cancel-all-orders
  instructions: |-
    Attempts to cancel all open orders. A response will be provided for each order that is attempted to be cancelled. If an order is no longer cancelable, the server reject the request, in alpaca
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    alpaca
  resource_type_def: |-
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'firmao' integration
    class firmao(TypedDict):
        api_key: str
        user_id: str

    # Define the main function for creating an offer
    def main(firmao_resource: firmao, offer_title: str, client_id: int, offer_description: str = '', offer_value: float = 0.0):
        # Assuming there's a library to interact with the Firmao API
        from firmao_api import create_offer  # If this conflicts with an existing name, rename as needed

        # Use the credentials from the resource to authenticate with the Firmao API
        api_key = firmao_resource['api_key']
        user_id = firmao_resource['user_id']

        # Create the offer using the Firmao API
        result = create_offer(api_key, user_id, offer_title, client_id, offer_description, offer_value)

        # Return the result of the offer creation
        return result

    # The script ends here, with no calls to the main function as per the instructions.
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'firmao' integration
    class firmao(TypedDict):
        api_key: str
        user_id: str

    # Define the main function for creating a new quote/offer in firmao
    def main(firmao_resource: firmao, customer_id: int, offer_details: dict, additional_info: str = "") -> Any:
        # Assuming there's a library to interact with firmao API
        import firmao_api_client

        # Create the offer in firmao using the provided details
        offer = firmao_api_client.create_offer(
            api_key=firmao_resource['api_key'],
            user_id=firmao_resource['user_id'],
            customer_id=customer_id,
            offer_details=offer_details,
            additional_info=additional_info
        )

        # Return the result of the offer creation
        return offer
  id: |-
    synthetic_create-offer
  instructions: |-
    Create a new quote/offer in firmao
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    firmao
  resource_type_def: |-
    class firmao(TypedDict):
        api_key: str
        user_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOnedrive = {
        accessToken: string;
    }

    export async function main(onDriveResource: MicrosoftOnedrive, folderName: string, parentFolderId: string = 'root') {
        const client = Client.init({
            authProvider: (done) => {
                done(null, onDriveResource.accessToken); // Here we are providing the access token to the authProvider callback
            }
        });

        const newFolder = {
            name: folderName,
            folder: { }, // This is an empty object to specify that we are creating a folder
            '@microsoft.graph.conflictBehavior': 'rename' // This tells OneDrive to rename the folder if there's a conflict
        };

        try {
            const result = await client.api(`/me/drive/items/${parentFolderId}/children`)
                .version('v1.0')
                .post(newFolder);

            return result;
        } catch (error) {
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOnedrive = {
        accessToken: string;
    }

    export async function main(onedriveResource: MicrosoftOnedrive, folderName: string, parentFolderId: string = 'root') {
        const client = Client.init({
            authProvider: (done) => {
                done(null, onedriveResource.accessToken); // Here we are providing the access token to the Microsoft Graph client
            }
        });

        const folder = {
            name: folderName,
            folder: { }, // This is an empty object to indicate that this item is a folder
            '@microsoft.graph.conflictBehavior': 'rename' // This tells OneDrive what to do if a folder with the same name already exists
        };

        try {
            const result = await client.api(`/me/drive/items/${parentFolderId}/children`)
                .version('v1.0')
                .post(folder);

            return result;
        } catch (error) {
            throw error;
        }
    }
  id: |-
    synthetic_create-folder
  instructions: |-
    Create a new folder in a drive in microsoft onedrive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftOnedrive
  resource_type_def: |-
    type MicrosoftOnedrive = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the 'companycam' integration
    class companycam(TypedDict):
        api_key: str  # API key for authentication

    def main(companycam_resource: companycam, photo_path: str, project_id: str, title: str = "Untitled Photo") -> Any:
        # Endpoint for adding a photo to a project in CompanyCam
        endpoint = f"https://api.companycam.com/v3/projects/{project_id}/photos"

        # Prepare headers for authentication
        headers = {
            "Authorization": f"Bearer {companycam_resource['api_key']}"
        }

        # Prepare the file data to send
        files = {
            'photo': open(photo_path, 'rb')
        }

        # Prepare additional data if needed
        data = {
            'title': title
        }

        # Make the request to add the photo
        response = requests.post(endpoint, headers=headers, files=files, data=data)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the companycam integration
    class companycam(TypedDict):
        api_key: str  # API key for authentication

    def main(companycam_resource: companycam, project_id: str, photo_path: str, photo_name: str) -> Any:
        # Endpoint for adding a photo to a project in CompanyCam
        endpoint = f"https://api.companycam.com/v3/projects/{project_id}/photos"

        # Prepare headers for authentication
        headers = {
            "Authorization": f"Bearer {companycam_resource['api_key']}"
        }

        # Prepare the file data to send
        files = {
            'photo': (photo_name, open(photo_path, 'rb'), 'image/jpeg')
        }

        # Make the request to add the photo to the project
        response = requests.post(endpoint, headers=headers, files=files)

        # Return the response from the API
        return response.json()

    # Note: The function does not call itself, it's meant to be exported and used with the appropriate parameters.
  id: |-
    synthetic_add-photo
  instructions: |-
    Add a photo to a project. in companycam
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    companycam
  resource_type_def: |-
    class companycam(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Chatwork = {
        apiToken: string;
    }

    export async function main(chatworkResource: Chatwork, roomId: string, body: string) {
        const endpoint = `https://api.chatwork.com/v2/rooms/${roomId}/tasks`;
        const headers = {
            'X-ChatWorkToken': chatworkResource.apiToken,
            'Content-Type': 'application/x-www-form-urlencoded'
        };
        const payload = new URLSearchParams({ body });

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: payload
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Chatwork = {
        apiKey: string;
        roomId: string;
    }

    export async function main(chatworkResource: Chatwork, taskDescription: string, toIds: number[], limitDate?: Date) {
        const endpoint = `https://api.chatwork.com/v2/rooms/${chatworkResource.roomId}/tasks`;
        const headers = {
            "X-ChatWorkToken": chatworkResource.apiKey,
            "Content-Type": "application/x-www-form-urlencoded"
        };

        const body = new URLSearchParams({
            body: taskDescription,
            to_ids: toIds.join(','),
            limit: limitDate ? Math.floor(limitDate.getTime() / 1000).toString() : undefined
        });

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Create a new task in a specified room in chatwork
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Chatwork
  resource_type_def: |-
    type Chatwork = {
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { FormData } from "npm:@deno/form-data";

    type CroveApp = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(croveAppResource: CroveApp, documentId: string, recipientEmail: string, subject: string, message: string) {
        const url = `https://api.crove.app/v1/workspaces/${croveAppResource.workspaceId}/send-document`;

        const formData = new FormData();
        formData.append('documentId', documentId);
        formData.append('recipientEmail', recipientEmail);
        formData.append('subject', subject);
        formData.append('message', message);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${croveAppResource.apiKey}`,
                // 'Content-Type': 'multipart/form-data', // This header is not necessary as the browser will set it with the correct boundary
            },
            body: formData,
        });

        if (!response.ok) {
            throw new Error(`Failed to send document: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type CroveApp = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(croveAppResource: CroveApp, documentId: string, email: string, redirectUrl: string) {
        const { apiKey, workspaceId } = croveAppResource;
        const endpoint = `https://api.crove.app/v1/workspaces/${workspaceId}/documents/${documentId}/send`;

        const body = JSON.stringify({
            email,
            redirectUrl
        });

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${encode(apiKey + ':')}`,
                'Content-Type': 'application/json'
            },
            body: body
        });

        if (!response.ok) {
            throw new Error(`Failed to send email invitation: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_send-document
  instructions: |-
    Send email invitation link to fill & sign the document.   in crove app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CroveApp
  resource_type_def: |-
    type CroveApp = {
        apiKey: string;
        workspaceId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type BadgerMaps = {
        apiKey: string;
        username: string;
        password: string;
    }

    export async function main(badgerMapsResource: BadgerMaps, checkInDetails: { accountId: number, latitude: number, longitude: number, notes: string }) {
        // Encode the credentials
        const credentials = encode(`${badgerMapsResource.username}:${badgerMapsResource.password}`);

        // Prepare the request headers
        const headers = new Headers({
            'Authorization': `Basic ${credentials}`,
            'Content-Type': 'application/json',
        });

        // Prepare the request body
        const body = JSON.stringify({
            accountId: checkInDetails.accountId,
            latitude: checkInDetails.latitude,
            longitude: checkInDetails.longitude,
            notes: checkInDetails.notes,
        });

        // Send the request to the Badger Maps API
        const response = await fetch('https://api.badgermapping.com/v1/checkins', {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Parse the response
        const result = await response.json();

        // Always return the result
        return result;
    }
  good: |-
    import { BadgerMapsClient } from "npm:badgermaps-client";

    type BadgerMaps = {
        apiKey: string;
    }

    export async function main(badgerMapsResource: BadgerMaps, checkInDetails: { customerId: number, notes: string, time: Date }) {
        const client = new BadgerMapsClient(badgerMapsResource.apiKey);
        const result = await client.createCheckIn(checkInDetails.customerId, checkInDetails.notes, checkInDetails.time);
        return result;
    }
  id: |-
    synthetic_create-check-in
  instructions: |-
    Creates a check-in. in badger maps
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BadgerMaps
  resource_type_def: |-
    type BadgerMaps = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Discogs = {
        consumerKey: string;
        consumerSecret: string;
        token: string;
        tokenSecret: string;
    }

    export async function main(discogsResource: Discogs, orderId: string, newStatus: string) {
        const authHeader = `OAuth oauth_consumer_key="${discogsResource.consumerKey}",oauth_token="${discogsResource.token}",oauth_signature_method="PLAINTEXT",oauth_timestamp="${Math.floor(Date.now() / 1000)}",oauth_nonce="${Math.random().toString(36).substring(2, 15)}",oauth_version="1.0",oauth_signature="${discogsResource.consumerSecret}&${discogsResource.tokenSecret}"`;

        const response = await fetch(`https://api.discogs.com/marketplace/orders/${orderId}`, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
                'User-Agent': 'YourAppName/1.0'
            },
            body: JSON.stringify({
                status: newStatus
            })
        });

        if (!response.ok) {
            throw new Error(`Error updating order status: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Discogs = {
        consumerKey: string;
        consumerSecret: string;
        token: string;
        tokenSecret: string;
    }

    export async function main(discogsResource: Discogs, orderId: string, status: string) {
        const apiUrl = `https://api.discogs.com/marketplace/orders/${orderId}`;
        const method = 'POST';
        const headers = new Headers({
            'Authorization': `OAuth oauth_consumer_key="${discogsResource.consumerKey}",oauth_token="${discogsResource.token}",oauth_signature_method="PLAINTEXT",oauth_timestamp="${Math.floor(Date.now() / 1000)}",oauth_nonce="${Math.random().toString(36).substring(2, 15)}",oauth_version="1.0",oauth_signature="${discogsResource.consumerSecret}&${discogsResource.tokenSecret}"`,
            'Content-Type': 'application/x-www-form-urlencoded',
            'User-Agent': 'YourAppName/1.0' // Replace with your app's user agent
        });
        const body = `status=${encode(status)}`;

        try {
            const response = await fetch(apiUrl, {
                method: method,
                headers: headers,
                body: body
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Error updating order status:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-order
  instructions: |-
    Updates the status of an existing order on Discogs in discogs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Discogs
  resource_type_def: |-
    type Discogs = {
        consumerKey: string;
        consumerSecret: string;
        token: string;
        tokenSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { IP2Location } from "npm:ip2location-nodejs";

    type Ip2location = {
        apiKey: string,
        package: string
    }

    export async function main(ip2locationResource: Ip2location, ipAddress: string) {
        const ip2location = new IP2Location();
        ip2location.open(ip2locationResource.apiKey, ip2locationResource.package);

        const result = await ip2location.IPQuery(ipAddress);

        if ("response" in result && result.response === "OK") {
            return result;
        } else {
            throw new Error(`IP2Location query failed: ${result}`);
        }
    }
  good: |-
    // Importing the necessary library to make HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type Ip2location = {
        apiKey: string;
    }

    export async function main(ip2locationResource: Ip2location, ipAddress: string) {
        const url = `https://api.ip2location.com/v2/?ip=${encodeURIComponent(ipAddress)}&key=${ip2locationResource.apiKey}&format=json`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_query-ip-info
  instructions: |-
    Query IP address using IP2Location API for how to use this API. in ip2location
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ip2location
  resource_type_def: |-
    type Ip2location = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for HTTP requests
    import fetch from "npm:node-fetch";

    type IpdataCo = {
        apiKey: string;
    }

    export async function main(ipdataCoResource: IpdataCo, ipAddress: string) {
        const url = `https://api.ipdata.co/${encodeURIComponent(ipAddress)}/time_zone?api-key=${ipdataCoResource.apiKey}`;
        const response = await fetch(url);
        const data = await response.json();

        return data;
    }
  good: |-
    // Importing necessary libraries
    import { fetch } from "npm:@deno/fetch";

    type IpdataCo = {
        apiKey: string;
    }

    export async function main(ipdataCoResource: IpdataCo, ipAddress: string) {
        const endpoint = `https://api.ipdata.co/${ipAddress}/timezone?api-key=${ipdataCoResource.apiKey}`;

        try {
            const response = await fetch(endpoint);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error("Error fetching timezone data:", error);
            throw error;
        }
    }
  id: |-
    synthetic_get-time-zone
  instructions: |-
    We provide detailed and accurate Timezone data, adjusted for DST where necessary. https://docs.ipdata.co/overview/timezone-detection in ipdata co
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    IpdataCo
  resource_type_def: |-
    type IpdataCo = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to interact with Miro's API

    class miro_custom_app(TypedDict):
        access_token: str
        board_id: str

    def main(miro_resource: miro_custom_app, text: str, x_position: float, y_position: float, width: float = 300.0, height: float = 150.0, color: str = 'yellow'):
        headers = {
            'Authorization': f"Bearer {miro_resource['access_token']}",
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        payload = {
            'data': {
                'content': text,
                'shape': 'rectangle',
                'width': width,
                'height': height,
                'x': x_position,
                'y': y_position,
                'style': {
                    'fillColor': color
                }
            },
            'type': 'sticker'
        }
        response = requests.post(f"https://api.miro.com/v1/boards/{miro_resource['board_id']}/widgets", json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function for creating a sticky note on a Miro board
    def main(miro_resource: miro_custom_app, board_id: str, text: str, color: str = 'yellow', position_x: int = 0, position_y: int = 0):
        import requests  # Import requests or another HTTP library if needed

        # Miro API endpoint to create a widget (sticky note)
        api_url = f"https://api.miro.com/v1/boards/{board_id}/widgets"

        # Prepare the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {miro_resource['access_token']}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        # Prepare the data for the sticky note
        data = {
            "type": "sticker",
            "text": text,
            "style": {
                "backgroundColor": color
            },
            "geometry": {
                "x": position_x,
                "y": position_y
            }
        }

        # Make the request to create the sticky note
        response = requests.post(api_url, headers=headers, json=data)

        # Return the result of the API call
        return response.json()

    # Note: The function is not called here, it's just defined and ready to be exported.
  id: |-
    synthetic_create-sticky-note
  instructions: |-
    Creates a sticky note on a Miro board. in miro custom app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    miro_custom_app
  resource_type_def: |-
    class miro_custom_app(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AmaraApi } from "npm:amara";

    type Amara = {
        apiKey: string
    }

    export async function main(amaraResource: Amara, team: string, project: string, videoId: string, languageCode: string) {
        const amaraApi = new AmaraApi(amaraResource.apiKey);

        const result = await amaraApi.createSubtitleLanguage(team, project, videoId, languageCode);

        return result;
    }
  good: |-
    import { AmaraApi } from "npm:@amara/api"; // Assuming there's an npm package for Amara API

    type Amara = {
        apiKey: string,
        team: string,
        project: string
    }

    export async function main(amaraResource: Amara, videoId: string, languageCode: string): Promise<string> {
        const amaraApi = new AmaraApi({
            apiKey: amaraResource.apiKey,
            team: amaraResource.team,
            project: amaraResource.project
        });

        const response = await amaraApi.createSubtitleLanguage(videoId, languageCode);
        return response;
    }
  id: |-
    synthetic_create-subtitle-language
  instructions: |-
    Create a subtitle language in amara
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amara
  resource_type_def: |-
    type Amara = {
        apiKey: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@getresponse/client";

    type Getresponse = {
        apiKey: string,
        apiUrl?: string
    }

    export async function main(getresponseResource: Getresponse, campaignId: string, subject: string, fromFieldId: string, content: string, timeTravel: boolean, perfectTiming: boolean) {
        const client = new Client({ apiKey: getresponseResource.apiKey, apiUrl: getresponseResource.apiUrl });

        const newsletter = {
            subject,
            fromField: { fromFieldId },
            content: {
                html: content
            },
            sendSettings: {
                timeTravel,
                perfectTiming
            }
        };

        const response = await client.createNewsletter(campaignId, newsletter);
        return response;
    }
  good: |-
    import { GetResponseClient } from "npm:getresponse";

    type Getresponse = {
        apiKey: string;
        apiUrl?: string;
    }

    export async function main(getresponseResource: Getresponse, newsletterSubject: string, newsletterBody: string, fromFieldId: string, campaignId: string, sendTime: Date) {
        const client = new GetResponseClient(getresponseResource.apiKey, getresponseResource.apiUrl);

        const newsletter = {
            subject: newsletterSubject,
            body: newsletterBody,
            fromField: { fromFieldId: fromFieldId },
            campaign: { campaignId: campaignId },
            sendOn: sendTime.toISOString()
        };

        const result = await client.createNewsletter(newsletter);

        return result;
    }
  id: |-
    synthetic_create-newsletter
  instructions: |-
    Creates a new newsletter and puts it in a queue to send in getresponse
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Getresponse
  resource_type_def: |-
    type Getresponse = {
        apiKey: string,
        apiUrl?: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { initializeApp, credential, firestore } from "npm:@firebase/admin";

    type FirebaseAdminSdk = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
    }

    export async function main(firebaseAdminSdkResource: FirebaseAdminSdk, eventName: string, eventData: Record<string, any>, collectionPath: string) {
        // Initialize the Firebase app with the provided credentials
        initializeApp({
            credential: credential.cert({
                projectId: firebaseAdminSdkResource.projectId,
                clientEmail: firebaseAdminSdkResource.clientEmail,
                privateKey: firebaseAdminSdkResource.privateKey.replace(/\\n/g, '\n'),
            })
        });

        // Get a Firestore instance
        const db = firestore();

        // Add the event to the specified Firestore collection
        const result = await db.collection(collectionPath).add({
            name: eventName,
            data: eventData,
            timestamp: firestore.FieldValue.serverTimestamp()
        });

        // Return the result which includes the document reference
        return result;
    }
  good: |-
    import { initializeApp, credential, firestore } from "npm:@firebase/admin";

    type FirebaseAdminSdk = {
        type: string;
        projectId: string;
        privateKeyId: string;
        privateKey: string;
        clientEmail: string;
        clientId: string;
        authUri: string;
        tokenUri: string;
        authProviderX509CertUrl: string;
        clientX509CertUrl: string;
    }

    export async function main(
        firebaseAdminResource: FirebaseAdminSdk,
        sourceCollectionPath: string,
        targetCollectionPath: string,
        documentId: string
    ) {
        // Initialize the Firebase Admin SDK
        initializeApp({
            credential: credential.cert({
                projectId: firebaseAdminResource.projectId,
                clientEmail: firebaseAdminResource.clientEmail,
                privateKey: firebaseAdminResource.privateKey.replace(/\\n/g, '\n'),
                privateKeyId: firebaseAdminResource.privateKeyId,
                clientX509CertUrl: firebaseAdminResource.clientX509CertUrl
            }),
            databaseURL: `https://${firebaseAdminResource.projectId}.firebaseio.com`
        });

        // Get a reference to the Firestore service
        const db = firestore();

        // Retrieve the document from the source collection
        const sourceDocRef = db.collection(sourceCollectionPath).doc(documentId);
        const sourceDocSnapshot = await sourceDocRef.get();

        if (!sourceDocSnapshot.exists) {
            throw new Error(`Document with ID ${documentId} does not exist in collection ${sourceCollectionPath}`);
        }

        // Get the data from the source document
        const sourceData = sourceDocSnapshot.data();

        // Create a reference to the target collection
        const targetDocRef = db.collection(targetCollectionPath).doc(documentId);

        // Replicate the document in the target collection
        await targetDocRef.set(sourceData);

        // Return a success message
        return `Document with ID ${documentId} replicated from ${sourceCollectionPath} to ${targetCollectionPath}`;
    }
  id: |-
    synthetic_replicate-event-firestore
  instructions: |-
    Replicate event in Firestore in firebase admin sdk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FirebaseAdminSdk
  resource_type_def: |-
    type FirebaseAdminSdk = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to Airtable API

    # Define the resource type for the airtable integration
    class airtable(TypedDict):
        api_key: str
        base_id: str
        table_name: str

    def main(airtable_resource: airtable, record_id: str) -> dict:
        # Construct the URL for the Airtable API
        url = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{airtable_resource['table_name']}/{record_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {airtable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the DELETE request to the Airtable API to delete the record
        response = requests.delete(url, headers=headers)

        # Return the response as a dictionary
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Airtable API

    class airtable(TypedDict):
        api_key: str
        base_id: str

    def main(airtable_resource: airtable, table_name: str, record_id: str) -> dict:
        headers = {
            'Authorization': f"Bearer {airtable_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{table_name}/{record_id}"

        response = requests.delete(url, headers=headers)

        if response.status_code == 200:
            return {'success': True, 'deleted_record_id': record_id}
        else:
            return {'success': False, 'error': response.json()}
  id: |-
    synthetic_delete-record
  instructions: |-
    Delete a record from a table by record ID. in airtable
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        api_key: str
        base_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class big_data_cloud(TypedDict):
        api_key: str

    def main(big_data_cloud_resource: big_data_cloud, latitude: float, longitude: float, locality_language: str) -> dict:
        base_url = "https://api.bigdatacloud.net/data/reverse-geocode-client"
        params = {
            "latitude": latitude,
            "longitude": longitude,
            "localityLanguage": locality_language,
            "key": big_data_cloud_resource['api_key']
        }
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        return response.json()

    # Example usage:
    # result = main(big_data_cloud_resource={'api_key': 'your_api_key'}, latitude=40.7128, longitude=-74.0060, locality_language="en")
    # print(result)
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Big Data Cloud API

    class big_data_cloud(TypedDict):
        api_key: str

    def main(big_data_cloud_resource: big_data_cloud, latitude: float, longitude: float) -> str:
        base_url = "https://api.bigdatacloud.net/data/reverse-geocode-client"
        params = {
            "latitude": latitude,
            "longitude": longitude,
            "localityLanguage": "en",
            "key": big_data_cloud_resource['api_key']
        }
        response = requests.get(base_url, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        address_info = response.json()
        return address_info.get('principalSubdivision', '') + ', ' + address_info.get('city', '') + ', ' + address_info.get('countryName', '')

    # The main function is now ready to be exported and used with the required parameters.
  id: |-
    synthetic_reverse-geocode
  instructions: |-
    Convert a user's coordinates to a human-readable address in big data cloud
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    big_data_cloud
  resource_type_def: |-
    class big_data_cloud(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Coda = {
        apiToken: string,
        docId: string
    }

    export async function main(codaResource: Coda, tableName: string) {
        const endpoint = `https://coda.io/apis/v1/docs/${codaResource.docId}/tables/${tableName}/columns`;

        const headers = {
            'Authorization': `Bearer ${codaResource.apiToken}`,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(endpoint, { headers: headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const columns = await response.json();
            return columns;
        } catch (error) {
            console.error('Error fetching columns:', error);
            throw error;
        }
    }
  good: |-
    import { Coda } from "npm:@codahq/packs-sdk";

    type CodaResource = {
        apiToken: string,
        docId: string
    }

    export async function main(codaResource: CodaResource, tableName: string) {
        const coda = new Coda(codaResource.apiToken);
        const columns = await coda.listColumns(codaResource.docId, tableName);
        return columns;
    }
  id: |-
    synthetic_list-columns
  instructions: |-
    Lists columns in a table in coda
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coda
  resource_type_def: |-
    type Coda = {
        apiToken: string,
        docId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for Bingx integration
    }

    export async function main(
        bingxResource: Bingx,
        entryPrice: number,
        stopPrice: number,
        accountBalance: number,
        leverage: number // Assuming the user defines the leverage they want to use
    ) {
        // Calculate the position size based on the given parameters
        const riskAmount = accountBalance * (entryPrice - stopPrice);
        const positionSize = riskAmount * leverage;

        // The result object to return
        const result = {
            entryPrice,
            stopPrice,
            accountBalance,
            leverage,
            positionSize
        };

        // Return the result
        return result;
    }
  good: |-
    import { BigNumber } from "npm:bignumber.js";

    type Bingx = {
        apiKey: string;
        secretKey: string;
    }

    export async function main(
        bingxResource: Bingx,
        symbol: string,
        entryPrice: string,
        leverage: number,
        positionSize: string
    ) {
        BigNumber.config({ DECIMAL_PLACES: 8 });

        const entryPriceBN = new BigNumber(entryPrice);
        const positionSizeBN = new BigNumber(positionSize);

        const leveragedPositionSize = positionSizeBN.multipliedBy(leverage);

        const result = {
            symbol: symbol,
            entryPrice: entryPriceBN.toString(),
            leverage: leverage,
            positionSize: positionSizeBN.toString(),
            leveragedPositionSize: leveragedPositionSize.toString()
        };

        return result;
    }
  id: |-
    synthetic_custom-calculate-leveraged-position
  instructions: |-
    Calculate leveraged position based on entry, stop price and account balance in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OneSignal } from "npm:@onesignal/node-onesignal";

    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }

    export async function main(onesignalResource: OnesignalRestApi, deviceId: string) {
        const oneSignalClient = new OneSignal({
            appId: onesignalResource.appId,
            restApiKey: onesignalResource.restApiKey
        });

        try {
            const device = await oneSignalClient.viewDevice(deviceId);
            return device;
        } catch (error) {
            // Handle error (e.g., device not found, API error)
            console.error("Failed to get device:", error);
            throw error;
        }
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type OnesignalRestApi = {
        apiKey: string;
        appId: string;
    }

    export async function main(onesignalResource: OnesignalRestApi, deviceId: string) {
        const url = `https://onesignal.com/api/v1/players/${deviceId}?app_id=${onesignalResource.appId}`;
        const headers = new Headers({
            "Content-Type": "application/json; charset=utf-8",
            "Authorization": `Basic ${encode(onesignalResource.apiKey)}`
        });

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Error fetching device: ${response.statusText}`);
        }

        const deviceDetails = await response.json();
        return deviceDetails;
    }
  id: |-
    synthetic_get-device
  instructions: |-
    Get a specific device in onesignal rest api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    OnesignalRestApi
  resource_type_def: |-
    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { NangoConnection } from "npm:@nangohq/node-sdk";

    type Nango = {
        apiKey: string;
    }

    export async function main(nangoResource: Nango) {
        const nango = new NangoConnection({ apiKey: nangoResource.apiKey });

        const connections = await nango.listConnections();
        return connections;
    }
  good: |-
    // Import any libraries you need here
    import { NangoConnection as NangoApiClient } from "npm:nango";

    type Nango = {
        apiKey: string;
    }

    export async function main(nangoResource: Nango) {
        // Initialize the Nango client with the API key from the resource
        const nangoClient = new NangoApiClient({ apiKey: nangoResource.apiKey });

        // Fetch the list of connections
        const connections = await nangoClient.listConnections();

        // Return the result
        return connections;
    }
  id: |-
    synthetic_list-connections
  instructions: |-
    Returns a list of Connections in nango
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nango
  resource_type_def: |-
    type Nango = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests library is used for HTTP requests

    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str
        zone_id: str

    def main(cloudflare_resource: cloudflare_api_key, urls_to_purge: List[str]) -> dict:
        purge_endpoint = f"https://api.cloudflare.com/client/v4/zones/{cloudflare_resource['zone_id']}/purge_cache"
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json",
        }
        data = {
            "files": urls_to_purge
        }
        response = requests.post(purge_endpoint, headers=headers, json=data)
        return response.json()
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the Cloudflare API integration
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
        zone_id: str

    # Define the main function for purging files by URL
    def main(cloudflare_resource: cloudflare_api_key, urls_to_purge: List[str]) -> dict:
        import requests  # Import requests or any other library if needed

        # Cloudflare API endpoint for purging files
        purge_endpoint = f"https://api.cloudflare.com/client/v4/zones/{cloudflare_resource['zone_id']}/purge_cache"

        # Headers for authentication
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Data payload for the purge request
        data = {
            "files": urls_to_purge
        }

        # Make the POST request to Cloudflare API to purge the files
        response = requests.post(purge_endpoint, headers=headers, json=data)

        # Return the response from the API
        return response.json()

    # The script ends here, and the function is ready to be used with the required parameters.
  id: |-
    synthetic_purge-files-by-url
  instructions: |-
    Granularly remove one or more files from Cloudflare's cache by specifying URLs in cloudflare api key
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudflare_api_key
  resource_type_def: |-
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
        zone_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HttpClient as AngularHttpClient } from "@angular/common/http";

    type Omnivore = {
        apiKey: string;
        locationId: string;
        apiUrl: string;
    }

    export async function main(omnivoreResource: Omnivore, articleId: string) {
        const httpClient = new AngularHttpClient();
        const url = `${omnivoreResource.apiUrl}/locations/${omnivoreResource.locationId}/articles/${articleId}`;
        const headers = {
            'Api-Key': omnivoreResource.apiKey,
            'Content-Type': 'application/json'
        };

        try {
            const response = await httpClient.get(url, { headers });
            return response;
        } catch (error) {
            console.error('Error fetching article:', error);
            throw error;
        }
    }
  good: |-
    import { Article } from "npm:@omnivore/api"; // Assuming @omnivore/api is the npm package for Omnivore API

    type Omnivore = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(omnivoreResource: Omnivore, articleId: string) {
        const response = await fetch(`${omnivoreResource.apiUrl}/articles/${articleId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${omnivoreResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const article: Article = await response.json();
        return article;
    }
  id: |-
    synthetic_get-article
  instructions: |-
    Get a single article and its content in omnivore
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Omnivore
  resource_type_def: |-
    type Omnivore = {
        apiKey: string;
        locationId: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Buffer } from "npm:buffer";
    import { FormData } from "npm:formdata-node";
    import { fileFromPath } from "npm:formdata-node/file-from-path";

    type Discord = {
        botToken: string;
    }

    export async function main(discordResource: Discord, channelId: string, messageContent: string, filePath: string) {
        const url = `https://discord.com/api/v9/channels/${channelId}/messages`;
        const formData = new FormData();
        formData.append('content', messageContent);
        formData.append('file', await fileFromPath(filePath));

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bot ${discordResource.botToken}`,
                ...formData.getHeaders(),
            },
            body: formData,
        });

        return response.json();
    }
  good: |-
    // Importing necessary libraries
    import { Buffer } from "npm:buffer";
    import { FormData } from "npm:formdata-node";
    import { fileFromPath } from "npm:formdata-node/file-from-path";

    type Discord = {
        token: string;
        channelId: string;
    }

    export async function main(discordResource: Discord, messageContent: string, filePath: string, fileName: string) {
        const url = `https://discord.com/api/v9/channels/${discordResource.channelId}/messages`;
        const formData = new FormData();
        formData.append('content', messageContent);
        const file = await fileFromPath(filePath, fileName);
        formData.append('file', file, fileName);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bot ${discordResource.token}`,
                ...formData.getHeaders(),
            },
            body: formData,
        });

        if (!response.ok) {
            throw new Error(`Failed to send message: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_send-message-with-file
  instructions: |-
    Post a message with an attached file in discord
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Discord
  resource_type_def: |-
    type Discord = {
        botToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BotconversaClient } from "npm:botconversa-sdk"; // Assuming such an npm package exists

    type Botconversa = {
        apiKey: string,
        botId: string
    }

    export async function main(botconversaResource: Botconversa, recipientId: string, messageText: string) {
        const client = new BotconversaClient(botconversaResource.apiKey);
        const result = await client.sendMessage(botconversaResource.botId, recipientId, messageText);
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { BotConversaClient } from "npm:botconversa-sdk";

    type Botconversa = {
        apiKey: string;
        botId: string;
    }

    export async function main(botconversaResource: Botconversa, subscriberId: string, message: string) {
        const client = new BotConversaClient(botconversaResource.apiKey, botconversaResource.botId);
        const result = await client.sendMessage(subscriberId, message);
        return result;
    }
  id: |-
    synthetic_send-message
  instructions: |-
    Send a message to a specific subscriber in botconversa
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Botconversa
  resource_type_def: |-
    type Botconversa = {
        apiKey: string,
        botId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'getemails' integration
    class getemails(TypedDict):
        api_key: str

    # Define the main function for the 'getemails' integration
    def main(getemails_resource: getemails, user_id: str, domain: str) -> str:
        # Assuming there's a library to interact with the 'getemails' service
        from getemails_api import find_email as find_email_api  # Rename if necessary

        # Use the credentials from the resource to authenticate with the 'getemails' service
        api_key = getemails_resource['api_key']

        # Call the service's method to find the email
        email_address = find_email_api(api_key, domain, user_id)

        # Return the result
        return email_address
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    class getemails(TypedDict):
        api_key: str

    def main(getemails_resource: getemails, full_name: str, domain: str) -> str:
        base_url = "https://api.getemails.com/v1"
        endpoint = "/find"

        headers = {
            "Authorization": f"Bearer {getemails_resource['api_key']}",
            "Content-Type": "application/json"
        }

        payload = {
            "fullName": full_name,
            "domain": domain
        }

        response = requests.post(f"{base_url}{endpoint}", headers=headers, json=payload)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        email_address = response.json().get('email', '')
        return email_address
  id: |-
    synthetic_find-email
  instructions: |-
    Provide Full name of your prospect with Domain or Website and Api will provide you an email address of the prospect in response. . in getemails
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    getemails
  resource_type_def: |-
    class getemails(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailwizz API

    class mailwizz(TypedDict):
        api_url: str
        public_key: str
        private_key: str

    def main(mailwizz_resource: mailwizz, list_id: str, email: str, details: dict):
        # Construct the endpoint URL for creating a new subscriber
        endpoint = f"{mailwizz_resource['api_url']}/lists/{list_id}/subscribers"

        # Prepare the data payload with the subscriber's email and additional details
        payload = {
            'EMAIL': email,
            'details': details
        }

        # Prepare the headers with authentication details
        headers = {
            'X-MW-PUBLIC-KEY': mailwizz_resource['public_key'],
            'X-MW-PRIVATE-KEY': mailwizz_resource['private_key']
        }

        # Make the POST request to create the new subscriber
        response = requests.post(endpoint, json=payload, headers=headers)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the mailwizz integration
    class mailwizz(TypedDict):
        api_url: str
        public_key: str
        private_key: str

    # Define the main function for adding a subscriber to a list in mailwizz
    def main(mailwizz_resource: mailwizz, list_id: str, email: str, details: dict):
        # Import the necessary library for making HTTP requests
        import requests

        # Construct the endpoint URL for adding a subscriber
        endpoint = f"{mailwizz_resource['api_url']}/lists/{list_id}/subscribers"

        # Prepare the data payload with the subscriber's email and additional details
        payload = {
            'EMAIL': email,
            'details': details
        }

        # Prepare the headers with the authentication keys
        headers = {
            'X-MW-PUBLIC-KEY': mailwizz_resource['public_key'],
            'X-MW-PRIVATE-KEY': mailwizz_resource['private_key']
        }

        # Make the POST request to add the subscriber
        response = requests.post(endpoint, json=payload, headers=headers)

        # Return the response from the API
        return response.json()

    # Example usage:
    # result = main(mailwizz_resource={'api_url': 'https://api.mailwizz.com', 'public_key': 'your_public_key', 'private_key': 'your_private_key'}, list_id='your_list_id', email='subscriber_email', details={'FNAME': 'John', 'LNAME': 'Doe'})
    # print(result)
  id: |-
    synthetic_add-subscriber
  instructions: |-
    Create a new subscriber to a list in mailwizz
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailwizz
  resource_type_def: |-
    class mailwizz(TypedDict):
        api_url: str
        public_key: str
        private_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { v4 as uuidv4 } from "npm:uuid";

    type KanbanTool = {
        apiKey: string;
        boardId: string;
        workflowId: string;
    }

    export async function main(
        kanbanToolResource: KanbanTool,
        taskTitle: string,
        taskDescription: string,
        swimlaneId: string,
        columnId: string,
        priority: string
    ) {
        const apiUrl = `https://kanbantool.com/api/v1/boards/${kanbanToolResource.boardId}/tasks.json`;
        const taskData = {
            task: {
                name: taskTitle,
                description: taskDescription,
                workflow_stage_id: columnId,
                swimlane_id: swimlaneId,
                priority: priority,
                type: 'Task',
                uuid: uuidv4()
            }
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'X-KanbanToolToken': kanbanToolResource.apiKey,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(taskData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type KanbanTool = {
        apiKey: string;
        boardId: string;
        domain: string;
    }

    export async function main(
        kanbanToolResource: KanbanTool,
        taskName: string,
        taskDescription: string,
        swimlaneId: string,
        columnId: string,
        color: string = 'white',
        typeId: string = 'default'
    ) {
        const endpoint = `https://${kanbanToolResource.domain}.kanbantool.com/api/v1/boards/${kanbanToolResource.boardId}/tasks.json`;
        const taskData = {
            task: {
                name: taskName,
                description: taskDescription,
                swimlane_id: swimlaneId,
                column_id: columnId,
                color: color,
                type_id: typeId,
                unique_id: uuidv4() // Generate a unique ID for the task
            }
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'X-KanbanToolToken': kanbanToolResource.apiKey,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(taskData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a task in kanban tool
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    KanbanTool
  resource_type_def: |-
    type KanbanTool = {
        apiKey: string;
        boardId: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed to make HTTP calls to Formstack API

    class formstack(TypedDict):
        access_token: str
        form_id: str

    def main(formstack_resource: formstack, form_id: str) -> Dict[str, Any]:
        base_url = "https://www.formstack.com/api/v2"
        headers = {
            "Authorization": f"Bearer {formstack_resource['access_token']}"
        }

        response = requests.get(f"{base_url}/form/{form_id}.json", headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Formstack API

    # Define the resource type for the 'formstack' integration
    class formstack(TypedDict):
        access_token: str  # OAuth2 access token

    def main(formstack_resource: formstack, form_id: str, additional_parameters: Dict[str, Any]) -> Dict[str, Any]:
        # Endpoint to get a form from Formstack
        endpoint = f"https://www.formstack.com/api/v2/form/{form_id}.json"

        # Prepare headers for OAuth2 authentication
        headers = {
            "Authorization": f"Bearer {formstack_resource['access_token']}"
        }

        # Make the HTTP request to get the form
        response = requests.get(endpoint, headers=headers, params=additional_parameters)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the form data
            return response.json()
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Example usage:
    # result = main(formstack_resource={'access_token': 'your_access_token'}, form_id='your_form_id', additional_parameters={'data': 'value'})
    # print(result)
  id: |-
    synthetic_get-form
  instructions: |-
    Get the details of the specified form in formstack
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    formstack
  resource_type_def: |-
    class formstack(TypedDict):
        access_token: str  # OAuth2 access token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests

    class convertkit(TypedDict):
        api_secret: str
        api_key: str

    def main(convertkit_resource: convertkit, subscriber_id: int, tag_id: int) -> dict:
        base_url = "https://api.convertkit.com/v3"
        endpoint = f"/tags/{tag_id}/subscribe"
        url = base_url + endpoint
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {convertkit_resource['api_secret']}"
        }
        payload = {
            "api_key": convertkit_resource['api_key'],
            "email": None,  # Email is not provided as it's not needed when subscriber_id is used
            "subscriber": {
                "id": subscriber_id
            }
        }

        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the ConvertKit integration
    class convertkit(TypedDict):
        api_secret: str
        api_key: str

    # Define the main function to add a tag to a subscriber
    def main(convertkit_resource: convertkit, subscriber_email: str, tag_id: int) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for adding a tag to a subscriber
        endpoint = f"https://api.convertkit.com/v3/tags/{tag_id}/subscribe"

        # Prepare the payload with the subscriber's email
        payload = {
            'api_secret': convertkit_resource['api_secret'],
            'email': subscriber_email
        }

        # Make the POST request to add the tag to the subscriber
        response = requests.post(endpoint, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the response as a JSON object
        else:
            # If the request failed, return the status code and error message
            return {
                'status_code': response.status_code,
                'error_message': response.text
            }

    # Note: The function is not called here, it is just defined and ready to be used.
  id: |-
    synthetic_add-tag-to-subscriber
  instructions: |-
    Add tag to a subscriber in convertkit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    convertkit
  resource_type_def: |-
    class convertkit(TypedDict):
        api_secret: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { S3Client, GetObjectCommand } from "npm:@aws-sdk/client-s3";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }

    export async function main(awsResource: Aws, bucketName: string, objectKey: string) {
        const s3Client = new S3Client({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
                sessionToken: awsResource.sessionToken,
            },
            region: awsResource.region,
        });

        const getObjectParams = {
            Bucket: bucketName,
            Key: objectKey,
        };

        const command = new GetObjectCommand(getObjectParams);
        const response = await s3Client.send(command);

        // Assuming the primary key is in the object's metadata
        const primaryKey = response.Metadata?.['primary-key'];

        return primaryKey;
    }
  good: |-
    import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(awsResource: Aws, tableName: string, item: { [key: string]: any }) {
        const client = new DynamoDBClient({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
            },
            region: awsResource.region,
        });

        const command = new PutItemCommand({
            TableName: tableName,
            Item: item,
        });

        const response = await client.send(command);
        return response;
    }
  id: |-
    synthetic_dynamodb-put-item
  instructions: |-
    Value for the primary key in aws
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aws
  resource_type_def: |-
    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { hmac as createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const timestamp = new Date().getTime();
        const params = `api_key=${bybitResource.apiKey}&symbol=${symbol}&timestamp=${timestamp}`;
        const signature = createHmac('sha256', bybitResource.apiSecret, params, 'utf8', 'hex');

        const url = `${bybitResource.endpoint}/v2/public/tickers?${params}&sign=${signature}`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching market tickers:', error);
            throw error;
        }
    }
  good: |-
    // Import any libraries you need here
    import { hmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const endpoint = `https://api.bybit.com/v2/public/tickers?symbol=${symbol}`;
        const timestamp = new Date().getTime();
        const params = `api_key=${bybitResource.apiKey}&timestamp=${timestamp}`;
        const signature = hmac('sha256', bybitResource.apiSecret, params).digest('hex');

        const url = `${endpoint}&${params}&sign=${signature}`;

        const response = await fetch(url);
        const data = await response.json();

        return data;
    }
  id: |-
    synthetic_generic-market-tickers
  instructions: |-
    Get the latest information for symbol in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the hugging_face integration
    class hugging_face(TypedDict):
        api_key: str
        model_id: str

    # Define the main function for object detection
    def main(hugging_face_resource: hugging_face, image_url: str) -> List[dict]:
        # Set up the headers for the HTTP request to the Hugging Face API
        headers = {
            "Authorization": f"Bearer {hugging_face_resource['api_key']}"
        }

        # Prepare the payload for the API request
        payload = {
            "inputs": {
                "url": image_url
            }
        }

        # Send the request to the Hugging Face model API
        response = requests.post(
            f"https://api-inference.huggingface.co/models/{hugging_face_resource['model_id']}",
            headers=headers,
            json=payload
        )

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response and return the object detection results
            return response.json()
        else:
            # Handle errors (for simplicity, just returning an empty list here)
            return []
  good: |-
    from typing import TypedDict, List, Tuple
    import requests

    # Define the resource type for the hugging_face integration
    class hugging_face(TypedDict):
        api_key: str

    # Define the main function for object detection using Hugging Face API
    def main(hugging_face_resource: hugging_face, image_url: str) -> List[Tuple[str, float, Tuple[int, int, int, int]]]:
        # Hugging Face API endpoint for object detection
        api_endpoint = "https://api-inference.huggingface.co/models/facebook/detr-resnet-50"

        # Prepare headers for the request
        headers = {
            "Authorization": f"Bearer {hugging_face_resource['api_key']}"
        }

        # Prepare the payload for the request
        payload = {
            "inputs": image_url
        }

        # Send the request to the Hugging Face API
        response = requests.post(api_endpoint, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code != 200:
            raise Exception(f"Error: {response.status_code}, {response.text}")

        # Parse the response
        result = response.json()

        # Extract the likelihood of classes and bounding boxes
        detections = []
        for detection in result:
            label = detection['label']
            score = detection['score']
            box = tuple(detection['box'])
            detections.append((label, score, box))

        # Return the list of detections
        return detections

    # Example usage:
    # detections = main(hugging_face_resource={'api_key': 'your_api_key'}, image_url='https://example.com/image.jpg')
    # print(detections)
  id: |-
    synthetic_object-detection
  instructions: |-
    This task reads some image input and outputs the likelihood of classes and bounding boxes of detected objects. in hugging face
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hugging_face
  resource_type_def: |-
    class hugging_face(TypedDict):
        api_key: str
        model_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function for updating a sticky note on a Miro board
    def main(miro_resource: miro_custom_app, board_id: str, sticky_note_id: str, new_text: str, new_color: str = 'yellow') -> Any:
        import requests  # Import requests or any other library if needed

        # Miro API endpoint to update a sticky note
        update_url = f"https://api.miro.com/v1/boards/{board_id}/sticky_notes/{sticky_note_id}"

        # Headers for the API request
        headers = {
            'Authorization': f"Bearer {miro_resource['access_token']}",
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }

        # Data payload for the API request
        data = {
            'data': {
                'content': new_text,
                'style': {
                    'fillColor': new_color
                }
            }
        }

        # Make the API request to update the sticky note
        response = requests.patch(update_url, json=data, headers=headers)

        # Return the API response
        return response.json()

    # Note: The function is not called here, it's just defined and ready to be used with the required parameters.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to interact with the Miro API

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str
        board_id: str

    def main(miro_resource: miro_custom_app, sticky_note_id: str, new_content: str):
        # Construct the API endpoint for updating a sticky note
        api_endpoint = f"https://api.miro.com/v1/boards/{miro_resource['board_id']}/sticky_notes/{sticky_note_id}"

        # Prepare the headers for the HTTP request
        headers = {
            "Authorization": f"Bearer {miro_resource['access_token']}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        # Prepare the payload with the new content of the sticky note
        payload = {
            "data": {
                "content": new_content
            }
        }

        # Send the HTTP request to update the sticky note
        response = requests.patch(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated sticky note data
        else:
            # Handle the error (you could raise an exception or return an error message)
            return {"error": "Failed to update the sticky note", "status_code": response.status_code}
  id: |-
    synthetic_update-sticky-note
  instructions: |-
    Updates content of an existing sticky note on a Miro board. in miro custom app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    miro_custom_app
  resource_type_def: |-
    class miro_custom_app(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { KlazifyClient } from "npm:klazify";

    type Klazify = {
        apiKey: string;
    }

    export async function main(klazifyResource: Klazify, urlToCategorize: string) {
        const klazifyClient = new KlazifyClient(klazifyResource.apiKey);

        const categorizationResult = await klazifyClient.categorize(urlToCategorize);

        return categorizationResult;
    }
  good: |-
    import { KlazifyClient } from "npm:klazify";

    type Klazify = {
        apiKey: string;
    }

    export async function main(klazifyResource: Klazify, input: string) {
        const klazifyClient = new KlazifyClient(klazifyResource.apiKey);
        let result;

        // Check if the input is an email or a URL
        const isEmail = input.includes('@');
        const domain = isEmail ? input.split('@')[1] : input;

        try {
            if (isEmail) {
                // Classify based on email's domain
                result = await klazifyClient.classifyDomain(domain);
            } else {
                // Classify based on URL
                result = await klazifyClient.classifyURL(input);
            }
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error('Error classifying the input:', error);
            throw error;
        }

        // Return the classification result
        return result;
    }
  id: |-
    synthetic_real-time-categorization
  instructions: |-
    Analize the URL content or email's domain (if the input is an email) and classifies it into 385+ possible topic categories. in klazify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Klazify
  resource_type_def: |-
    type Klazify = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type CloudflareApiKey = {
        email: string;
        apiKey: string;
        accountId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, securityProfile: 'low' | 'medium' | 'high') {
        const url = `https://api.cloudflare.com/client/v4/accounts/${cloudflareResource.accountId}/settings/security_level`;

        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'X-Auth-Email': cloudflareResource.email,
                'X-Auth-Key': cloudflareResource.apiKey,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ value: securityProfile }),
        });

        if (!response.ok) {
            throw new Error(`Failed to update security profile: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { Cloudflare } from "npm:@cloudflare/client";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        accountId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, zoneId: string, securityLevel: 'essentially_off' | 'low' | 'medium' | 'high' | 'under_attack') {
        const cloudflare = new Cloudflare({
            email: cloudflareResource.email,
            key: cloudflareResource.apiKey
        });

        const response = await cloudflare.zones.editZoneSettings(zoneId, {
            security_level: securityLevel
        });

        return response;
    }
  id: |-
    synthetic_update-zone-security-level
  instructions: |-
    Choose the appropriate security profile for your website, which will automatically adjust each of the security settings in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        accountId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for Bingx integration
    }

    export async function main(bingxResource: Bingx, method: string, endpoint: string, body: Record<string, any> = {}, queryParams: Record<string, string> = {}) {
        // Construct the URL with query parameters if any
        const url = new URL(`https://api.bingx.com/v1/${endpoint}`);
        Object.keys(queryParams).forEach(key => url.searchParams.append(key, queryParams[key]));

        // Prepare the headers and sign the request if necessary
        const headers = new Headers({
            'Content-Type': 'application/json',
            'X-BingX-APIKEY': bingxResource.apiKey,
            // Add any other headers required by Bingx
        });

        // If the method is POST or PUT, stringify the body
        const bodyContent = (method === 'POST' || method === 'PUT') ? JSON.stringify(body) : null;

        // Make the API call
        const response = await fetch(url.toString(), {
            method: method,
            headers: headers,
            body: bodyContent
        });

        // Parse the response and return the result
        const result = await response.json();
        return result;
    }
  good: |-
    // Import any libraries you might need here. For example, if you need to make HTTP requests, you might import a library like axios, but since fetch is globally available, you might not need to.

    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for authentication/configuration
    }

    export async function main(bingxResource: Bingx, endpoint: string, method: 'GET' | 'POST' | 'PUT' | 'DELETE', body?: Record<string, unknown>) {
        // Construct the headers with the API key
        const headers = {
            'Content-Type': 'application/json',
            'X-BingX-APIKEY': bingxResource.apiKey,
            // Add any other headers required by Bingx Futures API
        };

        // Construct the request options
        const requestOptions: RequestInit = {
            method: method,
            headers: headers,
        };

        // If the method is POST or PUT, include the body in the request options
        if (body && (method === 'POST' || method === 'PUT')) {
            requestOptions.body = JSON.stringify(body);
        }

        // Make the API call
        const response = await fetch(`https://api.bingx.com/v1/${endpoint}`, requestOptions);

        // Check if the response is ok (status code 200-299)
        if (!response.ok) {
            // If not, throw an error with the status
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse the response body as JSON
        const result = await response.json();

        // Always return the result
        return result;
    }
  id: |-
    synthetic_generic-api-call
  instructions: |-
    Make any API call for Bingx Futures as per the documentation in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for Bingx integration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Nordigen API

    class nordigen(TypedDict):
        access_token: str
        endpoint: str

    def main(nordigen_resource: nordigen, account_id: str):
        headers = {
            'Authorization': f"Bearer {nordigen_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        response = requests.get(
            f"{nordigen_resource['endpoint']}/accounts/{account_id}/details/",
            headers=headers
        )
        response.raise_for_status()  # This will raise an exception for HTTP error responses
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls

    class nordigen(TypedDict):
        access_token: str
        endpoint: str

    def main(nordigen_resource: nordigen, account_id: str) -> dict:
        headers = {
            'Authorization': f"Bearer {nordigen_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        response = requests.get(
            f"{nordigen_resource['endpoint']}/accounts/{account_id}/details",
            headers=headers
        )
        response.raise_for_status()  # This will raise an exception for HTTP error responses
        return response.json()
  id: |-
    synthetic_get-account-details
  instructions: |-
    Get the details of a Nordigen account in nordigen
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nordigen
  resource_type_def: |-
    class nordigen(TypedDict):
        access_token: str
        endpoint: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the ftrack integration
    class ftrack(TypedDict):
        api_key: str
        user_name: str
        api_url: str

    # Define the main function for the ftrack integration
    def main(ftrack_resource: ftrack, task_id: str) -> Dict[str, Any]:
        # Import the ftrack API module here to avoid naming conflicts
        import ftrack_api

        # Connect to the ftrack server using the provided credentials
        session = ftrack_api.Session(
            server_url=ftrack_resource['api_url'],
            api_key=ftrack_resource['api_key'],
            api_user=ftrack_resource['user_name']
        )

        # Retrieve the task information using the task ID
        task = session.query('Task where id is "{}"'.format(task_id)).one()

        # Extract the relevant information from the task object
        task_info = {
            'id': task['id'],
            'name': task['name'],
            'status': task['status']['name'],
            'start_date': task['start_date'],
            'end_date': task['end_date']
        }

        # Always close the session
        session.close()

        # Return the task information
        return task_info
  good: |-
    from typing import TypedDict, Any
    import ftrack_api  # Assuming ftrack_api is the library used for ftrack integration

    class ftrack(TypedDict):
        api_key: str
        api_user: str
        server_url: str

    def main(ftrack_resource: ftrack, task_id: str) -> Any:
        session = ftrack_api.Session(
            server_url=ftrack_resource['server_url'],
            api_key=ftrack_resource['api_key'],
            api_user=ftrack_resource['api_user']
        )

        task = session.query('Task where id is {}'.format(task_id)).first()
        if not task:
            return {'error': 'Task not found'}

        task_info = {
            'id': task['id'],
            'name': task['name'],
            'status': task['status']['name'] if task['status'] else None,
            'start_date': task['start_date'],
            'end_date': task['end_date']
        }

        session.close()
        return task_info
  id: |-
    synthetic_get-task-info
  instructions: |-
    Get information about a task in ftrack
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ftrack
  resource_type_def: |-
    class ftrack(TypedDict):
        api_key: str
        user_name: str
        api_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:@std/encoding/base64";

    type Endorsal = {
        apiKey: string;
    }

    export async function main(endorsalResource: Endorsal) {
        const baseUrl = 'https://api.endorsal.io/v1';
        const testimonialsEndpoint = '/testimonials';

        // Prepare the authorization header
        const headers = new Headers({
            'Authorization': `Basic ${encode(endorsalResource.apiKey)}`,
            'Content-Type': 'application/json'
        });

        // Fetch the list of testimonials from Endorsal
        const response = await fetch(`${baseUrl}${testimonialsEndpoint}`, {
            method: 'GET',
            headers: headers
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`Error fetching testimonials: ${response.status} ${response.statusText}`);
        }

        // Parse the response body as JSON
        const testimonials = await response.json();

        // Return the list of testimonials
        return testimonials;
    }
  good: |-
    import { EndorsalClient } from "npm:@endorsal/sdk";

    type Endorsal = {
        apiKey: string,
        subdomain: string
    }

    export async function main(endorsalResource: Endorsal, page: number = 1, perPage: number = 10) {
        const client = new EndorsalClient({
            apiKey: endorsalResource.apiKey,
            subdomain: endorsalResource.subdomain
        });

        const testimonials = await client.testimonials.list({
            page: page,
            perPage: perPage
        });

        return testimonials;
    }
  id: |-
    synthetic_list-testimonials
  instructions: |-
    Retrieves a list of testimonials received in endorsal
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Endorsal
  resource_type_def: |-
    type Endorsal = {
        apiKey: string,
        subdomain: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls

    class klazify(TypedDict):
        api_key: str

    def main(klazify_resource: klazify, company_domain: str) -> dict:
        headers = {
            'Authorization': f"Bearer {klazify_resource['api_key']}"
        }
        response = requests.get(f"https://api.klazify.com/domain/{company_domain}", headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make API calls to klazify

    class klazify(TypedDict):
        api_key: str

    def main(klazify_resource: klazify, domain: str):
        headers = {
            'Authorization': f"Bearer {klazify_resource['api_key']}"
        }
        response = requests.get(f"https://api.klazify.com/lookup?domain={domain}", headers=headers)
        return response.json()
  id: |-
    synthetic_get-company-domain-info
  instructions: |-
    Get information about a company's domain. in klazify
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    klazify
  resource_type_def: |-
    class klazify(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { DateTime } from "npm:luxon";

    type Dayschedule = {
        apiKey: string;
        calendarId: string;
    }

    export async function main(
        dayscheduleResource: Dayschedule,
        eventId: string,
        updatedTitle: string,
        updatedDescription: string,
        updatedStartTime: string, // ISO 8601 format
        updatedEndTime: string, // ISO 8601 format
        updatedLocation?: string
    ) {
        const apiUrl = `https://api.dayschedule.com/v1/calendars/${dayscheduleResource.calendarId}/events/${eventId}`;

        const eventUpdatePayload = {
            title: updatedTitle,
            description: updatedDescription,
            start: {
                dateTime: DateTime.fromISO(updatedStartTime).toISO(),
                timeZone: 'UTC'
            },
            end: {
                dateTime: DateTime.fromISO(updatedEndTime).toISO(),
                timeZone: 'UTC'
            },
            ...(updatedLocation && { location: updatedLocation })
        };

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${dayscheduleResource.apiKey}`
            },
            body: JSON.stringify(eventUpdatePayload)
        });

        if (!response.ok) {
            throw new Error(`Failed to update event: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { DaySchedule } from 'npm:dayschedule';

    type Dayschedule = {
        apiKey: string;
        calendarId: string;
    }

    export async function main(
        dayscheduleResource: Dayschedule,
        eventId: string,
        updatedEventDetails: {
            title?: string;
            description?: string;
            location?: string;
            start?: string; // ISO 8601 date string
            end?: string; // ISO 8601 date string
        }
    ) {
        // Initialize the DaySchedule client with the API key
        const client = new DaySchedule(dayscheduleResource.apiKey);

        // Retrieve the existing event from the calendar
        const existingEvent = await client.events.retrieve(dayscheduleResource.calendarId, eventId);

        // Update the event details
        const updatedEvent = {
            ...existingEvent,
            ...updatedEventDetails
        };

        // Save the updated event back to the calendar
        const result = await client.events.update(dayscheduleResource.calendarId, eventId, updatedEvent);

        // Return the result
        return result;
    }
  id: |-
    synthetic_update-event
  instructions: |-
    Modify an existing event in the DaySchedule in dayschedule
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dayschedule
  resource_type_def: |-
    type Dayschedule = {
        apiKey: string;
        calendarId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { NordigenClient } from "npm:nordigen";

    type Nordigen = {
        accessToken: string,
        accountId: string
    }

    export async function main(nordigenResource: Nordigen, fromDate: string, toDate: string) {
        // Initialize Nordigen client with the access token
        const nordigenClient = new NordigenClient({ accessToken: nordigenResource.accessToken });

        // Fetch transactions for the given account within the specified date range
        const transactions = await nordigenClient.getTransactions(
            nordigenResource.accountId,
            fromDate,
            toDate
        );

        // Return the transactions
        return transactions;
    }
  good: |-
    import { NordigenClient } from "npm:nordigen";

    type Nordigen = {
        accessToken: string,
        accountId: string
    }

    export async function main(nordigenResource: Nordigen, fromDate: string, toDate: string) {
        const nordigenClient = new NordigenClient(nordigenResource.accessToken);

        const transactions = await nordigenClient.getAccountTransactions(nordigenResource.accountId, fromDate, toDate);

        return transactions;
    }
  id: |-
    synthetic_get-account-transactions
  instructions: |-
    Get the transactions of a Nordigen account in nordigen
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nordigen
  resource_type_def: |-
    type Nordigen = {
        accessToken: string,
        accountId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict, Optional
    import boto3
    from botocore.exceptions import ClientError

    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str

    def main(aws_resource: aws, table_name: str, key: Dict[str, Any], update_expression: str, expression_attribute_values: Dict[str, Any], aws_session_token: Optional[str] = None) -> Dict[str, Any]:
        # Initialize a boto3 DynamoDB client using the provided AWS resource credentials
        dynamodb = boto3.resource(
            'dynamodb',
            aws_access_key_id=aws_resource['aws_access_key_id'],
            aws_secret_access_key=aws_resource['aws_secret_access_key'],
            region_name=aws_resource['region_name'],
            aws_session_token=aws_session_token
        )

        # Get the table object
        table = dynamodb.Table(table_name)

        try:
            # Update the item in DynamoDB table
            response = table.update_item(
                Key=key,
                UpdateExpression=update_expression,
                ExpressionAttributeValues=expression_attribute_values,
                ReturnValues="UPDATED_NEW"
            )
            return response
        except ClientError as e:
            # In case of an error, return the error message
            return {"error": str(e)}
  good: |-
    from typing import TypedDict

    # Define the resource type for the AWS integration
    class aws(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str

    def main(aws_resource: aws, table_name: str, primary_key_name: str) -> str:
        import boto3
        from botocore.exceptions import ClientError

        # Initialize a boto3 client for DynamoDB using the provided AWS resource credentials
        dynamodb = boto3.resource(
            'dynamodb',
            aws_access_key_id=aws_resource['access_key_id'],
            aws_secret_access_key=aws_resource['secret_access_key'],
            region_name=aws_resource['region_name']
        )

        # Retrieve the table
        table = dynamodb.Table(table_name)

        # Attempt to retrieve the primary key value
        try:
            response = table.scan(
                ProjectionExpression=primary_key_name,
                Limit=1
            )
            primary_key_value = response['Items'][0][primary_key_name] if response['Items'] else None
            return primary_key_value
        except ClientError as e:
            raise Exception(f"An error occurred: {e.response['Error']['Message']}")

    # Note: The function does not call itself, it's meant to be called with the appropriate parameters.
  id: |-
    synthetic_dynamodb-update-item
  instructions: |-
    Value for the primary key in aws
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aws
  resource_type_def: |-
    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP calls

    class github(TypedDict):
        access_token: str
        repository_owner: str
        repository_name: str

    def main(github_resource: github, issue_number: int, comment_body: str) -> dict:
        headers = {
            "Authorization": f"token {github_resource['access_token']}",
            "Accept": "application/vnd.github.v3+json"
        }
        comment_url = f"https://api.github.com/repos/{github_resource['repository_owner']}/{github_resource['repository_name']}/issues/{issue_number}/comments"
        response = requests.post(comment_url, headers=headers, json={"body": comment_body})
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls to GitHub API

    class github(TypedDict):
        access_token: str

    def main(github_resource: github, repository_owner: str, repository_name: str, issue_number: int, comment_body: str) -> dict:
        headers = {
            "Authorization": f"token {github_resource['access_token']}",
            "Accept": "application/vnd.github.v3+json"
        }
        url = f"https://api.github.com/repos/{repository_owner}/{repository_name}/issues/{issue_number}/comments"
        data = {
            "body": comment_body
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()
  id: |-
    synthetic_create-issue-comment
  instructions: |-
    Create a new comment in a issue in github
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Bitly API

    class bitly(TypedDict):
        access_token: str

    def main(bitly_resource: bitly, long_url: str) -> str:
        headers = {
            'Authorization': f"Bearer {bitly_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        data = {
            'long_url': long_url
        }
        response = requests.post('https://api-ssl.bitly.com/v4/shorten', json=data, headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()['link']
  good: |-
    from typing import TypedDict

    # Define the resource type for the bitly integration
    class bitly(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import any libraries you might need
    import requests

    # Define the main function with the resource type and any additional parameters
    def main(bitly_resource: bitly, long_url: str) -> str:
        # Prepare the API request
        headers = {
            'Authorization': f"Bearer {bitly_resource['access_token']}",
            'Content-Type': 'application/json',
        }
        payload = {
            'long_url': long_url,
        }
        url = 'https://api-ssl.bitly.com/v4/shorten'

        # Make the request to shorten the URL
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP error responses

        # Extract the shortened URL from the response
        shortened_url = response.json().get('link')

        # Return the shortened URL
        return shortened_url

    # Note: The main function is not called here, it's just defined and ready to be used.
  id: |-
    synthetic_expand-bitlink
  instructions: |-
    This is the shortened url in bitly
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitly
  resource_type_def: |-
    class bitly(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the Databricks integration
    class databricks(TypedDict):
        domain: str
        token: str

    # Define the main function to run a job now in Databricks
    def main(databricks_resource: databricks, job_id: int):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for running a job now
        api_endpoint = f"https://{databricks_resource['domain']}/api/2.0/jobs/run-now"

        # Set up the headers with the Databricks token
        headers = {
            'Authorization': f"Bearer {databricks_resource['token']}"
        }

        # Set up the payload with the job ID
        payload = {
            'job_id': job_id
        }

        # Make the POST request to run the job now
        response = requests.post(api_endpoint, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if the job was triggered successfully
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # Example usage:
    # result = main(databricks_resource={'domain': 'your-databricks-workspace-domain', 'token': 'your-databricks-access-token'}, job_id=123)
    # print(result)
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to Databricks API

    class databricks(TypedDict):
        domain: str
        token: str

    def main(databricks_resource: databricks, job_id: int) -> str:
        headers = {
            'Authorization': f'Bearer {databricks_resource["token"]}',
            'Content-Type': 'application/json'
        }
        response = requests.post(
            url=f'https://{databricks_resource["domain"]}/api/2.0/jobs/run-now',
            headers=headers,
            json={'job_id': job_id}
        )
        response.raise_for_status()  # This will raise an error if the request failed
        run_id = response.json().get('run_id')
        return run_id
  id: |-
    synthetic_run-job-now
  instructions: |-
    Run a job now and return the id of the triggered run in databricks
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    databricks
  resource_type_def: |-
    class databricks(TypedDict):
        domain: str
        token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to Mautic API

    class mautic(TypedDict):
        base_url: str
        access_token: str

    def main(mautic_resource: mautic, search_term: str) -> List[dict]:
        headers = {
            'Authorization': f'Bearer {mautic_resource["access_token"]}'
        }
        response = requests.get(
            f'{mautic_resource["base_url"]}/api/campaigns',
            headers=headers,
            params={'search': search_term}
        )
        response.raise_for_status()  # This will raise an exception for HTTP error responses
        return response.json().get('campaigns', [])
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to Mautic API

    # Define the resource type for the Mautic integration
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str

    # Define the main function with the Mautic resource and any other necessary parameters
    def main(mautic_resource: mautic, access_token: str, search_filter: str = '') -> List[dict]:
        # Construct the API endpoint for searching campaigns
        endpoint = f"{mautic_resource['base_url']}/api/campaigns"

        # Prepare the headers with the access token for OAUTH2 authentication
        headers = {
            'Authorization': f'Bearer {access_token}'
        }

        # Prepare the search parameters
        params = {
            'search': search_filter
        }

        # Make the request to the Mautic API
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the campaigns
            return response.json().get('campaigns', [])
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()
  id: |-
    synthetic_search-campaigns
  instructions: |-
    Gets a list of campaigns by a search term in mautic
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mautic
  resource_type_def: |-
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AgileCrmClient as AgileCrmApiClient } from "npm:agilecrm";

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, companyId: string, updatedCompanyDetails: { [key: string]: any }) {
        const client = new AgileCrmApiClient({
            apiKey: agileCrmResource.apiKey,
            domain: agileCrmResource.domain,
            email: agileCrmResource.email
        });

        const result = await client.companies.update(companyId, updatedCompanyDetails);

        return result;
    }
  good: |-
    // Import necessary libraries
    import { AgileCrmClient } from "npm:agilecrm";

    type AgileCrm = {
        apiKey: string;
        email: string;
        domain: string;
    }

    export async function main(agileCrmResource: AgileCrm, companyId: string, companyData: { [key: string]: any }) {
        // Initialize the Agile CRM client
        const client = new AgileCrmClient({
            apiKey: agileCrmResource.apiKey,
            email: agileCrmResource.email,
            domain: agileCrmResource.domain
        });

        // Update the company in Agile CRM
        const result = await client.companies.update(companyId, companyData);

        // Return the result
        return result;
    }
  id: |-
    synthetic_update-company
  instructions: |-
    Updates an existing company in Agile CRM in agile crm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AgileCrm
  resource_type_def: |-
    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Coda as CodaSDK } from "npm:@codahq/packs-sdk";

    type Coda = {
        apiToken: string;
        docId: string;
    }

    export async function main(codaResource: Coda, tableName: string, rows: Array<{ [key: string]: any }>) {
        const coda = new CodaSDK(codaResource.apiToken);
        const result = await coda.addRows(codaResource.docId, tableName, rows);
        return result;
    }
  good: |-
    import { Coda } from "npm:@codahq/packs-sdk";

    type CodaResource = {
        apiToken: string;
        docId: string;
    }

    export async function main(codaResource: CodaResource, tableName: string, rowData: Record<string, any>) {
        const coda = new Coda(codaResource.apiToken);
        const result = await coda.addRow(codaResource.docId, tableName, rowData);
        return result;
    }
  id: |-
    synthetic_create-rows
  instructions: |-
    Insert a row in a selected table in coda
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coda
  resource_type_def: |-
    type Coda = {
        apiToken: string;
        docId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed to make HTTP calls to the ClickUp API

    class clickup(TypedDict):
        api_key: str
        space_id: str

    def main(clickup_resource: clickup) -> List[Any]:
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }
        space_id = clickup_resource['space_id']
        url = f"https://api.clickup.com/api/v2/space/{space_id}/view"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json()['views']
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for getting space views
    def main(clickup_resource: clickup, space_id: str) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Define the base URL for the ClickUp API
        base_url = "https://api.clickup.com/api/v2"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Make a GET request to retrieve the views for the specified space
        response = requests.get(f"{base_url}/space/{space_id}/view", headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of views
            return response.json().get('views', [])
        else:
            # Handle errors (e.g., space not found, authentication error)
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_get-space-views
  instructions: |-
    Get all views of a space. See the docs in **Views / Get Space Views** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ConstantContact as ConstantContactAPI } from "npm:@hutsoninc/constant-contact";

    type ConstantContact = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(constantContactResource: ConstantContact, contactId: string) {
        const cc = new ConstantContactAPI({
            apiKey: constantContactResource.apiKey,
            accessToken: constantContactResource.accessToken,
        });

        try {
            const response = await cc.contacts.deleteContact(contactId);
            return response;
        } catch (error) {
            throw new Error(`Failed to remove contact: ${error}`);
        }
    }
  good: |-
    // Import the necessary library for making HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type ConstantContact = {
        apiKey: string;
        accessToken: string;
        apiEndpoint: string;
    }

    export async function main(constantContactResource: ConstantContact, contactId: string) {
        const url = `${constantContactResource.apiEndpoint}/contacts/${contactId}`;
        const headers = {
            'Authorization': `Bearer ${constantContactResource.accessToken}`,
            'Content-Type': 'application/json',
            'Api-Key': constantContactResource.apiKey
        };

        try {
            const response = await fetch(url, {
                method: 'DELETE',
                headers: headers
            });

            if (!response.ok) {
                throw new Error(`Error deleting contact: ${response.statusText}`);
            }

            return { success: true, message: `Contact with ID ${contactId} deleted successfully.` };
        } catch (error) {
            return { success: false, message: error.message };
        }
    }
  id: |-
    synthetic_delete-contact
  instructions: |-
    Delete a specific contact identified by contact_id in constant contact
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    ConstantContact
  resource_type_def: |-
    type ConstantContact = {
        apiKey: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { OAuth2Client } from "npm:@googleapis/oauth2";

    type Enedis = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }

    export async function main(enedisResource: Enedis, usagePointId: string) {
        const oauth2Client = new OAuth2Client(
            enedisResource.clientId,
            enedisResource.clientSecret
        );

        oauth2Client.setCredentials({
            access_token: enedisResource.accessToken,
            refresh_token: enedisResource.refreshToken
        });

        const url = `https://api.enedis.fr/dataconnect/v1/usage_points/${usagePointId}/addresses`;
        const headers = {
            Authorization: `Bearer ${enedisResource.accessToken}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Enedis = {
        accessToken: string;
        apiEndpoint: string;
    }

    export async function main(enedisResource: Enedis, clientId: string) {
        const response = await fetch(`${enedisResource.apiEndpoint}/clients/${clientId}/address`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${enedisResource.accessToken}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching client address: ${response.statusText}`);
        }

        const address = await response.json();
        return address;
    }
  id: |-
    synthetic_get-address
  instructions: |-
    Returns the address of a client in enedis
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Enedis
  resource_type_def: |-
    type Enedis = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import firebase_admin
    from firebase_admin import credentials, firestore

    class firebase_admin_sdk(TypedDict):
        type: str
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str

    def main(firebase_resource: firebase_admin_sdk, event_data: dict, collection_name: str):
        # Initialize the Firebase admin SDK
        if not firebase_admin._apps:
            firebase_credential = credentials.Certificate(firebase_resource)
            firebase_admin.initialize_app(firebase_credential)

        # Get the Firestore client
        db = firestore.client()

        # Save the event to the specified Firestore collection
        collection_ref = db.collection(collection_name)
        document_ref = collection_ref.add(event_data)

        # Return the result
        return document_ref
  good: |-
    from typing import TypedDict, Any
    import firebase_admin
    from firebase_admin import credentials, firestore

    # Define the resource type for the firebase_admin_sdk integration
    class firebase_admin_sdk(TypedDict):
        type: str
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str

    # Initialize the Firebase Admin SDK with the provided credentials
    def initialize_firebase_admin_sdk(firebase_admin_sdk_resource: firebase_admin_sdk):
        cred = credentials.Certificate(firebase_admin_sdk_resource)
        firebase_admin.initialize_app(cred)

    # Main function to replicate an event in Firestore
    def main(firebase_admin_sdk_resource: firebase_admin_sdk, collection_path: str, document_id: str, event_data: Any):
        # Initialize Firebase Admin SDK
        initialize_firebase_admin_sdk(firebase_admin_sdk_resource)

        # Get the Firestore client
        db = firestore.client()

        # Reference to the document
        doc_ref = db.collection(collection_path).document(document_id)

        # Set the event data in the document
        doc_ref.set(event_data)

        # Return a success message
        return f"Event replicated in Firestore at {collection_path}/{document_id}"

    # Example usage:
    # main(
    #     firebase_admin_sdk_resource={
    #         "type": "service_account",
    #         "project_id": "your-project-id",
    #         "private_key_id": "your-private-key-id",
    #         "private_key": "your-private-key",
    #         "client_email": "your-client-email",
    #         "client_id": "your-client-id",
    #         "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    #         "token_uri": "https://oauth2.googleapis.com/token",
    #         "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
    #         "client_x509_cert_url": "your-client-x509-cert-url"
    #     },
    #     collection_path="events",
    #     document_id="event_id",
    #     event_data={"name": "Event Name", "timestamp": "2023-04-01T00:00:00Z"}
    # )
  id: |-
    synthetic_replicate-event-firestore
  instructions: |-
    Replicate event in Firestore in firebase admin sdk
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    firebase_admin_sdk
  resource_type_def: |-
    class firebase_admin_sdk(TypedDict):
        type: str
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here

    type BadgerMaps = {
        apiKey: string;
    }

    export async function main(badgerMapsResource: BadgerMaps, accountDetails: { firstName: string, lastName: string, email: string, companyName: string }) {
        const apiUrl = 'https://api.badgermapping.com/v1/accounts';

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${badgerMapsResource.apiKey}`
            },
            body: JSON.stringify({
                first_name: accountDetails.firstName,
                last_name: accountDetails.lastName,
                email: accountDetails.email,
                company_name: accountDetails.companyName
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type BadgerMaps = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(badgerMapsResource: BadgerMaps, accountName: string, accountEmail: string, additionalDetails?: Record<string, any>) {
        const credentials = `${badgerMapsResource.apiKey}:${badgerMapsResource.apiSecret}`;
        const encodedCredentials = encode(credentials);

        const response = await fetch('https://api.badgermapping.com/v1/accounts', {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                name: accountName,
                email: accountEmail,
                ...additionalDetails
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-account
  instructions: |-
    Creates an account. in badger maps
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BadgerMaps
  resource_type_def: |-
    type BadgerMaps = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to Alpaca API

    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca, symbol: str, qty: int, side: str, type: str, time_in_force: str, limit_price: Optional[float] = None, stop_price: Optional[float] = None):
        headers = {
            'APCA-API-KEY-ID': alpaca_resource['api_key'],
            'APCA-API-SECRET-KEY': alpaca_resource['api_secret']
        }

        data = {
            'symbol': symbol,
            'qty': qty,
            'side': side,
            'type': type,
            'time_in_force': time_in_force
        }

        if limit_price is not None:
            data['limit_price'] = limit_price

        if stop_price is not None:
            data['stop_price'] = stop_price

        response = requests.post(f"{alpaca_resource['base_url']}/v2/orders", headers=headers, json=data)

        if response.status_code == 200:
            return response.json()  # Order successfully placed
        else:
            response.raise_for_status()  # Raise an HTTPError if the HTTP request returned an unsuccessful status code
  good: |-
    from typing import TypedDict

    # Define the resource type for the alpaca integration
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    # Define the main function for placing an order with the alpaca integration
    def main(alpaca_resource: alpaca, symbol: str, qty: int, side: str, order_type: str, time_in_force: str):
        # Import the Alpaca API library and rename it if it conflicts with the resource type name
        import alpaca_trade_api as tradeapi

        # Create an instance of the REST client with the provided credentials
        api = tradeapi.REST(
            alpaca_resource['api_key'],
            alpaca_resource['api_secret'],
            alpaca_resource['base_url'],
            api_version='v2'
        )

        # Place the order using the parameters provided
        order = api.submit_order(
            symbol=symbol,
            qty=qty,
            side=side,
            type=order_type,
            time_in_force=time_in_force
        )

        # Return the order object
        return order
  id: |-
    synthetic_place-order
  instructions: |-
    Places a new order for the given account. An order request may be rejected if the account is not authorized for trading, or if the tradable balance is insufficient to fill the order, in alpaca
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    alpaca
  resource_type_def: |-
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { JSDOM } from "npm:jsdom";

    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }

    export async function main(nationbuilderResource: Nationbuilder, htmlContent: string) {
        const dom = new JSDOM(htmlContent);
        const document = dom.window.document;
        const body = document.body;
        body.querySelectorAll('*').forEach(el => el.remove());

        return body.textContent || '';
    }
  good: |-
    // Import necessary libraries
    import { Client } from "npm:@nationbuilder/client";

    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }

    export async function main(nationbuilderResource: Nationbuilder, personId: number, tagsToRemove: string[]) {
        // Initialize the NationBuilder client with the provided credentials
        const client = new Client({
            accessToken: nationbuilderResource.accessToken,
            nationSlug: nationbuilderResource.nationSlug,
        });

        // Remove tags from the specified person
        for (const tag of tagsToRemove) {
            await client.people.tagsDelete(personId, tag);
        }

        // Return a success message
        return `Tags removed from person with ID ${personId}`;
    }
  id: |-
    synthetic_remove-tags
  instructions: |-
    Rmove tags from a specific person in nationbuilder
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nationbuilder
  resource_type_def: |-
    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { fetch } from "npm:@deno/fetch";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, folderId: string) {
        const url = `https://api.clickup.com/api/v2/folder/${folderId}/view`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': clickupResource.apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching folder views: ${response.statusText}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Importing necessary libraries
    import { Client } from "npm:@clickup/api";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, folderId: string) {
        // Initialize ClickUp API client
        const clickupClient = new Client(clickupResource.apiKey);

        // Fetch folder views
        const response = await clickupClient.getFolderViews(folderId);

        // Return the result
        return response;
    }
  id: |-
    synthetic_get-folder-views
  instructions: |-
    Get all views of a folder. See the docs in **Views / Get Folder Views** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Mautic = {
        baseUrl: string;
        username: string;
        password: string;
    }

    export async function main(
        mauticResource: Mautic,
        contactId: number,
        contactData: { [key: string]: any }
    ) {
        const credentials = `${mauticResource.username}:${mauticResource.password}`;
        const encodedCredentials = encode(credentials);
        const url = `${mauticResource.baseUrl}/api/contacts/${contactId}/edit?merge=true`;

        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(contactData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:querystring";

    type Mautic = {
        baseUrl: string;
        accessToken: string;
    }

    export async function main(mauticResource: Mautic, contactId: number, contactData: Record<string, any>) {
        const url = `${mauticResource.baseUrl}/api/contacts/${contactId}/edit?${encode({ access_token: mauticResource.accessToken })}`;
        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(contactData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-contact
  instructions: |-
    Updates a contact in mautic
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mautic
  resource_type_def: |-
    type Mautic = {
        baseUrl: string;
        username: string;
        password: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Klaxoon = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(klaxoonResource: Klaxoon, boardTitle: string, boardDescription?: string) {
        const url = `https://api.klaxoon.com/v2/workspace/${klaxoonResource.workspaceId}/board`;

        const body = {
            title: boardTitle,
            description: boardDescription || '',
            externalId: uuidv4(), // Generate a unique identifier for the board
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${klaxoonResource.apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Klaxoon = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(klaxoonResource: Klaxoon, boardTitle: string, boardDescription: string = "") {
        const url = `https://api.klaxoon.com/v2/workspace/${klaxoonResource.workspaceId}/board`;

        const body = {
            title: boardTitle,
            description: boardDescription,
            externalId: uuidv4(), // Generate a unique identifier for the board
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${klaxoonResource.apiKey}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-board
  instructions: |-
    Creates a board in klaxoon
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Klaxoon
  resource_type_def: |-
    type Klaxoon = {
        apiKey: string;
        workspaceId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Mastodon as MastodonAPI } from "npm:mastodon-api";

    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodonResource: Mastodon, statuses: string[]) {
        const mastodonClient = new MastodonAPI({
            access_token: mastodonResource.accessToken,
            api_url: mastodonResource.apiUrl
        });

        const results = [];
        for (const status of statuses) {
            const response = await mastodonClient.post('statuses', { status: status });
            results.push(response.data);
        }

        return results;
    }
  good: |-
    // Importing necessary libraries
    import { Mastodon } from "npm:mastodon-api";

    type MastodonResource = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodonResource: MastodonResource, statuses: string[], visibility: 'public' | 'unlisted' | 'private' | 'direct' = 'public') {
        const M = new Mastodon({
            access_token: mastodonResource.accessToken,
            api_url: mastodonResource.apiUrl
        });

        if (statuses.length === 0) {
            throw new Error("No statuses provided to post.");
        }

        let inReplyToId: string | undefined = undefined;
        const results = [];

        for (const status of statuses) {
            const params = {
                status: status,
                visibility: visibility,
                in_reply_to_id: inReplyToId
            };

            const result = await M.post('statuses', params);
            results.push(result.data);

            // The first status will not be a reply, subsequent statuses will be replies to the first
            if (!inReplyToId) {
                inReplyToId = result.data.id;
            }
        }

        return results;
    }
  id: |-
    synthetic_post-multiple-statuses
  instructions: |-
    Publish multiple statuses with the given parameters, the subsequent statuses will be posted as a reply of of the first status in mastodon
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mastodon
  resource_type_def: |-
    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { DrataClient as DrataAPIClient } from "npm:@drata/sdk"; // Renamed imported method to avoid conflict

    type Drata = {
        apiKey: string;
        // Add other authentication/configuration properties as needed
    }

    export async function main(drataResource: Drata, assetName: string, assetType: string, assetIdentifier: string) {
        const drataClient = new DrataAPIClient({ apiKey: drataResource.apiKey });

        const result = await drataClient.createAsset({
            name: assetName,
            type: assetType,
            identifier: assetIdentifier,
        });

        return result;
    }
  good: |-
    // Import any libraries you need here
    import { DrataClient } from "npm:@drata/sdk"; // Hypothetical npm package for Drata integration

    type Drata = {
        apiKey: string;
        // Add other properties relevant to Drata authentication/configuration
    }

    export async function main(drataResource: Drata, assetName: string) {
        // Initialize the Drata client with the API key from the resource
        const drataClient = new DrataClient({ apiKey: drataResource.apiKey });

        // Fetch the asset information from Drata by the asset name
        const assetInfo = await drataClient.getAssetByName(assetName);

        // Return the asset information
        return assetInfo;
    }
  id: |-
    synthetic_create-asset
  instructions: |-
    The name of the asset in drata
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Drata
  resource_type_def: |-
    type Drata = {
        apiKey: string;
        // Add other authentication/configuration properties as needed
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import datetime  # Assuming we need this for handling dates and times

    # Define the resource type for the Microsoft Teams integration
    class microsoft_teams(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function that lists shifts
    def main(microsoft_teams_resource: microsoft_teams, team_id: str, schedule_id: str, start_date: datetime.date, end_date: datetime.date) -> List[dict]:
        # Assuming we have a function to set up the Microsoft Teams client
        # and that it uses the OAuth2 access token from the resource
        client = setup_microsoft_teams_client(microsoft_teams_resource)

        # Call the Microsoft Teams API to list shifts
        shifts = client.list_shifts(team_id, schedule_id, start_date, end_date)

        # Return the list of shifts
        return shifts

    # Assuming a function to set up the Microsoft Teams client
    def setup_microsoft_teams_client(resource: microsoft_teams):
        # Setup code for the client would go here, using the resource credentials
        pass

    # The script ends here, with no calls to the main function as per the instructions.
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the microsoft_teams integration
    class microsoft_teams(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
        access_token: str  # Assuming OAUTH2 access token is provided

    # Define the main function to get the list of shift instances for a team
    def main(microsoft_teams_resource: microsoft_teams, team_id: str) -> List[dict]:
        # Endpoint for Microsoft Graph API to list shift instances
        endpoint = f"https://graph.microsoft.com/v1.0/teams/{team_id}/schedule/shifts"

        # Set up the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {microsoft_teams_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Make the HTTP request to get the list of shift instances
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of shift instances
            return response.json().get('value', [])
        else:
            # Handle errors (for simplicity, just raise an exception)
            response.raise_for_status()

    # Example usage (this line should not be included in the script):
    # shifts = main(microsoft_teams_resource={'tenant_id': '...', 'client_id': '...', 'client_secret': '...', 'access_token': '...'}, team_id='...')
  id: |-
    synthetic_list-shifts
  instructions: |-
    Get the list of shift instances for a team in microsoft teams
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_teams
  resource_type_def: |-
    class microsoft_teams(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    class ghost_org_content_api(TypedDict):
        api_key: str
        api_url: str

    def main(ghost_resource: ghost_org_content_api, author_slug: str):
        headers = {
            'Authorization': f"Ghost {ghost_resource['api_key']}"
        }
        response = requests.get(
            f"{ghost_resource['api_url']}/ghost/api/v3/content/authors/slug/{author_slug}/",
            headers=headers
        )
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the ghost_org_content_api integration
    class ghost_org_content_api(TypedDict):
        api_key: str
        admin_api_url: str

    # Define the main function for the script
    def main(ghost_resource: ghost_org_content_api, author_slug: str):
        import requests  # Import requests or any other library if needed

        # Construct the URL to access the Ghost Content API for authors
        url = f"{ghost_resource['admin_api_url']}/ghost/api/v3/content/authors/slug/{author_slug}/"

        # Set up the headers with the API key
        headers = {
            'Authorization': f"Ghost {ghost_resource['api_key']}"
        }

        # Make the request to the Ghost Content API
        response = requests.get(url, headers=headers)

        # Check if the response is successful
        if response.status_code == 200:
            # Parse the response JSON to get the author data
            author_data = response.json()
            return author_data
        else:
            # Handle the error (e.g., author not found or API error)
            return {'error': 'Author not found or API error', 'status_code': response.status_code}

    # Note: The function does not call itself, it's meant to be exported and used with the provided parameters.
  id: |-
    synthetic_find-author
  instructions: |-
    Find an author. in ghost org content api
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ghost_org_content_api
  resource_type_def: |-
    class ghost_org_content_api(TypedDict):
        api_key: str
        admin_api_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed to make HTTP calls to the Harvest API

    class harvest(TypedDict):
        account_id: str
        access_token: str

    def main(harvest_resource: harvest, timer_id: int):
        headers = {
            "Authorization": f"Bearer {harvest_resource['access_token']}",
            "Harvest-Account-ID": harvest_resource['account_id'],
            "User-Agent": "Python Harvest API Sample",
            "Content-Type": "application/json"
        }

        url = f"https://api.harvestapp.com/v2/time_entries/{timer_id}/stop"

        response = requests.patch(url, headers=headers)

        if response.status_code == 200:
            return response.json()  # Timer stopped successfully
        else:
            response.raise_for_status()  # Raise an HTTPError if the HTTP request returned an unsuccessful status code
  good: |-
    from typing import TypedDict

    # Define the resource type for the Harvest integration
    class harvest(TypedDict):
        access_token: str
        account_id: str

    # Define the main function for stopping a time entry in Harvest
    def main(harvest_resource: harvest, time_entry_id: int) -> dict:
        import requests  # Import requests or any other library if needed

        # Set up the headers with the authentication details
        headers = {
            "Authorization": f"Bearer {harvest_resource['access_token']}",
            "Harvest-Account-ID": harvest_resource['account_id'],
            "User-Agent": "Python Harvest API Script",
            "Content-Type": "application/json"
        }

        # Define the URL for stopping the time entry
        url = f"https://api.harvestapp.com/v2/time_entries/{time_entry_id}/stop"

        # Make the request to stop the time entry
        response = requests.patch(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the stopped time entry details
        else:
            # Handle errors (e.g., time entry not found, access denied, etc.)
            return {
                "error": response.status_code,
                "message": response.text
            }

    # Note: The function is not called here, it's just defined and ready to be used.
  id: |-
    synthetic_stop-timer
  instructions: |-
    Stop a timer entry in harvest
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    harvest
  resource_type_def: |-
    class harvest(TypedDict):
        access_token: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SheetsV4 } from "npm:@googleapis/sheets";

    type GoogleSheets = {
        apiKey: string,
        accessToken: string,
        spreadsheetId: string
    }

    export async function main(googleSheetsResource: GoogleSheets, sheetName: string, rowIndex: number) {
        const sheets = new SheetsV4.Sheets({ auth: googleSheetsResource.apiKey });

        const range = `${sheetName}!A${rowIndex}:Z${rowIndex}`;
        const requestBody = {
            requests: [
                {
                    deleteDimension: {
                        range: {
                            sheetId: 0,
                            dimension: "ROWS",
                            startIndex: rowIndex - 1,
                            endIndex: rowIndex
                        }
                    }
                }
            ]
        };

        const response = await sheets.spreadsheets.batchUpdate({
            spreadsheetId: googleSheetsResource.spreadsheetId,
            requestBody,
            auth: googleSheetsResource.accessToken
        });

        return response.data;
    }
  good: |-
    import { GoogleAuth } from "npm:google-auth-library";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, spreadsheetId: string, sheetName: string, rowIndex: number) {
        const { apiKey, accessToken } = googleSheetsResource;
        const auth = new GoogleAuth({
            credentials: {
                access_token: accessToken,
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets'],
        });

        const sheets = google.sheets({ version: 'v4', auth });

        const range = `${sheetName}!A${rowIndex}:Z${rowIndex}`;
        const response = await sheets.spreadsheets.values.clear({
            spreadsheetId,
            range,
            key: apiKey,
        });

        return response.data;
    }
  id: |-
    synthetic_clear-row
  instructions: |-
    Delete the content of a row in a spreadsheet. Deleted rows will appear as blank rows. in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
        databaseId: string;
    }

    export async function main(notionResource: Notion, query?: any) {
        const notion = new Client({ auth: notionResource.authToken });

        const response = await notion.databases.query({
            database_id: notionResource.databaseId,
            ...query
        });

        return response;
    }
  good: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
        databaseId: string;
    }

    export async function main(notionResource: Notion, query?: any) {
        const notion = new Client({ auth: notionResource.authToken });

        const response = await notion.databases.query({
            database_id: notionResource.databaseId,
            ...query
        });

        return response;
    }
  id: |-
    synthetic_query-database
  instructions: |-
    Query a database in notion
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
        authToken: string;
        databaseId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { calendar_v3, google } from "npm:googleapis";

    type GoogleCalendar = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(
        googleCalendarResource: GoogleCalendar,
        eventId: string,
        attendees: { email: string }[]
    ) {
        const { clientId, clientSecret, refreshToken, accessToken } = googleCalendarResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret);
        oauth2Client.setCredentials({
            refresh_token: refreshToken,
            access_token: accessToken,
        });

        const calendar: calendar_v3.Calendar = google.calendar({ version: 'v3', auth: oauth2Client });

        const result = await calendar.events.patch({
            calendarId: 'primary',
            eventId: eventId,
            requestBody: {
                attendees: attendees,
            },
        });

        return result.data;
    }
  good: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type GoogleCalendar = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(
        googleCalendarResource: GoogleCalendar,
        eventId: string,
        attendees: { email: string }[]
    ) {
        const { clientId, clientSecret, refreshToken, accessToken } = googleCalendarResource;
        const oauth2Client = new OAuth2Client(clientId, clientSecret);
        oauth2Client.setCredentials({
            refresh_token: refreshToken,
            access_token: accessToken,
        });

        const calendarApiEndpoint = `https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`;
        const requestBody = {
            attendees: attendees,
        };

        const response = await fetch(calendarApiEndpoint, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
            throw new Error(`Failed to update attendees: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-event-attendees
  instructions: |-
    Update attendees of an existing event in google calendar
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleCalendar
  resource_type_def: |-
    type GoogleCalendar = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to OneNote API

    class onenote(TypedDict):
        access_token: str  # OAuth2 Access Token for OneNote API

    def main(onenote_resource: onenote, section_id: str, page_title: str, page_content: str):
        headers = {
            'Authorization': f"Bearer {onenote_resource['access_token']}",
            'Content-Type': 'application/xhtml+xml'
        }
        page_data = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>{page_title}</title>
            </head>
            <body>
                {page_content}
            </body>
            </html>
        """
        onenote_api_url = f"https://graph.microsoft.com/v1.0/me/onenote/sections/{section_id}/pages"
        response = requests.post(url=onenote_api_url, headers=headers, data=page_data)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the OneNote integration
    class onenote(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str

    # Define the main function for creating a page in OneNote
    def main(onenote_resource: onenote, page_title: str, page_content: str, section_id: str) -> str:
        import requests

        # OneNote API endpoint to create a page
        endpoint = f"https://graph.microsoft.com/v1.0/me/onenote/sections/{section_id}/pages"

        # Headers for the POST request
        headers = {
            "Content-Type": "application/xhtml+xml",
            "Authorization": f"Bearer {onenote_resource['access_token']}"
        }

        # Construct the HTML content for the new page
        content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>{page_title}</title>
        </head>
        <body>
            <p>{page_content}</p>
        </body>
        </html>
        """

        # Make the POST request to create the page
        response = requests.post(endpoint, headers=headers, data=content)

        # Check for successful creation
        if response.status_code == 201:
            return f"Page created successfully. Page ID: {response.json()['id']}"
        else:
            return f"Failed to create page. Status code: {response.status_code}, Error message: {response.text}"

    # Note: The function does not call itself, it's meant to be used by the user with the appropriate parameters.
  id: |-
    synthetic_create-page
  instructions: |-
    Creates a page in onenote
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    onenote
  resource_type_def: |-
    class onenote(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the bybit integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        # Add any other properties needed for bybit authentication/configuration

    # Import any libraries needed for the bybit integration
    # If any imports conflict with the 'bybit' resource type name, rename the import
    import bybit_api  # Hypothetical library for bybit, renamed if it conflicts with the resource type name

    def main(bybit_resource: bybit, symbol: str, margin: float):
        # Initialize the bybit API client with the provided credentials
        client = bybit_api.bybit(api_key=bybit_resource['api_key'], api_secret=bybit_resource['api_secret'])

        # Call the method to reduce margin, assuming such a method exists in the bybit API client
        result = client.reduce_margin(symbol=symbol, margin=margin)

        # Return the result of the API call
        return result

    # The script ends here without calling the main function, as per the instructions.
  good: |-
    from typing import TypedDict

    class bybit(TypedDict):
        api_key: str
        api_secret: str

    def main(bybit_resource: bybit, symbol: str, position_id: int, margin: float):
        import bybit_api

        client = bybit_api.bybit(test=False, api_key=bybit_resource['api_key'], api_secret=bybit_resource['api_secret'])

        result = client.LinearPositions.LinearPositions_changeMargin(
            symbol=symbol,
            position_id=position_id,
            margin=margin
        ).result()

        return result
  id: |-
    synthetic_linear-position-update-margin
  instructions: |-
    Add Reduce Margin. in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Gitlab = {
        apiToken: string;
        apiUrl: string;
    }

    export async function main(gitlabResource: Gitlab, projectId: string, branchName: string) {
        const url = `${gitlabResource.apiUrl}/projects/${encodeURIComponent(projectId)}/repository/commits?ref_name=${encodeURIComponent(branchName)}`;
        const headers = {
            "Authorization": `Bearer ${gitlabResource.apiToken}`,
            "Content-Type": "application/json"
        };

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`Failed to fetch commits: ${response.status} ${response.statusText}`);
        }

        const commits = await response.json();
        return commits;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Gitlab = {
        apiToken: string;
        projectId: string;
    }

    export async function main(gitlabResource: Gitlab, branch: string, since?: string, until?: string) {
        const headers = new Headers({
            "Authorization": `Bearer ${gitlabResource.apiToken}`,
            "Content-Type": "application/json",
        });

        let url = `https://gitlab.com/api/v4/projects/${encodeURIComponent(gitlabResource.projectId)}/repository/commits?ref_name=${encodeURIComponent(branch)}`;
        if (since) {
            url += `&since=${encodeURIComponent(since)}`;
        }
        if (until) {
            url += `&until=${encodeURIComponent(until)}`;
        }

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`GitLab API responded with status code ${response.status}`);
        }

        const commits = await response.json();
        return commits;
    }
  id: |-
    synthetic_list-commits
  instructions: |-
    List commits in a repository branch in gitlab
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
        apiToken: string;
        projectId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { CroveClient as CroveClientLib } from "npm:crove";

    type CroveApp = {
        apiKey: string;
    }

    export async function main(croveResource: CroveApp, documentId: string, variables: Record<string, any>) {
        const croveClient = new CroveClientLib(croveResource.apiKey);
        const result = await croveClient.completeDocument(documentId, variables);
        return result;
    }
  good: |-
    type CroveApp = {
        apiKey: string;
        projectId: string;
    }

    export async function main(croveAppResource: CroveApp, documentId: string) {
        const response = await fetch(`https://api.crove.app/v1/projects/${croveAppResource.projectId}/documents/${documentId}/complete`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${croveAppResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error marking document as completed: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_complete-document
  instructions: |-
    Mark the document as completed in crove app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CroveApp
  resource_type_def: |-
    type CroveApp = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { KanbanTool } from "npm:kanban-tool-api";

    type KanbanToolResource = {
        apiKey: string;
        boardId: string;
        workflowId: string;
    }

    export async function main(
        kanbanToolResource: KanbanToolResource,
        taskId: string,
        targetColumnId: string
    ) {
        const kanbanTool = new KanbanTool(kanbanToolResource.apiKey);

        // Move the task to the target column
        const result = await kanbanTool.moveTask(
            kanbanToolResource.boardId,
            kanbanToolResource.workflowId,
            taskId,
            targetColumnId
        );

        // Always return the result
        return result;
    }
  good: |-
    import { KanbanTool as KanbanToolAPI } from "npm:kanban-tool-api";

    type KanbanTool = {
        apiKey: string;
        boardId: number;
        subdomain: string;
    }

    export async function main(
        kanbanToolResource: KanbanTool,
        taskId: number,
        targetColumnId: number,
        targetSwimlaneId?: number
    ) {
        const kanbanTool = new KanbanToolAPI(
            kanbanToolResource.apiKey,
            kanbanToolResource.boardId,
            kanbanToolResource.subdomain
        );

        const result = await kanbanTool.moveTask(taskId, targetColumnId, targetSwimlaneId);

        return result;
    }
  id: |-
    synthetic_move-task
  instructions: |-
    Moves a task in kanban tool
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    KanbanTool
  resource_type_def: |-
    type KanbanTool = {
        apiKey: string;
        boardId: number;
        subdomain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { post as httpPost } from "npm:@deno/stdlib/http/mod.ts";

    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }

    export async function main(
        onesignalResource: OnesignalRestApi,
        message: string,
        includedSegments: string[] = ["All"],
        data: Record<string, any> = {},
        url: string = "",
        headings: Record<string, string> = { "en": "Notification" }
    ) {
        const notificationPayload = {
            app_id: onesignalResource.appId,
            contents: { "en": message },
            included_segments: includedSegments,
            data: data,
            url: url,
            headings: headings
        };

        const response = await httpPost("https://onesignal.com/api/v1/notifications", {
            headers: {
                "Content-Type": "application/json; charset=utf-8",
                "Authorization": `Basic ${onesignalResource.restApiKey}`
            },
            body: JSON.stringify(notificationPayload),
        });

        return response;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type OnesignalRestApi = {
        apiKey: string,
        appId: string
    }

    export async function main(onesignalResource: OnesignalRestApi, message: string, includedSegments: string[] = ["All"]) {
        const url = 'https://onesignal.com/api/v1/notifications';
        const headers = new Headers({
            "Content-Type": "application/json; charset=utf-8",
            "Authorization": `Basic ${encode(onesignalResource.apiKey)}`
        });

        const body = JSON.stringify({
            app_id: onesignalResource.appId,
            contents: { "en": message },
            included_segments: includedSegments
        });

        const response = await fetch(url, {
            method: "POST",
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_create-notification
  instructions: |-
    Create a notification in onesignal rest api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    OnesignalRestApi
  resource_type_def: |-
    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }

    export async function main(nationbuilderResource: Nationbuilder, personData: { email: string, firstName: string, lastName: string }) {
        const url = `https://${nationbuilderResource.nationSlug}.nationbuilder.com/api/v1/people`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${nationbuilderResource.accessToken}`
        };
        const body = JSON.stringify({
            person: personData
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import necessary libraries
    import { Nationbuilder } from "npm:nationbuilder";

    type Nationbuilder = {
        accessToken: string,
        nationSlug: string,
        apiEndpoint: string
    }

    export async function main(nationbuilderResource: Nationbuilder, personData: { email: string, firstName: string, lastName: string, phone?: string, mobile?: string }) {
        // Construct the API endpoint for creating a new person
        const url = `${nationbuilderResource.apiEndpoint}/${nationbuilderResource.nationSlug}/people`;

        // Prepare the headers and body for the POST request
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${nationbuilderResource.accessToken}`
        };
        const body = JSON.stringify({
            person: personData
        });

        // Make the POST request to create a new person
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Parse the response and return the result
        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_create-person
  instructions: |-
    Create a new person with the provided data in nationbuilder
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nationbuilder
  resource_type_def: |-
    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { format } from "npm:date-fns";

    type Jibble = {
        apiKey: string;
        apiSecret: string;
        apiUrl: string;
    }

    export async function main(jibbleResource: Jibble, userId: string, clockInTime: Date) {
        const formattedTime = format(clockInTime, "yyyy-MM-dd'T'HH:mm:ssXXX");
        const clockInEndpoint = `${jibbleResource.apiUrl}/time_entries`;

        const response = await fetch(clockInEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jibbleResource.apiKey}:${jibbleResource.apiSecret}`
            },
            body: JSON.stringify({
                user_id: userId,
                type: 'clock_in',
                time: formattedTime
            })
        });

        if (!response.ok) {
            throw new Error(`Failed to clock in: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { formatISO } from "npm:date-fns";

    type Jibble = {
        apiKey: string;
        teamId: string;
    }

    export async function main(jibbleResource: Jibble, userId: string, clockInTime: Date) {
        const clockInTimeISO = formatISO(clockInTime);
        const response = await fetch(`https://api.jibble.io/v1/teams/${jibbleResource.teamId}/timeEntries`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jibbleResource.apiKey}`
            },
            body: JSON.stringify({
                userId: userId,
                type: 'clockIn',
                time: clockInTimeISO
            })
        });

        if (!response.ok) {
            throw new Error(`Error creating time entry: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_clock-in
  instructions: |-
    Create a new clock in time entry. in jibble
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jibble
  resource_type_def: |-
    type Jibble = {
        apiKey: string;
        apiSecret: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Clickup as ClickupAPI } from "npm:@/clickup";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, teamId: string) {
        const clickup = new ClickupAPI(clickupResource.apiKey);
        const templates = await clickup.getTaskTemplates(teamId);
        return templates;
    }
  good: |-
    import { fetch } from "npm:@deno/fetch";

    type Clickup = {
        accessToken: string;
    }

    export async function main(clickupResource: Clickup, teamId: string) {
        const url = `https://api.clickup.com/api/v2/team/${teamId}/taskTemplate`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': clickupResource.accessToken,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching task templates: ${response.statusText}`);
        }

        const templates = await response.json();
        return templates;
    }
  id: |-
    synthetic_get-task-templates
  instructions: |-
    Get a list of templates. See the docs in **Task Templates / Get Task Templates** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to ClickUp API

    class clickup(TypedDict):
        api_key: str
        team_id: str

    def main(clickup_resource: clickup, list_id: str, item_name: str, assignee_id: str = None, priority: int = None) -> dict:
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }
        url = f"https://api.clickup.com/api/v2/list/{list_id}/item"
        data = {
            "name": item_name,
            "assignee": assignee_id,
            "priority": priority
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    # Define the main function for creating a checklist item in ClickUp
    def main(clickup_resource: clickup, list_id: str, task_id: str, checklist_name: str, item_name: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the URL for the ClickUp API endpoint to create a checklist item
        url = f"https://api.clickup.com/api/v2/list/{list_id}/task/{task_id}/checklist"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Prepare the payload with the checklist name and item name
        payload = {
            "name": checklist_name,
            "items": [
                {"name": item_name}
            ]
        }

        # Make the POST request to create the checklist item
        response = requests.post(url, json=payload, headers=headers)

        # Return the response as a dictionary
        return response.json()
  id: |-
    synthetic_create-checklist-item
  instructions: |-
    Creates a new item in a checklist. See the docs in **Checklists / Create Checklist Item** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import openai

    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, thread_id: str, run_id: str):
        openai.api_key = openai_resource['api_key']
        response = openai.ChatCompletion.retrieve(
            thread_id=thread_id,
            run_id=run_id
        )
        return response
  good: |-
    from typing import TypedDict

    # Define the resource type for the openai integration
    class openai(TypedDict):
        api_key: str

    # Define the main function with the openai resource and additional parameters
    def main(openai_resource: openai, model: str, prompt: str, max_tokens: int):
        import openai as openai_lib  # Renamed the imported module to avoid conflict

        # Set up the OpenAI API key from the resource
        openai_lib.api_key = openai_resource['api_key']

        # Call the OpenAI API to retrieve the run
        response = openai_lib.Completion.create(
            model=model,
            prompt=prompt,
            max_tokens=max_tokens
        )

        # Return the result of the API call
        return response
  id: |-
    synthetic_retrieve-run
  instructions: |-
    Retrieves a specific run within a thread in openai
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createHmac } from "npm:crypto";

    type Hellosign = {
        apiKey: string,
        clientId: string,
        apiSecret: string
    }

    export async function main(
        hellosignResource: Hellosign,
        templateId: string,
        signers: Array<{ role: string, email_address: string, name: string }>,
        ccEmailAddresses?: Array<string>,
        customFields?: Array<{ name: string, value: string }>
    ) {
        const url = 'https://api.hellosign.com/v3/signature_request/send_with_template';
        const data = {
            template_id: templateId,
            client_id: hellosignResource.clientId,
            signers: signers.reduce((acc, signer) => {
                acc[signer.role] = {
                    email_address: signer.email_address,
                    name: signer.name
                };
                return acc;
            }, {}),
            cc_email_addresses: ccEmailAddresses,
            custom_fields: customFields
        };

        const auth = 'Basic ' + Buffer.from(hellosignResource.apiKey + ':').toString('base64');

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': auth,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { Client } from "npm:@hellosign/sdk";

    type Hellosign = {
        apiKey: string
    }

    export async function main(hellosignResource: Hellosign, templateId: string, signers: { email_address: string, name: string }[], subject: string, message: string) {
        const client = new Client({ key: hellosignResource.apiKey });

        const signatureRequest = {
            template_id: templateId,
            subject: subject,
            message: message,
            signers: signers
        };

        try {
            const response = await client.signatureRequest.sendWithTemplate(signatureRequest);
            return response;
        } catch (error) {
            console.error("Failed to send signature request:", error);
            throw error;
        }
    }
  id: |-
    synthetic_send-signature-request-from-template
  instructions: |-
    Send a signature request from a template with Dropbox Sign in hellosign
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hellosign
  resource_type_def: |-
    type Hellosign = {
        apiKey: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Enrichment } from "npm:@clearbit/enrichment";

    type Clearbit = {
        apiKey: string;
    }

    export async function main(clearbitResource: Clearbit, domain: string) {
        const enrichmentClient = new Enrichment(clearbitResource.apiKey);
        const result = await enrichmentClient.findCompany({ domain });
        return result;
    }
  good: |-
    import { Enrichment } from "npm:@clearbit/enrichment";

    type Clearbit = {
        apiKey: string;
    }

    export async function main(clearbitResource: Clearbit, criteria: { domain?: string, email?: string, company?: string }) {
        const enrichmentClient = new Enrichment(clearbitResource.apiKey);

        let result;
        if (criteria.domain) {
            result = await enrichmentClient.findCompany({ domain: criteria.domain });
        } else if (criteria.email) {
            result = await enrichmentClient.findPerson({ email: criteria.email });
        } else if (criteria.company) {
            result = await enrichmentClient.findCompany({ name: criteria.company });
        } else {
            throw new Error('No valid criteria provided. Please provide a domain, email, or company name.');
        }

        return result;
    }
  id: |-
    synthetic_find-companies
  instructions: |-
    Find companies via specific criteria in clearbit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clearbit
  resource_type_def: |-
    type Clearbit = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { EodhdApis } from "npm:eodhd-api"; // Assuming there's an npm package for Eodhd APIs

    // Define the resource type for the EodhdApis integration
    type EodhdApis = {
        apiKey: string; // API key for authentication with EodhdApis
    };

    // Define the function signature with the necessary parameters
    export async function main(
        eodhdResource: EodhdApis,
        symbol: string, // Stock symbol to retrieve the price for
        date?: string // Optional date parameter to get historical prices
    ) {
        // Initialize the EodhdApis client with the provided API key
        const eodhdClient = new EodhdApis(eodhdResource.apiKey);

        // Retrieve stock prices using the EodhdApis client
        let stockPrice;
        if (date) {
            // If a date is provided, retrieve the historical price
            stockPrice = await eodhdClient.getHistoricalPrice(symbol, date);
        } else {
            // Otherwise, retrieve the latest price
            stockPrice = await eodhdClient.getLatestPrice(symbol);
        }

        // Return the result
        return stockPrice;
    }
  good: |-
    // Import any libraries you need here
    import { format } from "npm:date-fns";

    type EodhdApis = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(eodhdResource: EodhdApis, symbol: string, startDate: Date, endDate: Date) {
        const formattedStartDate = format(startDate, 'yyyy-MM-dd');
        const formattedEndDate = format(endDate, 'yyyy-MM-dd');
        const url = `${eodhdResource.baseUrl}/eod/${symbol}?from=${formattedStartDate}&to=${formattedEndDate}&api_token=${eodhdResource.apiKey}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        return data;
    }
  id: |-
    synthetic_retrieve-stock-prices
  instructions: |-
    Fetch historical stock prices for a given symbol and time period in eodhd apis
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    EodhdApis
  resource_type_def: |-
    type EodhdApis = {
        apiKey: string; // API key for authentication with EodhdApis
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'more_trees_' integration
    class more_trees_(TypedDict):
        api_key: str
        endpoint_url: str

    def main(more_trees_resource: more_trees_, project_id: str, amount_to_offset: float) -> dict:
        import requests  # Import here to avoid conflicts with parameter names

        # Construct the request to the 'more_trees_' integration API
        headers = {
            'Authorization': f"Bearer {more_trees_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'project_id': project_id,
            'amount': amount_to_offset
        }
        response = requests.post(
            f"{more_trees_resource['endpoint_url']}/offset",
            headers=headers,
            json=payload
        )

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()
        else:
            # Handle error responses
            response.raise_for_status()
  good: |-
    from typing import TypedDict

    # Define the resource type for the more_trees_ integration
    class more_trees_(TypedDict):
        api_key: str
        organization_id: str

    def main(more_trees_resource: more_trees_, project_id: str) -> int:
        # Assuming that there is a library to interact with the more_trees_ API
        from more_trees_api import get_project_offset  # hypothetical import

        # Retrieve the total carbon offset for the specified project
        total_offset = get_project_offset(
            api_key=more_trees_resource['api_key'],
            organization_id=more_trees_resource['organization_id'],
            project_id=project_id
        )

        # Return the total carbon offset
        return total_offset
  id: |-
    synthetic_get-carbon-offset
  instructions: "Get the total carbon offset in more trees "
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    more_trees_
  resource_type_def: |-
    class more_trees_(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
    }

    export async function main(kanbanToolResource: KanbanTool, taskId: number) {
        const authHeader = `Basic ${encode(`${kanbanToolResource.apiKey}:x`)}`;
        const url = `https://${kanbanToolResource.domain}.kanbantool.com/api/v1/boards/${kanbanToolResource.boardId}/tasks/${taskId}.json`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const taskDetails = await response.json();
        return taskDetails;
    }
  good: |-
    import { KanbanToolTask } from 'npm:kanban-tool-api';

    type KanbanTool = {
        apiKey: string;
    }

    export async function main(kanbanToolResource: KanbanTool, taskId: number, boardId: number, workspaceId: number) {
        const kanbanToolApi = new KanbanToolTask(kanbanToolResource.apiKey, boardId, workspaceId);

        const taskDetails = await kanbanToolApi.getTaskDetails(taskId);

        return taskDetails;
    }
  id: |-
    synthetic_get-task-details
  instructions: |-
    Gets details of a selected task in kanban tool
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    KanbanTool
  resource_type_def: |-
    type KanbanTool = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type Ahrefs = {
        accessToken: string;
        apiUrl: string;
    }

    export async function main(ahrefsResource: Ahrefs, targetUrl: string) {
        const endpoint = `${ahrefsResource.apiUrl}/backlinks?target=${encodeURIComponent(targetUrl)}`;
        const headers = {
            'Authorization': `Bearer ${ahrefsResource.accessToken}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(endpoint, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { Ahrefs as AhrefsClient } from 'npm:ahrefs-api'; // Renamed imported Ahrefs to AhrefsClient to avoid conflict

    type Ahrefs = {
        accessToken: string; // OAuth2 Access Token for Ahrefs API
    }

    export async function main(ahrefsResource: Ahrefs, target: string, from: number = 0, size: number = 100) {
        const ahrefs = new AhrefsClient({ accessToken: ahrefsResource.accessToken });

        const backlinks = await ahrefs.backlinks({
            target: target,
            from: from,
            size: size
        });

        return backlinks;
    }
  id: |-
    synthetic_get-backlinks
  instructions: |-
    Get the backlinks for a domain or URL with details for the referring pages (e.g., anchor and page title). in ahrefs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ahrefs
  resource_type_def: |-
    type Ahrefs = {
        accessToken: string; // OAuth2 Access Token for Ahrefs API
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type Blogger = {
        accessToken: string;
        blogId: string;
    }

    export async function main(bloggerResource: Blogger, postId: string, updatedContent: string, updatedTitle?: string) {
        const oauth2Client = new OAuth2Client();
        oauth2Client.setCredentials({
            access_token: bloggerResource.accessToken,
        });

        const url = `https://www.googleapis.com/blogger/v3/blogs/${bloggerResource.blogId}/posts/${postId}`;
        const body = {
            content: updatedContent,
            ...(updatedTitle && { title: updatedTitle }),
        };

        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${bloggerResource.accessToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });

        if (!response.ok) {
            throw new Error(`Failed to update the post: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type Blogger = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }

    export async function main(bloggerResource: Blogger, blogId: string, postId: string, updatedContent: string, updatedTitle?: string) {
        const oauth2Client = new OAuth2Client(
            bloggerResource.clientId,
            bloggerResource.clientSecret
        );

        oauth2Client.setCredentials({
            refresh_token: bloggerResource.refreshToken
        });

        const accessTokenResponse = await oauth2Client.getAccessToken();
        const accessToken = accessTokenResponse.token;

        const updatePostUrl = `https://www.googleapis.com/blogger/v3/blogs/${blogId}/posts/${postId}`;

        const updatePostData = {
            content: updatedContent,
            ...(updatedTitle && { title: updatedTitle })
        };

        const response = await fetch(updatePostUrl, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updatePostData)
        });

        if (!response.ok) {
            throw new Error(`Failed to update post: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-post
  instructions: |-
    Updates a published post. in blogger
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Blogger
  resource_type_def: |-
    type Blogger = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Optional
    import requests  # Assuming requests is needed for HTTP requests to MonkeyLearn API

    class monkeylearn(TypedDict):
        api_key: str

    def main(monkeylearn_resource: monkeylearn, data: List[dict], tags: Optional[List[str]] = None):
        """
        Uploads or updates data in MonkeyLearn classifier.

        :param monkeylearn_resource: A dictionary containing the API key for MonkeyLearn.
        :param data: A list of dictionaries, each containing a 'text' field and optionally an 'external_id'.
        :param tags: An optional list of tags for the texts.
        :return: The result of the API call to MonkeyLearn.
        """
        headers = {
            'Authorization': f"Token {monkeylearn_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Define the endpoint URL for uploading data to MonkeyLearn classifier
        url = "https://api.monkeylearn.com/v3/classifiers/{classifier_id}/data/"

        # Prepare the payload with data and tags if provided
        payload = {
            'data': data
        }
        if tags:
            payload['tags'] = tags

        # Make the POST request to MonkeyLearn API
        response = requests.post(url, json=payload, headers=headers)

        # Return the response from the API call
        return response.json()

    # Note: The 'main' function is not called here, it is just defined and exported.
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP requests to the MonkeyLearn API

    # Define the resource type for the monkeylearn integration
    class monkeylearn(TypedDict):
        api_key: str

    def main(monkeylearn_resource: monkeylearn, data: List[Dict[str, str]], model_id: str) -> Dict:
        """
        Uploads training data to the MonkeyLearn platform for a given model.

        :param monkeylearn_resource: A dictionary containing the API key for authentication.
        :param data: A list of dictionaries, where each dictionary represents a training data point.
        :param model_id: The ID of the model to which the training data will be uploaded.
        :return: A dictionary containing the response from the MonkeyLearn API.
        """
        headers = {
            'Authorization': f'Token {monkeylearn_resource["api_key"]}',
            'Content-Type': 'application/json'
        }
        url = f'https://api.monkeylearn.com/v3/classifiers/{model_id}/data/'
        response = requests.post(url, json={'data': data}, headers=headers)
        return response.json()
  id: |-
    synthetic_upload-training-data
  instructions: |-
    Uploads data to a classifier. This component can be used to upload new data to a classifier, to update the tags of texts that have already been uploaded, or both in monkeylearn
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    monkeylearn
  resource_type_def: |-
    class monkeylearn(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Hookdeck as HookdeckClient } from "npm:@hookdeck/client";

    type Hookdeck = {
        apiKey: string;
    }

    export async function main(hookdeckResource: Hookdeck) {
        const hookdeckClient = new HookdeckClient(hookdeckResource.apiKey);

        const events = await hookdeckClient.events.list();

        return events;
    }
  good: |-
    import { Hookdeck } from "npm:@hookdeck/client";

    type HookdeckResource = {
        apiKey: string;
        // Add any other properties required for Hookdeck authentication
    }

    export async function main(hookdeckResource: HookdeckResource, eventName?: string) {
        const hookdeck = new Hookdeck(hookdeckResource.apiKey);

        let events;
        if (eventName) {
            events = await hookdeck.events.list({ event: eventName });
        } else {
            events = await hookdeck.events.list();
        }

        return events;
    }
  id: |-
    synthetic_retrieve-all-events
  instructions: |-
    This endpoint lists all events, or a subset of events. in hookdeck
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hookdeck
  resource_type_def: |-
    type Hookdeck = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Dext = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }

    export async function main(dextResource: Dext, startDate: string, endDate: string) {
        // Construct the request for the Dext API to get client activity stats
        const credentials = `${dextResource.clientId}:${dextResource.clientSecret}`;
        const encodedCredentials = encode(credentials);
        const response = await fetch('https://api.dext.com/some-endpoint/client-activity-stats', {
            method: 'GET',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json',
                'X-Refresh-Token': dextResource.refreshToken,
                'X-Start-Date': startDate,
                'X-End-Date': endDate
            }
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse the response body as JSON
        const data = await response.json();

        // Return the result
        return data;
    }
  good: |-
    // Import any libraries you might need here
    import { format } from "npm:date-fns";

    type Dext = {
        apiKey: string;
        accountId: string;
    }

    export async function main(dextResource: Dext, clientId: string, startDate: string, endDate: string) {
        const baseUrl = 'https://api.dext.com';
        const statsEndpoint = `/v1/clients/${clientId}/activity-stats`;

        // Prepare headers for the API request
        const headers = {
            'Authorization': `Bearer ${dextResource.apiKey}`,
            'Account-Id': dextResource.accountId,
            'Content-Type': 'application/json'
        };

        // Format the dates for the API request
        const formattedStartDate = format(new Date(startDate), 'yyyy-MM-dd');
        const formattedEndDate = format(new Date(endDate), 'yyyy-MM-dd');

        // Construct the URL with query parameters
        const url = `${baseUrl}${statsEndpoint}?start_date=${formattedStartDate}&end_date=${formattedEndDate}`;

        // Make the API request
        const response = await fetch(url, { headers: headers });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse the response data
        const data = await response.json();

        // Return the result
        return data;
    }
  id: |-
    synthetic_get-client-activity-stats
  instructions: |-
    Retrieves the rolling annual and monthly-average Activity Stats for a particular client in dext
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dext
  resource_type_def: |-
    type Dext = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    def main(clickup_resource: clickup, time_entry_id: str) -> bool:
        import requests  # Import here to avoid conflicts with any parameter names

        # Endpoint to stop a time entry in ClickUp
        stop_time_entry_endpoint = f"https://api.clickup.com/api/v2/team/time_entries/{time_entry_id}/stop"

        # Headers for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Make the request to stop the time entry
        response = requests.put(stop_time_entry_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return True
        else:
            return False

    # The complete script is ready to be exported and used with the specified parameters.
  good: |-
    import requests
    from typing import TypedDict

    class clickup(TypedDict):
        api_key: str
        team_id: str

    def main(clickup_resource: clickup, time_entry_id: str) -> dict:
        headers = {
            'Authorization': clickup_resource['api_key'],
            'Content-Type': 'application/json'
        }
        url = f"https://api.clickup.com/api/v2/team/{clickup_resource['team_id']}/time_entries/{time_entry_id}/stop"

        response = requests.post(url, headers=headers)
        return response.json()
  id: |-
    synthetic_stop-time-entry
  instructions: |-
    Stop time entry in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the brex_staging integration
    class brex_staging(TypedDict):
        api_key: str
        account_id: str

    # Define the main function for listing transactions for a selected cash account
    def main(brex_staging_resource: brex_staging, start_date: str, end_date: str) -> List[dict]:
        # Import the requests library here to avoid potential naming conflicts
        import requests

        # Construct the API endpoint for listing transactions
        transactions_endpoint = f"https://api.brex.io/staging/accounts/{brex_staging_resource['account_id']}/transactions"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {brex_staging_resource['api_key']}"
        }

        # Set up the parameters for the date range
        params = {
            "start_date": start_date,
            "end_date": end_date
        }

        # Make the API request to list transactions
        response = requests.get(transactions_endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of transactions
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # The main function is not called here, as per the instructions
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the brex_staging integration
    class brex_staging(TypedDict):
        api_key: str
        account_id: str

    def main(brex_staging_resource: brex_staging, cash_account_id: str) -> List[Dict]:
        # Construct the API endpoint for listing transactions
        url = f"https://api.brex.io/staging/cash/accounts/{cash_account_id}/transactions"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {brex_staging_resource['api_key']}"
        }

        # Make the API request to list transactions
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of transactions
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()
  id: |-
    synthetic_list-transactions-for-selected-cash-account
  instructions: |-
    Lists all transactions for the specified cash account. in brex staging
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    brex_staging
  resource_type_def: |-
    class brex_staging(TypedDict):
        api_key: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { hmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, leverage: number) {
        const timestamp = new Date().getTime();
        const params = `api_key=${bybitResource.apiKey}&symbol=${symbol}&leverage=${leverage}&timestamp=${timestamp}`;
        const signature = hmac('sha256', bybitResource.apiSecret, params).toString('hex');
        const url = `${bybitResource.endpoint}/user/leverage/save`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Request-Signature': signature
            },
            body: params
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string; // e.g. "https://api.bybit.com"
    }

    export async function main(bybitResource: Bybit, symbol: string, leverage: number) {
        const timestamp = new Date().getTime();
        const params = {
            api_key: bybitResource.apiKey,
            timestamp: timestamp.toString(),
            symbol: symbol,
            leverage: leverage.toString(),
        };

        const signature = createHmac('sha256', bybitResource.apiSecret)
            .update(new URLSearchParams(params).toString())
            .digest('hex');

        const response = await fetch(`${bybitResource.endpoint}/v2/private/position/leverage/save`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({ ...params, sign: signature }).toString(),
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_linear-position-set-leverage
  instructions: |-
    Set Leverage in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string; // e.g. "https://api.bybit.com"
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type IntellexerApi = {
        apiKey: string;
    }

    export async function main(intellexerApiResource: IntellexerApi, documentContent: string) {
        const apiUrl = `http://api.intellexer.com/recognizeNeText?apikey=${intellexerApiResource.apiKey}`;
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'text/plain',
                'Accept': 'application/json',
            },
            body: documentContent
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  good: |-
    import { NER } from "npm:@intellexer/api";

    type IntellexerApi = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(intellexerApiResource: IntellexerApi, text: string) {
        const ner = new NER(intellexerApiResource.baseUrl, intellexerApiResource.apiKey);
        const entities = await ner.extractNamedEntities(text);
        return entities;
    }
  id: |-
    synthetic_extract-named-entities
  instructions: |-
    Extract named entities from a document using Intellexer API in intellexer api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    IntellexerApi
  resource_type_def: |-
    type IntellexerApi = {
        apiKey: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for making HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type Browserless = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: Browserless, url: string, options?: { [key: string]: any }) {
        const { apiKey, endpoint } = browserlessResource;
        const pdfEndpoint = `${endpoint}/pdf?token=${apiKey}`;
        const body = JSON.stringify({
            url,
            ...options
        });

        const response = await fetch(pdfEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error generating PDF: ${response.statusText}`);
        }

        const pdfBuffer = await response.arrayBuffer();
        return new Uint8Array(pdfBuffer);
    }
  good: |-
    import { Browserless as BrowserlessClient } from "@browserless/node";

    type Browserless = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: Browserless, htmlString: string, pdfOptions?: Record<string, unknown>) {
        const browserless = new BrowserlessClient(browserlessResource.apiKey, { endpoint: browserlessResource.endpoint });

        const pdfBuffer = await browserless.pdf(htmlString, pdfOptions);

        return pdfBuffer;
    }
  id: |-
    synthetic_convert-html-to-pdf
  instructions: |-
    See https://docs.browserless.io/docs/pdf.html in browserless
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Browserless
  resource_type_def: |-
    type Browserless = {
        apiKey: string,
        endpoint: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'companycam' integration
    class companycam(TypedDict):
        api_key: str  # Assuming API key is used for authentication

    # Main function to find a project in CompanyCam
    def main(companycam_resource: companycam, project_id: str):
        import requests  # Import here to avoid conflicts with any parameter names

        # Base URL for CompanyCam API
        base_url = "https://api.companycam.com/v3/"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {companycam_resource['api_key']}"
        }

        # Endpoint for getting a specific project
        endpoint = f"projects/{project_id}"

        # Make the request to get the project details
        response = requests.get(base_url + endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the project details
            return response.json()
        else:
            # Handle errors (e.g., project not found, authentication error)
            return {
                "error": response.status_code,
                "message": response.json().get('message', 'An error occurred')
            }

    # The script ends here, with no call to the main function as per the instructions.
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to the CompanyCam API

    # Define the resource type for the companycam integration
    class companycam(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function with the resource type and additional parameters
    def main(companycam_resource: companycam, project_name: str) -> Optional[dict]:
        # Set up the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {companycam_resource['api_key']}"
        }

        # Define the base URL for the CompanyCam API
        base_url = "https://api.companycam.com/v3/projects"

        # Set up the parameters for the request to find a project by name
        params = {
            'search': project_name
        }

        # Make the GET request to the CompanyCam API to search for the project
        response = requests.get(base_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            projects = response.json()

            # Iterate through the projects to find the one that matches the project_name
            for project in projects.get('projects', []):
                if project.get('name') == project_name:
                    # Return the matching project's details
                    return project

        # If no project is found or there's an error, return None
        return None
  id: |-
    synthetic_find-project
  instructions: |-
    Find a project by name. in companycam
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    companycam
  resource_type_def: |-
    class companycam(TypedDict):
        api_key: str  # Assuming API key is used for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to onedesk API

    class onedesk(TypedDict):
        api_key: str
        base_url: str

    def main(onedesk_resource: onedesk, item_name: str, item_description: str, additional_data: dict[str, Any]):
        headers = {
            'Authorization': f"Bearer {onedesk_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"{onedesk_resource['base_url']}/items"
        payload = {
            'name': item_name,
            'description': item_description,
            **additional_data
        }
        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'onedesk' integration
    class onedesk(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    # Main function to create an item in onedesk
    def main(onedesk_resource: onedesk, item_name: str, item_description: str, additional_data: dict[str, Any]):
        import requests  # Import here to avoid conflicts with parameter names

        # Construct the URL for the onedesk API endpoint to create an item
        url = f"{onedesk_resource['base_url']}/items"

        # Prepare the headers with the necessary authentication details
        headers = {
            'Authorization': f"Bearer {onedesk_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Prepare the payload with the item details
        payload = {
            'name': item_name,
            'description': item_description,
            **additional_data  # Include any additional data provided
        }

        # Make the POST request to create the item
        response = requests.post(url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created item details
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {'error': response.text, 'status_code': response.status_code}
  id: |-
    synthetic_create-item
  instructions: |-
    Creates a new item in onedesk
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    onedesk
  resource_type_def: |-
    class onedesk(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { hmac } from "npm:crypto";

    type Bingx = {
        apiKey: string;
        secretKey: string;
        passphrase: string;
    }

    export async function main(bingxResource: Bingx, symbol: string, size: number, side: 'buy' | 'sell', leverage: number, price: number) {
        const apiPath = '/openApi/spot/v1/trade/order';
        const baseUrl = 'https://api.bingx.com';
        const timestamp = Date.now();
        const body = {
            symbol: symbol,
            size: size,
            side: side,
            type: 'LIMIT',
            price: price,
            leverage: leverage,
            timestamp: timestamp
        };

        const queryString = Object.entries(body).map(([key, val]) => `${key}=${val}`).join('&');
        const signature = hmac('sha256', bingxResource.secretKey, queryString, 'utf8', 'hex');

        const headers = {
            'Content-Type': 'application/json',
            'X-BX-APIKEY': bingxResource.apiKey,
            'X-BX-SIGN': signature,
            'X-BX-TIMESTAMP': timestamp.toString(),
            'X-BX-PASSPHRASE': bingxResource.passphrase
        };

        const response = await fetch(`${baseUrl}${apiPath}`, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { BingX as BingXClient } from "npm:@bingx/bingx-api";

    type Bingx = {
        apiKey: string;
        secretKey: string;
    }

    export async function main(bingxResource: Bingx, symbol: string) {
        const bingxClient = new BingXClient(bingxResource.apiKey, bingxResource.secretKey);
        const positions = await bingxClient.getPositions(symbol);
        return positions;
    }
  id: |-
    synthetic_account-get-positions
  instructions: |-
    Perpetual Swap Positions. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the bingx integration
    class bingx(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the bingx integration
    def main(bingx_resource: bingx, ticker_symbol: str) -> dict:
        # Import the necessary library for HTTP requests
        import requests

        # Define the endpoint for getting ticker information
        ticker_url = f"https://api.bingx.com/v1/market/ticker?symbol={ticker_symbol}"

        # Set up the headers with the API key
        headers = {
            "X-BingX-APIKEY": bingx_resource['api_key'],
            "X-BingX-SECRET": bingx_resource['api_secret']
        }

        # Make the HTTP request to get the ticker information
        response = requests.get(ticker_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            ticker_data = response.json()
            # Return the ticker data
            return ticker_data
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function is not called here, as per the instructions.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to BingX Market API

    class bingx(TypedDict):
        api_key: str
        api_secret: str

    def main(bingx_resource: bingx, symbol: str) -> dict:
        base_url = "https://api.bingx.com/v1"
        endpoint = f"/market/ticker?symbol={symbol}"
        headers = {
            "X-BingX-APIKEY": bingx_resource['api_key'],
            "X-BingX-SECRET": bingx_resource['api_secret']
        }

        response = requests.get(base_url + endpoint, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  id: |-
    synthetic_market-get-ticker
  instructions: |-
    Get Ticker. in bingx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bingx
  resource_type_def: |-
    class bingx(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GoogleAuth } from "npm:google-auth-library";

    type GoogleSheets = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, title?: string, spreadsheetIdToDuplicate?: string) {
        const auth = new GoogleAuth({
            credentials: {
                client_id: googleSheetsResource.clientId,
                client_secret: googleSheetsResource.clientSecret,
                redirect_uris: [googleSheetsResource.redirectUri],
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets'],
        });

        const client = await auth.getClient();
        const sheets = google.sheets({ version: 'v4', auth: client });

        if (spreadsheetIdToDuplicate) {
            // Duplicate the existing spreadsheet
            const copyTitle = title || `Copy of ${spreadsheetIdToDuplicate}`;
            const requestBody = {
                name: copyTitle,
            };

            const response = await sheets.spreadsheets.copyTo({
                spreadsheetId: spreadsheetIdToDuplicate,
                resource: requestBody,
            });

            return response.data;
        } else {
            // Create a new blank spreadsheet
            const requestBody = {
                properties: {
                    title: title || 'New Spreadsheet',
                },
            };

            const response = await sheets.spreadsheets.create({
                resource: requestBody,
            });

            return response.data;
        }
    }
  good: |-
    // Importing necessary libraries
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, title: string) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.accessToken });

        const resource = {
            properties: {
                title: title
            }
        };

        try {
            const response = await sheets.spreadsheets.create({
                resource,
                fields: 'spreadsheetId'
            });

            return response.data;
        } catch (error) {
            // Handle the error appropriately in your script
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  id: |-
    synthetic_create-spreadsheet
  instructions: |-
    Create a blank spreadsheet or duplicate an existing spreadsheet in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict

    # Define the resource type for the 'moxie' integration
    class moxie(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for searching contacts in the 'moxie' integration
    def main(moxie_resource: moxie, search_query: str, page: int = 1, page_size: int = 10) -> List[Dict]:
        import requests  # Import requests or any other library if needed

        # Construct the search URL
        search_url = f"{moxie_resource['base_url']}/contacts/search"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {moxie_resource['api_key']}"
        }

        # Set up the search parameters
        params = {
            "query": search_query,
            "page": page,
            "pageSize": page_size
        }

        # Make the HTTP request to the 'moxie' API
        response = requests.get(search_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the contacts
            return response.json().get('contacts', [])
        else:
            # Handle errors (e.g., by raising an exception or returning an empty list)
            response.raise_for_status()

    # The script ends here, with no calls to the main function, as per the instructions.
  good: |-
    from typing import TypedDict, List, Optional
    import moxie  # Assuming 'moxie' is the name of the library for the integration

    # Rename the imported 'moxie' method if it conflicts with the resource type name
    import moxie as moxie_lib

    class moxie(TypedDict):
        api_key: str
        workspace_id: str

    def main(moxie_resource: moxie, search_query: str, max_results: Optional[int] = None) -> List[dict]:
        # Initialize the Moxie client with the provided API key and workspace ID
        client = moxie_lib.Client(api_key=moxie_resource['api_key'], workspace_id=moxie_resource['workspace_id'])

        # Search for contacts using the search query and optional max results limit
        contacts = client.search_contacts(query=search_query, limit=max_results)

        # Return the list of found contacts
        return contacts
  id: |-
    synthetic_search-contacts
  instructions: |-
    Searches contacts in your workspace in moxie
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    moxie
  resource_type_def: |-
    class moxie(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'knorish' integration
    class knorish(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for adding a user to a course
    def main(knorish_resource: knorish, user_email: str, user_first_name: str, user_last_name: str, course_id: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for adding a user to a course
        endpoint = f"{knorish_resource['base_url']}/courses/{course_id}/users"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Bearer {knorish_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'email': user_email,
            'first_name': user_first_name,
            'last_name': user_last_name
        }

        # Make the API request to add the user to the course
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check the response and return the result
        if response.status_code == 200:
            return response.json()  # Return the response data if successful
        else:
            response.raise_for_status()  # Raise an exception if there's an error

    # The main function is now defined and ready to be used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'knorish' integration
    class knorish(TypedDict):
        api_key: str
        site_url: str

    # Import any additional libraries you might need
    import requests

    # Define the main function for the 'knorish' integration
    def main(knorish_resource: knorish, course_id: str, user_email: str, user_first_name: str, user_last_name: str):
        # Construct the API endpoint for adding a user to a course
        endpoint = f"{knorish_resource['site_url']}/api/v1/courses/{course_id}/users"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Bearer {knorish_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "email": user_email,
            "first_name": user_first_name,
            "last_name": user_last_name
        }

        # Make the API request to add the user to the course
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful and return the result
        if response.status_code == 200:
            return response.json()
        else:
            # If the request failed, raise an exception with the error message
            response.raise_for_status()
  id: |-
    synthetic_add-user-in-course
  instructions: |-
    Add a specific user to a specific course on your Knorish site in knorish
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    knorish
  resource_type_def: |-
    class knorish(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type HelperFunctions = {
        // Assuming no specific credentials or configuration are needed for HelperFunctions integration
    }

    export async function main(helperFunctionsResource: HelperFunctions, items: any[], count: number = 1) {
        const shuffled = items.sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count);
    }
  good: |-
    // Import any libraries you might need here

    type HelperFunctions = {
        apiKey: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, items: string[]) {
        // Assuming that the 'items' parameter is an array of strings that we need to process using the HelperFunctions integration

        // Process the items using the HelperFunctions integration and apiKey
        const processedItems = items.map(item => {
            // Implement the logic to process each item here
            // This is a placeholder for the actual processing logic
            return `Processed: ${item}`;
        });

        // Return the processed items
        return processedItems;
    }
  id: |-
    synthetic_random-item-from-list
  instructions: |-
    List of items. Can pass an array from a previous step. in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        // Assuming no specific credentials or configuration are needed for HelperFunctions integration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the klazify integration
    class klazify(TypedDict):
        api_key: str

    def main(klazify_resource: klazify, url_to_categorize: str) -> Dict[str, Any]:
        # Assuming the Klazify API requires an API key in the headers for authentication
        headers = {
            'Authorization': f"Bearer {klazify_resource['api_key']}"
        }

        # Assuming the Klazify API endpoint for real-time categorization
        api_endpoint = "https://api.klazify.com/categorize"

        # Prepare the data payload for the POST request
        data = {
            'url': url_to_categorize
        }

        # Make the POST request to the Klazify API
        response = requests.post(api_endpoint, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response from the API
            return response.json()
        else:
            # Handle errors (for simplicity, just returning the status code and error message)
            return {
                'error': True,
                'status_code': response.status_code,
                'message': response.text
            }

    # The main function is not called, as per the instructions.
  good: |-
    from typing import TypedDict, Union
    import requests  # Assuming requests is needed for HTTP requests to Klazify API

    # Define the resource type for the klazify integration
    class klazify(TypedDict):
        api_key: str  # API key for authentication with Klazify

    def main(klazify_resource: klazify, input_data: str) -> dict:
        """
        Analyzes the URL content or email's domain and classifies it into possible topic categories using Klazify.

        :param klazify_resource: A dictionary containing the API key for Klazify.
        :param input_data: A string that is either a URL or an email address to be classified.
        :return: A dictionary with the classification results.
        """
        # Determine if the input data is a URL or an email
        if "@" in input_data:
            # Extract the domain from the email
            domain = input_data.split('@')[-1]
            endpoint = f"https://api.klazify.com/klazify/domain"
            data_to_send = {"domain": domain}
        else:
            # Assume the input data is a URL
            endpoint = f"https://api.klazify.com/klazify/url"
            data_to_send = {"url": input_data}

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {klazify_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to Klazify API
        response = requests.post(endpoint, json=data_to_send, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the classification result
            return response.json()
        else:
            # Handle errors (you could also raise an exception here)
            return {"error": "Failed to classify the input data", "status_code": response.status_code}

    # Example usage (this line should not be included in the script as per instructions):
    # result = main(klazify_resource={"api_key": "your_api_key"}, input_data="https://www.example.com")
  id: |-
    synthetic_real-time-categorization
  instructions: |-
    Analize the URL content or email's domain (if the input is an email) and classifies it into 385+ possible topic categories. in klazify
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    klazify
  resource_type_def: |-
    class klazify(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { toDataURL } from "npm:qrcode";

    type Codereadr = {
        apiKey: string;
        serviceId: string;
    }

    export async function main(codereadrResource: Codereadr, data: string, width: number = 300, height: number = 300) {
        const qrCodeDataURL = await toDataURL(data, {
            width: width,
            height: height
        });

        return qrCodeDataURL;
    }
  good: |-
    import { create } from "npm:qrcode";

    type Codereadr = {
        apiKey: string;
        serviceId: string;
    }

    export async function main(codereadrResource: Codereadr, dataToEncode: string, width: number = 256, height: number = 256) {
        const apiUrl = `https://api.codereadr.com/api/`;
        const postBody = {
            api_key: codereadrResource.apiKey,
            service_id: codereadrResource.serviceId,
            data: dataToEncode,
            width: width,
            height: height
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(postBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const qrCodeData = await response.json();

        // Generate QR code using the qrcode library
        const qrCode = await create(qrCodeData.url, { width: width, height: height });

        return qrCode;
    }
  id: |-
    synthetic_generate-qr-code
  instructions: |-
    Generates a unique QR code in codereadr
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Codereadr
  resource_type_def: |-
    type Codereadr = {
        apiKey: string;
        serviceId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import mastodon

    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    def main(mastodon_resource: mastodon, max_statuses: int = 20) -> List[dict]:
        mastodon_api = mastodon.Mastodon(
            access_token=mastodon_resource['access_token'],
            api_base_url=mastodon_resource['api_base_url']
        )

        return mastodon_api.timeline_home(limit=max_statuses)
  good: |-
    from typing import TypedDict, List, Dict
    import mastodon as mastodon_lib  # Assuming 'mastodon' is the name of the library and it conflicts with the integration name

    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    def main(mastodon_resource: mastodon, max_statuses: int = 20) -> List[Dict]:
        mastodon_api = mastodon_lib.Mastodon(
            access_token=mastodon_resource['access_token'],
            api_base_url=mastodon_resource['api_base_url']
        )

        timeline = mastodon_api.timeline_home(limit=max_statuses)

        return timeline
  id: |-
    synthetic_view-home-timeline
  instructions: |-
    View statuses from followed users in mastodon
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mastodon
  resource_type_def: |-
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const { apiKey, apiSecret, endpoint } = bybitResource;
        const timestamp = new Date().getTime();
        const params = `api_key=${apiKey}&timestamp=${timestamp}&symbol=${symbol}`;
        const signature = createHmac('sha256', apiSecret).update(params).digest('hex');
        const url = `${endpoint}/v2/private/position/list?${params}&sign=${signature}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, limit?: number) {
        const timestamp = new Date().getTime();
        const params = {
            api_key: bybitResource.apiKey,
            timestamp: timestamp.toString(),
            symbol: symbol,
            limit: limit?.toString() || '50', // default limit to 50 if not provided
        };

        // Create the signature
        const signature = createHmac('sha256', bybitResource.apiSecret)
            .update(new URLSearchParams(params).toString())
            .digest('hex');

        // Append the signature to the params
        params['sign'] = signature;

        // Make the request to Bybit API
        const response = await fetch(`${bybitResource.endpoint}/v2/private/position/list`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams(params)
        });

        // Parse the response
        const data = await response.json();

        // Return the result
        return data;
    }
  id: |-
    synthetic_linear-position-list
  instructions: |-
    Get Positions List in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP requests to the Linear API

    class linear_app(TypedDict):
        api_key: str

    def main(linear_resource: linear_app, team_name: str = None) -> List[Dict]:
        headers = {
            'Authorization': f'Bearer {linear_resource["api_key"]}',
            'Content-Type': 'application/json',
        }

        response = requests.get('https://api.linear.app/teams', headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        teams = response.json()

        if team_name:
            teams = [team for team in teams if team['name'].lower() == team_name.lower()]

        return teams
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed to make API calls

    class linear_app(TypedDict):
        api_key: str

    def main(linear_app_resource: linear_app, endpoint_url: str = "https://api.linear.app/teams") -> List[dict]:
        headers = {
            "Authorization": f"Bearer {linear_app_resource['api_key']}",
            "Content-Type": "application/json"
        }

        response = requests.get(endpoint_url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        return response.json()

    # Example usage:
    # teams = main(linear_app_resource={'api_key': 'your_api_key_here'})
    # print(teams)
  id: |-
    synthetic_get-teams
  instructions: |-
    Get all the teams (API Key). See the docs in linear app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linear_app
  resource_type_def: |-
    class linear_app(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { stringify } from "npm:querystring";

    type Adalo = {
        apiKey: string;
        appID: string;
        databaseID: string;
    }

    export async function main(adaloResource: Adalo, collectionName: string, recordData: Record<string, any>) {
        const url = `https://api.adalo.com/apps/${adaloResource.appID}/collections/${adaloResource.databaseID}/${collectionName}`;
        const options = {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${adaloResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(recordData)
        };

        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Error creating new record in Adalo:', error);
            throw error;
        }
    }
  good: |-
    import { AdaloApi } from "npm:adalo-api";

    type Adalo = {
        apiKey: string,
        appId: string
    }

    export async function main(adaloResource: Adalo, collectionId: string, recordData: Record<string, any>) {
        const adaloApi = new AdaloApi({
            apiKey: adaloResource.apiKey,
            appId: adaloResource.appId
        });

        const result = await adaloApi.createRecord(collectionId, recordData);

        return result;
    }
  id: |-
    synthetic_create-record
  instructions: |-
    Create a new record in adalo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Adalo
  resource_type_def: |-
    type Adalo = {
        apiKey: string,
        appId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { clearout } from "npm:clearout";

    type Clearout = {
        apiKey: string;
    }

    export async function main(clearoutResource: Clearout, emailToVerify: string) {
        const clearoutClient = clearout({ apiKey: clearoutResource.apiKey });
        const result = await clearoutClient.verifySingleEmail(emailToVerify);
        return result;
    }
  good: |-
    import { validate as validateEmail } from "npm:email-validator";

    type Clearout = {
        apiKey: string;
    }

    export async function main(clearoutResource: Clearout, emailAddress: string) {
        if (!validateEmail(emailAddress)) {
            throw new Error("Invalid email format");
        }

        const response = await fetch(`https://api.clearout.io/v2/email_verify/single?email=${encodeURIComponent(emailAddress)}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${clearoutResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_verify-email
  instructions: |-
    Verify an email in clearout
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clearout
  resource_type_def: |-
    type Clearout = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import googleapiclient.discovery

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, shared_drive_id: str) -> dict:
        service = googleapiclient.discovery.build('drive', 'v3', developerKey=google_drive_resource['api_key'])
        service.drives().delete(driveId=shared_drive_id).execute()
        return {"status": "success", "message": f"Shared drive with ID {shared_drive_id} has been deleted."}
  good: |-
    from typing import TypedDict
    import googleapiclient.discovery

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, drive_id: str) -> dict:
        service = googleapiclient.discovery.build('drive', 'v3', developerKey=google_drive_resource['api_key'])
        service.credentials = google_drive_resource['access_token']

        try:
            result = service.drives().delete(driveId=drive_id).execute()
            return {'status': 'success', 'result': result}
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
  id: |-
    synthetic_delete-shared-drive
  instructions: |-
    Delete a shared drive without any content for more information in google drive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_drive
  resource_type_def: |-
    class google_drive(TypedDict):
        api_key: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str) -> dict:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }
        response = requests.delete(f"{base_url}/lists/{list_id}", headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # Mailchimp API endpoints are prefixed with a server identifier, e.g., 'us1', 'us2', etc.

    def main(mailchimp_resource: mailchimp, list_id: str) -> dict:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }
        response = requests.delete(f"{base_url}/lists/{list_id}", headers=headers)

        if response.status_code == 204:
            return {"success": True, "message": "List deleted successfully."}
        else:
            return {"success": False, "message": "Failed to delete the list.", "status_code": response.status_code, "error": response.json()}
  id: |-
    synthetic_delete-list
  instructions: |-
    Deletes an existing list in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Amara as AmaraAPI } from "npm:@types/amara-api";

    type Amara = {
        apiKey: string;
        team: string;
    }

    export async function main(amaraResource: Amara, videoId: string, languageCode: string) {
        const amaraApi = new AmaraAPI({
            apiKey: amaraResource.apiKey,
            team: amaraResource.team
        });

        const subtitleUrl = `https://amara.org/api/videos/${videoId}/languages/${languageCode}/subtitles/`;
        const response = await fetch(subtitleUrl, {
            method: 'GET',
            headers: {
                'X-api-key': amaraResource.apiKey
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const subtitleDetails = await response.json();
        return subtitleDetails;
    }
  good: |-
    // Import any libraries you need here
    import { Amara } from 'npm:@types/amara-api'; // Assuming there's a type definition for Amara API

    type Amara = {
        apiKey: string;
        team: string;
        project: string;
    }

    export async function main(amaraResource: Amara, videoId: string, languageCode: string) {
        const amaraApi = new Amara({
            apiKey: amaraResource.apiKey,
            team: amaraResource.team,
            project: amaraResource.project,
        });

        const subtitleUrl = `https://amara.org/api/videos/${videoId}/languages/${languageCode}/subtitles/`;
        const response = await fetch(subtitleUrl, {
            method: 'GET',
            headers: {
                'X-api-key': amaraResource.apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const subtitleDetails = await response.json();
        return subtitleDetails;
    }
  id: |-
    synthetic_get-subtitle-language-details
  instructions: |-
    Get details on a single subtitle language in amara
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amara
  resource_type_def: |-
    type Amara = {
        apiKey: string;
        team: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Daffy } from "npm:@daffy/daffy-sdk"; // Assuming there's an npm package for Daffy

    type Daffy = {
        apiKey: string;
        // Add other properties needed for Daffy integration here
    }

    export async function main(daffyResource: Daffy, amount: number, donorEmail: string, campaignId: string) {
        const daffy = new Daffy({ apiKey: daffyResource.apiKey });

        const donation = {
            amount: amount,
            donor: {
                email: donorEmail
            },
            campaignId: campaignId
        };

        const result = await daffy.createDonation(donation);
        return result;
    }
  good: |-
    import { DaffyClient as DaffyApiClient } from "npm:daffy";

    type Daffy = {
        apiKey: string;
        apiSecret: string;
    }

    type DonationDetails = {
        amount: number;
        currency: string;
        donorEmail: string;
        campaignId: string;
    }

    export async function main(daffyResource: Daffy, donationDetails: DonationDetails) {
        const daffyClient = new DaffyApiClient(daffyResource.apiKey, daffyResource.apiSecret);

        const donationResult = await daffyClient.createDonation({
            amount: donationDetails.amount,
            currency: donationDetails.currency,
            donorEmail: donationDetails.donorEmail,
            campaignId: donationDetails.campaignId,
        });

        return donationResult;
    }
  id: |-
    synthetic_create-donation
  instructions: |-
    Create a new donation in daffy
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Daffy
  resource_type_def: |-
    type Daffy = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, recordId: string, fieldsToUpdate: { [fieldName: string]: any }) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(tableName);
        const updatedRecord = await table.updateRecordAsync(recordId, fieldsToUpdate);
        return updatedRecord;
    }
  good: |-
    import { Base } from "npm:airtable";

    type AirtableOauth = {
        apiKey: string,
        baseId: string,
        tableName: string
    }

    export async function main(
        airtableResource: AirtableOauth,
        recordId: string,
        updatedFields: { [fieldName: string]: any }
    ) {
        const base = new Base({ apiKey: airtableResource.apiKey })(airtableResource.baseId);
        const table = base(airtableResource.tableName);

        try {
            const updatedRecord = await table.update(recordId, updatedFields);
            return updatedRecord;
        } catch (error) {
            console.error('Error updating record in Airtable:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-table
  instructions: |-
    Updates an existing table in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueKey: string, transitionId: string) {
        const auth = Buffer.from(`${jiraResource.email}:${jiraResource.apiToken}`).toString('base64');
        const transitionUrl = `${jiraResource.host}/rest/api/3/issue/${issueKey}/transitions`;

        try {
            const response = await request('POST', transitionUrl, {
                headers: {
                    'Authorization': `Basic ${auth}`,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    transition: {
                        id: transitionId
                    }
                })
            });

            return response;
        } catch (error) {
            // Handle any errors that occurred during the request
            console.error('Error transitioning issue:', error);
            throw error;
        }
    }
  good: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        baseUrl: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueIdOrKey: string, transitionId: string, fieldsToUpdate: Record<string, any>) {
        const { baseUrl, email, apiToken } = jiraResource;
        const auth = Buffer.from(`${email}:${apiToken}`).toString('base64');

        const transitionRequest = {
            method: 'POST',
            url: `${baseUrl}/rest/api/3/issue/${issueIdOrKey}/transitions`,
            headers: {
                Authorization: `Basic ${auth}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                transition: {
                    id: transitionId
                },
                fields: fieldsToUpdate
            })
        };

        try {
            const transitionResponse = await request(transitionRequest);
            return transitionResponse;
        } catch (error) {
            throw new Error(`Failed to transition issue: ${error}`);
        }
    }
  id: |-
    synthetic_transition-issue
  instructions: |-
    Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen, in jira
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jira
  resource_type_def: |-
    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Calendly as CalendlyAPI } from "npm:@calendly/api";

    type CalendlyV2 = {
        personalAccessToken: string;
    }

    export async function main(calendlyResource: CalendlyV2, eventUri: string) {
        const calendly = new CalendlyAPI({ personalAccessToken: calendlyResource.personalAccessToken });

        const invitees = await calendly.invitees.list(eventUri);

        return invitees;
    }
  good: |-
    import { encode } from "npm:base-64";

    type CalendlyV2 = {
        apiKey: string;
        organization: string;
    }

    export async function main(calendlyResource: CalendlyV2, eventUri: string) {
        const authHeader = `Basic ${encode(calendlyResource.apiKey)}`;
        const inviteesEndpoint = `https://api.calendly.com${eventUri}/invitees`;

        const response = await fetch(inviteesEndpoint, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching invitees: ${response.status} ${response.statusText}`);
        }

        const inviteesList = await response.json();
        return inviteesList;
    }
  id: |-
    synthetic_list-event-invitees
  instructions: |-
    List invitees for an event in calendly v2
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CalendlyV2
  resource_type_def: |-
    type CalendlyV2 = {
        personalAccessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to query the IP address

    class ip2proxy(TypedDict):
        api_key: str
        endpoint: str

    def main(ip2proxy_resource: ip2proxy, ip_address: str) -> dict:
        url = f"{ip2proxy_resource['endpoint']}?key={ip2proxy_resource['api_key']}&ip={ip_address}"
        response = requests.get(url)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is needed for API calls

    class ip2proxy(TypedDict):
        api_key: str
        package: str
        format: str

    def main(ip2proxy_resource: ip2proxy, ip_address: str) -> dict:
        base_url = "https://api.ip2proxy.com"
        params = {
            'key': ip2proxy_resource['api_key'],
            'package': ip2proxy_resource['package'],
            'ip': ip_address,
            'format': ip2proxy_resource['format']
        }
        response = requests.get(base_url, params=params)
        return response.json()
  id: |-
    synthetic_query-ip-info
  instructions: |-
    Query IP address using IP2Proxy API for how to use this API. in ip2proxy
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ip2proxy
  resource_type_def: |-
    class ip2proxy(TypedDict):
        api_key: str
        endpoint: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the Mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str) -> List[dict]:
        """
        Fetches the members of a specific Mailchimp list segment.

        :param mailchimp_resource: A dictionary containing the Mailchimp API key and server prefix.
        :param list_id: The unique id for the list for which to retrieve the segment members.
        :return: A list of dictionaries, each representing a member of the segment.
        """
        api_key = mailchimp_resource['api_key']
        server_prefix = mailchimp_resource['server_prefix']
        url = f"https://{server_prefix}.api.mailchimp.com/3.0/lists/{list_id}/members"

        headers = {
            'Authorization': f'Bearer {api_key}'
        }

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        data = response.json()
        members = data.get('members', [])

        return members
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is used for HTTP requests

    # Define the resource type for the mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # The server prefix (e.g., 'us5') for the Mailchimp API endpoint

    def main(mailchimp_resource: mailchimp, list_id: str) -> List[dict]:
        """
        Retrieves a list of all segment members in Mailchimp for a given list ID.

        :param mailchimp_resource: A dictionary containing the Mailchimp API key and server prefix.
        :param list_id: The unique identifier for the list from which to retrieve segment members.
        :return: A list of dictionaries, each representing a segment member.
        """
        # Construct the API endpoint URL
        api_endpoint = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0/lists/{list_id}/segments"

        # Set up the headers for the HTTP request
        headers = {
            'Authorization': f"Bearer {mailchimp_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Make the HTTP GET request to retrieve the segments
        response = requests.get(api_endpoint, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP error responses

        # Extract the segments data from the response
        segments_data = response.json().get('segments', [])

        # Initialize an empty list to hold all segment members
        all_segment_members = []

        # Iterate over each segment to retrieve its members
        for segment in segments_data:
            segment_id = segment['id']
            members_endpoint = f"{api_endpoint}/{segment_id}/members"
            members_response = requests.get(members_endpoint, headers=headers)
            members_response.raise_for_status()
            segment_members = members_response.json().get('members', [])
            all_segment_members.extend(segment_members)

        return all_segment_members
  id: |-
    synthetic_list-segment-member
  instructions: |-
    Retrieves a list of all segment members in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleSlides = {
        apiKey: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(googleSlidesResource: GoogleSlides, presentationId: string, slideId: string, chartId: string) {
        const { apiKey, clientEmail, privateKey } = googleSlidesResource;

        // Configure a JWT auth client
        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            ['https://www.googleapis.com/auth/presentations'],
        );

        // Authenticate request
        await jwtClient.authorize();

        // Google Slides API client
        const slides = google.slides({ version: 'v1', auth: jwtClient });

        // Refresh a chart in a slide
        const response = await slides.presentations.batchUpdate({
            presentationId: presentationId,
            requestBody: {
                requests: [
                    {
                        refreshSheetsChart: {
                            objectId: chartId,
                            slideObjectId: slideId,
                        },
                    },
                ],
            },
        });

        return response.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleSlides = {
        apiKey: string;
        clientEmail: string;
        privateKey: string;
        scopes: string[];
    }

    export async function main(googleSlidesResource: GoogleSlides, presentationId: string, slideObjectId: string) {
        const { apiKey, clientEmail, privateKey, scopes } = googleSlidesResource;
        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            scopes
        );

        await jwtClient.authorize();

        const slides = google.slides({ version: 'v1', auth: jwtClient });

        const response = await slides.presentations.batchUpdate({
            presentationId: presentationId,
            requestBody: {
                requests: [
                    {
                        refreshSheetsChart: {
                            objectId: slideObjectId,
                        },
                    },
                ],
            },
        });

        return response.data;
    }
  id: |-
    synthetic_refresh-chart
  instructions: |-
    Refresh a chart from Sheets in google slides
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSlides
  resource_type_def: |-
    type GoogleSlides = {
        apiKey: string;
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(linkedin_resource: linkedin, query: str) -> Dict[str, Any]:
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}"
        }

        # Define the URL for the Analytics Finder endpoint
        url = "https://api.linkedin.com/v2/analyticsFinder"

        # Set up the parameters for the request
        params = {
            'q': query
        }

        # Make the API call to LinkedIn's Analytics Finder endpoint
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Return an error message if the call was unsuccessful
            return {'error': 'Failed to retrieve analytics', 'status_code': response.status_code}

    # The main function is not called, as per the instructions.
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the linkedin integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(linkedin_resource: linkedin, entity_id: str, entity_type: str, start_date: str, end_date: str) -> Dict[str, Any]:
        # Construct the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Define the Analytics Finder endpoint URL
        analytics_url = f"https://api.linkedin.com/v2/analyticsFinder?q=analytics&entity={entity_type}:{entity_id}"

        # Define the parameters for the time range
        params = {
            'timeRange.start': start_date,
            'timeRange.end': end_date
        }

        # Make the GET request to the LinkedIn Analytics Finder API
        response = requests.get(analytics_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the analytics data
            return response.json()
        else:
            # Return an error message if the call was unsuccessful
            return {'error': response.json()}

    # The main function is not called, as per the instructions.
  id: |-
    synthetic_query-analytics-finder
  instructions: |-
    Queries the Analytics Finder to get analytics for the specified entity i.e company, account, campaign in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the agile_crm integration
    class agile_crm(TypedDict):
        api_key: str
        email: str
        domain: str

    # Define the main function for updating a deal in Agile CRM
    def main(agile_crm_resource: agile_crm, deal_id: str, deal_data: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a deal
        endpoint = f"https://{agile_crm_resource['domain']}.agilecrm.com/dev/api/opportunity/{deal_id}"

        # Set up the headers for the request
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {agile_crm_resource['api_key']}"
        }

        # Make the request to update the deal
        response = requests.put(endpoint, json=deal_data, headers=headers)

        # Check for a successful response and return the result
        if response.status_code == 200:
            return response.json()
        else:
            # Handle error responses
            response.raise_for_status()

    # Example usage:
    # result = main(agile_crm_resource={'api_key': 'your_api_key', 'email': 'your_email', 'domain': 'your_domain'}, deal_id='12345', deal_data={'name': 'Updated Deal Name', 'expected_value': 10000})
    # print(result)
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to Agile CRM

    # Define the resource type for the Agile CRM integration
    class agile_crm(TypedDict):
        api_key: str
        email: str
        domain: str

    # Define the main function for updating an existing deal in Agile CRM
    def main(agile_crm_resource: agile_crm, deal_id: str, deal_data: dict) -> Any:
        # Construct the API endpoint for updating a deal
        endpoint = f"https://{agile_crm_resource['domain']}.agilecrm.com/dev/api/opportunity/{deal_id}"

        # Set up the headers for the request
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {agile_crm_resource['api_key']}"
        }

        # Make the HTTP request to update the deal
        response = requests.put(endpoint, json=deal_data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the updated deal information
            return response.json()
        else:
            # Handle errors (e.g., deal not found, invalid data, etc.)
            response.raise_for_status()

    # Example usage (do not include this in the script):
    # updated_deal = main(agile_crm_resource={'api_key': 'your_api_key', 'email': 'your_email', 'domain': 'your_domain'}, deal_id='12345', deal_data={'name': 'Updated Deal Name', 'expected_value': 10000})
  id: |-
    synthetic_update-deal
  instructions: |-
    Updates an existing deal in Agile CRM in agile crm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    agile_crm
  resource_type_def: |-
    class agile_crm(TypedDict):
        api_key: str
        email: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Airmeet = {
        apiKey: string;
        airmeetId: string;
        organizerId: string;
    }

    export async function main(airmeetResource: Airmeet, attendeeEmail: string, attendeeFirstName: string, attendeeLastName: string) {
        const url = `https://api.airmeet.com/v2/airmeets/${airmeetResource.airmeetId}/attendees`;

        const authHeader = `Basic ${encode(`${airmeetResource.organizerId}:${airmeetResource.apiKey}`)}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                email: attendeeEmail,
                first_name: attendeeFirstName,
                last_name: attendeeLastName,
                type: "authorized"
            })
        });

        if (!response.ok) {
            throw new Error(`Error adding authorized attendee: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Airmeet = {
        apiKey: string;
        airmeetId: string;
        organizerId: string;
    }

    export async function main(airmeetResource: Airmeet, attendeeEmail: string, attendeeFirstName: string, attendeeLastName: string) {
        const url = `https://api.airmeet.com/v2/airmeets/${airmeetResource.airmeetId}/attendees`;

        const authHeader = `Basic ${encode(`${airmeetResource.organizerId}:${airmeetResource.apiKey}`)}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                email: attendeeEmail,
                first_name: attendeeFirstName,
                last_name: attendeeLastName,
                type: "authorized"
            })
        });

        if (!response.ok) {
            throw new Error(`Error adding attendee: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-authorized-attendee
  instructions: |-
    Add authorized Attendee in airmeet
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Airmeet
  resource_type_def: |-
    type Airmeet = {
        apiKey: string;
        airmeetId: string;
        organizerId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Webex } from "npm:webex";

    type CiscoWebex = {
        accessToken: string;
    }

    export async function main(ciscoWebexResource: CiscoWebex, roomId: string, messageText: string) {
        const webex = new Webex({
            credentials: ciscoWebexResource.accessToken
        });

        const message = await webex.messages.create({
            roomId: roomId,
            text: messageText
        });

        return message;
    }
  good: |-
    // Import necessary libraries
    import { Webex } from "npm:webex";

    type CiscoWebex = {
        accessToken: string;
    }

    export async function main(ciscoWebexResource: CiscoWebex, roomId: string, messageText: string, markdown?: string) {
        // Initialize the Webex instance with the access token
        const webex = new Webex({
            credentials: ciscoWebexResource.accessToken
        });

        // Prepare the message payload
        const messagePayload = {
            roomId: roomId,
            text: messageText,
            markdown: markdown
        };

        // Post the message to the specified room
        const response = await webex.messages.create(messagePayload);

        // Return the response from the Webex API
        return response;
    }
  id: |-
    synthetic_create-message
  instructions: |-
    Post a plain text or message, and optionally, a, to a room in cisco webex
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CiscoWebex
  resource_type_def: |-
    type CiscoWebex = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { PDFDocument } from "npm:pdf-lib";

    type Askyourpdf = {
        apiKey: string;
    }

    export async function main(askyourpdfResource: Askyourpdf, documentUrl: string, message: string) {
        const pdfDoc = await PDFDocument.load(await fetch(documentUrl).then(res => res.arrayBuffer()));

        const pages = pdfDoc.getPages();
        const firstPage = pages[0];
        firstPage.drawText(message, {
            x: 50,
            y: firstPage.getHeight() - 100,
            size: 12,
        });

        const pdfBytes = await pdfDoc.save();

        return Buffer.from(pdfBytes).toString('base64');
    }
  good: |-
    // Import any libraries you need here
    import { AskyourpdfClient } from "npm:askyourpdf";

    type Askyourpdf = {
        apiKey: string;
        // Add other properties relevant to the Askyourpdf integration for authentication
    }

    export async function main(askyourpdfResource: Askyourpdf, documentId: string, question: string) {
        // Initialize the Askyourpdf client with the provided API key
        const client = new AskyourpdfClient(askyourpdfResource.apiKey);

        // Chat with the document using the documentId and question provided
        const response = await client.chatWithDocument(documentId, question);

        // Return the result
        return response;
    }
  id: |-
    synthetic_chat-with-document
  instructions: |-
    Chat with a document in askyourpdf
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Askyourpdf
  resource_type_def: |-
    type Askyourpdf = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Gitlab as GitlabAPI } from "npm:@gitbeaker/node";

    type Gitlab = {
        host: string;
        token: string;
    }

    export async function main(gitlab: Gitlab, projectId: number, title: string, description?: string) {
        const api = new GitlabAPI({
            host: gitlab.host,
            token: gitlab.token,
        });

        const epicData = {
            title: title,
            description: description,
        };

        try {
            const epic = await api.Epics.create(projectId, epicData);
            return epic;
        } catch (error) {
            console.error('Error creating epic:', error);
            throw error;
        }
    }
  good: |-
    import { request } from "npm:@octokit/request";

    type Gitlab = {
        accessToken: string,
        projectId: number
    }

    export async function main(gitlabResource: Gitlab, title: string, description?: string) {
        const response = await request('POST /projects/:id/epics', {
            headers: {
                authorization: `Bearer ${gitlabResource.accessToken}`
            },
            id: gitlabResource.projectId,
            title: title,
            description: description
        });

        return response.data;
    }
  id: |-
    synthetic_create-epic
  instructions: |-
    Creates a new epic in gitlab
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
        host: string;
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import googleapiclient.discovery

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, path: str, folder_name: Optional[str] = None):
        service = googleapiclient.discovery.build('drive', 'v3', developerKey=google_drive_resource['api_key'], credentials=google_drive_resource['access_token'])

        query = f"name = '{folder_name}' and mimeType = 'application/vnd.google-apps.folder'" if folder_name else "mimeType = 'application/vnd.google-apps.folder'"
        results = service.files().list(q=query, spaces='drive', fields='files(id, name)').execute()
        items = results.get('files', [])

        folder_id = None
        for item in items:
            if item['name'] == path:
                folder_id = item['id']
                break

        return folder_id
  good: |-
    from typing import TypedDict
    import googleapiclient.discovery
    from google.oauth2.credentials import Credentials

    class google_drive(TypedDict):
        api_key: str

    def main(google_drive_resource: google_drive, folder_path: str) -> str:
        credentials = Credentials(google_drive_resource['access_token'])
        service = googleapiclient.discovery.build('drive', 'v3', developerKey=google_drive_resource['api_key'], credentials=credentials)

        folder_id = 'root'  # Start from the root directory
        for folder_name in folder_path.strip('/').split('/'):
            query = f"mimeType='application/vnd.google-apps.folder' and name='{folder_name}' and '{folder_id}' in parents and trashed=false"
            response = service.files().list(q=query, spaces='drive', fields='files(id, name)').execute()
            files = response.get('files', [])

            if not files:
                raise FileNotFoundError(f"Folder '{folder_name}' not found.")

            folder_id = files[0].get('id')

        return folder_id
  id: |-
    synthetic_get-folder-id-for-path
  instructions: |-
    Retrieve a folderId for a path for more information in google drive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_drive
  resource_type_def: |-
    class google_drive(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@asana/client";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, workspaceId: string, projectId: string, taskName: string, taskNotes?: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);

        const taskData = {
            workspace: workspaceId,
            projects: [projectId],
            name: taskName,
            notes: taskNotes || '',
        };

        const result = await client.tasks.createTask(taskData);
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { Client as AsanaClient } from "npm:@asana/client";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, workspaceId: string, projectId: string, taskName: string, taskNotes?: string, dueDate?: string) {
        // Initialize Asana client with the provided access token
        const client = AsanaClient.create().useAccessToken(asanaResource.accessToken);

        // Create a new task in the specified project and workspace
        const task = await client.tasks.createTask({
            name: taskName,
            notes: taskNotes,
            due_on: dueDate,
            workspace: workspaceId,
            projects: [projectId],
        });

        // Return the result
        return task;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a new task in asana
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asana
  resource_type_def: |-
    type Asana = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type OpenExchangeRates = {
        appId: string;
        baseCurrency?: string;
    }

    export async function main(openExchangeRatesResource: OpenExchangeRates, symbols?: string) {
        const appId = openExchangeRatesResource.appId;
        const baseCurrency = openExchangeRatesResource.baseCurrency || 'USD';
        const url = `https://openexchangerates.org/api/latest.json?app_id=${appId}&base=${baseCurrency}${symbols ? `&symbols=${symbols}` : ''}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        return data;
    }
  good: |-
    import { fetch } from "npm:@deno/fetch";

    type OpenExchangeRates = {
        appId: string;
        baseCurrency?: string;
    }

    export async function main(openExchangeRatesResource: OpenExchangeRates, symbols?: string) {
        const appId = openExchangeRatesResource.appId;
        const baseCurrency = openExchangeRatesResource.baseCurrency || 'USD';
        const url = `https://openexchangerates.org/api/latest.json?app_id=${appId}&base=${baseCurrency}${symbols ? `&symbols=${symbols}` : ''}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_retrieve-current-rates
  instructions: |-
    Get the latest exchange rates available in open exchange rates
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    OpenExchangeRates
  resource_type_def: |-
    type OpenExchangeRates = {
        appId: string;
        baseCurrency?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import crove_app as crove_integration  # Renamed the imported module to avoid conflict

    # Define the resource type for the 'crove_app' integration
    class crove_app(TypedDict):
        api_key: str
        base_url: str

    def main(crove_app_resource: crove_app, document_id: str, output_file_path: str) -> None:
        # Authenticate or configure the crove_app client with the provided resource
        client = crove_integration.Client(api_key=crove_app_resource['api_key'], base_url=crove_app_resource['base_url'])

        # Generate the PDF from the document
        pdf_content = client.generate_pdf_from_document(document_id)

        # Save the PDF to the specified file path
        with open(output_file_path, 'wb') as pdf_file:
            pdf_file.write(pdf_content)
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the crove_app integration
    class crove_app(TypedDict):
        api_key: str
        base_url: str

    # Define the main function with the resource type and any additional parameters
    def main(crove_app_resource: crove_app, document_id: str, document_name: str) -> str:
        # Construct the API endpoint for generating the PDF
        generate_pdf_endpoint = f"{crove_app_resource['base_url']}/generate-pdf/{document_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {crove_app_resource['api_key']}"
        }

        # Make the request to generate the PDF
        response = requests.post(generate_pdf_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Assuming the API returns a JSON with the PDF URL
            pdf_url = response.json().get('pdf_url')
            if pdf_url:
                return pdf_url
            else:
                raise ValueError("PDF URL not found in the response.")
        else:
            # Handle unsuccessful requests
            raise ConnectionError(f"Failed to generate PDF. Status code: {response.status_code}, Response: {response.text}")

    # Example usage (do not include this in the script):
    # pdf_url = main(crove_app_resource={'api_key': 'your_api_key', 'base_url': 'https://api.crove.app'}, document_id='12345', document_name='MyDocument')
    # print(pdf_url)
  id: |-
    synthetic_generate-pdf-from-document
  instructions: |-
    Generate PDF of a document and return PDF URL. in crove app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    crove_app
  resource_type_def: |-
    class crove_app(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str

    # Define the main function for deleting a subtask (checklist item) in a task
    def main(kanban_tool_resource: kanban_tool, task_id: str, subtask_id: str) -> bool:
        import requests  # Import requests or another HTTP library if needed

        # Construct the API endpoint for deleting a subtask
        api_endpoint = f"https://kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}/checklist_items/{subtask_id}.json"

        # Set up the headers with the API key for authentication
        headers = {
            'X-KanbanToolToken': kanban_tool_resource['api_key']
        }

        # Make the DELETE request to the Kanban Tool API
        response = requests.delete(api_endpoint, headers=headers)

        # Check if the deletion was successful and return the result
        return response.status_code == 204  # 204 No Content indicates success

    # The script ends here, and the main function is ready to be used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        domain: str
        board_id: str

    # Import any libraries you might need
    import requests

    # Define the main function for the kanban_tool integration
    def main(kanban_tool_resource: kanban_tool, subtask_id: str):
        # Construct the API endpoint for soft deleting a subtask
        api_endpoint = f"https://{kanban_tool_resource['domain']}/api/v1/subtasks/{subtask_id}/soft_delete.json"

        # Set up the headers with the API key for authentication
        headers = {
            "X-KanbanToolToken": kanban_tool_resource['api_key']
        }

        # Make the request to soft delete the subtask
        response = requests.put(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return {"success": True, "message": "Subtask soft deleted successfully."}
        else:
            return {"success": False, "message": "Failed to soft delete the subtask.", "error": response.text}

    # The script ends here, with no calls to the main function, as per the instructions.
  id: |-
    synthetic_delete-subtask
  instructions: |-
    Soft deletes a subtask in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'anthropic' integration
    class anthropic(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function for the 'anthropic' integration
    def main(anthropic_resource: anthropic, message: str, user_id: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the headers with the API key
        headers = {
            'Authorization': f"Bearer {anthropic_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the payload with the message and user_id
        payload = {
            'message': message,
            'user_id': user_id
        }

        # Make the API call to the Chat API endpoint
        response = requests.post(anthropic_resource['endpoint_url'], json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if successful
            return response.json()
        else:
            # Return an error message if the call failed
            return {'error': 'API request failed', 'status_code': response.status_code}

    # Note: The function does not call itself, it's ready to be exported and used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'anthropic' integration
    class anthropic(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function with the resource type and any additional parameters
    def main(anthropic_resource: anthropic, message: str, user_id: str):
        # Import the requests library here to avoid potential conflicts with the resource type name
        import requests

        # Construct the headers with the API key
        headers = {
            'Authorization': f'Bearer {anthropic_resource["api_key"]}',
            'Content-Type': 'application/json'
        }

        # Construct the payload with the message and user_id
        payload = {
            'message': message,
            'user_id': user_id
        }

        # Make the POST request to the Anthropics endpoint
        response = requests.post(anthropic_resource["endpoint_url"], json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  id: |-
    synthetic_chat
  instructions: |-
    The Chat API in anthropic
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    anthropic
  resource_type_def: |-
    class anthropic(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ClickUp as ClickUpAPI } from "npm:clickup-api"; // Renamed imported ClickUp to avoid conflict

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickup: Clickup, listId: string, itemId: string, itemName: string, itemStatus: string) {
        const clickupApi = new ClickUpAPI(clickup.apiKey);

        const result = await clickupApi.Tasks.update_task(listId, itemId, {
            name: itemName,
            status: itemStatus
        });

        return result;
    }
  good: |-
    // Importing necessary libraries
    import { stringify } from "npm:querystring";

    type Clickup = {
        apiKey: string;
    }

    export async function main(
        clickupResource: Clickup,
        listId: string,
        itemId: string,
        itemName: string,
        itemStatus?: string,
        assigneeId?: string
    ) {
        const endpoint = `https://api.clickup.com/api/v2/list/${listId}/item/${itemId}`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': clickupResource.apiKey
        };

        const body = {
            name: itemName,
            ...(itemStatus && { status: itemStatus }),
            ...(assigneeId && { assignee: assigneeId })
        };

        const response = await fetch(endpoint, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`Error updating checklist item: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-checklist-item
  instructions: |-
    Updates item in a checklist. See the docs in **Checklists / Edit Checklist Item** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import dropbox  # Assuming dropbox is the library used for Dropbox API

    # Rename the imported dropbox module if it conflicts with the resource type name
    import dropbox as dropbox_sdk

    class dropbox(TypedDict):
        access_token: str

    def main(dropbox_resource: dropbox, from_path: str, to_path: str) -> dict:
        dbx = dropbox_sdk.Dropbox(dropbox_resource['access_token'])
        result = dbx.files_move_v2(from_path=from_path, to_path=to_path, autorename=True)
        return result.metadata.name

    # The script ends here, and the function is ready to be exported and used.
  good: |-
    from typing import TypedDict
    import dropbox as dbx_lib  # Renamed to avoid conflict with the resource type

    # Define the resource type for the Dropbox integration
    class dropbox(TypedDict):
        access_token: str  # OAuth2 access token

    def main(dropbox: dropbox, from_path: str, to_path: str) -> dict:
        dbx = dbx_lib.Dropbox(dropbox['access_token'])
        result = dbx.files_move_v2(from_path=from_path, to_path=to_path)
        return {
            'status': 'success',
            'from_path': from_path,
            'to_path': to_path,
            'metadata': result.metadata
        }
  id: |-
    synthetic_rename-file-folder
  instructions: |-
    Renames a file or folder in the user's Dropbox in dropbox
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dropbox
  resource_type_def: |-
    class dropbox(TypedDict):
        access_token: str  # OAuth2 access token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Http = {
        endpoint: string;
    }

    export async function main(httpResource: Http, method: string, headers: Record<string, string>, body?: string) {
        const response = await fetch(httpResource.endpoint, {
            method: method,
            headers: headers,
            body: body
        });

        const result = await response.text();
        return result;
    }
  good: |-
    // Importing necessary libraries
    import { encode as base64Encode } from "npm:@stablelib/base64";

    type Http = {
        basicAuthUsername?: string;
        basicAuthPassword?: string;
    }

    export async function main(
        httpResource: Http,
        url: string,
        method: string = 'GET',
        queryParams?: Record<string, string>,
        headers?: Record<string, string>,
        body?: BodyInit | null
    ) {
        // Construct the full URL with query parameters if provided
        const urlWithParams = new URL(url);
        if (queryParams) {
            for (const [key, value] of Object.entries(queryParams)) {
                urlWithParams.searchParams.append(key, value);
            }
        }

        // Prepare the request headers
        const requestHeaders: HeadersInit = new Headers(headers);

        // Add Basic Auth header if credentials are provided
        if (httpResource.basicAuthUsername && httpResource.basicAuthPassword) {
            const credentials = `${httpResource.basicAuthUsername}:${httpResource.basicAuthPassword}`;
            const encodedCredentials = base64Encode(credentials);
            requestHeaders.set('Authorization', `Basic ${encodedCredentials}`);
        }

        // Prepare the request options
        const requestOptions: RequestInit = {
            method,
            headers: requestHeaders,
            body: method !== 'GET' && method !== 'HEAD' ? body : undefined
        };

        // Send the HTTP request
        const response = await fetch(urlWithParams.toString(), requestOptions);

        // Parse the response
        const responseBody = await response.text();

        // Return the response
        return {
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers),
            body: responseBody
        };
    }
  id: |-
    synthetic_custom-request
  instructions: |-
    Send an HTTP request using any method and URL. Optionally configure query string parameters, headers, and basic auth. in http
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Http
  resource_type_def: |-
    type Http = {
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { connect } from "npm:mailjet-client";

    type Mailjet = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(mailjetResource: Mailjet, contactEmail: string, contactName?: string) {
        const mailjet = connect(mailjetResource.apiKey, mailjetResource.apiSecret);

        const result = await mailjet.post("contact")
            .request({
                Email: contactEmail,
                Name: contactName,
            });

        return result.body;
    }
  good: |-
    import { connect } from "npm:mailjet-client";

    type Mailjet = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(mailjetResource: Mailjet, email: string, name: string, excludeFromCampaigns: boolean) {
        const mailjet = connect(mailjetResource.apiKey, mailjetResource.apiSecret);

        const contactData = {
            Email: email,
            Name: name,
            ExclusionFromCampaigns: excludeFromCampaigns
        };

        try {
            const result = await mailjet.post("contact").request(contactData);
            return result.body;
        } catch (error) {
            console.error("An error occurred while adding a contact to Mailjet:", error);
            throw error;
        }
    }
  id: |-
    synthetic_create-contact
  instructions: |-
    Add a new unique contact to your global contact list and select its exclusion status in mailjet
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailjet
  resource_type_def: |-
    type Mailjet = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    # Define the main function for getting folders from ClickUp
    def main(clickup_resource: clickup, space_id: str) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Set up the headers with the API key from the resource
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Define the endpoint URL for getting folders
        url = f"https://api.clickup.com/api/v2/space/{space_id}/folder"

        # Make the API request
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the folders
            folders = response.json().get('folders', [])
            return folders
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Example usage:
    # folders = main(clickup_resource={'api_key': 'YOUR_API_KEY'}, space_id='YOUR_SPACE_ID')
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests library is needed for HTTP requests

    # Define the resource type for the clickup integration
    class clickup(TypedDict):
        api_key: str

    def main(clickup_resource: clickup, team_id: str) -> List[dict]:
        """
        Fetches a list of folders in a workplace from ClickUp.

        :param clickup_resource: A dictionary containing the API key for ClickUp authentication.
        :param team_id: The ID of the team for which to retrieve folders.
        :return: A list of dictionaries, each representing a folder.
        """
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }
        url = f"https://api.clickup.com/api/v2/team/{team_id}/folder"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

        folders = response.json().get('folders', [])
        return folders

    # Note: The main function is not called here, it's just defined and exported.
  id: |-
    synthetic_get-folders
  instructions: |-
    Get a list of folders in a workplace. See the docs in **Folders / Get Folders** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createClient } from "npm:@deepai/client";

    type Dreamstudio = {
        apiKey: string;
    }

    export async function main(dreamstudioResource: Dreamstudio, prompt: string, numResults: number = 1) {
        const client = createClient(dreamstudioResource.apiKey);
        const response = await client.text2img({
            text: prompt,
            numResults: numResults,
        });

        return response;
    }
  good: |-
    // Importing necessary libraries
    import { createClient } from "npm:@deepai/client";

    type Dreamstudio = {
        apiKey: string;
    }

    export async function main(dreamstudioResource: Dreamstudio, prompt: string, numResults: number = 1, imageSize: string = "1024x1024") {
        // Initialize the DeepAI client with the provided API key
        const client = createClient({ apiKey: dreamstudioResource.apiKey });

        // Generate the image using the Dreamstudio API
        const response = await client.text2img({
            text: prompt,
            numResults: numResults,
            size: imageSize
        });

        // Return the result which should include the generated image(s)
        return response;
    }
  id: |-
    synthetic_generate-image
  instructions: |-
    Generate a new image from a text prompt in dreamstudio
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dreamstudio
  resource_type_def: |-
    type Dreamstudio = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'enedis' integration
    class enedis(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str

    # Define the main function with the resource type and additional parameters
    def main(enedis_resource: enedis, client_id: str):
        # Assuming there is a library to interact with the Enedis API
        # and it has a method to get contract information
        from enedis_api_client import get_contract_information as get_contract_info

        # Use the credentials from the resource to authenticate and get the contract information
        contract_info = get_contract_info(
            client_id=client_id,
            access_token=enedis_resource['access_token']
        )

        # Return the contract information
        return contract_info
  good: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the 'enedis' integration
    class enedis(TypedDict):
        access_token: str
        client_id: str
        client_secret: str
        refresh_token: str
        api_base_url: str

    def main(enedis_resource: enedis, customer_id: str) -> List[Any]:
        headers = {
            'Authorization': f"Bearer {enedis_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Construct the URL for the API endpoint
        contracts_url = f"{enedis_resource['api_base_url']}/customers/{customer_id}/contracts"

        # Make the HTTP request to get contracts
        response = requests.get(contracts_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response data
            contracts_data = response.json()
            return contracts_data
        else:
            # Handle errors (you could also raise an exception here)
            return {'error': response.text, 'status_code': response.status_code}

    # Note: The function is not called here, it's just defined and ready to be exported.
  id: |-
    synthetic_get-contracts
  instructions: |-
    Returns the contract informations of a client in enedis
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    enedis
  resource_type_def: |-
    class enedis(TypedDict):
        access_token: str
        client_id: str
        client_secret: str
        refresh_token: str
        api_base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Cloudflare API

    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str

    def main(cloudflare_resource: cloudflare_api_key, account_id: str, namespace_name: str) -> dict:
        url = f"https://api.cloudflare.com/client/v4/accounts/{account_id}/storage/kv/namespaces"
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json",
        }
        payload = {
            "title": namespace_name
        }
        response = requests.post(url, headers=headers, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests

    # Define the resource type for the cloudflare_api_key integration
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str

    # Define the main function for creating a namespace in Cloudflare
    def main(cloudflare_resource: cloudflare_api_key, account_id: str, namespace_name: str):
        # Construct the API endpoint for creating a namespace
        url = f"https://api.cloudflare.com/client/v4/accounts/{account_id}/storage/kv/namespaces"

        # Set up the headers with the API key and email from the resource
        headers = {
            "Authorization": f"Bearer {cloudflare_resource['api_key']}",
            "X-Auth-Email": cloudflare_resource['email'],
            "Content-Type": "application/json"
        }

        # Define the payload with the namespace name
        payload = {
            "title": namespace_name
        }

        # Make the POST request to create the namespace
        response = requests.post(url, headers=headers, json=payload)

        # Return the result of the API call
        return response.json()
  id: |-
    synthetic_create-namespace
  instructions: |-
    Create a new Namespace in an account in cloudflare api key
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudflare_api_key
  resource_type_def: |-
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Firmao } from 'npm:firmao';

    type FirmaoResource = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(firmaoResource: FirmaoResource, customerID: number, offerDetails: { title: string, description: string, price: number }) {
        // Initialize the Firmao client with the provided API key and API URL
        const firmaoClient = new Firmao(firmaoResource.apiKey, firmaoResource.apiUrl);

        // Create a new quote/offer in Firmao
        const result = await firmaoClient.createOffer(customerID, offerDetails);

        // Return the result
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Firmao = {
        apiUrl: string;
        apiKey: string;
        userToken: string;
    }

    export async function main(firmaoResource: Firmao, offerDetails: { title: string, description: string, price: number, currency: string, expirationDate: string }) {
        // Construct the headers for authentication
        const authHeader = `Basic ${encode(`${firmaoResource.apiKey}:${firmaoResource.userToken}`)}`;
        const headers = {
            'Authorization': authHeader,
            'Content-Type': 'application/json'
        };

        // Construct the body of the request with the offer details
        const body = JSON.stringify({
            title: offerDetails.title,
            description: offerDetails.description,
            price: offerDetails.price,
            currency: offerDetails.currency,
            expiration_date: offerDetails.expirationDate
        });

        // Make the request to the Firmao API to create the offer
        const response = await fetch(`${firmaoResource.apiUrl}/offers`, {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse the response body as JSON
        const result = await response.json();

        // Return the result
        return result;
    }
  id: |-
    synthetic_create-offer
  instructions: |-
    Create a new quote/offer in firmao
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Firmao
  resource_type_def: |-
    type Firmao = {
        apiUrl: string;
        apiKey: string;
        userToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the iauditor_by_safetyculture integration
    class iauditor_by_safetyculture(TypedDict):
        api_token: str
        base_url: str

    # Define the main function for updating a user
    def main(
        iauditor_resource: iauditor_by_safetyculture,
        user_id: str,
        update_fields: dict[str, Any]
    ) -> dict:
        """
        Update a user in the iAuditor by SafetyCulture platform.

        :param iauditor_resource: A dictionary containing the API token and base URL for the iAuditor API.
        :param user_id: The ID of the user to be updated.
        :param update_fields: A dictionary of the fields to update with their new values.
        :return: A dictionary containing the response from the iAuditor API.
        """
        headers = {
            'Authorization': f"Bearer {iauditor_resource['api_token']}",
            'Content-Type': 'application/json'
        }
        url = f"{iauditor_resource['base_url']}/users/{user_id}"

        response = requests.put(url, json=update_fields, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is needed for HTTP requests

    # Define the resource type for the iAuditor by SafetyCulture integration
    class iauditor_by_safetyculture(TypedDict):
        api_token: str
        base_url: str

    # Define the main function for updating an existing user in iAuditor by SafetyCulture
    def main(iauditor_resource: iauditor_by_safetyculture, user_id: str, updated_user_details: dict) -> dict:
        headers = {
            'Authorization': f"Bearer {iauditor_resource['api_token']}",
            'Content-Type': 'application/json'
        }
        url = f"{iauditor_resource['base_url']}/users/{user_id}"

        response = requests.put(url, headers=headers, json=updated_user_details)

        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code

    # Example usage:
    # result = main(iauditor_resource={'api_token': 'your_api_token', 'base_url': 'https://api.safetyculture.io'}, user_id='user_id_to_update', updated_user_details={'firstname': 'John', 'lastname': 'Doe'})
    # print(result)
  id: |-
    synthetic_update-user
  instructions: |-
    Update an existing user in iAuditor by SafetyCulture in iauditor by safetyculture
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    iauditor_by_safetyculture
  resource_type_def: |-
    class iauditor_by_safetyculture(TypedDict):
        api_token: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, spreadsheetId: string, range: string) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.apiKey });

        // Create an OAuth2 client and set the access token
        const authClient = await google.auth.getClient({
            credentials: {
                api_key: googleSheetsResource.apiKey,
                access_token: googleSheetsResource.accessToken,
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets'],
        });

        const response = await sheets.spreadsheets.values.clear({
            spreadsheetId: spreadsheetId,
            range: range,
            auth: authClient,
        });

        return response.data;
    }
  good: |-
    import { GoogleAuth } from "npm:google-auth-library";

    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
        spreadsheetId: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, sheetName: string, rowIndices: number[]) {
        const { clientEmail, privateKey, spreadsheetId } = googleSheetsResource;
        const auth = new GoogleAuth({
            credentials: {
                client_email: clientEmail,
                private_key: privateKey,
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets'],
        });

        const client = await auth.getClient();
        const sheets = google.sheets({ version: 'v4', auth: client });

        const batchUpdateRequest = {
            requests: rowIndices.map(rowIndex => ({
                deleteDimension: {
                    range: {
                        sheetId: sheetName,
                        dimension: 'ROWS',
                        startIndex: rowIndex - 1,
                        endIndex: rowIndex,
                    },
                },
            })),
        };

        const response = await sheets.spreadsheets.batchUpdate({
            spreadsheetId: spreadsheetId,
            resource: batchUpdateRequest,
        });

        return response.data;
    }
  id: |-
    synthetic_delete-rows
  instructions: |-
    Deletes the specified rows from a spreadsheet in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'drata' integration
    class drata(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the 'drata' integration
    def main(drata_resource: drata, control_id: str) -> dict:
        # Assuming a library 'drata_api' is used to interact with the Drata API
        from drata_api import get_control as get_drata_control  # Rename if necessary to avoid conflict

        # Use the credentials from the resource to authenticate with the Drata API
        # This is a placeholder for actual authentication code
        authenticate_with_drata(drata_resource['api_key'], drata_resource['api_secret'])

        # Retrieve the control information using the control ID
        control_info = get_drata_control(control_id)

        # Return the control information
        return control_info

    # Helper function to authenticate with Drata (not part of the main function)
    def authenticate_with_drata(api_key: str, api_secret: str):
        # This is a placeholder for actual authentication code
        # In a real script, you would use the API key and secret to authenticate with the Drata API
        pass
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'drata' integration
    class drata(TypedDict):
        api_key: str
        base_url: str

    # Define the main function with the resource type and additional parameters
    def main(drata_resource: drata, query: str) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the headers with the API key
        headers = {
            'Authorization': f"Bearer {drata_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the URL for the search endpoint
        search_url = f"{drata_resource['base_url']}/search"

        # Define the payload for the search query
        payload = {
            'query': query
        }

        # Make the HTTP request to the Drata search endpoint
        response = requests.post(search_url, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the search results
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_find-controls
  instructions: |-
    Query to search for in drata
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    drata
  resource_type_def: |-
    class drata(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the iAuditor API

    # Define the resource type for the iauditor_by_safetyculture integration
    class iauditor_by_safetyculture(TypedDict):
        api_token: str
        base_url: str

    # Define the main function with the resource type and additional parameters
    def main(iauditor_resource: iauditor_by_safetyculture, inspection_id: str, file_format: str = 'pdf') -> bytes:
        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {iauditor_resource['api_token']}",
            'Content-Type': 'application/json'
        }

        # Construct the URL for the API endpoint
        url = f"{iauditor_resource['base_url']}/audit/{inspection_id}/export?format={file_format}"

        # Make the HTTP request to get the inspection report
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the content of the report
            return response.content
        else:
            # Handle the error (you could raise an exception or return an error message)
            response.raise_for_status()

    # Example usage (do not include this in the script):
    # report = main(iauditor_resource={'api_token': 'your_api_token', 'base_url': 'https://api.safetyculture.io'}, inspection_id='your_inspection_id')
    # with open('inspection_report.pdf', 'wb') as f:
    #     f.write(report)
  good: |-
    from typing import TypedDict, Union
    import iauditor_by_safetyculture as safetyculture_api  # Renamed the imported library to avoid conflict

    class iauditor_by_safetyculture(TypedDict):
        api_token: str

    def main(iauditor_resource: iauditor_by_safetyculture, inspection_id: str, export_format: str = 'pdf') -> Union[bytes, str]:
        if export_format not in ['pdf', 'word']:
            raise ValueError("Invalid export format. Please choose 'pdf' or 'word'.")

        client = safetyculture_api.IAuditor(api_token=iauditor_resource['api_token'])

        if export_format == 'pdf':
            exported_file = client.export_inspection_to_pdf(inspection_id)
        else:  # export_format == 'word'
            exported_file = client.export_inspection_to_word(inspection_id)

        return exported_file
  id: |-
    synthetic_export-inspection
  instructions: |-
    Retrieve an inspection report formatted as a PDF or Word (docx) document in iauditor by safetyculture
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    iauditor_by_safetyculture
  resource_type_def: |-
    class iauditor_by_safetyculture(TypedDict):
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import feedparser  # Assuming feedparser is used for parsing RSS feeds

    # Rename imported method if it conflicts with the resource type name
    parse_rss = feedparser.parse

    class helper_functions(TypedDict):
        rss_url: str

    def main(helper_functions_resource: helper_functions, max_stories: int = 10) -> List[dict]:
        rss_url = helper_functions_resource['rss_url']
        feed = parse_rss(rss_url)
        stories = []

        for entry in feed.entries[:max_stories]:
            story = {
                'title': entry.title,
                'link': entry.link,
                'published': entry.published
            }
            stories.append(story)

        return stories
  good: |-
    from typing import TypedDict, List
    import feedparser  # Assuming feedparser is the library used for parsing RSS feeds

    # Rename the imported method if it conflicts with the integration name
    from helper_functions import some_function as helper_functions_some_function

    class helper_functions(TypedDict):
        # Assuming the helper_functions integration requires an API key for authentication
        api_key: str

    def parse_rss_feed(feed_url: str) -> List[dict]:
        """
        Helper function to parse an RSS feed and return a list of stories.
        """
        feed = feedparser.parse(feed_url)
        stories = []
        for entry in feed.entries:
            stories.append({
                'title': entry.title,
                'link': entry.link,
                'published': entry.published
            })
        return stories

    def main(helper_functions_resource: helper_functions, feed_urls: List[str]) -> List[dict]:
        """
        Main function to retrieve all stories from one or more RSS feeds.
        """
        all_stories = []
        for url in feed_urls:
            stories = parse_rss_feed(url)
            all_stories.extend(stories)
        return all_stories
  id: |-
    synthetic_retrieve-all-rss-stories
  instructions: |-
    Retrieve all stories from one or more RSS feeds. in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        rss_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'accredible' integration
    class accredible(TypedDict):
        api_key: str  # API key for the Accredible API

    # Main function to create a credential on Accredible
    def main(accredible_resource: accredible, recipient_name: str, recipient_email: str, course_name: str, course_id: str, credential_template_id: str):
        import requests  # Import requests or any other library if needed

        # Endpoint for creating a credential
        url = "https://api.accredible.com/v1/credentials"

        # Prepare the data for the API request
        data = {
            "credential": {
                "group_id": credential_template_id,
                "recipient": {
                    "name": recipient_name,
                    "email": recipient_email
                },
                "course_name": course_name,
                "course_id": course_id
            }
        }

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Token token={accredible_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the API request to create the credential
        response = requests.post(url, json=data, headers=headers)

        # Return the API response
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the 'accredible' integration
    class accredible(TypedDict):
        api_key: str
        group_id: int

    # Define the main function with the resource type and additional parameters
    def main(accredible_resource: accredible, recipient_name: str, recipient_email: str, credential_name: str, credential_description: str):
        # API endpoint for issuing a new credential
        url = "https://api.accredible.com/v1/credentials"

        # Prepare the headers with the API key from the resource
        headers = {
            "Authorization": f"Token token={accredible_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload with the recipient information and credential details
        data = {
            "credential": {
                "group_id": accredible_resource['group_id'],
                "recipient": {
                    "name": recipient_name,
                    "email": recipient_email
                },
                "name": credential_name,
                "description": credential_description
            }
        }

        # Make the POST request to issue the credential
        response = requests.post(url, json=data, headers=headers)

        # Return the response from the API
        return response.json()

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_create-credential
  instructions: |-
    Issue a new credential to a given recipient in accredible
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    accredible
  resource_type_def: |-
    class accredible(TypedDict):
        api_key: str  # API key for the Accredible API
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    class google_palm_api(TypedDict):
        api_key: str

    def main(google_palm_api_resource: google_palm_api, text_to_generate: str, length: int = 100) -> Dict[str, Any]:
        from google_palm import generate_text as palm_generate_text

        config = {
            'api_key': google_palm_api_resource['api_key'],
            'text': text_to_generate,
            'length': length
        }

        result = palm_generate_text(config)

        return result
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed to make API calls

    # Define the resource type for the google_palm_api integration
    class google_palm_api(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function with the resource type and any additional parameters
    def main(google_palm_api_resource: google_palm_api, prompt: str, max_tokens: int = 256) -> Dict[str, Any]:
        headers = {
            'Authorization': f'Bearer {google_palm_api_resource["api_key"]}',
            'Content-Type': 'application/json',
        }

        payload = {
            'prompt': prompt,
            'max_tokens': max_tokens,
        }

        response = requests.post(
            google_palm_api_resource["endpoint_url"],
            headers=headers,
            json=payload
        )

        response.raise_for_status()  # This will raise an exception for HTTP error responses
        return response.json()

    # Example usage:
    # result = main(google_palm_api_resource={'api_key': 'YOUR_API_KEY', 'endpoint_url': 'https://api.yourpalmendpoint.com'}, prompt="Translate the following English text to French:", max_tokens=100)
    # print(result)
  id: |-
    synthetic_generate-text
  instructions: |-
    Generate text using Google PaLM in google palm api
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_palm_api
  resource_type_def: |-
    class google_palm_api(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Meistertask as MeistertaskClient } from "npm:@bitrix24/api";

    type Meistertask = {
        apiKey: string;
        projectId: string;
    }

    export async function main(meistertaskResource: Meistertask, taskName: string, taskNotes?: string, taskDueDate?: string) {
        // Initialize Meistertask client with the API key
        const meistertaskClient = new MeistertaskClient(meistertaskResource.apiKey);

        // Create the task in the specified project
        const task = await meistertaskClient.createTask({
            name: taskName,
            notes: taskNotes,
            due_date: taskDueDate,
            project_id: meistertaskResource.projectId
        });

        // Return the result
        return task;
    }
  good: |-
    // Import necessary libraries
    import { Meistertask } from "npm:@bitrise/meistertask";

    type MeistertaskResource = {
        apiKey: string;
        projectId: string;
    }

    export async function main(meistertaskResource: MeistertaskResource, sectionId: string, taskName: string, taskNotes?: string) {
        // Initialize Meistertask client with the API key
        const meistertask = new Meistertask(meistertaskResource.apiKey);

        // Create a new task in the specified project section
        const task = await meistertask.createTask({
            name: taskName,
            notes: taskNotes,
            section_id: sectionId,
            project_id: meistertaskResource.projectId
        });

        // Return the result
        return task;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Create a new task in a project section in meistertask
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Meistertask
  resource_type_def: |-
    type Meistertask = {
        apiKey: string;
        projectId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Mocean } from "npm:@mocean/client";

    type MoceanApi = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(moceanApiResource: MoceanApi, from: string, to: string, text: string) {
        // Initialize Mocean client with the provided API credentials
        const mocean = new Mocean({
            apiKey: moceanApiResource.apiKey,
            apiSecret: moceanApiResource.apiSecret,
        });

        // Prepare the SMS message payload
        const smsParams = {
            'mocean-from': from,
            'mocean-to': to,
            'mocean-text': text
        };

        // Send the SMS message
        const response = await mocean.sms().send(smsParams);

        // Return the response from the Mocean API
        return response;
    }
  good: |-
    // Import necessary libraries
    import { Mocean } from "npm:@mocean/client";

    type MoceanApi = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(moceanApiResource: MoceanApi, to: string, from: string, text: string) {
        // Initialize Mocean client with the provided credentials
        const mocean = new Mocean({
            apiKey: moceanApiResource.apiKey,
            apiSecret: moceanApiResource.apiSecret,
        });

        // Prepare the SMS message payload
        const smsParams = {
            'mocean-to': to,
            'mocean-from': from,
            'mocean-text': text
        };

        // Send the SMS message
        try {
            const response = await mocean.sms().send(smsParams);
            return response; // Return the response from the SMS API
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error('Error sending SMS:', error);
            throw error; // Rethrow the error to be handled by the caller
        }
    }
  id: |-
    synthetic_send-sms
  instructions: |-
    Send an outbound SMS from your Mocean account in mocean api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MoceanApi
  resource_type_def: |-
    type MoceanApi = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { GetemailsClient } from "npm:getemails-api-client";

    type Getemails = {
        apiKey: string;
    }

    export async function main(getemailsResource: Getemails, domain: string) {
        const client = new GetemailsClient(getemailsResource.apiKey);
        const emails = await client.findEmails(domain);

        return emails;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type GetemailsResource = {
        apiKey: string;
    }

    export async function main(getemailsResource: GetemailsResource, fullName: string, domain: string): Promise<string> {
        const url = `https://api.getemails.com/v1/find?fullName=${encodeURIComponent(fullName)}&domain=${encodeURIComponent(domain)}`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getemailsResource.apiKey}`
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Error fetching email: ${response.statusText}`);
        }

        const data = await response.json();
        return data.email;
    }
  id: |-
    synthetic_find-email
  instructions: |-
    Provide Full name of your prospect with Domain or Website and Api will provide you an email address of the prospect in response. . in getemails
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Getemails
  resource_type_def: |-
    type Getemails = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(
        googleDialogflowResource: GoogleDialogflow,
        sessionId: string,
        text: string,
        languageCode: string = 'en-US'
    ) {
        // Initialize the Dialogflow client with credentials
        const dialogflowClient = new SessionsClient({
            credentials: {
                private_key: googleDialogflowResource.privateKey,
                client_email: googleDialogflowResource.clientEmail,
            },
            projectId: googleDialogflowResource.projectId,
        });

        // Define the session path
        const sessionPath = dialogflowClient.projectAgentSessionPath(
            googleDialogflowResource.projectId,
            sessionId
        );

        // The text query request.
        const request = {
            session: sessionPath,
            queryInput: {
                text: {
                    text: text,
                    languageCode: languageCode,
                },
            },
        };

        // Send request and log result
        const responses = await dialogflowClient.detectIntent(request);
        const result = responses[0].queryResult;

        // Return the query result
        return result;
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(
        dialogflowResource: GoogleDialogflow,
        sessionId: string,
        contextId: string,
        parameters: Record<string, any>,
        lifespanCount: number
    ) {
        const sessionClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail,
            },
            projectId: dialogflowResource.projectId,
        });

        const sessionPath = sessionClient.projectAgentSessionPath(
            dialogflowResource.projectId,
            sessionId
        );

        const contextPath = sessionClient.projectAgentSessionContextPath(
            dialogflowResource.projectId,
            sessionId,
            contextId
        );

        const context = {
            name: contextPath,
            lifespanCount: lifespanCount,
            parameters: parameters,
        };

        const request = {
            parent: sessionPath,
            context: context,
        };

        const [result] = await sessionClient.updateContext(request);

        return result;
    }
  id: |-
    synthetic_update-context
  instructions: |-
    Updates a context, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client as DocusignClient } from "npm:docusign-esign";

    type Docusign = {
        // Docusign integration resource type for authentication
        accountId: string;
        basePath: string;
        oAuthToken: string;
    }

    export async function main(docusignResource: Docusign, envelopeDefinition: any) {
        // Initialize the DocuSign client
        const client = new DocusignClient({
            basePath: docusignResource.basePath,
            oAuth: {
                token: docusignResource.oAuthToken,
            },
        });

        // Create a draft envelope using the provided envelope definition
        const result = await client.envelopes.createDraft({
            accountId: docusignResource.accountId,
            envelopeDefinition: envelopeDefinition,
        });

        // Return the result which should include the draft envelope's details
        return result;
    }
  good: |-
    import { EnvelopesApi, EnvelopeDefinition, Document, Signer, SignHere, Tabs } from "npm:docusign-esign";

    type Docusign = {
        // Docusign credentials or configuration
        accountId: string;
        basePath: string;
        oAuthToken: string;
    }

    export async function main(
        docusignResource: Docusign,
        documentBase64: string,
        documentName: string,
        documentFileExtension: string,
        emailSubject: string,
        recipientEmail: string,
        recipientName: string,
        createDraft: boolean
    ) {
        // Initialize the EnvelopesApi with the provided resource information
        const envelopesApi = new EnvelopesApi();
        envelopesApi.setBasePath(docusignResource.basePath);

        // Create the document object
        const document = new Document();
        document.documentBase64 = documentBase64;
        document.name = documentName;
        document.fileExtension = documentFileExtension;
        document.documentId = '1';

        // Create a signer object
        const signer = new Signer();
        signer.email = recipientEmail;
        signer.name = recipientName;
        signer.recipientId = '1';
        signer.routingOrder = '1';

        // Create a signHere tab (field on the document where the recipient will sign)
        const signHere = new SignHere();
        signHere.documentId = '1';
        signHere.pageNumber = '1';
        signHere.recipientId = '1';
        signHere.tabLabel = 'SignHereTab';
        signHere.xPosition = '195';
        signHere.yPosition = '147';

        // Add the signHere tab to the signer object
        const tabs = new Tabs();
        tabs.signHereTabs = [signHere];
        signer.tabs = tabs;

        // Create the envelope definition and set the email subject and documents
        const envelopeDefinition = new EnvelopeDefinition();
        envelopeDefinition.emailSubject = emailSubject;
        envelopeDefinition.documents = [document];
        envelopeDefinition.recipients = { signers: [signer] };
        envelopeDefinition.status = createDraft ? 'created' : 'sent';

        // Use the Docusign API to create and send the envelope
        const options = { accessToken: docusignResource.oAuthToken, accountId: docusignResource.accountId };
        const results = await envelopesApi.createEnvelope(options.accountId, { envelopeDefinition: envelopeDefinition }, null);

        // Return the envelopeId of the newly created envelope
        return results.envelopeId;
    }
  id: |-
    synthetic_create-draft
  instructions: |-
    Create and send an envelope, or create a draft envelope in docusign
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Docusign
  resource_type_def: |-
    type Docusign = {
        // Docusign integration resource type for authentication
        accountId: string;
        basePath: string;
        oAuthToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type Lusha = {
        apiKey: string;
    }

    export async function main(lushaResource: Lusha, searchTerm: string) {
        const url = `https://api.lusha.co/person?property=${encodeURIComponent(searchTerm)}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'api_key': lushaResource.apiKey
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching contact: ${response.statusText}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { LushaAPI as LushaApiClient } from "npm:lusha";

    type Lusha = {
        apiKey: string;
    }

    export async function main(lushaResource: Lusha, emailAddress: string) {
        const lushaClient = new LushaApiClient(lushaResource.apiKey);
        const contactInfo = await lushaClient.findContactByEmail(emailAddress);
        return contactInfo;
    }
  id: |-
    synthetic_find-contact
  instructions: |-
    Search for a contact in lusha
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lusha
  resource_type_def: |-
    type Lusha = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type CalCom = {
        apiKey: string;
        calendarId: string;
    }

    export async function main(calComResource: CalCom, bookingId: string) {
        const response = await fetch(`https://api.cal.com/v1/bookings/${bookingId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${calComResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to delete booking: ${response.status} ${response.statusText}`);
        }

        return `Booking with ID ${bookingId} deleted successfully.`;
    }
  good: |-
    // Import any libraries you need here
    import { CalComClient } from "npm:calcom";

    type CalCom = {
        apiKey: string;
        calendarId: string;
    }

    export async function main(calComResource: CalCom, bookingId: string) {
        const client = new CalComClient(calComResource.apiKey);
        const result = await client.deleteBooking(calComResource.calendarId, bookingId);
        return result;
    }
  id: |-
    synthetic_delete-booking
  instructions: |-
    Delete an existing booking by its ID in cal com
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CalCom
  resource_type_def: |-
    type CalCom = {
        apiKey: string;
        calendarId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the calendly_v2 integration
    class calendly_v2(TypedDict):
        api_key: str

    # Define the main function for listing events from Calendly
    def main(calendly_resource: calendly_v2, user_email: str) -> List[Dict]:
        # Set up the headers for authentication
        headers = {
            'Authorization': f"Bearer {calendly_resource['api_key']}"
        }

        # Define the endpoint for listing events
        events_endpoint = f"https://api.calendly.com/scheduled_events?user={user_email}"

        # Make the API call to list events
        response = requests.get(events_endpoint, headers=headers)

        # Check if the response is successful
        if response.status_code == 200:
            # Parse the events from the response
            events = response.json().get('collection', [])
            return events
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {'error': 'Failed to retrieve events', 'status_code': response.status_code}

    # Note: The function is not called here, it's just defined and ready to be exported.
  good: |-
    from typing import TypedDict, List, Optional
    import requests  # Assuming requests is needed for API calls

    class calendly_v2(TypedDict):
        api_key: str

    def main(calendly_resource: calendly_v2, user_email: str, max_results: Optional[int] = None) -> List[dict]:
        headers = {
            'Authorization': f"Bearer {calendly_resource['api_key']}"
        }
        params = {
            'user': user_email,
            'count': max_results
        }
        response = requests.get('https://api.calendly.com/scheduled_events', headers=headers, params=params)
        response.raise_for_status()  # This will raise an exception for HTTP error codes
        events = response.json().get('collection', [])
        return events

    # The main function is not called, as per the instructions.
  id: |-
    synthetic_list-events
  instructions: |-
    List events for an user in calendly v2
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    calendly_v2
  resource_type_def: |-
    class calendly_v2(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is used for HTTP requests

    # Define the resource type for the Mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str) -> List[dict]:
        """
        Fetches the list of activities for a specific list in Mailchimp.

        :param mailchimp_resource: A dictionary containing the Mailchimp API key and server prefix.
        :param list_id: The unique id for the list whose activities you want to retrieve.
        :return: A list of dictionaries, each representing an activity.
        """
        # Construct the API endpoint for list activities
        url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0/lists/{list_id}/activity"

        # Set up the headers with the authorization
        headers = {
            'Authorization': f"Bearer {mailchimp_resource['api_key']}"
        }

        # Make the HTTP GET request to the Mailchimp API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the activities
            return response.json()['activity']
        else:
            # Handle errors (you could also raise an exception here)
            return {'error': response.json()}

    # Note: The function is not called here, it's just defined and ready to be exported.
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP calls to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str, since_date: str) -> List[Dict]:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        endpoint = f"/lists/{list_id}/activity"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }
        params = {
            "since": since_date  # Date format should be YYYY-MM-DD
        }

        response = requests.get(f"{base_url}{endpoint}", headers=headers, params=params)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()["activity"]  # Assuming the response contains an "activity" key with the desired data
  id: |-
    synthetic_get-list-activities
  instructions: |-
    Retrieves up to the previous 180 days of daily detailed aggregated activity stats for a list in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import boxsdk  # Assuming boxsdk is the library used for Box integration

    class box(TypedDict):
        client_id: str
        client_secret: str
        access_token: str

    def main(box_resource: box, file_id: str, new_content: str) -> dict:
        auth = boxsdk.OAuth2(
            client_id=box_resource['client_id'],
            client_secret=box_resource['client_secret'],
            access_token=box_resource['access_token']
        )

        client = boxsdk.Client(auth)

        file = client.file(file_id=file_id)
        updated_file = file.update_contents(new_content)

        return {
            'id': updated_file.id,
            'name': updated_file.name,
            'size': updated_file.size
        }
  good: |-
    from typing import TypedDict
    import boxsdk as box_client  # Renamed to avoid conflict with the 'box' TypedDict

    class box(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str

    def main(box_resource: box, file_path: str, file_id: str, file_name: str = None):
        auth = box_client.OAuth2(
            client_id=box_resource['client_id'],
            client_secret=box_resource['client_secret'],
            access_token=box_resource['access_token'],
            refresh_token=box_resource['refresh_token']
        )
        client = box_client.Client(auth)

        with open(file_path, 'rb') as file_stream:
            updated_file = client.file(file_id=file_id).update_contents(file_stream, file_name=file_name)

        return updated_file
  id: |-
    synthetic_upload-file-version
  instructions: |-
    Update a file's content. in box
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    box
  resource_type_def: |-
    class box(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the ip2location.io API

    class ip2location_io(TypedDict):
        api_key: str

    def main(ip2location_io_resource: ip2location_io, ip_address: str):
        base_url = "https://api.ip2location.io"
        endpoint = f"/?key={ip2location_io_resource['api_key']}&ip={ip_address}"
        response = requests.get(base_url + endpoint)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for the IP lookup

    class ip2location_io(TypedDict):
        api_key: str

    def main(ip2location_io_resource: ip2location_io, ip_address: str) -> dict:
        url = f"https://api.ip2location.io/?key={ip2location_io_resource['api_key']}&ip={ip_address}"
        response = requests.get(url)
        return response.json()
  id: |-
    synthetic_lookup-ip-address
  instructions: |-
    Retrieve geolocation data about an IP Address in ip2location io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ip2location_io
  resource_type_def: |-
    class ip2location_io(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, projectKey: string) {
        const { host, email, apiToken } = jiraResource;

        // Base64 encode the email and API token for Basic Authentication
        const base64Credentials = Buffer.from(`${email}:${apiToken}`).toString('base64');
        const authHeader = `Basic ${base64Credentials}`;

        // Construct the Jira API endpoint for fetching users
        const apiUrl = `${host}/rest/api/3/user/assignable/search?project=${projectKey}`;

        // Fetch the users from the Jira API
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Accept': 'application/json'
            }
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`Error fetching users: ${response.status} ${response.statusText}`);
        }

        // Parse the response as JSON
        const users = await response.json();

        // Return the list of users
        return users;
    }
  good: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        baseUrl: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, userAccountIds: string[]) {
        const auth = Buffer.from(`${jiraResource.email}:${jiraResource.apiToken}`).toString('base64');
        const headers = {
            'Authorization': `Basic ${auth}`,
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        };

        const userDetailsPromises = userAccountIds.map(accountId =>
            request(`GET ${jiraResource.baseUrl}/rest/api/3/user?accountId=${accountId}`, {
                headers: headers
            })
        );

        const userDetailsResponses = await Promise.all(userDetailsPromises);
        const userDetails = userDetailsResponses.map(response => response.data);

        return userDetails;
    }
  id: |-
    synthetic_get-users
  instructions: |-
    Gets details of a list of users in jira
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jira
  resource_type_def: |-
    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, title: string, sheetTitles: string[]) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.accessToken });

        const resource = {
            properties: {
                title: title
            },
            sheets: sheetTitles.map(sheetTitle => ({
                properties: {
                    title: sheetTitle
                }
            }))
        };

        const response = await sheets.spreadsheets.create({
            resource,
            fields: 'spreadsheetId'
        });

        return response.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleSheetsResource: GoogleSheets, title: string) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.accessToken });

        const request = {
            resource: {
                properties: {
                    title: title
                }
            }
        };

        try {
            const response = await sheets.spreadsheets.create(request);
            return response.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  id: |-
    synthetic_create-worksheet
  instructions: |-
    Create a blank worksheet with a title in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'drip' integration
    class drip(TypedDict):
        api_token: str
        account_id: str

    # Define the main function for activating a workflow in Drip
    def main(drip_resource: drip, workflow_id: str, subscriber_email: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for activating a workflow
        workflow_activation_url = f"https://api.getdrip.com/v2/{drip_resource['account_id']}/subscribers/{subscriber_email}/workflow_triggers/{workflow_id}/activations"

        # Set up the headers with the API token for authentication
        headers = {
            "Content-Type": "application/vnd.api+json",
            "Authorization": f"Bearer {drip_resource['api_token']}"
        }

        # Make the POST request to activate the workflow for the subscriber
        response = requests.post(workflow_activation_url, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'drip' integration
    class drip(TypedDict):
        api_token: str
        account_id: str

    # Define the main function for activating a workflow in Drip
    def main(drip_resource: drip, workflow_id: str, subscriber_email: str):
        import requests  # Import requests or any other necessary library here

        # Construct the API endpoint for activating a workflow
        endpoint = f"https://api.getdrip.com/v2/{drip_resource['account_id']}/subscribers/{subscriber_email}/workflow_triggers/{workflow_id}/activations"

        # Set up the headers with the necessary authentication details
        headers = {
            "Authorization": f"Bearer {drip_resource['api_token']}",
            "Content-Type": "application/vnd.api+json"
        }

        # Make the POST request to activate the workflow for the subscriber
        response = requests.post(endpoint, headers=headers)

        # Return the response from the API call
        return response.json()

    # The script ends here, with the main function ready to be exported and used with the required parameters.
  id: |-
    synthetic_activate-workflow
  instructions: |-
    Activate a workflow in drip
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    drip
  resource_type_def: |-
    class drip(TypedDict):
        api_token: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HostawayApi } from "npm:hostaway";

    type Hostaway = {
        apiKey: string,
        accountId: string
    }

    export async function main(
        hostawayResource: Hostaway,
        taskId: number,
        taskStatus: string,
        taskDetails: string
    ) {
        const hostawayClient = new HostawayApi(hostawayResource.apiKey, hostawayResource.accountId);

        const result = await hostawayClient.updateTask(taskId, {
            status: taskStatus,
            details: taskDetails
        });

        return result;
    }
  good: |-
    // Import any libraries you need here
    import { HostawayApi } from "npm:hostaway"; // Assuming there's a fictional npm package for Hostaway

    type Hostaway = {
        apiKey: string;
        accountId: string;
    }

    export async function main(
        hostawayResource: Hostaway,
        taskId: number,
        taskDetails: {
            title?: string;
            description?: string;
            status?: string;
            priority?: string;
            assignedTo?: number;
            startDate?: string;
            endDate?: string;
        }
    ) {
        // Initialize the Hostaway API client with the provided credentials
        const hostawayClient = new HostawayApi(hostawayResource.apiKey, hostawayResource.accountId);

        // Update the task with the provided details
        const updatedTask = await hostawayClient.updateTask(taskId, taskDetails);

        // Return the result
        return updatedTask;
    }
  id: |-
    synthetic_update-task
  instructions: |-
    Updates an existing task in Hostaway in hostaway
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hostaway
  resource_type_def: |-
    type Hostaway = {
        apiKey: string,
        accountId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Bitly API

    # Define the resource type for the bitly integration
    class bitly(TypedDict):
        access_token: str

    def main(bitly_resource: bitly, long_url: str) -> str:
        # Prepare the headers for the HTTP request to Bitly
        headers = {
            'Authorization': f"Bearer {bitly_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Prepare the data for the HTTP request to create a Bitlink
        data = {
            'long_url': long_url
        }

        # Send the HTTP POST request to the Bitly API to create a Bitlink
        response = requests.post('https://api-ssl.bitly.com/v4/shorten', json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response to get the Bitlink
            bitlink = response.json().get('link')
            return bitlink
        else:
            # Handle the error
            raise Exception(f"Error creating Bitlink: {response.content}")

    # Note: The function is not called here, as per the instructions.
  good: |-
    from typing import TypedDict

    # Define the resource type for the bitly integration
    class bitly(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function for the bitly integration
    def main(bitly_resource: bitly, long_url: str) -> str:
        import requests as req_lib  # Import requests and rename if necessary

        # Construct the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {bitly_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Define the API endpoint for creating a short URL
        api_url = "https://api-ssl.bitly.com/v4/shorten"

        # Prepare the data payload with the long URL
        data = {
            "long_url": long_url
        }

        # Make the POST request to the Bitly API to shorten the URL
        response = req_lib.post(api_url, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Extract the shortened URL from the response
            short_url = response.json().get("link")
            return short_url
        else:
            # Handle errors (e.g., invalid token, bad request, etc.)
            response.raise_for_status()

    # Example usage (do not include this in the script):
    # bitly_credentials = bitly(access_token="YOUR_ACCESS_TOKEN")
    # print(main(bitly_credentials, "https://www.example.com"))
  id: |-
    synthetic_find-bitlink
  instructions: |-
    This is the shortened url in bitly
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitly
  resource_type_def: |-
    class bitly(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { F15fiveClient } from "npm:@f15five/core";

    type F15five = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for F15five authentication
    }

    export async function main(f15fiveResource: F15five, userId: string) {
        // Initialize the F15five client with the provided credentials
        const client = new F15fiveClient({
            apiKey: f15fiveResource.apiKey,
            apiSecret: f15fiveResource.apiSecret,
        });

        // Retrieve the user object using the F15five client
        const user = await client.getUser(userId);

        // Return the user object
        return user;
    }
  good: |-
    import { F15fiveClient } from "npm:@f15five/f15five-js-sdk";

    type F15five = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(f15fiveResource: F15five, userId: string) {
        const client = new F15fiveClient({
            apiKey: f15fiveResource.apiKey,
            apiSecret: f15fiveResource.apiSecret,
        });

        const user = await client.getUser(userId);

        return user;
    }
  id: |-
    synthetic_get-user
  instructions: |-
    Retrieve a user object in f15five
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    F15five
  resource_type_def: |-
    type F15five = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the 'emailable' integration
    class emailable(TypedDict):
        api_key: str

    def main(emailable_resource: emailable, emails: List[str]) -> List[dict]:
        # Assuming the Emailable API requires an API key for authentication and a list of emails to verify
        results = []
        for email in emails:
            response = requests.post(
                "https://api.emailable.com/v1/verify",
                params={"email": email, "api_key": emailable_resource['api_key']}
            )
            if response.status_code == 200:
                results.append(response.json())
            else:
                results.append({"email": email, "status": "error", "message": "Failed to verify"})
        return results
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the emailable API

    class emailable(TypedDict):
        api_key: str

    def main(emailable_resource: emailable, emails: List[str]) -> dict:
        url = "https://api.emailable.com/v1/verify/batch"
        headers = {
            "Authorization": f"Bearer {emailable_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "emails": emails
        }
        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_verify-batch-of-emails
  instructions: |-
    Verifies a batch of emails, up to 50,000 per batch in emailable
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    emailable
  resource_type_def: |-
    class emailable(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Clientify = {
        apiKey: string;
        apiSecret: string;
        apiUrl: string;
    }

    export async function main(clientifyResource: Clientify, taskTitle: string, taskDescription: string, dueDate: string, assignedTo: string) {
        const task = {
            id: uuidv4(), // Generate a unique identifier for the task
            title: taskTitle,
            description: taskDescription,
            due_date: dueDate,
            assigned_to: assignedTo
        };

        const response = await fetch(`${clientifyResource.apiUrl}/tasks`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${clientifyResource.apiKey}:${clientifyResource.apiSecret}`
            },
            body: JSON.stringify(task)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { Clientify as ClientifyClient } from "npm:clientify"; // Renamed the imported Clientify to ClientifyClient

    type Clientify = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(clientifyResource: Clientify, taskTitle: string, taskDescription: string, dueDate: string, assigneeId: string) {
        const clientifyClient = new ClientifyClient(clientifyResource.apiKey, clientifyResource.apiSecret);

        const task = {
            title: taskTitle,
            description: taskDescription,
            due_date: dueDate,
            assignee_id: assigneeId
        };

        const result = await clientifyClient.createTask(task);

        return result;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Add a new task in clientify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clientify
  resource_type_def: |-
    type Clientify = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the brex_staging integration
    class brex_staging(TypedDict):
        api_key: str
        api_base_url: str

    # Define the function to create a new card in brex staging
    def main(brex_staging_resource: brex_staging, cardholder_id: str, card_name: str, card_limit: int) -> Any:
        # Construct the API endpoint for creating a new card
        endpoint = f"{brex_staging_resource['api_base_url']}/cards"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Bearer {brex_staging_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "cardholder_id": cardholder_id,
            "card_name": card_name,
            "card_limit": card_limit
        }

        # Make the API request to create a new card
        response = requests.post(endpoint, json=payload, headers=headers)

        # Return the API response
        return response.json()

    # Note: The function is not called here, it's just defined and ready to be used.
  good: |-
    from typing import TypedDict

    # Define the resource type for the brex_staging integration
    class brex_staging(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a card on the brex_staging platform
    def main(brex_staging_resource: brex_staging, cardholder_id: str, card_name: str, limit: int):
        # Import the requests library here to avoid potential naming conflicts
        import requests as reqs

        # Construct the API endpoint for creating a card
        api_endpoint = "https://api.brex.io/staging/cards"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {brex_staging_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the card details
        payload = {
            "cardholder_id": cardholder_id,
            "card_name": card_name,
            "limit": limit
        }

        # Make the POST request to create the card
        response = reqs.post(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the card details if the creation was successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # Note: The main function is not called here, it is just defined and exported.
  id: |-
    synthetic_create-card
  instructions: |-
    Creates a new card. in brex staging
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    brex_staging
  resource_type_def: |-
    class brex_staging(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests as req  # Renamed to avoid conflict with the resource type name

    # Define the resource type for the 'asknicely' integration
    class asknicely(TypedDict):
        api_key: str
        base_url: str

    def main(asknicely_resource: asknicely, contact_email: str) -> Dict[str, Any]:
        # Construct the API endpoint for getting a contact
        endpoint = f"{asknicely_resource['base_url']}/contacts/{contact_email}"

        # Set up the headers with the API key for authentication
        headers = {
            "X-Api-Key": asknicely_resource['api_key']
        }

        # Make the GET request to the AskNicely API to retrieve the contact
        response = req.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact information as a dictionary
            return response.json()
        else:
            # Handle errors (e.g., contact not found, authentication error)
            response.raise_for_status()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the asknicely integration
    class asknicely(TypedDict):
        api_key: str
        domain: str

    # Define the main function with the resource type and additional parameters
    def main(asknicely_resource: asknicely, contact_id: int):
        # Construct the API endpoint for getting contact details
        api_endpoint = f"https://{asknicely_resource['domain']}.asknice.ly/api/v1/contacts/{contact_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "X-Api-Key": asknicely_resource['api_key']
        }

        # Make the GET request to the AskNicely API to retrieve the contact details
        response = requests.get(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact details as JSON
            return response.json()
        else:
            # Handle errors (e.g., contact not found, authentication error)
            response.raise_for_status()
  id: |-
    synthetic_get-contact
  instructions: |-
    Get the details of a particular contact in asknicely
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    asknicely
  resource_type_def: |-
    class asknicely(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BandwidthMessaging } from 'npm:@bandwidth/messaging';

    type Bandwidth = {
        accountId: string;
        applicationId: string;
        authToken: string;
        userId: string;
    }

    export async function main(
        bandwidthResource: Bandwidth,
        to: string,
        from: string,
        text: string
    ) {
        const messagingClient = new BandwidthMessaging({
            accountId: bandwidthResource.accountId,
            applicationId: bandwidthResource.applicationId,
            authToken: bandwidthResource.authToken,
            userId: bandwidthResource.userId
        });

        const message = {
            to: to,
            from: from,
            text: text
        };

        try {
            const response = await messagingClient.sendMessage(message);
            return response;
        } catch (error) {
            // Handle errors appropriately in your actual implementation
            console.error('Error sending SMS:', error);
            throw error;
        }
    }
  good: |-
    import { MessageRequest, BandwidthMessaging as BandwidthClient } from "npm:@bandwidth/messaging";

    type Bandwidth = {
        accountId: string;
        applicationId: string;
        authToken: string;
        authSecret: string;
    };

    export async function main(
        bandwidthResource: Bandwidth,
        to: string,
        from: string,
        text: string
    ) {
        const messagingClient = new BandwidthClient({
            accountId: bandwidthResource.accountId,
            applicationId: bandwidthResource.applicationId,
            authToken: bandwidthResource.authToken,
            authSecret: bandwidthResource.authSecret
        });

        const messageRequest: MessageRequest = {
            applicationId: bandwidthResource.applicationId,
            to: [to],
            from: from,
            text: text
        };

        try {
            const messageResponse = await messagingClient.createMessage(bandwidthResource.accountId, messageRequest);
            return messageResponse;
        } catch (error) {
            console.error('Failed to send SMS:', error);
            throw error;
        }
    }
  id: |-
    synthetic_send-sms
  instructions: |-
    Send an SMS message using Bandwidth's Messaging API in bandwidth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bandwidth
  resource_type_def: |-
    type Bandwidth = {
        accountId: string;
        applicationId: string;
        authToken: string;
        authSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'businesslogic' integration
    class businesslogic(TypedDict):
        api_key: str

    # Define the main function with the resource type and additional parameters
    def main(businesslogic_resource: businesslogic, endpoint_url: str, method: str, data: Any = None, headers: dict = None, params: dict = None):
        import requests  # Import requests or any other library needed for HTTP calls

        # Prepare the request
        url = endpoint_url
        api_key = businesslogic_resource['api_key']

        # Default headers to include the API key, can be overridden by the user
        default_headers = {'Authorization': f'Bearer {api_key}'}
        if headers:
            default_headers.update(headers)

        # Make the HTTP request
        response = requests.request(method, url, headers=default_headers, params=params, json=data)

        # Return the response
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import json
    import requests  # Assuming requests is needed to call the webservice

    class businesslogic(TypedDict):
        api_endpoint: str
        api_key: str

    def main(businesslogic_resource: businesslogic, service_name: str) -> Dict[str, Any]:
        headers = {
            'Authorization': f'Bearer {businesslogic_resource["api_key"]}',
            'Content-Type': 'application/json'
        }

        # Construct the URL to get the input schema
        input_schema_url = f'{businesslogic_resource["api_endpoint"]}/{service_name}/input-schema'
        # Construct the URL to get the output schema
        output_schema_url = f'{businesslogic_resource["api_endpoint"]}/{service_name}/output-schema'

        # Make the request to get the input schema
        input_schema_response = requests.get(input_schema_url, headers=headers)
        input_schema_response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        input_schema = input_schema_response.json()

        # Make the request to get the output schema
        output_schema_response = requests.get(output_schema_url, headers=headers)
        output_schema_response.raise_for_status()
        output_schema = output_schema_response.json()

        # Return both schemas in a dictionary
        return {
            'input_schema': input_schema,
            'output_schema': output_schema
        }
  id: |-
    synthetic_describe-endpoint
  instructions: |-
    Returns json schemas for input and output parameters of a webservice. in businesslogic
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    businesslogic
  resource_type_def: |-
    class businesslogic(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    // Define the resource type for Microsoft365People integration
    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    };

    // Define the type for contact details
    type ContactDetails = {
        givenName: string;
        surname: string;
        emailAddresses: { address: string; name?: string }[];
        businessPhones?: string[];
        jobTitle?: string;
        company?: string;
        department?: string;
    };

    export async function main(
        microsoft365PeopleResource: Microsoft365People,
        accessToken: string,
        contactDetails: ContactDetails
    ) {
        // Initialize Microsoft Graph client with the provided credentials
        const client = Client.init({
            authProvider: (done) => {
                done(null, accessToken); // Provide the access token
            },
        });

        // Create the contact on Microsoft 365
        const result = await client.api('/me/contacts').post(contactDetails);

        // Return the result which should be the newly created contact
        return result;
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string; // Assuming OAuth2 flow has been completed and we have an access token
    }

    export async function main(microsoft365PeopleResource: Microsoft365People, givenName: string, surname: string, emailAddresses: { address: string, name?: string }[], businessPhones?: string[], jobTitle?: string, mobilePhone?: string, officeLocation?: string) {
        // Initialize the Microsoft Graph client
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsoft365PeopleResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Create a new contact object
        const newContact = {
            givenName: givenName,
            surname: surname,
            emailAddresses: emailAddresses,
            businessPhones: businessPhones,
            jobTitle: jobTitle,
            mobilePhone: mobilePhone,
            officeLocation: officeLocation
        };

        // Use the client to send the new contact to Microsoft 365 People
        try {
            const result = await client.api('/me/contacts').post(newContact);
            return result; // Return the result of the contact creation
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error("Error creating contact in Microsoft 365 People", error);
            throw error; // Rethrow the error for the caller to handle
        }
    }
  id: |-
    synthetic_create-contact
  instructions: |-
    Create a new contact in Microsoft 365 People in microsoft 365 people
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Microsoft365People
  resource_type_def: |-
    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { JWPlatformAPI } from "npm:jwplatform";

    type JwPlayer = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(jwPlayerResource: JwPlayer, title: string, description: string, fileUrl: string) {
        // Initialize JW Player API client
        const jwApi = new JWPlatformAPI({
            apiKey: jwPlayerResource.apiKey,
            apiSecret: jwPlayerResource.apiSecret,
        });

        // Create media on JW Player
        const result = await jwApi.videos.create({
            title: title,
            description: description,
            download_url: fileUrl,
        });

        // Return the result
        return result;
    }
  good: |-
    // Import necessary libraries
    import { FormData } from "npm:form-data";

    type JwPlayer = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(jwPlayerResource: JwPlayer, title: string, description: string, fileUrl?: string, uploadMethod: 'fetch' | 'external' = 'fetch') {
        const baseUrl = 'https://api.jwplatform.com/v1/videos/create';
        const params = new URLSearchParams({
            api_key: jwPlayerResource.apiKey,
            title: title,
            description: description,
            upload_method: uploadMethod,
        });

        if (fileUrl && uploadMethod === 'fetch') {
            params.append('download_url', fileUrl);
        }

        const requestOptions: RequestInit = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: params.toString(),
        };

        const response = await fetch(baseUrl, requestOptions);
        const result = await response.json();

        if (uploadMethod === 'external' && result.status === 'ok') {
            // If the upload method is external, we need to provide the user with the link and token to upload their file
            const uploadLink = result.link;
            const uploadToken = result.token;
            // The user should use the uploadLink and uploadToken to upload their file
            return { uploadLink, uploadToken };
        }

        return result;
    }
  id: |-
    synthetic_create-media
  instructions: |-
    Creates a new media file in JW Player using fetch or external upload methods in jw player
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    JwPlayer
  resource_type_def: |-
    type JwPlayer = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the deepgram integration
    class deepgram(TypedDict):
        api_key: str  # API key for authentication with the Deepgram service

    # Main function that utilizes the deepgram resource
    def main(deepgram_resource: deepgram, audio_url: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Deepgram API endpoint for transcribing audio from a URL
        deepgram_transcription_url = "https://api.deepgram.com/v1/listen"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Token {deepgram_resource['api_key']}"
        }

        # Prepare the payload with the audio URL
        payload = {
            "url": audio_url
        }

        # Make the request to the Deepgram API
        response = requests.post(deepgram_transcription_url, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response containing the transcription
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": "Failed to transcribe audio", "status_code": response.status_code}

    # Note: The function is not called here, it is only defined for use elsewhere.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make API calls to deepgram

    class deepgram(TypedDict):
        api_key: str

    def main(deepgram_resource: deepgram, start_time: str, end_time: str) -> dict:
        base_url = "https://api.deepgram.com/v1/usage"
        headers = {
            "Authorization": f"Token {deepgram_resource['api_key']}"
        }
        params = {
            "start": start_time,
            "end": end_time
        }
        response = requests.get(base_url, headers=headers, params=params)
        response.raise_for_status()  # This will raise an exception for HTTP error codes
        return response.json()

    # Example usage:
    # result = main(deepgram_resource={'api_key': 'your_deepgram_api_key'}, start_time='2023-01-01T00:00:00Z', end_time='2023-01-31T23:59:59Z')
    # print(result)
  id: |-
    synthetic_summarize-usage
  instructions: |-
    Retrieves a summary of usage statistics in deepgram
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    deepgram
  resource_type_def: |-
    class deepgram(TypedDict):
        api_key: str  # API key for authentication with the Deepgram service
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Mailchimp as MailchimpAPI } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpConfig: Mailchimp, campaignId: string, campaignData: { subject: string; fromName: string; replyTo: string; title: string; }) {
        MailchimpAPI.setConfig({
            apiKey: mailchimpConfig.apiKey,
            server: mailchimpConfig.serverPrefix,
        });

        const response = await MailchimpAPI.campaigns.update(campaignId, {
            settings: {
                subject_line: campaignData.subject,
                from_name: campaignData.fromName,
                reply_to: campaignData.replyTo,
                title: campaignData.title,
            }
        });

        return response;
    }
  good: |-
    import { Mailchimp } from "npm:@mailchimp/mailchimp_marketing";

    type MailchimpResource = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: MailchimpResource, campaignId: string, campaignData: object) {
        Mailchimp.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        try {
            const response = await Mailchimp.campaigns.update(campaignId, campaignData);
            return response;
        } catch (error) {
            console.error('Error updating Mailchimp campaign:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-campaign
  instructions: |-
    Update a campaign in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Ahrefs as AhrefsAPI } from "npm:@types/ahrefs";

    type Ahrefs = {
        accessToken: string;
        apiUrl: string;
    }

    export async function main(ahrefs: Ahrefs, target: string) {
        const endpoint = `${ahrefs.apiUrl}/referring_domains?target=${encodeURIComponent(target)}`;
        const headers = {
            Authorization: `Bearer ${ahrefs.accessToken}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(endpoint, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { fetch } from "npm:@deno/fetch";

    type Ahrefs = {
        accessToken: string;
        target: string;
    }

    export async function main(ahrefsResource: Ahrefs, targetUrl: string) {
        const url = `https://apiv2.ahrefs.com?from=refdomains&target=${encodeURIComponent(targetUrl)}&token=${ahrefsResource.accessToken}&output=json`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        return data;
    }
  id: |-
    synthetic_get-referring-domains
  instructions: |-
    Get the referring domains that contain backlinks to the target URL or domain. in ahrefs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ahrefs
  resource_type_def: |-
    type Ahrefs = {
        accessToken: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
    }

    export async function main(notionResource: Notion, pageId: string) {
        const notion = new Client({ auth: notionResource.authToken });

        const response = await notion.pages.retrieve({ page_id: pageId });

        return response;
    }
  good: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
    }

    export async function main(notionResource: Notion, pageTitle: string) {
        const notion = new Client({ auth: notionResource.authToken });

        const response = await notion.search({
            query: pageTitle,
            filter: {
                property: 'object',
                value: 'page',
            },
        });

        return response;
    }
  id: |-
    synthetic_find-page
  instructions: |-
    Searches for a page by its title in notion
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
        authToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { OAuth2Client } from "npm:@googleapis/oauth2";

    type Enedis = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }

    export async function main(enedisResource: Enedis, contactId: string) {
        // Assuming the accessToken is a valid OAuth2 token for the Enedis API
        const url = `https://api.enedis.fr/data/contact/${contactId}`;
        const headers = {
            "Authorization": `Bearer ${enedisResource.accessToken}`,
            "Content-Type": "application/json"
        };

        try {
            const response = await fetch(url, { headers: headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error("Error fetching contact from Enedis:", error);
            throw error;
        }
    }
  good: |-
    // Import any libraries you need here

    type Enedis = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(enedisResource: Enedis, clientId: string) {
        const url = `https://api.enedis.fr/customers/contact_data?client_id=${encodeURIComponent(clientId)}`;
        const headers = {
            'Authorization': `Bearer ${enedisResource.accessToken}`,
            'Content-Type': 'application/json',
            'apikey': enedisResource.apiKey
        };

        try {
            const response = await fetch(url, { headers: headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching contact information:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-contact
  instructions: |-
    Returns the contact informations of a client in enedis
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Enedis
  resource_type_def: |-
    type Enedis = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the clickup integration
    class clickup(TypedDict):
        api_key: str

    def main(clickup_resource: clickup, space_id: str, name: str = None, private: bool = None, features: dict = None):
        """
        Update a space in ClickUp.

        :param clickup_resource: A dictionary containing the API key for ClickUp authentication.
        :param space_id: The ID of the space to update.
        :param name: The new name of the space (optional).
        :param private: Whether the space is private or not (optional).
        :param features: A dictionary of features to update (optional).
        :return: The response from the ClickUp API.
        """
        # Construct the headers for authentication
        headers = {
            'Authorization': clickup_resource['api_key'],
            'Content-Type': 'application/json'
        }

        # Construct the payload for the update
        payload = {}
        if name is not None:
            payload['name'] = name
        if private is not None:
            payload['private'] = private
        if features is not None:
            payload['features'] = features

        # Make the request to update the space
        response = requests.put(f'https://api.clickup.com/api/v2/space/{space_id}', headers=headers, json=payload)

        # Return the response
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    # Define the main function for updating a space in ClickUp
    def main(clickup_resource: clickup, space_id: str, name: str, is_private: bool = False):
        import requests  # Import requests or any other necessary library here

        # Construct the headers with the API key for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Construct the payload with the parameters for updating the space
        payload = {
            "name": name,
            "private": is_private
        }

        # Define the endpoint URL for updating a space
        url = f"https://api.clickup.com/api/v2/space/{space_id}"

        # Make the HTTP request to update the space
        response = requests.put(url, headers=headers, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the JSON response if successful
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # The main function is now defined and ready to be used with the required parameters.
  id: |-
    synthetic_update-space
  instructions: |-
    Update a space. See the docs in **Spaces / Update Space** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type GoogleContacts = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(googleContactsResource: GoogleContacts, contactId: string) {
        const oauth2Client = new OAuth2Client(
            googleContactsResource.clientId,
            googleContactsResource.clientSecret
        );

        oauth2Client.setCredentials({
            refresh_token: googleContactsResource.refreshToken,
            access_token: googleContactsResource.accessToken,
        });

        const url = `https://people.googleapis.com/v1/people/${contactId}:deleteContact`;
        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${googleContactsResource.accessToken}`,
                'Accept': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Failed to delete contact: ${response.status} ${response.statusText}`);
        }

        return { success: true, message: `Contact with ID ${contactId} deleted successfully.` };
    }
  good: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type GoogleContacts = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleContactsResource: GoogleContacts, contactId: string) {
        const oauth2Client = new OAuth2Client(
            googleContactsResource.clientId,
            googleContactsResource.clientSecret,
            googleContactsResource.redirectUri
        );

        oauth2Client.setCredentials({
            refresh_token: googleContactsResource.refreshToken
        });

        const url = `https://people.googleapis.com/v1/people/${contactId}:deleteContact`;
        const accessToken = (await oauth2Client.getAccessToken()).token;

        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to delete contact: ${response.status} ${response.statusText}`);
        }

        return { success: true, message: 'Contact deleted successfully' };
    }
  id: |-
    synthetic_delete-contact
  instructions: |-
    Deletes a contact in google contacts
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleContacts
  resource_type_def: |-
    type GoogleContacts = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HarvestClient as HarvestApiClient, TimeEntry } from "npm:@harvest-profit/harvest-api";

    type Harvest = {
        accountId: string;
        accessToken: string;
    }

    export async function main(harvestResource: Harvest, projectId: number, taskId: number, hours: number, notes?: string) {
        const harvest = new HarvestApiClient({
            accountId: harvestResource.accountId,
            accessToken: harvestResource.accessToken,
        });

        const timeEntry: TimeEntry = {
            project_id: projectId,
            task_id: taskId,
            spent_date: new Date().toISOString().split('T')[0], // Assuming the entry is for the current date
            hours: hours,
            notes: notes,
        };

        const result = await harvest.timeEntries.create(timeEntry);
        return result;
    }
  good: |-
    import { HarvestClient, TimeEntry } from "npm:@harvest-profit/harvest-api";

    type Harvest = {
        accountId: string;
        accessToken: string;
    }

    export async function main(harvestResource: Harvest, stoppedTimeEntryId: number) {
        const harvest = new HarvestClient({
            accountId: harvestResource.accountId,
            accessToken: harvestResource.accessToken,
        });

        const stoppedTimeEntry: TimeEntry | null = await harvest.timeEntries.retrieve(stoppedTimeEntryId);

        if (stoppedTimeEntry && stoppedTimeEntry.is_running === false) {
            const restartedTimeEntry = await harvest.timeEntries.restart(stoppedTimeEntryId);
            return restartedTimeEntry;
        } else {
            throw new Error('Time entry is either running or does not exist.');
        }
    }
  id: |-
    synthetic_start-timer
  instructions: |-
    Restart a stopped timer entry in harvest
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Harvest
  resource_type_def: |-
    type Harvest = {
        accountId: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class chatwork(TypedDict):
        api_token: str

    def main(chatwork_resource: chatwork, room_id: str, message: str) -> dict:
        headers = {
            'X-ChatWorkToken': chatwork_resource['api_token']
        }
        payload = {
            'body': message
        }
        url = f'https://api.chatwork.com/v2/rooms/{room_id}/messages'
        response = requests.post(url, headers=headers, data=payload)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the chatwork integration
    class chatwork(TypedDict):
        api_token: str

    def main(chatwork_resource: chatwork, room_id: str, body: str):
        import requests  # Import here to avoid conflicts with any parameter names

        # Chatwork API endpoint to send a message
        chatwork_api_endpoint = f"https://api.chatwork.com/v2/rooms/{room_id}/messages"

        # Prepare headers for the HTTP request
        headers = {
            "X-ChatWorkToken": chatwork_resource['api_token']
        }

        # Prepare the data to be sent in the HTTP request
        data = {
            "body": body
        }

        # Send the HTTP POST request to Chatwork API
        response = requests.post(chatwork_api_endpoint, headers=headers, data=data)

        # Return the response from the API
        return response.json()
  id: |-
    synthetic_create-message
  instructions: |-
    Send a message to a specified room in chatwork
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    chatwork
  resource_type_def: |-
    class chatwork(TypedDict):
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Coinmarketcap } from "npm:@types/coinmarketcap-api";

    type Coinmarketcap = {
        apiKey: string;
    }

    export async function main(coinmarketcapResource: Coinmarketcap) {
        const url = 'https://pro-api.coinmarketcap.com/v1/cryptocurrency/map';
        const headers = {
            'X-CMC_PRO_API_KEY': coinmarketcapResource.apiKey,
            'Accept': 'application/json'
        };

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data.data; // Assuming the API returns the mapping in the 'data' field
    }
  good: |-
    import { fetch as fetchAPI } from "npm:@deno/fetch";

    type Coinmarketcap = {
        apiKey: string;
    }

    export async function main(coinmarketcapResource: Coinmarketcap, start: number = 1, limit: number = 5000, listingStatus: string = 'active', sort: string = 'id') {
        const url = new URL('https://pro-api.coinmarketcap.com/v1/cryptocurrency/map');
        url.searchParams.append('start', start.toString());
        url.searchParams.append('limit', limit.toString());
        url.searchParams.append('listing_status', listingStatus);
        url.searchParams.append('sort', sort);

        const response = await fetchAPI(url.toString(), {
            method: 'GET',
            headers: {
                'X-CMC_PRO_API_KEY': coinmarketcapResource.apiKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_id-map
  instructions: |-
    Returns a mapping of all cryptocurrencies to unique CoinMarketCap ids. https://coinmarketcap.com/api/documentation/v1/#operation/getV1CryptocurrencyMap in coinmarketcap
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coinmarketcap
  resource_type_def: |-
    type Coinmarketcap = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { MapClient } from "npm:@mapbox/mapbox-sdk";
    import { GeocodeResponse } from "npm:@mapbox/mapbox-sdk/services/geocoding";

    type Mapulus = {
        accessToken: string;
    }

    export async function main(mapulusResource: Mapulus, locationName: string, latitude: number, longitude: number): Promise<GeocodeResponse> {
        // Initialize the Mapbox client with the access token from the Mapulus resource
        const mapboxClient = MapClient({ accessToken: mapulusResource.accessToken });

        // Use the Mapbox client to create a location
        const response = await mapboxClient.forwardGeocode({
            query: `${latitude},${longitude}`,
            limit: 1
        }).send();

        // Return the result which should be a GeocodeResponse
        return response.body;
    }
  good: |-
    // Import any libraries you need here
    import { MapClient } from "npm:@mapulus/client"; // Hypothetical npm package for Mapulus

    type Mapulus = {
        apiKey: string;
        // Add other properties needed for Mapulus integration
    }

    export async function main(mapulusResource: Mapulus, locationName: string, latitude: number, longitude: number) {
        // Initialize the Mapulus client with the API key from the resource
        const mapClient = new MapClient(mapulusResource.apiKey);

        // Create a new location in Mapulus
        const newLocation = await mapClient.createLocation({
            name: locationName,
            coordinates: { lat: latitude, lng: longitude }
        });

        // Return the result
        return newLocation;
    }
  id: |-
    synthetic_create-location
  instructions: |-
    Create a new location in Mapulus in mapulus
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mapulus
  resource_type_def: |-
    type Mapulus = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Airmeet = {
        apiKey: string;
        apiSecret: string;
        organizationId: string;
    }

    export async function main(airmeetResource: Airmeet, eventName: string, eventStartTime: string, eventEndTime: string, eventDescription: string) {
        const createEventUrl = `https://api.airmeet.com/v1/organizations/${airmeetResource.organizationId}/events`;

        const eventData = {
            name: eventName,
            start_time: eventStartTime,
            end_time: eventEndTime,
            description: eventDescription,
            event_uuid: uuidv4(), // Generate a unique identifier for the event
        };

        const response = await fetch(createEventUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${airmeetResource.apiKey}:${airmeetResource.apiSecret}`
            },
            body: JSON.stringify(eventData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:base-64";

    type Airmeet = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(airmeetResource: Airmeet, eventName: string, eventStartTime: string, eventEndTime: string, timeZone: string, isPrivate: boolean) {
        const authHeader = `Basic ${encode(`${airmeetResource.apiKey}:${airmeetResource.apiSecret}`)}`;
        const airmeetApiUrl = 'https://api.airmeet.com/v1/events';

        const eventDetails = {
            name: eventName,
            startTime: eventStartTime,
            endTime: eventEndTime,
            timeZone: timeZone,
            isPrivate: isPrivate
        };

        const response = await fetch(airmeetApiUrl, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(eventDetails)
        });

        if (!response.ok) {
            throw new Error(`Error creating Airmeet event: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-airmeet
  instructions: |-
    Creates an airmeet in airmeet
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Airmeet
  resource_type_def: |-
    type Airmeet = {
        apiKey: string;
        apiSecret: string;
        organizationId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the maintainx integration
    class maintainx(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for updating a work order in maintainx
    def main(maintainx_resource: maintainx, work_order_id: str, update_fields: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a work order
        endpoint = f"https://api.maintainx.com/api/v1/work-orders/{work_order_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {maintainx_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to update the work order with the given fields
        response = requests.patch(endpoint, json=update_fields, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the updated work order data
            return response.json()
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {"error": response.text, "status_code": response.status_code}

    # The script ends here, and the main function is ready to be exported and used with the maintainx integration.
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'maintainx' integration
    class maintainx(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for updating a work order in MaintainX
    def main(maintainx_resource: maintainx, work_order_id: str, update_fields: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a work order
        api_endpoint = f"https://api.maintainx.com/api/v1/workorders/{work_order_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {maintainx_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the API request to update the work order with the given fields
        response = requests.patch(api_endpoint, headers=headers, json=update_fields)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the updated work order details
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # The script ends here, with no calls to the main function, as per the instructions.
  id: |-
    synthetic_update-work-order
  instructions: |-
    Updates a work order in maintainx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    maintainx
  resource_type_def: |-
    class maintainx(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import transformers  # Assuming transformers library is used for Hugging Face integration

    # If the 'transformers' module has a 'main' function, we would rename it to avoid conflict
    if hasattr(transformers, 'main'):
        transformers_main = transformers.main
        del transformers.main

    class hugging_face(TypedDict):
        api_key: str

    def main(hugging_face_resource: hugging_face, text_to_classify: List[str], model_name: str = "bert-base-uncased"):
        from transformers import pipeline

        classifier = pipeline("text-classification", model=model_name, api_key=hugging_face_resource['api_key'])
        results = classifier(text_to_classify)

        return results

    # Example usage:
    # result = main(hugging_face_resource={'api_key': 'your_api_key_here'}, text_to_classify=["Hello, world!", "Hugging Face is a technology company"])
  good: |-
    from typing import TypedDict, List
    from transformers import pipeline  # Assuming transformers is the library needed for Hugging Face

    # Define the resource type for the hugging_face integration
    class hugging_face(TypedDict):
        api_key: str

    # Define the main function with the resource type and additional parameters
    def main(hugging_face_resource: hugging_face, text_to_classify: str, model: str = "distilbert-base-uncased-finetuned-sst-2-english") -> List[dict]:
        # Initialize the Hugging Face pipeline for sentiment analysis with the provided model
        classifier = pipeline("sentiment-analysis", model=model, api_key=hugging_face_resource['api_key'])

        # Perform classification on the provided text
        results = classifier(text_to_classify)

        # Return the classification results
        return results
  id: |-
    synthetic_text-classification
  instructions: |-
    Usually used for sentiment-analysis this will output the likelihood of classes of an input. This action allows you to classify text into categories. in hugging face
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hugging_face
  resource_type_def: |-
    class hugging_face(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Filter = {
        // Properties for authentication/configuration relevant to the Filter integration
    }

    export async function main(filterResource: Filter, condition: string, inputData: any) {
        // Evaluate the condition
        const conditionMet = new Function('data', `return ${condition}`)(inputData);

        if (!conditionMet) {
            throw new Error('Condition not met.');
        }

        // If the condition is met, return the input data
        return inputData;
    }
  good: |-
    type Filter = {
        // No specific properties are needed for a generic filter integration
    }

    export async function main(filterResource: Filter, condition: boolean): Promise<boolean> {
        // Check the condition and return the result
        return condition;
    }
  id: |-
    synthetic_continue-based-on-condition
  instructions: |-
    Continue workflow execution only if a condition is met in filter
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Filter
  resource_type_def: |-
    type Filter = {
        // Properties for authentication/configuration relevant to the Filter integration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the 'kanban_tool' integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
        domain: str

    # Define the main function with the resource type and additional parameters
    def main(kanban_tool_resource: kanban_tool, task_name: str) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for searching tasks
        search_endpoint = f"https://{kanban_tool_resource['domain']}.kanbantool.com/api/v1/tasks/search.json"

        # Prepare the headers and parameters for the API request
        headers = {
            'X-KanbanToolToken': kanban_tool_resource['api_key']
        }
        params = {
            'board_id': kanban_tool_resource['board_id'],
            'query': task_name
        }

        # Make the API request to search for the task
        response = requests.get(search_endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the tasks
            tasks = response.json()
            return tasks
        else:
            # Handle the error case
            return {'error': 'Failed to retrieve tasks', 'status_code': response.status_code}

    # The script ends here, with no calls to the main function as per the instructions.
  good: |-
    from typing import TypedDict, List, Optional
    import requests  # Assuming requests is needed for API interaction

    class kanban_tool(TypedDict):
        api_key: str
        domain: str
        board_id: int

    def main(kanban_tool_resource: kanban_tool, task_name: str, task_description: Optional[str] = None) -> List[dict]:
        base_url = f"https://{kanban_tool_resource['domain']}.kanbantool.com/api/v1"
        headers = {
            "X-KanbanToolToken": kanban_tool_resource['api_key']
        }
        search_params = {
            "board_id": kanban_tool_resource['board_id'],
            "name": task_name,
            "description": task_description
        }

        response = requests.get(f"{base_url}/tasks", headers=headers, params=search_params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        tasks = response.json()
        matching_tasks = [task for task in tasks if task['name'] == task_name and (task_description is None or task['description'] == task_description)]

        return matching_tasks
  id: |-
    synthetic_find-task
  instructions: |-
    Finds task with given parameters in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SheetsV4 } from "npm:@googleapis/sheets";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        range: string,
        note: string
    ) {
        const sheets = new SheetsV4({});

        sheets.context._options.params = { key: googleSheetsResource.apiKey };
        sheets.context._options.auth = googleSheetsResource.accessToken;

        const result = await sheets.spreadsheets.batchUpdate({
            spreadsheetId: spreadsheetId,
            requestBody: {
                requests: [
                    {
                        updateCells: {
                            range: {
                                sheetId: range.split('!')[0],
                                startRowIndex: parseInt(range.split('!')[1].match(/\d+/)[0]) - 1,
                                startColumnIndex: range.split('!')[1].charCodeAt(0) - 'A'.charCodeAt(0),
                            },
                            rows: [
                                {
                                    values: [
                                        {
                                            note: note,
                                        },
                                    ],
                                },
                            ],
                            fields: 'note',
                        },
                    },
                ],
            },
        });

        return result.data;
    }
  good: |-
    import { google as googleapis } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        sheetName: string,
        noteText: string,
        cell: string
    ) {
        const { apiKey, clientEmail, privateKey } = googleSheetsResource;
        const scopes = ['https://www.googleapis.com/auth/spreadsheets'];
        const jwtClient = new googleapis.auth.JWT(clientEmail, undefined, privateKey, scopes);
        await jwtClient.authorize();

        const sheets = googleapis.sheets({ version: 'v4', auth: jwtClient });

        const request = {
            spreadsheetId: spreadsheetId,
            range: `${sheetName}!${cell}`,
            resource: {
                requests: [
                    {
                        repeatCell: {
                            range: {
                                sheetId: sheetName,
                                startRowIndex: 0,
                                endRowIndex: 1,
                                startColumnIndex: 0,
                                endColumnIndex: 1
                            },
                            cell: {
                                note: noteText
                            },
                            fields: 'note'
                        }
                    }
                ]
            },
            auth: apiKey,
        };

        const response = await sheets.spreadsheets.batchUpdate(request);
        return response.data;
    }
  id: |-
    synthetic_insert-anchored-note
  instructions: |-
    Insert a note on a spreadsheet cell in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        apiKey: string;
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { LeapClient } from "npm:leap-client";

    type Leap = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties required for Leap integration
    }

    export async function main(leapResource: Leap, modelName: string, modelSchema: object) {
        // Initialize the Leap client with the provided credentials
        const client = new LeapClient(leapResource.apiKey, leapResource.apiSecret);

        // Create the model using the Leap client
        const result = await client.createModel(modelName, modelSchema);

        // Always return the result
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { LeapClient } from "npm:@leap.ai/sdk"; // Assuming there's an npm package for Leap

    type Leap = {
        apiKey: string;
        projectId: string;
    }

    export async function main(leapResource: Leap, modelName: string, description?: string) {
        // Initialize the Leap client with the provided API key
        const leapClient = new LeapClient(leapResource.apiKey);

        // Create a new custom model entity within the specified project
        const result = await leapClient.createModel({
            projectId: leapResource.projectId,
            name: modelName,
            description: description || 'No description provided', // Use the provided description or a default one
        });

        // Return the result which should include details of the newly created model entity
        return result;
    }
  id: |-
    synthetic_create-model
  instructions: |-
    Creates a new custom model entity, which serves as a container that can be trained on custom images in leap
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Leap
  resource_type_def: |-
    type Leap = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties required for Leap integration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type Blogger = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }

    export async function main(bloggerResource: Blogger, blogId: string, title: string, content: string, isDraft: boolean = false) {
        const oauth2Client = new OAuth2Client(
            bloggerResource.clientId,
            bloggerResource.clientSecret
        );

        oauth2Client.setCredentials({
            refresh_token: bloggerResource.refreshToken
        });

        const accessTokenResponse = await oauth2Client.getAccessToken();
        const accessToken = accessTokenResponse.token;

        const response = await fetch(`https://www.googleapis.com/blogger/v3/blogs/${blogId}/posts/`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                kind: 'blogger#post',
                blog: {
                    id: blogId
                },
                title: title,
                content: content,
                isDraft: isDraft
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type Blogger = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        blogId: string;
    }

    export async function main(
        bloggerResource: Blogger,
        title: string,
        content: string,
        isDraft: boolean = false
    ) {
        const oauth2Client = new OAuth2Client(
            bloggerResource.clientId,
            bloggerResource.clientSecret
        );

        oauth2Client.setCredentials({
            refresh_token: bloggerResource.refreshToken
        });

        const accessTokenResponse = await oauth2Client.getAccessToken();
        const accessToken = accessTokenResponse.token;

        const response = await fetch(`https://www.googleapis.com/blogger/v3/blogs/${bloggerResource.blogId}/posts/`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                kind: 'blogger#post',
                blog: {
                    id: bloggerResource.blogId
                },
                title: title,
                content: content,
                isDraft: isDraft
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-post
  instructions: |-
    Creates and publishes a new post or creates a new post as a draft. in blogger
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Blogger
  resource_type_def: |-
    type Blogger = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import fetch from "npm:node-fetch";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: Mailchimp, emailAddress: string, listId: string) {
        const subscriberHash = Buffer.from(emailAddress.toLowerCase()).toString('hex');
        const url = `https://${mailchimpResource.serverPrefix}.api.mailchimp.com/3.0/lists/${listId}/members/${subscriberHash}`;

        const data = {
            status: 'unsubscribed'
        };

        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${mailchimpResource.apiKey}`
        };

        const response = await fetch(url, {
            method: 'PATCH',
            headers: headers,
            body: JSON.stringify(data)
        });

        const result = await response.json();

        if (!response.ok) {
            throw new Error(`Error unsubscribing email: ${result.detail}`);
        }

        return result;
    }
  good: |-
    import { SHA256 } from "npm:crypto-js";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string; // The server prefix associated with the user's account, e.g., 'us5'
    }

    export async function main(mailchimpResource: Mailchimp, emailAddress: string, audienceId: string) {
        const subscriberHash = SHA256(emailAddress.toLowerCase()).toString();
        const url = `https://${mailchimpResource.serverPrefix}.api.mailchimp.com/3.0/lists/${audienceId}/members/${subscriberHash}`;

        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${mailchimpResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                status: 'unsubscribed'
            })
        });

        if (!response.ok) {
            throw new Error(`Failed to unsubscribe email: ${emailAddress}. Status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_unsubscribe-email
  instructions: |-
    Unsubscribe an email address from an audience in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    def main(clickup_resource: clickup, list_id: str, task_ids: list[str]) -> dict:
        import requests  # Import here to avoid conflicts with any parameter names

        # Base URL for ClickUp API
        base_url = "https://api.clickup.com/api/v2"

        # Headers for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Initialize result dictionary
        result = {"deleted_tasks": []}

        # Loop through each task ID and attempt to delete it
        for task_id in task_ids:
            delete_url = f"{base_url}/list/{list_id}/task/{task_id}"
            response = requests.delete(delete_url, headers=headers)

            # Check if the deletion was successful and add to result
            if response.status_code == 204:
                result["deleted_tasks"].append(task_id)
            else:
                result.setdefault("errors", []).append({
                    "task_id": task_id,
                    "error": response.json()
                })

        return result
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to the ClickUp API

    class clickup(TypedDict):
        api_key: str
        team_id: str

    def main(clickup_resource: clickup, task_id: str, checklist_id: str) -> bool:
        base_url = "https://api.clickup.com/api/v2"
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        response = requests.delete(
            f"{base_url}/task/{task_id}/checklist/{checklist_id}",
            headers=headers
        )

        return response.status_code == 204  # 204 No Content indicates successful deletion
  id: |-
    synthetic_delete-checklist
  instructions: |-
    Deletes a checklist in a task. See the docs in **Checklists / Delete Checklist** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Onedesk as OnedeskClient } from 'npm:@onedesk/sdk'; // Renamed imported Onedesk to OnedeskClient to avoid conflict

    type Onedesk = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(onedesk: Onedesk, baseUrl: string, itemId: string) {
        // Initialize the Onedesk client with the provided credentials
        const onedeskClient = new OnedeskClient({
            apiKey: onedesk.apiKey,
            apiSecret: onedesk.apiSecret,
            baseUrl: baseUrl
        });

        // Fetch the item by ID
        const item = await onedeskClient.items.getItem(itemId);

        // Return the result
        return item;
    }
  good: |-
    import { encode } from "npm:base-64";

    type Onedesk = {
        apiKey: string;
        apiSecret: string;
        subdomain: string;
    }

    export async function main(onedeskResource: Onedesk, itemName: string) {
        const credentials = `${onedeskResource.apiKey}:${onedeskResource.apiSecret}`;
        const base64Credentials = encode(credentials);
        const url = `https://${onedeskResource.subdomain}.onedesk.com/api/v1/items/search`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${base64Credentials}`
            },
            body: JSON.stringify({
                name: itemName
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_find-item
  instructions: |-
    Search for an existing item in onedesk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Onedesk
  resource_type_def: |-
    type Onedesk = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Clerk, Users } from "npm:@clerk/clerk-sdk-node";

    type Clerk = {
        apiKey: string;
    }

    export async function main(clerkResource: Clerk, userId: string) {
        const clerk = new Clerk({ apiKey: clerkResource.apiKey });
        const users = new Users(clerk);

        const result = await users.deleteUser(userId);
        return result;
    }
  good: |-
    // Import necessary libraries
    import { Clerk as ClerkSDK, ClerkResource as ClerkSDKResource } from "npm:@clerk/clerk-sdk-node";

    type Clerk = {
        apiKey: string;
    }

    export async function main(clerk: Clerk, userId: string) {
        // Initialize Clerk with the provided API key
        const clerkInstance = new ClerkSDK({ apiKey: clerk.apiKey });

        // Delete the user with the given userId
        const result = await clerkInstance.users.deleteUser(userId);

        // Return the result of the deletion
        return result;
    }
  id: |-
    synthetic_delete-user
  instructions: |-
    Delete the specified user in clerk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clerk
  resource_type_def: |-
    type Clerk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Lemlist = {
        apiKey: string;
    }

    export async function main(lemlistResource: Lemlist, email: string) {
        const response = await fetch('https://api.lemlist.com/api/unsubscribes', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${lemlistResource.apiKey}`
            },
            body: JSON.stringify({ email: email })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    type Lemlist = {
        apiKey: string;
        campaignId: string;
    }

    export async function main(lemlistResource: Lemlist, email: string, firstName?: string, lastName?: string) {
        const url = `https://api.lemlist.com/api/campaigns/${lemlistResource.campaignId}/unsubscribes`;

        const body = {
            email: email,
            ...(firstName && { firstName: firstName }),
            ...(lastName && { lastName: lastName }),
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${lemlistResource.apiKey}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-email-in-unsubscribes
  instructions: |-
    This action adds a lead in the unsubscribed list in lemlist
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lemlist
  resource_type_def: |-
    type Lemlist = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Page } from "npm:@types/facebook-js-sdk";

    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }

    export async function main(facebookPagesResource: FacebookPages, fields: string = 'name,category') {
        const url = `https://graph.facebook.com/v14.0/${facebookPagesResource.pageId}?fields=${fields}&access_token=${facebookPagesResource.accessToken}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const pageData: Page = await response.json();

        return pageData;
    }
  good: |-
    import { Page } from "npm:@types/facebook-js-sdk";

    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }

    export async function main(facebookPagesResource: FacebookPages, fields: string = 'name,about,emails') {
        const url = `https://graph.facebook.com/v14.0/${facebookPagesResource.pageId}?fields=${fields}&access_token=${facebookPagesResource.accessToken}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const pageData: Page = await response.json();
            return pageData;
        } catch (error) {
            console.error('Error fetching page data:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-page
  instructions: |-
    Retrieves a Facebook Page in facebook pages
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FacebookPages
  resource_type_def: |-
    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Dropbox } from "npm:dropbox";

    type DropboxResource = {
        accessToken: string;
    }

    export async function main(dropboxResource: DropboxResource, searchQuery: string) {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        const result = await dbx.filesSearch({ path: '', query: searchQuery });
        return result;
    }
  good: |-
    import { Dropbox as DropboxClient } from "npm:dropbox";

    type Dropbox = {
        accessToken: string;
    }

    export async function main(dropbox: Dropbox, searchQuery: string, path: string = '') {
        const dbx = new DropboxClient({ accessToken: dropbox.accessToken });

        try {
            const response = await dbx.filesSearch({ path, query: searchQuery });
            return response.result.matches;
        } catch (error) {
            console.error('Error searching Dropbox:', error);
            throw error;
        }
    }
  id: |-
    synthetic_search-files-folders
  instructions: |-
    Searches for files and folders by name in dropbox
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dropbox
  resource_type_def: |-
    type Dropbox = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'maintainx' integration
    class maintainx(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for creating a work order in MaintainX
    def main(maintainx_resource: maintainx, title: str, description: str, priority: str, assigned_to: str, due_date: str) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a work order
        url = "https://api.maintainx.com/workorders"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {maintainx_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the work order
        data = {
            "title": title,
            "description": description,
            "priority": priority,
            "assignedTo": assigned_to,
            "dueDate": due_date
        }

        # Make the POST request to create the work order
        response = requests.post(url, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created work order details
        else:
            raise Exception(f"Failed to create work order: {response.status_code} {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the maintainx integration
    class maintainx(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for creating a work order in maintainx
    def main(maintainx_resource: maintainx, title: str, description: str,
             assigned_to: Optional[str] = None, due_date: Optional[str] = None):
        import requests  # Import requests or any other library if needed

        # Endpoint for creating a work order in maintainx
        url = "https://api.maintainx.com/workorders"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {maintainx_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Data payload for the work order
        data = {
            "title": title,
            "description": description,
            "assignedTo": assigned_to,
            "dueDate": due_date
        }

        # Filter out None values from the data payload
        data = {k: v for k, v in data.items() if v is not None}

        # Make the POST request to create the work order
        response = requests.post(url, json=data, headers=headers)

        # Check for successful response
        if response.status_code == 201:
            return response.json()  # Return the created work order details
        else:
            response.raise_for_status()  # Raise an error if the request failed

    # The main function is now defined and can be used to create a work order in maintainx
  id: |-
    synthetic_create-work-order
  instructions: |-
    Creates a work order in maintainx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    maintainx
  resource_type_def: |-
    class maintainx(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'envoy' integration
    class envoy(TypedDict):
        api_key: str

    # Main function to create an invite on the Envoy platform
    def main(envoy_resource: envoy, access_token: str, visitor_email: str, visitor_name: str, visit_date: str, host_email: str):
        import requests  # Import requests or any other library if needed

        # Endpoint for creating an invite on the Envoy platform
        create_invite_endpoint = "https://app.envoy.com/api/invites"

        # Headers to authenticate the request
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Data payload for the invite
        invite_data = {
            "invite": {
                "email": visitor_email,
                "name": visitor_name,
                "startDate": visit_date,
                "host": {
                    "email": host_email
                }
            }
        }

        # Make the POST request to create an invite
        response = requests.post(create_invite_endpoint, json=invite_data, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the envoy integration
    class envoy(TypedDict):
        access_token: str  # OAuth2 Access Token
        location_id: int   # ID of the location in Envoy

    # Import any additional libraries you might need
    import requests

    # Define the main function for the envoy integration
    def main(envoy_resource: envoy, visitor_email: str, visitor_name: str, visit_date: str, host_email: str):
        # Endpoint for creating an invite in Envoy
        create_invite_endpoint = f"https://app.envoy.com/api/invites"

        # Headers for the request including the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {envoy_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Data payload for creating an invite
        data = {
            "invite": {
                "location_id": envoy_resource['location_id'],
                "email": visitor_email,
                "name": visitor_name,
                "start_date": visit_date,
                "host": {
                    "email": host_email
                }
            }
        }

        # Make the request to create an invite
        response = requests.post(create_invite_endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the invite details
        else:
            raise Exception(f"Failed to create invite: {response.status_code} - {response.text}")

    # Example usage:
    # result = main(envoy_resource={'access_token': 'your_access_token', 'location_id': 123},
    #               visitor_email='visitor@example.com',
    #               visitor_name='Visitor Name',
    #               visit_date='2023-04-15T09:00:00Z',
    #               host_email='host@example.com')
    # print(result)
  id: |-
    synthetic_create-an-invite
  instructions: |-
    Create an Invite to a person to visit a location. in envoy
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    envoy
  resource_type_def: |-
    class envoy(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { post } from "npm:@deno/standard/http/mod.ts";

    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }

    export async function main(onesignalResource: OnesignalRestApi, deviceType: number, deviceModel: string, deviceOS: string, language: string, timezone: number, deviceToken: string) {
        const url = `https://onesignal.com/api/v1/players`;
        const headers = {
            "Content-Type": "application/json",
            "Authorization": `Basic ${onesignalResource.restApiKey}`
        };
        const body = JSON.stringify({
            app_id: onesignalResource.appId,
            device_type: deviceType,
            device_model: deviceModel,
            device_os: deviceOS,
            language: language,
            timezone: timezone,
            identifier: deviceToken
        });

        const response = await post(url, {
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Failed to add device: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { v4 as uuidv4 } from "npm:uuid";

    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }

    export async function main(onesignalResource: OnesignalRestApi, deviceType: number, deviceModel: string, deviceOS: string, language: string, timezone: number, deviceToken: string) {
        const url = `https://onesignal.com/api/v1/players`;
        const body = {
            app_id: onesignalResource.appId,
            device_type: deviceType,
            device_model: deviceModel,
            device_os: deviceOS,
            language: language,
            timezone: timezone,
            identifier: deviceToken,
            // Generate a unique UUID for the device if not provided
            // This is a simplified example, in a real-world scenario, you should get this from the device itself
            ad_id: uuidv4()
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Basic ${onesignalResource.restApiKey}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-device
  instructions: |-
    Register a new device to your app in onesignal rest api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    OnesignalRestApi
  resource_type_def: |-
    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { Mercury } from "npm:@mercuryhq/mercury-sdk"; // Assuming there's an npm package for Mercury

    type Mercury = {
        apiKey: string;
        // Add other properties relevant to Mercury authentication/configuration
    }

    export async function main(mercuryResource: Mercury) {
        // Initialize the Mercury client with the provided API key
        const mercuryClient = new Mercury(mercuryResource.apiKey);

        // Fetch the account information
        const accountInfo = await mercuryClient.getAccountInformation();

        // Return the result
        return accountInfo;
    }
  good: |-
    // Import any libraries you need here
    import { Mercury } from "npm:@mercuryhq/mercury-node"; // Assuming there's an npm package for Mercury

    type MercuryResource = {
        apiKey: string;
    }

    export async function main(mercuryResource: MercuryResource, accountId: string) {
        // Initialize the Mercury client with the API key
        const mercuryClient = new Mercury(mercuryResource.apiKey);

        // Retrieve information about the specific account
        const accountInfo = await mercuryClient.getAccount(accountId);

        // Always return the result
        return accountInfo;
    }
  id: |-
    synthetic_get-account-info
  instructions: |-
    Retrieve information about a specific account in mercury
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mercury
  resource_type_def: |-
    type Mercury = {
        apiKey: string;
        // Add other properties relevant to Mercury authentication/configuration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { ClockworkClient } from "npm:clockwork-recruiting-client";

    type ClockworkRecruiting = {
        apiKey: string;
        firmId: number;
    }

    export async function main(clockworkResource: ClockworkRecruiting, positionTitle: string, positionDescription: string, projectId: number) {
        // Initialize the ClockworkRecruiting client with the provided API key
        const client = new ClockworkClient(clockworkResource.apiKey, clockworkResource.firmId);

        // Create the position within the specified project
        const newPosition = {
            title: positionTitle,
            description: positionDescription,
            projectId: projectId
        };

        // Use the ClockworkRecruiting client to add the position
        const result = await client.addPosition(newPosition);

        // Return the result
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { ClockworkClient } from "npm:clockwork-recruiting-client";

    type ClockworkRecruiting = {
        apiKey: string;
        firmId: number;
    }

    export async function main(clockworkResource: ClockworkRecruiting, personId: number, positionTitle: string, positionStatus: string) {
        const client = new ClockworkClient(clockworkResource.apiKey, clockworkResource.firmId);

        const position = {
            title: positionTitle,
            status: positionStatus
        };

        const result = await client.addPositionToPerson(personId, position);

        return result;
    }
  id: |-
    synthetic_add-person-position
  instructions: |-
    Add a position to a specific person in clockwork recruiting
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    ClockworkRecruiting
  resource_type_def: |-
    type ClockworkRecruiting = {
        apiKey: string;
        firmId: number;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { stringify } from "npm:querystring";

    type Ip2proxy = {
        apiKey: string;
        package: string;
        useSSL: boolean;
    }

    export async function main(ip2proxyResource: Ip2proxy, ipAddress: string) {
        const baseUrl = ip2proxyResource.useSSL ? 'https://api.ip2proxy.com' : 'http://api.ip2proxy.com';
        const queryParams = stringify({
            key: ip2proxyResource.apiKey,
            package: ip2proxyResource.package,
            ip: ipAddress,
            format: 'json'
        });

        const url = `${baseUrl}/?${queryParams}`;
        const response = await fetch(url);
        const data = await response.json();

        return data;
    }
  good: |-
    import fetch from "npm:node-fetch";

    type Ip2proxy = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(ip2proxyResource: Ip2proxy, ipAddress: string) {
        const url = `${ip2proxyResource.apiUrl}?key=${ip2proxyResource.apiKey}&ip=${ipAddress}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error querying IP address:', error);
            throw error;
        }
    }
  id: |-
    synthetic_query-ip-info
  instructions: |-
    Query IP address using IP2Proxy API for how to use this API. in ip2proxy
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ip2proxy
  resource_type_def: |-
    type Ip2proxy = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Noco } from "npm:@nocodb/sdk"; // Importing Nocodb SDK from npm

    // Define the Nocodb resource type with properties needed for authentication
    type Nocodb = {
        apiKey: string,
        baseUrl: string,
        projectId: string
    }

    // Define the parameters for updating a record in a table
    export async function main(
        nocodbResource: Nocodb,
        tableName: string,
        recordId: number,
        updateData: Record<string, any> // A dictionary representing the data to update
    ) {
        // Initialize the NocoDB client with the provided resource credentials
        const noco = new Noco({
            apiKey: nocodbResource.apiKey,
            baseUrl: nocodbResource.baseUrl
        });

        // Access the specific project and table
        const table = noco.db(nocodbResource.projectId).table(tableName);

        // Update the record with the given ID and data
        const result = await table.row(recordId).update(updateData);

        // Return the result of the update operation
        return result;
    }
  good: |-
    import { Noco as NocoSDK } from "npm:@nocodb/sdk"; // Importing Nocodb SDK from npm and renaming to avoid conflict

    // Define the Nocodb resource type with properties needed for authentication/configuration
    type Nocodb = {
        apiKey: string,
        baseUrl: string
    }

    // Define the main function with the Nocodb resource and parameters specific to updating a record
    export async function main(
        nocodb: Nocodb,
        tableName: string,
        recordId: number,
        updateData: Record<string, any> // A dictionary representing the data to update in the record
    ) {
        // Initialize the NocoDB client with the provided resource credentials
        const noco = new NocoSDK({
            apiKey: nocodb.apiKey,
            baseUrl: nocodb.baseUrl
        });

        // Access the specific table
        const table = noco.table(tableName);

        // Update the record with the given ID and data
        const result = await table.update(recordId, updateData);

        // Return the result of the update operation
        return result;
    }
  id: |-
    synthetic_update-record
  instructions: |-
    This action updates a record in a table in nocodb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nocodb
  resource_type_def: |-
    type Nocodb = {
        apiKey: string,
        baseUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Noticeable as NoticeableClient } from "npm:@noticeable/node";

    type Noticeable = {
        projectId: string;
        apiKey: string;
    }

    export async function main(noticeableResource: Noticeable, emailAddress: string, subscriptionPreferences: Record<string, any>) {
        const noticeable = new NoticeableClient({
            projectId: noticeableResource.projectId,
            apiKey: noticeableResource.apiKey
        });

        const result = await noticeable.subscribe({
            email: emailAddress,
            preferences: subscriptionPreferences
        });

        return result;
    }
  good: |-
    import { NoticeableClient } from "npm:@noticeable/node";

    type Noticeable = {
        projectId: string;
        apiKey: string;
    }

    export async function main(noticeableResource: Noticeable, emailAddress: string, subscriptionAttributes?: Record<string, any>) {
        const noticeableClient = new NoticeableClient({ apiKey: noticeableResource.apiKey });

        const subscription = {
            email: emailAddress,
            properties: subscriptionAttributes || {},
        };

        const result = await noticeableClient.createSubscription(noticeableResource.projectId, subscription);

        return result;
    }
  id: |-
    synthetic_create-email-subscription
  instructions: |-
    Creates an email subscription, in noticeable
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Noticeable
  resource_type_def: |-
    type Noticeable = {
        projectId: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library to make HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type GoogleTagManager = {
        accessToken: string;
        accountId: string;
        containerId: string;
    }

    export async function main(
        googleTagManagerResource: GoogleTagManager,
        tagId: string,
        tagName: string,
        tagFiringTriggerId: string
    ) {
        const endpoint = `https://www.googleapis.com/tagmanager/v2/accounts/${googleTagManagerResource.accountId}/containers/${googleTagManagerResource.containerId}/tags/${tagId}`;
        const headers = {
            'Authorization': `Bearer ${googleTagManagerResource.accessToken}`,
            'Content-Type': 'application/json'
        };

        // Retrieve the current configuration of the tag
        const getResponse = await fetch(endpoint, { headers });
        if (!getResponse.ok) {
            throw new Error(`Failed to retrieve tag: ${getResponse.statusText}`);
        }
        const tagConfig = await getResponse.json();

        // Update the tag configuration
        tagConfig.name = tagName;
        tagConfig.triggerId = [tagFiringTriggerId];

        // Update the tag in Google Tag Manager
        const updateResponse = await fetch(endpoint, {
            method: 'PUT',
            headers,
            body: JSON.stringify(tagConfig)
        });

        if (!updateResponse.ok) {
            throw new Error(`Failed to update tag: ${updateResponse.statusText}`);
        }

        return await updateResponse.json();
    }
  good: |-
    // Importing the necessary library to make HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type GoogleTagManager = {
        accessToken: string;
        accountId: string;
        containerId: string;
    }

    export async function main(
        googleTagManagerResource: GoogleTagManager,
        workspaceId: string,
        tagId: string,
        tagBody: Record<string, any> // The tag body should follow the structure required by the Google Tag Manager API
    ) {
        const baseUrl = `https://www.googleapis.com/tagmanager/v2/accounts/${googleTagManagerResource.accountId}/containers/${googleTagManagerResource.containerId}/workspaces/${workspaceId}/tags/${tagId}`;
        const response = await fetch(baseUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${googleTagManagerResource.accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(tagBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-tag
  instructions: |-
    Update a tag in a workspace in google tag manager
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleTagManager
  resource_type_def: |-
    type GoogleTagManager = {
        accessToken: string;
        accountId: string;
        containerId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { CustomerIO } from "npm:@customer.io/node";

    type CustomerIo = {
        siteId: string;
        apiKey: string;
    }

    export async function main(customerIoResource: CustomerIo, customerId: string, eventName: string, eventData: Record<string, any>) {
        const cio = new CustomerIO(customerIoResource.siteId, customerIoResource.apiKey);

        try {
            const response = await cio.track(customerId, eventName, eventData);
            return response;
        } catch (error) {
            // Handle any errors that occur during the API call
            throw error;
        }
    }
  good: |-
    import { TrackClient } from "npm:customerio-node";

    type CustomerIo = {
        siteId: string;
        apiKey: string;
    }

    export async function main(customerIoResource: CustomerIo, customerId: string, eventName: string, eventData: Record<string, any>) {
        const cio = new TrackClient(customerIoResource.siteId, customerIoResource.apiKey);

        try {
            await cio.track(customerId, {
                name: eventName,
                data: eventData
            });
            return { success: true, message: `Event '${eventName}' sent for customer '${customerId}'.` };
        } catch (error) {
            return { success: false, message: `Failed to send event: ${error.message}` };
        }
    }
  id: |-
    synthetic_send-event-to
  instructions: |-
    Sends an event to Customer.io in customer io
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CustomerIo
  resource_type_def: |-
    type CustomerIo = {
        siteId: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { hmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, orderId: string, newQty: number, newPrice: number) {
        const { apiKey, apiSecret, endpoint } = bybitResource;
        const timestamp = new Date().getTime();
        const params = {
            api_key: apiKey,
            symbol: symbol,
            order_id: orderId,
            qty: newQty,
            price: newPrice,
            timestamp: timestamp
        };

        const query = Object.keys(params)
            .map(key => `${key}=${encodeURIComponent(params[key])}`)
            .join('&');

        const signature = hmac('sha256', apiSecret, query, 'utf8', 'hex');

        const response = await fetch(`${endpoint}/v2/private/order/replace`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Request-Signature': signature
            },
            body: query
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { hmac as createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, orderId: string, symbol: string, price: number, quantity: number) {
        const { apiKey, apiSecret, endpoint } = bybitResource;

        const params = {
            api_key: apiKey,
            order_id: orderId,
            symbol: symbol,
            p_r_qty: quantity.toString(),
            p_r_price: price.toString(),
            timestamp: Date.now().toString(),
        };

        const query = Object.entries(params)
            .map(([key, val]) => `${key}=${encodeURIComponent(val)}`)
            .join('&');

        const signature = createHmac('sha256', apiSecret, query, 'utf8', 'hex');

        const response = await fetch(`${endpoint}/v2/private/order/replace`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Request-Signature': signature,
            },
            body: query,
        });

        const result = await response.json();

        return result;
    }
  id: |-
    synthetic_linear-order-replace
  instructions: |-
    Replace active order. in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP calls

    class google_tag_manager(TypedDict):
        access_token: str
        workspace_id: str

    def main(google_tag_manager_resource: google_tag_manager, tag_id: str) -> dict:
        base_url = "https://www.googleapis.com/tagmanager/v2"
        headers = {
            "Authorization": f"Bearer {google_tag_manager_resource['access_token']}"
        }
        endpoint = f"/accounts/{google_tag_manager_resource['workspace_id']}/tags/{tag_id}"
        response = requests.get(base_url + endpoint, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the Google Tag Manager integration
    class google_tag_manager(TypedDict):
        account_id: str
        container_id: str
        access_token: str  # Assuming OAuth2 access token is provided

    # Main function to get a tag from Google Tag Manager
    def main(gtm_resource: google_tag_manager, workspace_id: str, tag_id: str) -> Dict[str, Any]:
        from googleapiclient.discovery import build as google_build

        # Initialize the Google Tag Manager service
        service = google_build('tagmanager', 'v2', credentials=None)
        service._http = service._http.authorize(lambda: gtm_resource['access_token'])

        # Construct the API request to get the tag
        tag_path = f"accounts/{gtm_resource['account_id']}/containers/{gtm_resource['container_id']}/workspaces/{workspace_id}/tags/{tag_id}"
        request = service.accounts().containers().workspaces().tags().get(path=tag_path)

        # Execute the request and return the response
        response = request.execute()
        return response
  id: |-
    synthetic_get-tag
  instructions: |-
    Get a specific tag of a workspace in google tag manager
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_tag_manager
  resource_type_def: |-
    class google_tag_manager(TypedDict):
        account_id: str
        container_id: str
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Requests library to make HTTP requests

    # Define the resource type for the ByBit integration
    class bybit(TypedDict):
        pass

    # Define the main function with the resource type and any other parameters
    def main(bybit_resource: bybit, symbol: str, limit: int = 50) -> List[Dict]:
        # ByBit API endpoint for linear market recent trading records
        endpoint = f"https://api.bybit.com/v2/public/trading-records?symbol={symbol}&limit={limit}"

        # Make the HTTP request to the ByBit API
        response = requests.get(endpoint)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            # Return the result, which is a list of trading records
            return data.get('result', [])
        else:
            # If the request failed, raise an exception with the error message
            raise Exception(f"Failed to get trading records: {response.text}")

    # Example usage:
    # result = main(bybit_resource={}, symbol='BTCUSD')
    # print(result)
  good: |-
    from typing import TypedDict, List, Dict

    # Define the resource type for the bybit integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str

    # Import any libraries you need here
    import requests  # Assuming requests is needed to make HTTP calls to bybit API

    # Define the main function with the bybit resource and any other parameters
    def main(bybit_resource: bybit, symbol: str, limit: int = 50) -> List[Dict]:
        # Construct the endpoint URL for getting recent trades
        url = f"https://api.bybit.com/v2/public/trading-records?symbol={symbol}&limit={limit}"

        # Make the HTTP request to the bybit API
        response = requests.get(url)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the result
            trades = response.json().get('result', [])
            return trades
        else:
            # Handle the error case
            response.raise_for_status()

    # Note: The function is not called here, as per the instructions.
  id: |-
    synthetic_linear-market-recent-trading-records
  instructions: |-
    Get recent trades in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        pass
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls to Axonaut API

    class axonaut(TypedDict):
        api_key: str
        base_url: str

    def main(axonaut_resource: axonaut, company_name: str, company_email: str, company_phone: str, additional_info: dict):
        headers = {
            'Authorization': f"Bearer {axonaut_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'name': company_name,
            'email': company_email,
            'phone': company_phone,
            **additional_info
        }
        response = requests.post(f"{axonaut_resource['base_url']}/companies", headers=headers, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'axonaut' integration
    class axonaut(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for creating a company in Axonaut
    def main(axonaut_resource: axonaut, company_name: str, company_email: str, company_phone: str = None, company_address: str = None):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a company
        endpoint = f"{axonaut_resource['base_url']}/api/companies"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Bearer {axonaut_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'name': company_name,
            'email': company_email,
            'phone': company_phone,
            'address': company_address
        }

        # Make the API request to create a company
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check the response and return the result
        if response.status_code == 201:
            return response.json()  # Return the created company details
        else:
            raise Exception(f"Failed to create company: {response.status_code} - {response.text}")
  id: |-
    synthetic_create-company
  instructions: |-
    Creates a company in axonaut
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    axonaut
  resource_type_def: |-
    class axonaut(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { LinkedIn } from "npm:@typefully/linkedin";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, organizationUrn: string) {
        const linkedInClient = new LinkedIn(linkedinResource.accessToken);

        const adminMembers = await linkedInClient.organization.getAdmins({
            organizationUrn: organizationUrn,
        });

        return adminMembers;
    }
  good: |-
    // Import necessary libraries
    import { LinkedInClient } from "npm:linkedin-private-api";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, organizationId: string) {
        // Initialize the LinkedIn client with the provided access token
        const client = new LinkedInClient(linkedinResource.accessToken);

        // Fetch the organization administrators from LinkedIn
        const administrators = await client.organization.getAdministrators(organizationId);

        // Return the list of administrators
        return administrators;
    }
  id: |-
    synthetic_get-organization-administrators
  instructions: |-
    Gets the administator members of an organization, given the organization urn in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { networks } from "npm:@meraki/dashboard-api";

    type CiscoMeraki = {
        apiKey: string;
        organizationId: string;
    }

    export async function main(ciscoMerakiResource: CiscoMeraki, networkId: string) {
        const meraki = networks(ciscoMerakiResource.apiKey);
        const network = await meraki.getNetwork(ciscoMerakiResource.organizationId, networkId);
        return network;
    }
  good: |-
    import { Meraki } from "npm:@meraki/dashboard";

    type CiscoMeraki = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(ciscoMerakiResource: CiscoMeraki, networkId: string) {
        const meraki = new Meraki(ciscoMerakiResource.apiKey, ciscoMerakiResource.baseUrl);
        const network = await meraki.networks.getNetwork(networkId);

        return network;
    }
  id: |-
    synthetic_get-network
  instructions: |-
    Gets a network. in cisco meraki
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CiscoMeraki
  resource_type_def: |-
    type CiscoMeraki = {
        apiKey: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bannerbear } from 'npm:@bannerbear/bannerbear';

    type Bannerbear = {
        apiKey: string;
    }

    export async function main(bannerbearResource: Bannerbear, templateId: string, modifications: Array<{name: string, text: string}>, webhookUrl?: string) {
        const bb = new Bannerbear(bannerbearResource.apiKey);

        const response = await bb.createVideo(templateId, modifications, webhookUrl);

        return response;
    }
  good: |-
    import { Bannerbear as BannerbearAPI } from 'npm:@bannerbear/api';

    type Bannerbear = {
        apiKey: string;
    }

    export async function main(bannerbearResource: Bannerbear, templateId: string, modifications: Array<{ name: string; text: string }>, webhookUrl?: string) {
        const bb = new BannerbearAPI(bannerbearResource.apiKey);

        const response = await bb.createVideo(templateId, modifications, webhookUrl);

        return response;
    }
  id: |-
    synthetic_create-video
  instructions: |-
    Creates a Video. in bannerbear
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bannerbear
  resource_type_def: |-
    type Bannerbear = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(
        googleDialogflowResource: GoogleDialogflow,
        sessionId: string,
        entityTypeName: string,
        entityValues: string[]
    ) {
        // Initialize the Dialogflow sessions client with credentials
        const sessionClient = new SessionsClient({
            credentials: {
                client_email: googleDialogflowResource.clientEmail,
                private_key: googleDialogflowResource.privateKey,
            },
            projectId: googleDialogflowResource.projectId,
        });

        // Define the session path
        const sessionPath = sessionClient.projectAgentSessionPath(
            googleDialogflowResource.projectId,
            sessionId
        );

        // Define the entity type path
        const entityTypePath = sessionClient.projectAgentEntityTypePath(
            googleDialogflowResource.projectId,
            entityTypeName
        );

        // Prepare the request for deleting entities
        const request = {
            parent: entityTypePath,
            entityValues: entityValues,
        };

        // Call the Dialogflow API to delete entities
        const result = await sessionClient.deleteEntities(request);

        // Return the result of the deletion
        return result;
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(dialogflowResource: GoogleDialogflow, entityTypeName: string, entityValues: string[]) {
        const client = new SessionsClient({
            credentials: {
                client_email: dialogflowResource.clientEmail,
                private_key: dialogflowResource.privateKey,
            },
            projectId: dialogflowResource.projectId,
        });

        const formattedParent = client.entityTypePath(dialogflowResource.projectId, '-', entityTypeName);

        const requests = entityValues.map(entityValue => ({
            parent: formattedParent,
            entity: {
                value: entityValue,
            },
        }));

        try {
            const deletionResults = await Promise.all(
                requests.map(request => client.deleteEntity(request))
            );
            return deletionResults;
        } catch (error) {
            console.error("Failed to delete entities:", error);
            throw error;
        }
    }
  id: |-
    synthetic_delete-entities
  instructions: |-
    Batch delete entities, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, stopLoss: number, takeProfit: number, positionIdx: number) {
        const { apiKey, apiSecret, endpoint } = bybitResource;

        const params = {
            api_key: apiKey,
            symbol: symbol,
            stop_loss: stopLoss.toString(),
            take_profit: takeProfit.toString(),
            position_idx: positionIdx.toString(),
            timestamp: Date.now().toString(),
        };

        const query = Object.keys(params)
            .map(key => `${key}=${encodeURIComponent(params[key])}`)
            .join('&');

        const signature = createHmac('sha256', apiSecret)
            .update(query)
            .digest('hex');

        const url = `${endpoint}/v2/private/position/trading-stop`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Request-Signature': signature,
            },
            body: query,
        });

        const result = await response.json();

        return result;
    }
  good: |-
    import { hmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, mode: 'Full' | 'Partial') {
        const timestamp = new Date().getTime();
        const params = {
            api_key: bybitResource.apiKey,
            timestamp: timestamp.toString(),
            recv_window: '5000',
            mode: mode
        };

        const query = Object.keys(params)
            .map(key => `${key}=${params[key]}`)
            .join('&');

        const signature = hmac('sha256', bybitResource.apiSecret, query).digest('hex');

        const response = await fetch(`${bybitResource.endpoint}/v2/private/position/switch-mode`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Request-Signature': signature
            },
            body: query
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_linear-position-tpsl-switch-mode
  instructions: |-
    Switch mode between Full or Partial.  in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to query the IP address

    class ip2location(TypedDict):
        api_key: str
        base_url: str

    def main(ip2location_resource: ip2location, ip_address: str) -> dict:
        url = f"{ip2location_resource['base_url']}/ip_location_api?api_key={ip2location_resource['api_key']}&ip={ip_address}"
        response = requests.get(url)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is needed for API call

    class ip2location(TypedDict):
        api_key: str

    def main(ip2location_resource: ip2location, ip_address: str) -> dict:
        base_url = "https://api.ip2location.com/v2/"
        params = {
            'key': ip2location_resource['api_key'],
            'ip': ip_address,
            'format': 'json'
        }
        response = requests.get(base_url, params=params)
        return response.json()
  id: |-
    synthetic_query-ip-info
  instructions: |-
    Query IP address using IP2Location API for how to use this API. in ip2location
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ip2location
  resource_type_def: |-
    class ip2location(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks/models";

    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, searchField: string, searchValue: string) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(tableName);
        const query = await table.selectRecordsAsync();
        const records = query.records.filter(record => record.getCellValueAsString(searchField) === searchValue);

        return records.map(record => ({
            id: record.id,
            fields: record.fields
        }));
    }
  good: |-
    import { Base } from "npm:@airtable/blocks/models";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
        tableName: string;
    }

    export async function main(airtableResource: AirtableOauth, searchField: string, searchValue: string) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(airtableResource.tableName);
        const query = await table.select({ filterByFormula: `{${searchField}} = "${searchValue}"` }).firstPage();

        const records = query.map(record => ({
            id: record.id,
            fields: record.fields
        }));

        return records;
    }
  id: |-
    synthetic_search-records
  instructions: |-
    Searches for a record by field value. Search Field must accept string values in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the cloudflare_api_key integration
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str

    def main(cloudflare_resource: cloudflare_api_key, key: str, value: str) -> dict:
        # Assuming the existence of a Cloudflare library that can handle API requests
        import CloudflareAPI as cfapi

        # Create a new key/value pair using the Cloudflare API
        result = cfapi.create_key_value_pair(api_key=cloudflare_resource['api_key'],
                                             email=cloudflare_resource['email'],
                                             key=key,
                                             value=value)
        return result
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is needed for HTTP requests to Cloudflare API

    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str
        account_id: str

    def main(cloudflare_resource: cloudflare_api_key, namespace_id: str, key: str, value: str) -> dict:
        base_url = "https://api.cloudflare.com/client/v4"
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json",
        }

        url = f"{base_url}/accounts/{cloudflare_resource['account_id']}/storage/kv/namespaces/{namespace_id}/values/{key}"
        response = requests.put(url, headers=headers, data=value)

        return response.json()
  id: |-
    synthetic_create-key-value-pairs
  instructions: |-
    Create new Key/Value pairs in a Namespace in cloudflare api key
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudflare_api_key
  resource_type_def: |-
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { BingX } from "npm:@bingxio/bingx-api";

    type Bingx = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for Bingx integration
    }

    export async function main(bingxResource: Bingx, symbol: string) {
        // Initialize the Bingx client with the provided credentials
        const bingxClient = new BingX(bingxResource.apiKey, bingxResource.apiSecret);

        // Fetch the current funding rate for the specified symbol
        const fundingRate = await bingxClient.getFundingRate(symbol);

        // Return the result
        return fundingRate;
    }
  good: |-
    import { Bingx as BingxClient } from "npm:@bingx/sdk"; // Renamed to avoid conflict with the resource type

    type Bingx = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for authentication with BingX
    }

    export async function main(bingxResource: Bingx, symbol: string) {
        const bingxClient = new BingxClient(bingxResource.apiKey, bingxResource.apiSecret);
        const fundingRate = await bingxClient.getLatestFundingRate(symbol);
        return fundingRate;
    }
  id: |-
    synthetic_market-get-latest-funding
  instructions: |-
    Current Funding Rate. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for authentication with BingX
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Magnetic = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(magneticResource: Magnetic, taskId: string, hoursSpent: number, notes: string) {
        const url = `${magneticResource.apiUrl}/tasks/${taskId}/log_time`;
        const authHeader = `Basic ${encode(`${magneticResource.apiKey}:`)}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                time: hoursSpent,
                notes: notes
            })
        });

        if (!response.ok) {
            throw new Error(`Error logging time: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Magnetic = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(magneticResource: Magnetic, taskId: string, hours: number, note: string) {
        const url = `${magneticResource.apiUrl}/api/v1/tasks/${taskId}/time_entries`;
        const authHeader = `Basic ${encode(`${magneticResource.apiKey}:`)}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                time_entry: {
                    hours: hours,
                    note: note,
                }
            }),
        });

        if (!response.ok) {
            throw new Error(`Error logging time: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_log-time-on-task
  instructions: |-
    Log time on an existing task in magnetic
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Magnetic
  resource_type_def: |-
    type Magnetic = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import ably  # Assuming 'ably' is the Python package for the Ably Realtime service

    # Rename the imported 'ably' module if it conflicts with the resource type name
    import ably as ably_sdk

    class ably(TypedDict):
        api_key: str

    def main(ably_resource: ably, channel_name: str, message_name: str, message_data: str):
        ably_client = ably_sdk.AblyRest(ably_resource['api_key'])
        channel = ably_client.channels.get(channel_name)
        result = channel.publish(message_name, message_data)
        return result
  good: |-
    from typing import TypedDict

    class ably(TypedDict):
        api_key: str

    def main(ably_resource: ably, channel_name: str, message: str):
        from ably import AblyRest as AblyClient

        client = AblyClient(ably_resource['api_key'])

        channel = client.channels.get(channel_name)

        result = channel.publish('message', message)

        return result
  id: |-
    synthetic_publish-message
  instructions: |-
    Publish a message in a channel in ably
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ably
  resource_type_def: |-
    class ably(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { HttpHeaders } from "npm:@angular/common/http";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, teamId: string): Promise<any> {
        const url = `https://api.clickup.com/api/v2/team/${teamId}/list`;

        const headers = new HttpHeaders({
            'Authorization': clickupResource.apiKey,
            'Content-Type': 'application/json'
        });

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: headers
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching ClickUp lists:', error);
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@clickup/client"; // Importing Clickup client from npm

    // Define the Clickup resource type with properties needed for authentication
    type Clickup = {
        accessToken: string;
    }

    export async function main(clickupResource: Clickup, teamId: string) {
        // Initialize the Clickup client with the access token
        const clickupClient = new Client(clickupResource.accessToken);

        // Fetch the lists for the specified team
        const response = await clickupClient.getLists(teamId);

        // Return the result
        return response;
    }
  id: |-
    synthetic_get-lists
  instructions: |-
    Get a list of lists. See the docs in **Lists / Get Lists** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'devrev' integration
    class devrev(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a task in the 'devrev' integration
    def main(devrev_resource: devrev, task_title: str, task_description: str, assignee_id: str, due_date: str):
        # Assuming there is a library to interact with the 'devrev' API
        from devrev_api import create_task as devrev_create_task

        # Use the credentials from the resource to authenticate with the 'devrev' API
        auth_credentials = {
            'api_key': devrev_resource['api_key'],
            'api_secret': devrev_resource['api_secret']
        }

        # Call the function to create a task with the provided parameters
        result = devrev_create_task(
            title=task_title,
            description=task_description,
            assignee_id=assignee_id,
            due_date=due_date,
            credentials=auth_credentials
        )

        # Return the result of the task creation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the devrev integration
    class devrev(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a new task in DevRev
    def main(devrev_resource: devrev, task_title: str, task_description: str, assignee_id: str = None, due_date: str = None):
        # Import the necessary library for making HTTP requests
        import requests

        # Define the endpoint for creating a new task in DevRev
        create_task_endpoint = "https://api.devrev.ai/task"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {devrev_resource['api_key']}",
            "X-Api-Secret": devrev_resource['api_secret'],
            "Content-Type": "application/json"
        }

        # Prepare the payload with the task details
        payload = {
            "title": task_title,
            "description": task_description,
            "assignee_id": assignee_id,
            "due_date": due_date
        }

        # Make the POST request to create a new task
        response = requests.post(create_task_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the created task details
            return response.json()
        else:
            # Return an error message if something went wrong
            return {"error": response.text}

    # Note: The function is not called here, it is just defined and ready to be exported.
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a new task in DevRev in devrev
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    devrev
  resource_type_def: |-
    class devrev(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Centralstationcrm = {
        apiKey: string;
        accountId: string;
    }

    export async function main(
        centralstationcrmResource: Centralstationcrm,
        dealTitle: string,
        dealValue: number,
        contactId: string,
        probability: number,
        closingDate: string
    ) {
        const dealId = uuidv4(); // Generate a unique identifier for the deal
        const apiUrl = `https://${centralstationcrmResource.accountId}.centralstationcrm.net/deals`;

        const dealData = {
            id: dealId,
            title: dealTitle,
            value: dealValue,
            contact_id: contactId,
            probability: probability,
            closing_date: closingDate
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${centralstationcrmResource.apiKey}`
            },
            body: JSON.stringify(dealData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Centralstationcrm = {
        apiKey: string,
        accountId: string
    }

    export async function main(centralstationcrmResource: Centralstationcrm, dealTitle: string, dealValue: number, contactId?: string) {
        const apiUrl = `https://${centralstationcrmResource.accountId}.centralstationcrm.net/deals.json`;
        const authHeader = `Basic ${encode(centralstationcrmResource.apiKey + ':x')}`;

        const dealData = {
            deal: {
                title: dealTitle,
                value: dealValue,
                contact_id: contactId
            }
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(dealData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-deal
  instructions: |-
    Creates a new deal in CentralStationCRM in centralstationcrm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Centralstationcrm
  resource_type_def: |-
    type Centralstationcrm = {
        apiKey: string;
        accountId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { create as createSSHKey } from "npm:@digitalocean/client";

    type DigitalOcean = {
        accessToken: string;
    }

    export async function main(digitalOceanResource: DigitalOcean, sshKeyName: string, publicKey: string) {
        const client = createSSHKey({
            token: digitalOceanResource.accessToken,
        });

        const response = await client.sshKeys.create({
            name: sshKeyName,
            public_key: publicKey,
        });

        return response;
    }
  good: |-
    // Import necessary libraries
    import { createClient } from "npm:@digitalocean/client";

    type DigitalOcean = {
        accessToken: string;
    }

    export async function main(digitalOceanResource: DigitalOcean, sshKey: string, keyName: string) {
        // Initialize the DigitalOcean client with the provided access token
        const client = createClient(digitalOceanResource.accessToken);

        // Add the SSH key to the DigitalOcean account
        const response = await client.account.createSshKey({
            name: keyName,
            public_key: sshKey
        });

        // Return the result
        return response;
    }
  id: |-
    synthetic_add-ssh-key
  instructions: |-
    Adds a new SSH to your account in digital ocean
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DigitalOcean
  resource_type_def: |-
    type DigitalOcean = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Browserless as BrowserlessClient } from "npm:@browserless/node";

    type Browserless = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: Browserless, urls: string[]) {
        const browserless = new BrowserlessClient(browserlessResource.apiKey, { endpoint: browserlessResource.endpoint });

        const results = [];
        for (const url of urls) {
            const pageContent = await browserless.screenshot(url, { gotoOptions: { waitUntil: 'networkidle2' } });
            results.push({
                url,
                screenshot: pageContent
            });
        }

        return results;
    }
  good: |-
    // Importing necessary libraries
    import { Browserless } from 'npm:@browserless/node';

    type BrowserlessResource = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: BrowserlessResource, urls: string[]) {
        const browserless = new Browserless(browserlessResource.apiKey, { endpoint: browserlessResource.endpoint });

        const pageContents = await Promise.all(urls.map(async (url) => {
            const page = await browserless.page();
            await page.goto(url);
            const content = await page.content();
            await page.close();
            return { url, content };
        }));

        return pageContents;
    }
  id: |-
    synthetic_scrape-url-list
  instructions: |-
    Scrape content from a list of pages. in browserless
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Browserless
  resource_type_def: |-
    type Browserless = {
        apiKey: string,
        endpoint: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MoneybirdContact, MoneybirdSalesInvoice } from "npm:@moneybird/types";
    import { createSalesInvoice } from "npm:@moneybird/api";

    type Moneybird = {
        administrationId: string;
        accessToken: string;
    }

    export async function main(
        moneybirdResource: Moneybird,
        contact: MoneybirdContact,
        invoiceDetails: MoneybirdSalesInvoice
    ) {
        const { administrationId, accessToken } = moneybirdResource;

        const response = await createSalesInvoice(administrationId, accessToken, contact, invoiceDetails);

        return response;
    }
  good: |-
    import { Moneybird as MoneybirdAPI } from "npm:@moneybird-js/api"; // Renamed imported Moneybird to avoid conflict

    type Moneybird = {
        administrationId: string;
        accessToken: string;
    }

    export async function main(
        moneybird: Moneybird,
        contactId: string,
        workflowId: string,
        details: Array<{
            description: string;
            quantity: number;
            price: number;
        }>
    ) {
        const moneybirdClient = new MoneybirdAPI({
            administrationId: moneybird.administrationId,
            accessToken: moneybird.accessToken,
        });

        const quoteData = {
            contact_id: contactId,
            workflow_id: workflowId,
            details: details.map(detail => ({
                description: detail.description,
                quantity: detail.quantity,
                price: detail.price,
            })),
        };

        try {
            const quote = await moneybirdClient.salesInvoices.create(quoteData);
            return quote;
        } catch (error) {
            console.error("Error creating quote in Moneybird:", error);
            throw error;
        }
    }
  id: |-
    synthetic_create-quote
  instructions: |-
    Create a new quote in moneybird
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Moneybird
  resource_type_def: |-
    type Moneybird = {
        administrationId: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HttpClient as AngularHttpClient } from "@angular/common/http";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, taskId: string) {
        const httpClient = new AngularHttpClient();
        const url = `https://api.clickup.com/api/v2/task/${taskId}`;

        const headers = {
            'Authorization': clickupResource.apiKey,
            'Content-Type': 'application/json'
        };

        try {
            const response = await httpClient.delete(url, { headers: headers });
            return response;
        } catch (error) {
            console.error('Error deleting the task:', error);
            throw error;
        }
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:base-64";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, commentId: string) {
        const url = `https://api.clickup.com/api/v2/comment/${commentId}`;
        const headers = {
            "Authorization": clickupResource.apiKey,
            "Content-Type": "application/json"
        };

        const response = await fetch(url, {
            method: 'DELETE',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Error deleting comment: ${response.status} ${response.statusText}`);
        }

        return `Comment with ID ${commentId} deleted successfully.`;
    }
  id: |-
    synthetic_delete-comment
  instructions: |-
    Deletes a comment. See the docs in **Comments / Deleet Comment** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { lookup as ip2whoisLookup } from "npm:ip2whois";

    type Ip2whois = {
        apiKey: string;
    }

    export async function main(ip2whoisResource: Ip2whois, domain: string) {
        const options = {
            apiKey: ip2whoisResource.apiKey,
            domain: domain
        };

        const result = await ip2whoisLookup(options);
        return result;
    }
  good: |-
    import { WHOIS } from "npm:ip2whois";

    type Ip2whois = {
        apiKey: string;
    }

    export async function main(ip2whoisResource: Ip2whois, domainName: string) {
        const whois = new WHOIS(ip2whoisResource.apiKey);
        const result = await whois.lookup(domainName);
        return result;
    }
  id: |-
    synthetic_query-domain-info
  instructions: |-
    Helps users to obtain domain information, WHOIS record, by using a domain name. Please refer to the for the details of the fields returned. in ip2whois
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ip2whois
  resource_type_def: |-
    type Ip2whois = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BrexStaging as BrexStagingClient } from 'npm:@brex/brex-api'; // Rename the imported method to avoid conflict

    type BrexStaging = {
        apiKey: string
    }

    export async function main(brexStaging: BrexStaging, accountId: string, startDate: string, endDate: string) {
        const brexClient = new BrexStagingClient(brexStaging.apiKey);

        const transactions = await brexClient.getTransactions({
            accountId: accountId,
            startDate: startDate,
            endDate: endDate
        });

        return transactions;
    }
  good: |-
    // Import any libraries you need here
    import { BrexStaging } from 'npm:@brex/api'; // Hypothetical npm package for Brex API

    type BrexStagingResource = {
        apiKey: string;
        accountId: string;
    }

    export async function main(brexStagingResource: BrexStagingResource, startDate: string, endDate: string) {
        // Initialize the Brex API client with the provided API key
        const brexClient = new BrexStaging({ apiKey: brexStagingResource.apiKey });

        // Fetch the transactions for the specified cash account within the date range
        const transactions = await brexClient.getTransactions({
            accountId: brexStagingResource.accountId,
            startDate: startDate,
            endDate: endDate
        });

        // Return the list of transactions
        return transactions;
    }
  id: |-
    synthetic_list-transactions-for-selected-cash-account
  instructions: |-
    Lists all transactions for the specified cash account. in brex staging
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BrexStaging
  resource_type_def: |-
    type BrexStaging = {
        apiKey: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ChartMogul } from "npm:chartmogul-node";

    type ChartmogulResource = {
        accountToken: string;
        secretKey: string;
    }

    export async function main(chartmogulResource: ChartmogulResource, startDate: string, endDate: string) {
        const config = new ChartMogul.Config(chartmogulResource.accountToken, chartmogulResource.secretKey);

        try {
            const metrics = await ChartMogul.Metrics.all(config, {
                start_date: startDate,
                end_date: endDate
            });

            return metrics;
        } catch (error) {
            // Handle error appropriately; rethrow, return a default value, etc.
            throw error;
        }
    }
  good: |-
    import { Config, ChartMogul as ChartMogulClient } from "npm:@chartmogul/node";

    type Chartmogul = {
        accountToken: string;
        secretKey: string;
    }

    export async function main(chartmogulResource: Chartmogul, startDate: string, endDate: string) {
        const config = new Config(chartmogulResource.accountToken, chartmogulResource.secretKey);

        try {
            const metrics = await ChartMogulClient.Metrics.all(config, {
                start_date: startDate,
                end_date: endDate
            });

            return metrics;
        } catch (error) {
            console.error('Error retrieving key metrics:', error);
            throw error;
        }
    }
  id: |-
    synthetic_retrieve-all-key-metrics
  instructions: |-
    Retrieves all key metrics, for the specified time period in chartmogul
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Chartmogul
  resource_type_def: |-
    type Chartmogul = {
        accountToken: string;
        secretKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the openai integration
    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, directory: str) -> List[str]:
        import openai as openai_sdk

        # Configure the OpenAI SDK with the provided API key
        openai_sdk.api_key = openai_resource['api_key']

        # Assuming the integration provides a method to list files in a directory
        # This is a placeholder for the actual method provided by the OpenAI SDK
        # Replace 'list_files_in_directory' with the actual method name
        file_list = openai_sdk.list_files_in_directory(directory)

        return file_list
  good: |-
    from typing import TypedDict, List
    import openai as openai_client

    class openai(TypedDict):
        api_key: str
        organization: str

    def main(openai_resource: openai, file_type: str = 'all') -> List[str]:
        openai_client.api_key = openai_resource['api_key']
        openai_client.Organization = openai_resource['organization']

        files_list = []
        response = openai_client.File.list()

        for file in response['data']:
            if file_type == 'all' or file['type'] == file_type:
                files_list.append(file['id'])

        return files_list
  id: |-
    synthetic_list-files
  instructions: |-
    Returns a list of files that belong to the user's organization in openai
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str  # OAuth2 Access Token
        board_id: str      # ID of the Miro board

    # Define the main function for updating a shape in Miro
    def main(miro_resource: miro_custom_app, shape_id: str, new_text: str, new_style: Dict[str, Any]):
        # Assuming the existence of a Miro API client library
        from miro import MiroClient  # If this conflicts with an imported method, rename as needed

        # Initialize the Miro API client with the access token
        miro_client = MiroClient(miro_resource['access_token'])

        # Update the shape with the new text and style
        updated_shape = miro_client.update_shape(board_id=miro_resource['board_id'], shape_id=shape_id, text=new_text, style=new_style)

        # Return the updated shape object
        return updated_shape
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Miro API

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str
        board_id: str

    # Define the main function with the resource type and additional parameters
    def main(miro_resource: miro_custom_app, shape_id: str, new_text: str, new_style: dict):
        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {miro_resource['access_token']}",
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }

        # Construct the URL for updating the shape
        url = f"https://api.miro.com/v1/boards/{miro_resource['board_id']}/widgets/{shape_id}"

        # Construct the payload with the new content and style
        payload = {
            'data': {
                'text': new_text,
                'style': new_style
            }
        }

        # Make the HTTP request to update the shape
        response = requests.patch(url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated shape data
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # Note: The function is not called here, it is just defined and exported.
  id: |-
    synthetic_update-shape
  instructions: |-
    Updates content of an existing shape on a Miro board. in miro custom app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    miro_custom_app
  resource_type_def: |-
    class miro_custom_app(TypedDict):
        access_token: str  # OAuth2 Access Token
        board_id: str      # ID of the Miro board
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { IP2Location as IP2LocationService } from "npm:ip2location-nodejs";

    type Ip2locationIo = {
        apiKey: string
    }

    export async function main(ip2locationIoResource: Ip2locationIo, ipAddress: string) {
        const ip2location = new IP2LocationService();
        ip2location.open(ip2locationIoResource.apiKey);

        const result = await ip2location.IPQuery(ipAddress);

        return result;
    }
  good: |-
    // Importing necessary libraries
    import { IP2Location } from "npm:ip2location-nodejs";

    type Ip2locationIo = {
        apiKey: string;
    }

    export async function main(ip2locationIoResource: Ip2locationIo, ipAddress: string) {
        // Initialize the IP2Location instance with the API key
        const ip2location = new IP2Location();
        ip2location.open(ip2locationIoResource.apiKey);

        // Retrieve geolocation data for the given IP address
        const geolocationData = await ip2location.IPQuery(ipAddress);

        // Check for any errors in the response
        if (geolocationData.status !== 'OK') {
            throw new Error(`Error retrieving geolocation data: ${geolocationData.status}`);
        }

        // Return the geolocation data
        return geolocationData;
    }
  id: |-
    synthetic_lookup-ip-address
  instructions: |-
    Retrieve geolocation data about an IP Address in ip2location io
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ip2locationIo
  resource_type_def: |-
    type Ip2locationIo = {
        apiKey: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for making HTTP requests
    import { encode } from "npm:@std/encoding/base64";

    type D7Networks = {
        api_key: string;
        api_secret: string;
    }

    export async function main(d7NetworksResource: D7Networks, to: string, message: string) {
        const url = 'https://rest-api.d7networks.com/secure/send';
        const authHeader = `Basic ${encode(`${d7NetworksResource.api_key}:${d7NetworksResource.api_secret}`)}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                to: to,
                content: message,
                from: 'D7Net'
            })
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { SMS } from "npm:d7networks";

    type D7Networks = {
        apiKey: string,
        apiSecret: string
    }

    export async function main(d7NetworksResource: D7Networks, to: string, from: string, message: string) {
        const sms = new SMS(d7NetworksResource.apiKey, d7NetworksResource.apiSecret);

        const response = await sms.send({
            to,
            from,
            message
        });

        return response;
    }
  id: |-
    synthetic_send-sms
  instructions: |-
    Sending sms via D7 networks! in d7 networks
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    D7Networks
  resource_type_def: |-
    type D7Networks = {
        apiKey: string,
        apiSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { request } from "npm:@octokit/request";

    type Bitbucket = {
        username: string;
        appPassword: string;
    }

    export async function main(bitbucketResource: Bitbucket, workspace: string, repoSlug: string, issueId: number, commentBody: string) {
        const { username, appPassword } = bitbucketResource;
        const authString = Buffer.from(`${username}:${appPassword}`).toString('base64');

        const response = await request('POST /2.0/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments', {
            headers: {
                Authorization: `Basic ${authString}`,
            },
            workspace: workspace,
            repo_slug: repoSlug,
            issue_id: issueId,
            body: commentBody
        });

        return response.data;
    }
  good: |-
    import { request } from "npm:@octokit/request";

    type Bitbucket = {
        username: string;
        appPassword: string;
        repoSlug: string;
        workspace: string;
    }

    export async function main(bitbucketResource: Bitbucket, issueId: number, commentBody: string) {
        const { username, appPassword, repoSlug, workspace } = bitbucketResource;
        const authString = Buffer.from(`${username}:${appPassword}`).toString('base64');

        const response = await request('POST /2.0/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments', {
            headers: {
                Authorization: `Basic ${authString}`,
            },
            workspace: workspace,
            repo_slug: repoSlug,
            issue_id: issueId,
            body: commentBody
        });

        return response.data;
    }
  id: |-
    synthetic_create-issue-comment
  instructions: |-
    Creates a new issue comment in bitbucket
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bitbucket
  resource_type_def: |-
    type Bitbucket = {
        username: string;
        appPassword: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string) {
        const octokit = new Octokit({ auth: githubResource.accessToken });
        const response = await octokit.repos.listReleases({
            owner,
            repo,
        });

        return response.data;
    }
  good: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string) {
        const octokit = new Octokit({ auth: githubResource.accessToken });

        const releases = await octokit.repos.listReleases({
            owner,
            repo,
        });

        return releases.data;
    }
  id: |-
    synthetic_list-releases
  instructions: |-
    List releases for a repository in github
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        baseUrl: string;
        username: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueKey: string) {
        const auth = Buffer.from(`${jiraResource.username}:${jiraResource.apiToken}`).toString('base64');
        const response = await request('GET /rest/api/3/issue/{issueIdOrKey}/comment', {
            headers: {
                Authorization: `Basic ${auth}`,
                'Accept': 'application/json'
            },
            baseUrl: jiraResource.baseUrl,
            issueIdOrKey: issueKey
        });

        return response.data;
    }
  good: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        baseUrl: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueKey: string) {
        const { baseUrl, email, apiToken } = jiraResource;
        const auth = Buffer.from(`${email}:${apiToken}`).toString('base64');

        const response = await request('GET /rest/api/3/issue/{issueKey}/comment', {
            headers: {
                Authorization: `Basic ${auth}`,
                'Accept': 'application/json'
            },
            baseUrl: baseUrl,
            issueKey: issueKey
        });

        return response.data;
    }
  id: |-
    synthetic_list-issue-comments
  instructions: |-
    Lists all comments for an issue, in jira
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jira
  resource_type_def: |-
    type Jira = {
        baseUrl: string;
        email: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type CroveApp = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(croveAppResource: CroveApp, eventName: string, maxAttendees: number) {
        const invitationEndpoint = `${croveAppResource.baseUrl}/create-invitation`;
        const body = {
            eventName: eventName,
            maxAttendees: maxAttendees,
            invitationId: uuidv4() // Generate a unique identifier for the invitation
        };

        const response = await fetch(invitationEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${croveAppResource.apiKey}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import necessary libraries
    import { v4 as uuidv4 } from "npm:uuid";

    type CroveApp = {
        apiKey: string;
        documentId: string;
    }

    export async function main(croveAppResource: CroveApp, recipientEmail: string, documentName: string, redirectUrl?: string) {
        const invitationEndpoint = `https://api.crove.app/v1/documents/${croveAppResource.documentId}/invitations`;
        const body = {
            recipientEmail,
            documentName,
            redirectUrl,
            idempotencyKey: uuidv4() // Generate a unique idempotency key for the invitation
        };

        const response = await fetch(invitationEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${croveAppResource.apiKey}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`Failed to create invitation link: ${response.statusText}`);
        }

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_create-invitation-link
  instructions: |-
    Create invitation link to fill or sign the document.  in crove app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CroveApp
  resource_type_def: |-
    type CroveApp = {
        apiKey: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the 'dropcontact' integration
    class dropcontact(TypedDict):
        api_key: str

    def main(dropcontact_resource: dropcontact, email: str) -> Dict[str, Any]:
        # Endpoint for the Dropcontact enrichment request
        enrichment_endpoint = "https://api.dropcontact.io/v2/enrich"

        # Prepare the payload with the email to be enriched
        payload = {
            "email": email,
        }

        # Prepare the headers with the API key
        headers = {
            "Content-Type": "application/json",
            "X-Access-Token": dropcontact_resource['api_key'],
        }

        # Make the POST request to the Dropcontact API
        response = requests.post(enrichment_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response from the API
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": f"Request failed with status code {response.status_code}"}
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the dropcontact integration
    class dropcontact(TypedDict):
        api_key: str

    # Define the function signature with the resource type and any additional parameters
    def main(dropcontact_resource: dropcontact, contacts: List[Dict[str, str]]) -> List[Dict[str, str]]:
        # Dropcontact API endpoint for enriching contacts
        dropcontact_api_url = "https://api.dropcontact.io/v2"

        # Prepare the headers with the API key
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {dropcontact_resource['api_key']}"
        }

        # Prepare the payload with the contacts to be enriched
        payload = {
            "request": contacts
        }

        # Make the API request to Dropcontact to enrich the contacts
        response = requests.post(dropcontact_api_url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response and return the enriched contacts
            enriched_contacts = response.json()
            return enriched_contacts.get('data', [])
        else:
            # Handle the error case
            response.raise_for_status()

    # Example usage:
    # enriched_contacts = main(dropcontact_resource={'api_key': 'your_api_key'}, contacts=[{'email': 'contact@example.com'}])
    # print(enriched_contacts)
  id: |-
    synthetic_get-enrichment-request
  instructions: |-
    Retrieve the enriched contacts of a request in Dropcontact in dropcontact
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dropcontact
  resource_type_def: |-
    class dropcontact(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { purgeCache } from "npm:@cloudflare/purge-cache";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        zoneId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, purgeEverything: boolean) {
        const purgeResult = await purgeCache(cloudflareResource.apiKey, cloudflareResource.email, cloudflareResource.zoneId, purgeEverything);
        return purgeResult;
    }
  good: |-
    import { purgeCache } from "npm:@cloudflare/wrangler";

    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        zoneId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey) {
        const url = `https://api.cloudflare.com/client/v4/zones/${cloudflareResource.zoneId}/purge_cache`;
        const body = JSON.stringify({ purge_everything: true });

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'X-Auth-Email': cloudflareResource.email,
                'X-Auth-Key': cloudflareResource.apiKey,
                'Content-Type': 'application/json',
            },
            body: body
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_purge-all-files
  instructions: |-
    Remove ALL files from Cloudflare's cache. in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        apiKey: string;
        email: string;
        zoneId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the brex_staging integration
    class brex_staging(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for inviting a new user as an employee in brex staging
    def main(brex_staging_resource: brex_staging, email: str, first_name: str, last_name: str, phone_number: str, job_title: str) -> dict:
        # Assuming the use of requests library for HTTP requests
        import requests

        # Define the endpoint for inviting a user
        invite_endpoint = "https://api.brex.io/staging/employees/invite"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {brex_staging_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the user details
        payload = {
            "email": email,
            "first_name": first_name,
            "last_name": last_name,
            "phone_number": phone_number,
            "job_title": job_title
        }

        # Send the POST request to invite the user
        response = requests.post(invite_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response data if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    from typing import TypedDict

    # Define the resource type for the brex_staging integration
    class brex_staging(TypedDict):
        api_key: str
        api_secret: str
        endpoint_url: str

    # Define the main function for inviting a user to the brex_staging platform
    def main(brex_staging_resource: brex_staging, email: str, first_name: str, last_name: str, role: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API URL for inviting a user
        invite_url = f"{brex_staging_resource['endpoint_url']}/invite_user"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Bearer {brex_staging_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'email': email,
            'first_name': first_name,
            'last_name': last_name,
            'role': role
        }

        # Make the API request to invite the user
        response = requests.post(invite_url, headers=headers, json=payload)

        # Check if the request was successful and return the result
        if response.status_code == 200:
            return {'success': True, 'data': response.json()}
        else:
            return {'success': False, 'error': response.text}

    # Note: The function is not called here, it is only defined and ready to be used with the required parameters.
  id: |-
    synthetic_invite-user
  instructions: |-
    Invites a new user as an employee. in brex staging
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    brex_staging
  resource_type_def: |-
    class brex_staging(TypedDict):
        api_key: str
        api_secret: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        domain: str
        board_id: int

    # Define the main function for the kanban_tool integration
    def main(kanban_tool_resource: kanban_tool, task_id: int) -> bool:
        # Import the requests library here to avoid naming conflicts
        import requests

        # Construct the API endpoint for soft deleting a task
        api_endpoint = f"https://{kanban_tool_resource['domain']}/kanban/api/v1/tasks/{task_id}/delete"

        # Prepare the headers with the API key for authentication
        headers = {
            "X-KanbanToolToken": kanban_tool_resource['api_key']
        }

        # Make the request to soft delete the task
        response = requests.post(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return True if the task was successfully soft deleted
            return True
        else:
            # Log the error message if the request failed
            print(f"Failed to soft delete the task. Status Code: {response.status_code}, Response: {response.text}")
            # Return False if the task was not successfully soft deleted
            return False

    # The complete script is ready to be used with the kanban_tool integration
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'kanban_tool' integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str

    # Main function to delete a task in the Kanban Tool
    def main(kanban_tool_resource: kanban_tool, task_id: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for deleting a task
        api_endpoint = f"https://kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "X-KanbanToolToken": kanban_tool_resource['api_key']
        }

        # Make the DELETE request to the Kanban Tool API
        response = requests.delete(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return {"success": True, "message": "Task deleted successfully."}
        else:
            return {"success": False, "message": "Failed to delete the task.", "error": response.text}
  id: |-
    synthetic_delete-task
  instructions: |-
    Soft deletes a task in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Chatwork = {
        apiToken: string;
    }

    export async function main(chatworkResource: Chatwork, members: string, name?: string) {
        const url = 'https://api.chatwork.com/v2/rooms';
        const headers = {
            'X-ChatWorkToken': chatworkResource.apiToken,
            'Content-Type': 'application/x-www-form-urlencoded'
        };
        const body = `members_admin_ids=${encode(members)}${name ? `&name=${encode(name)}` : ''}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Chatwork = {
        apiKey: string;
    }

    export async function main(chatworkResource: Chatwork, roomName: string, roomDescription?: string, membersAdminIds?: number[], membersMemberIds?: number[], membersReadonlyIds?: number[]) {
        const endpoint = 'https://api.chatwork.com/v2/rooms';
        const headers = {
            'X-ChatWorkToken': chatworkResource.apiKey
        };

        const body = new URLSearchParams();
        body.append('name', roomName);
        if (roomDescription) body.append('description', roomDescription);
        if (membersAdminIds) body.append('members_admin_ids', membersAdminIds.join(','));
        if (membersMemberIds) body.append('members_member_ids', membersMemberIds.join(','));
        if (membersReadonlyIds) body.append('members_readonly_ids', membersReadonlyIds.join(','));

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-room
  instructions: |-
    Create a new group chat in chatwork
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Chatwork
  resource_type_def: |-
    type Chatwork = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Insightly as InsightlyClient } from "npm:@types/insightly";

    type Insightly = {
        apiKey: string;
    }

    export async function main(insightlyResource: Insightly, taskName: string, taskDetails: string, dueDate: string, responsibleUserId: number, projectId?: number) {
        const insightly = new InsightlyClient(insightlyResource.apiKey);

        const task = {
            TITLE: taskName,
            DETAILS: taskDetails,
            DUE_DATE: dueDate,
            RESPONSIBLE_USER_ID: responsibleUserId,
            PROJECT_ID: projectId,
        };

        const response = await insightly.createTask(task);
        return response;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Insightly = {
        apiKey: string;
    }

    export async function main(insightlyResource: Insightly, taskName: string, taskDetails: string, dueDate: string, responsibleUserId: number, status: string) {
        const apiUrl = 'https://api.insightly.com/v3.1/Tasks';
        const authHeader = `Basic ${encode(insightlyResource.apiKey + ":")}`;

        const taskData = {
            TITLE: taskName,
            DETAILS: taskDetails,
            DUE_DATE: dueDate,
            RESPONSIBLE_USER_ID: responsibleUserId,
            STATUS: status
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(taskData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a new task in insightly
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Insightly
  resource_type_def: |-
    type Insightly = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Knorish = {
        apiKey: string;
        siteUrl: string;
    }

    export async function main(knorishResource: Knorish, courseId: string, userEmail: string, userFirstName: string, userLastName: string) {
        // Construct the API endpoint
        const endpoint = `${knorishResource.siteUrl}/api/v1/courses/${courseId}/users`;

        // Prepare the authorization header
        const authHeader = `Basic ${encode(`${knorishResource.apiKey}:`)}`;

        // Prepare the request body
        const requestBody = {
            email: userEmail,
            first_name: userFirstName,
            last_name: userLastName
        };

        // Make the API request to add the user to the course
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        // Parse the response
        const result = await response.json();

        // Return the result
        return result;
    }
  good: |-
    type Knorish = {
        apiKey: string;
    }

    export async function main(knorishResource: Knorish, courseId: string, userEmail: string, userFirstName: string, userLastName: string) {
        const addUserUrl = `https://api.knorish.com/v1/course/${courseId}/users`;

        const response = await fetch(addUserUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': knorishResource.apiKey
            },
            body: JSON.stringify({
                email: userEmail,
                firstName: userFirstName,
                lastName: userLastName
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-user-in-course
  instructions: |-
    Add a specific user to a specific course on your Knorish site in knorish
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Knorish
  resource_type_def: |-
    type Knorish = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Firmao = {
        apiKey: string,
        apiUrl: string
    }

    export async function main(firmaoResource: Firmao, companyName: string, email: string, phone: string, address: string) {
        const url = `${firmaoResource.apiUrl}/newCompanyCustomer`;
        const headers = {
            'Authorization': `Basic ${encode(firmaoResource.apiKey)}`,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            companyName,
            email,
            phone,
            address
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { Firmao as FirmaoClient } from "npm:@my/firmao-sdk"; // Renamed imported class to avoid conflict

    type Firmao = { // Renamed type to avoid conflict with imported class
        apiKey: string;
        apiUrl: string;
    }

    export async function main(firmaoResource: Firmao, customerData: { name: string; email: string; phone?: string; address?: string; }) {
        const firmaoClient = new FirmaoClient(firmaoResource.apiUrl, firmaoResource.apiKey);

        const result = await firmaoClient.createCustomer(customerData);

        return result;
    }
  id: |-
    synthetic_create-customer
  instructions: |-
    Create a new company customer in firmao
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Firmao
  resource_type_def: |-
    type Firmao = { // Renamed type to avoid conflict with imported class
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { connect } from "npm:tedious";

    type MicrosoftSqlServer = {
        server: string;
        authentication: {
            type: "default" | "ntlm" | "azure-active-directory-password" | "azure-active-directory-access-token";
            options: {
                userName: string;
                password: string;
            };
        };
        options: {
            database: string;
            encrypt: boolean;
            trustServerCertificate: boolean;
        };
    }

    export async function main(microsoftSqlServerResource: MicrosoftSqlServer, query: string) {
        const connection = connect(microsoftSqlServerResource);

        return new Promise((resolve, reject) => {
            const result: any[] = [];
            const request = new Request(query, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });

            request.on('row', (columns) => {
                const row: any = {};
                columns.forEach((column) => {
                    row[column.metadata.colName] = column.value;
                });
                result.push(row);
            });

            connection.execSql(request);
        });
    }
  good: |-
    import { connect, Request } from "npm:tedious";

    type MicrosoftSqlServer = {
        server: string;
        authentication: {
            type: "default" | "ntlm" | "azure-active-directory-password" | "azure-active-directory-access-token";
            options: {
                userName: string;
                password: string;
            };
        };
        options: {
            database: string;
            encrypt: boolean;
            trustServerCertificate: boolean;
        };
    }

    export async function main(microsoftSqlServerResource: MicrosoftSqlServer, query: string) {
        const connection = connect(microsoftSqlServerResource);

        return new Promise((resolve, reject) => {
            const result: any[] = [];
            const request = new Request(query, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });

            request.on('row', (columns) => {
                const row: any = {};
                columns.forEach((column) => {
                    row[column.metadata.colName] = column.value;
                });
                result.push(row);
            });

            connection.execSql(request);
        });
    }
  id: |-
    synthetic_execute-query
  instructions: |-
    Executes a SQL query and returns the results in microsoft sql server
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftSqlServer
  resource_type_def: |-
    type MicrosoftSqlServer = {
        server: string;
        authentication: {
            type: "default" | "ntlm" | "azure-active-directory-password" | "azure-active-directory-access-token";
            options: {
                userName: string;
                password: string;
            };
        };
        options: {
            database: string;
            encrypt: boolean;
            trustServerCertificate: boolean;
        };
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for the HTTP GET request

    class ipdata_co(TypedDict):
        api_key: str

    def main(ipdata_resource: ipdata_co, ip_address: str) -> dict:
        base_url = "https://api.ipdata.co/"
        headers = {
            "Authorization": f"Bearer {ipdata_resource['api_key']}"
        }
        response = requests.get(f"{base_url}time_zone/{ip_address}", headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls to the ipdata.co API

    class ipdata_co(TypedDict):
        api_key: str

    def main(ipdata_co_resource: ipdata_co, ip_address: str) -> dict:
        base_url = "https://api.ipdata.co/"
        headers = {
            "Authorization": f"Bearer {ipdata_co_resource['api_key']}"
        }
        response = requests.get(f"{base_url}{ip_address}/timezone", headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  id: |-
    synthetic_get-time-zone
  instructions: |-
    We provide detailed and accurate Timezone data, adjusted for DST where necessary. https://docs.ipdata.co/overview/timezone-detection in ipdata co
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ipdata_co
  resource_type_def: |-
    class ipdata_co(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, companyId: string, companyUpdates: Record<string, any>) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });
        const result = await hubspotClient.crm.companies.basicApi.update(companyId, { properties: companyUpdates });
        return result;
    }
  good: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, companyId: string, companyUpdates: Record<string, any>) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });

        try {
            const response = await hubspotClient.crm.companies.basicApi.update(companyId, { properties: companyUpdates });
            return response;
        } catch (error) {
            console.error('Error updating company in HubSpot:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-company
  instructions: |-
    Update a company in Hubspot in hubspot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the airmeet integration
    class airmeet(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating an airmeet
    def main(airmeet_resource: airmeet, event_name: str, start_time: str, end_time: str, host_email: str):
        # Assuming there's a library to interact with Airmeet API
        from airmeet_api import create_event  # hypothetical import, rename if conflicts

        # Use the airmeet_resource credentials to authenticate and create an event
        event_details = {
            'name': event_name,
            'start_time': start_time,
            'end_time': end_time,
            'host_email': host_email
        }

        # Call the hypothetical create_event function from the airmeet_api library
        result = create_event(api_key=airmeet_resource['api_key'], api_secret=airmeet_resource['api_secret'], event_details=event_details)

        # Return the result of the event creation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the Airmeet integration
    class airmeet(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the Airmeet integration
    def main(airmeet_resource: airmeet, event_title: str, event_start_time: str, event_end_time: str, event_description: str = ""):
        # Assuming there's a library to interact with Airmeet API
        from airmeet_api import create_event

        # Use the credentials from the airmeet_resource to authenticate with the Airmeet API
        authenticated_session = create_event.authenticate(airmeet_resource['api_key'], airmeet_resource['api_secret'])

        # Create the event with the provided details
        event = create_event.create(
            session=authenticated_session,
            title=event_title,
            start_time=event_start_time,
            end_time=event_end_time,
            description=event_description
        )

        # Return the created event details
        return event
  id: |-
    synthetic_create-airmeet
  instructions: |-
    Creates an airmeet in airmeet
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    airmeet
  resource_type_def: |-
    class airmeet(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'devrev' integration
    class devrev(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a comment in the 'devrev' integration
    def main(devrev_resource: devrev, issue_id: str, comment_body: str) -> dict:
        # Assuming 'requests' is needed for HTTP requests
        import requests as http_requests

        # Construct the API endpoint for creating a comment
        api_endpoint = f"https://api.devrev.ai/issues/{issue_id}/comments"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {devrev_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Define the payload for the comment creation
        payload = {
            "body": comment_body
        }

        # Make the POST request to create the comment
        response = http_requests.post(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created comment as a JSON object
        else:
            # Handle error cases appropriately
            response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code

    # Note: The function does not call itself, it's meant to be imported and used with the appropriate parameters.
  good: |-
    from typing import TypedDict, Any
    import devrev_api_client as devrev_client

    class devrev(TypedDict):
        api_key: str
        api_secret: str

    def main(devrev_resource: devrev, work_item_id: str, comment_body: str) -> Any:
        client = devrev_client.DevRevAPIClient(api_key=devrev_resource['api_key'], api_secret=devrev_resource['api_secret'])
        result = client.create_comment(work_item_id, comment_body)
        return result
  id: |-
    synthetic_create-comment
  instructions: |-
    Creates a new comment on a work item in DevRev in devrev
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    devrev
  resource_type_def: |-
    class devrev(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import dropbox as dbx_sdk  # Import the Dropbox SDK and alias it to avoid name conflict

    # Define the resource type for the Dropbox integration
    class dropbox(TypedDict):
        access_token: str  # OAuth2 access token for Dropbox API

    # Define the main function for creating a folder in Dropbox
    def main(dropbox: dropbox, folder_path: str) -> dict:
        # Initialize the Dropbox client with the access token
        dbx = dbx_sdk.Dropbox(dropbox['access_token'])

        # Create the folder at the specified path
        result = dbx.files_create_folder_v2(folder_path)

        # Return the result of the folder creation
        return result.metadata

    # Example usage:
    # result = main(dropbox={'access_token': 'YOUR_ACCESS_TOKEN'}, folder_path='/new_folder')
    # print(result)
  good: |-
    from typing import TypedDict
    import dropbox

    class dropbox_resource(TypedDict):
        access_token: str

    def main(dropbox_resource: dropbox_resource, folder_path: str) -> dict:
        dbx = dropbox.Dropbox(dropbox_resource['access_token'])
        result = dbx.files_create_folder_v2(folder_path)
        return {"metadata": result.metadata}
  id: |-
    synthetic_create-folder
  instructions: |-
    Create a folder in dropbox
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dropbox
  resource_type_def: |-
    class dropbox(TypedDict):
        access_token: str  # OAuth2 access token for Dropbox API
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the 'emailable' integration
    class emailable(TypedDict):
        api_key: str

    def main(emailable_resource: emailable, email_address: str) -> dict:
        # Construct the API endpoint with the email address to verify
        api_endpoint = f"https://api.emailable.com/v1/verify?email={email_address}&apikey={emailable_resource['api_key']}"

        # Make the API request to verify the email address
        response = requests.get(api_endpoint)

        # Return the JSON response from the API
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API interaction

    class emailable(TypedDict):
        api_key: str

    def main(emailable_resource: emailable, email_address: str) -> dict:
        api_endpoint = "https://api.emailable.com/v1/verify"
        params = {
            "email": email_address,
            "api_key": emailable_resource['api_key']
        }
        response = requests.get(api_endpoint, params=params)
        return response.json()
  id: |-
    synthetic_verify-email-address
  instructions: |-
    Verifies a single email address using Emailable in emailable
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    emailable
  resource_type_def: |-
    class emailable(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import requests
    from typing import TypedDict

    # Define the resource type for the alpaca integration
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca, order_id: str) -> dict:
        headers = {
            'APCA-API-KEY-ID': alpaca_resource['api_key'],
            'APCA-API-SECRET-KEY': alpaca_resource['api_secret']
        }
        url = f"{alpaca_resource['base_url']}/v2/orders/{order_id}"

        response = requests.delete(url, headers=headers)

        if response.status_code == 200:
            return {'status': 'success', 'message': 'Order canceled successfully.'}
        else:
            return {'status': 'error', 'message': response.json()}
  good: |-
    from typing import TypedDict

    # Define the resource type for the Alpaca integration
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca, order_id: str) -> dict:
        from alpaca_trade_api import REST as AlpacaAPIClient

        # Initialize the Alpaca API client
        client = AlpacaAPIClient(
            key_id=alpaca_resource['api_key'],
            secret_key=alpaca_resource['api_secret'],
            base_url=alpaca_resource['base_url']
        )

        # Cancel the order with the given order_id
        response = client.cancel_order(order_id)

        # Return the response from the cancel order request
        return response
  id: |-
    synthetic_cancel-order
  instructions: |-
    Attempts to cancel an open order. If the order is no longer cancelable (example: status=`filled`), the server will reject the request, in alpaca
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    alpaca
  resource_type_def: |-
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { DynamoDBClient, UpdateTableCommand } from "npm:@aws-sdk/client-dynamodb";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(awsResource: Aws, tableName: string, readCapacityUnits: number, writeCapacityUnits: number) {
        const client = new DynamoDBClient({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
            },
            region: awsResource.region,
        });

        const updateTableCommand = new UpdateTableCommand({
            TableName: tableName,
            ProvisionedThroughput: {
                ReadCapacityUnits: readCapacityUnits,
                WriteCapacityUnits: writeCapacityUnits,
            },
        });

        const response = await client.send(updateTableCommand);
        return response;
    }
  good: |-
    import { DynamoDB } from "npm:aws-sdk";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(awsResource: Aws, tableName: string) {
        const dynamoDb = new DynamoDB({
            accessKeyId: awsResource.accessKeyId,
            secretAccessKey: awsResource.secretAccessKey,
            region: awsResource.region,
        });

        try {
            const response = await dynamoDb.describeTable({ TableName: tableName }).promise();
            const readCapacityUnits = response.Table?.ProvisionedThroughput?.ReadCapacityUnits;

            return {
                tableName: tableName,
                readCapacityUnits: readCapacityUnits,
            };
        } catch (error) {
            if (error.code === 'ThrottlingException') {
                // Handle the specific case of throttling exception
                console.error('ThrottlingException: Too many requests for the given read capacity units');
            } else {
                // Handle other possible exceptions
                console.error('An error occurred', error);
            }
            throw error;
        }
    }
  id: |-
    synthetic_dynamodb-update-table
  instructions: |-
    The maximum number of strongly consistent reads consumed per second before DynamoDB returns a `ThrottlingException` in aws
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aws
  resource_type_def: |-
    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { FiberyEntityTypeField } from "npm:@fibery/unofficial";

    type Fibery = {
        apiToken: string;
        workspaceApiUrl: string;
    }

    export async function main(fiberyResource: Fibery, entityType: string) {
        const apiUrl = `${fiberyResource.workspaceApiUrl}/api/commands`;
        const headers = {
            'Authorization': `Token ${fiberyResource.apiToken}`,
            'Content-Type': 'application/json',
        };
        const body = JSON.stringify({
            command: 'fibery.entity/query',
            args: {
                query: {
                    'q/from': entityType,
                    'q/select': ['fibery/fields'],
                    'q/limit': 'q/no-limit',
                }
            }
        });

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error fetching fields for entity type ${entityType}: ${response.statusText}`);
        }

        const data = await response.json();
        const fields = data.result.map((field: FiberyEntityTypeField) => ({
            id: field.id,
            name: field.name,
            type: field.type,
            isCollection: field.isCollection,
        }));

        return fields;
    }
  good: |-
    import { Fibery } from 'npm:@fibery/unofficial';

    type Fibery = {
        apiToken: string;
        workspace: string;
    }

    export async function main(fiberyResource: Fibery, entityType: string) {
        const fibery = new Fibery({
            token: fiberyResource.apiToken,
            workspace: fiberyResource.workspace
        });

        const fields = await fibery.getEntitySchema(entityType);

        return fields;
    }
  id: |-
    synthetic_list-fields-for-entity-type
  instructions: |-
    Lists fields for an entity type in fibery
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Fibery
  resource_type_def: |-
    type Fibery = {
        apiToken: string;
        workspace: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Flodesk } from "npm:flodesk";

    type FlodeskResource = {
        apiKey: string;
    }

    export async function main(flodeskResource: FlodeskResource, emailAddress: string) {
        const flodesk = new Flodesk(flodeskResource.apiKey);

        const subscriber = await flodesk.subscribers.findByEmail(emailAddress);

        return subscriber;
    }
  good: |-
    // Import any libraries you need here
    import { Flodesk as FlodeskSDK, FlodeskMember } from "npm:@flodesk/node-sdk";

    type Flodesk = {
        apiKey: string;
    }

    export async function main(flodeskResource: Flodesk, email: string): Promise<FlodeskMember | null> {
        // Initialize the Flodesk SDK with the provided API key
        const flodeskClient = new FlodeskSDK(flodeskResource.apiKey);

        // Find the subscriber by email
        const subscriber = await flodeskClient.subscribers.findByEmail(email);

        // Return the subscriber if found, otherwise return null
        return subscriber;
    }
  id: |-
    synthetic_find-subscriber
  instructions: |-
    Find a subscriber by email address in Flodesk in flodesk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Flodesk
  resource_type_def: |-
    type Flodesk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'clerk' integration
    class clerk(TypedDict):
        api_key: str
        endpoint_url: str

    def main(clerk_resource: clerk, user_id: str) -> bool:
        import requests  # Import here to avoid conflicts with parameter names

        # Construct the request to delete a user
        headers = {
            'Authorization': f"Bearer {clerk_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"{clerk_resource['endpoint_url']}/users/{user_id}"

        # Send the DELETE request
        response = requests.delete(url, headers=headers)

        # Return True if the deletion was successful, False otherwise
        return response.status_code == 204
  good: |-
    from typing import TypedDict

    # Define the resource type for the clerk integration
    class clerk(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for deleting a user in clerk
    def main(clerk_resource: clerk, user_id: str) -> bool:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for deleting a user
        delete_endpoint = f"{clerk_resource['base_url']}/users/{user_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {clerk_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the DELETE request to the clerk API
        response = requests.delete(delete_endpoint, headers=headers)

        # Check if the deletion was successful and return the result
        return response.status_code == 204  # 204 No Content is the expected success status code for a DELETE operation

    # The script ends here, with the main function defined and ready to be used.
  id: |-
    synthetic_delete-user
  instructions: |-
    Delete the specified user in clerk
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clerk
  resource_type_def: |-
    class clerk(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the dbt integration
    class dbt(TypedDict):
        api_token: str

    # Define the main function for the dbt integration
    def main(dbt_resource: dbt, account_id: str, run_id: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for getting a run
        endpoint = f"https://cloud.getdbt.com/api/v2/accounts/{account_id}/runs/{run_id}/"

        # Set up the headers with the API token for authentication
        headers = {
            "Authorization": f"Token {dbt_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Make the API request to get the run
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed to make API calls to dbt

    class dbt(TypedDict):
        api_token: str
        account_id: str
        project_id: str
        job_id: str

    def main(dbt_resource: dbt, run_id: int) -> Any:
        headers = {
            "Authorization": f"Token {dbt_resource['api_token']}",
            "Content-Type": "application/json"
        }
        url = f"https://cloud.getdbt.com/api/v2/accounts/{dbt_resource['account_id']}/runs/{run_id}/"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        return response.json()
  id: |-
    synthetic_get-run
  instructions: |-
    Retrieve information about a run in dbt
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dbt
  resource_type_def: |-
    class dbt(TypedDict):
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to send an SMS via D7 Networks API

    class d7_networks(TypedDict):
        api_key: str
        api_secret: str

    def main(d7_networks_resource: d7_networks, phone_number: str, message: str) -> dict:
        url = "http://rest-api.d7networks.com/secure/send"
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        payload = {
            'to': phone_number,
            'from': 'D7Net',
            'content': message,
            'dlr': 'yes',
            'dlr-method': 'POST',
            'dlr-level': '2',
            'dlr-url': 'http://your-listener-url.com/dlr'
        }
        response = requests.post(url, headers=headers, data=payload, auth=(d7_networks_resource['api_key'], d7_networks_resource['api_secret']))
        return response.json()
  good: |-
    from typing import TypedDict
    import requests

    class d7_networks(TypedDict):
        api_key: str
        api_secret: str

    def main(d7_networks_resource: d7_networks, phone_number: str, message: str, sender_id: str, callback_url: str):
        url = "https://rest-api.d7networks.com/secure/send"
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        payload = {
            'to': phone_number,
            'from': sender_id,
            'content': message,
            'dlr': 'yes',
            'dlr-method': 'POST',
            'dlr-level': '2',
            'dlr-url': callback_url
        }
        auth = (d7_networks_resource['api_key'], d7_networks_resource['api_secret'])
        response = requests.post(url, headers=headers, data=payload, auth=auth)
        return response.json()
  id: |-
    synthetic_send-sms
  instructions: |-
    Sending sms via D7 networks! in d7 networks
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    d7_networks
  resource_type_def: |-
    class d7_networks(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca):
        headers = {
            'APCA-API-KEY-ID': alpaca_resource['api_key'],
            'APCA-API-SECRET-KEY': alpaca_resource['api_secret']
        }

        # Endpoint to close all positions
        close_positions_url = f"{alpaca_resource['base_url']}/v2/positions"

        # Send a DELETE request to close all positions
        response = requests.delete(close_positions_url, headers=headers)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict
    import alpaca_trade_api as alpaca_api

    # Define the resource type for the alpaca integration
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(alpaca_resource: alpaca, symbol: str = None):
        # Initialize the Alpaca API
        api = alpaca_api.REST(
            alpaca_resource['api_key'],
            alpaca_resource['api_secret'],
            alpaca_resource['base_url'],
            api_version='v2'
        )

        # Close all positions or a specific symbol if provided
        if symbol:
            order = api.close_position(symbol)
        else:
            order = api.close_all_positions()

        return order
  id: |-
    synthetic_close-all-positions
  instructions: "Closes (liquidates) all of the account\u2019s open long and short\
    \ positions. A response will be provided for each order that is attempted to be\
    \ cancelled. If an order is no longer cancelable, the server will reject the request,\
    \ in alpaca"
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    alpaca
  resource_type_def: |-
    class alpaca(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        range: string,
        values: any[][],
        valueInputOption: 'RAW' | 'USER_ENTERED' = 'RAW'
    ) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.accessToken });

        const response = await sheets.spreadsheets.values.update({
            spreadsheetId: spreadsheetId,
            range: range,
            valueInputOption: valueInputOption,
            requestBody: {
                values: values
            },
            key: googleSheetsResource.apiKey
        });

        return response.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
        spreadsheetId: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        range: string,
        values: any[][],
        valueInputOption: 'RAW' | 'USER_ENTERED' = 'RAW'
    ) {
        const sheets = google.sheets({ version: 'v4', auth: googleSheetsResource.accessToken });

        const resource = {
            values,
        };

        try {
            const response = await sheets.spreadsheets.values.update({
                spreadsheetId: googleSheetsResource.spreadsheetId,
                range,
                valueInputOption,
                resource,
                key: googleSheetsResource.apiKey,
            });

            return response.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  id: |-
    synthetic_upsert-row
  instructions: |-
    Upsert a row of data in a Google Sheet in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        apiKey: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { FullContactPersonEnrichment } from "npm:@fullcontact/api"; // Assuming this is the npm package for FullContact

    type FullContact = {
        apiKey: string;
    }

    export async function main(fullContactResource: FullContact, email: string) {
        // Initialize the FullContact client with the API key
        const fullContactClient = new FullContactPersonEnrichment(fullContactResource.apiKey);

        // Enrich the person using the provided email
        const personInfo = await fullContactClient.enrich(email);

        // Return the result
        return personInfo;
    }
  good: |-
    // Importing necessary libraries
    import { FullContactClient } from "npm:@fullcontact/client";

    type FullContact = {
        apiKey: string;
    }

    export async function main(fullContactResource: FullContact, personEmail: string) {
        const fullContactClient = new FullContactClient(fullContactResource.apiKey);

        const personEnrichment = await fullContactClient.enrichPerson({ email: personEmail });

        return personEnrichment;
    }
  id: |-
    synthetic_enrich-person
  instructions: |-
    Enrich a person in full contact
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FullContact
  resource_type_def: |-
    type FullContact = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GoogleAuth } from "npm:google-auth-library";

    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        spreadsheetId: string,
        sheetName: string,
        row: number,
        column: string,
        newValue: string
    ) {
        const { clientEmail, privateKey } = googleSheetsResource;
        const auth = new GoogleAuth({
            credentials: {
                client_email: clientEmail,
                private_key: privateKey,
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets'],
        });

        const client = await auth.getClient();
        const sheets = google.sheets({ version: 'v4', auth: client });

        const range = `${sheetName}!${column}${row}`;
        const valueInputOption = 'USER_ENTERED';
        const requestBody = {
            values: [[newValue]],
        };

        const response = await sheets.spreadsheets.values.update({
            spreadsheetId,
            range,
            valueInputOption,
            requestBody,
        });

        return response.data;
    }
  good: |-
    import { GoogleAuth } from "npm:google-auth-library";

    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
        spreadsheetId: string;
    }

    export async function main(
        googleSheetsResource: GoogleSheets,
        range: string,
        values: any[][]
    ) {
        const auth = new GoogleAuth({
            credentials: {
                client_email: googleSheetsResource.clientEmail,
                private_key: googleSheetsResource.privateKey,
            },
            scopes: ['https://www.googleapis.com/auth/spreadsheets'],
        });

        const client = await auth.getClient();
        const sheets = google.sheets({ version: 'v4', auth: client });

        const updateOptions = {
            spreadsheetId: googleSheetsResource.spreadsheetId,
            range: range,
            valueInputOption: 'USER_ENTERED',
            resource: {
                values: values,
            },
        };

        const result = await sheets.spreadsheets.values.update(updateOptions);
        return result.data;
    }
  id: |-
    synthetic_update-row
  instructions: |-
    Update a row in a spreadsheet in google sheets
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleSheets
  resource_type_def: |-
    type GoogleSheets = {
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import aweber_api  # Assuming aweber_api is the library for the Aweber integration

    # Renaming the imported method if it conflicts with the resource type name
    from aweber_api import get_lists as get_aweber_lists

    class aweber(TypedDict):
        consumer_key: str
        consumer_secret: str
        access_token: str
        access_token_secret: str
        account_id: str

    def main(aweber_resource: aweber) -> List[dict]:
        # Initialize the AWeber API client with the provided credentials
        client = aweber_api.OAuthClient(
            consumer_key=aweber_resource['consumer_key'],
            consumer_secret=aweber_resource['consumer_secret'],
            access_token=aweber_resource['access_token'],
            access_token_secret=aweber_resource['access_token_secret']
        )

        # Retrieve the account using the account ID
        account = client.get_account(aweber_resource['account_id'])

        # Use the renamed get_aweber_lists method to get the lists
        lists = get_aweber_lists(account)

        # Return the lists
        return lists
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests

    class aweber(TypedDict):
        access_token: str
        client_id: str
        client_secret: str

    def main(aweber_resource: aweber, page_size: int = 20, page_start: int = 0) -> List[dict]:
        base_url = "https://api.aweber.com/1.0/accounts"
        headers = {
            "Authorization": f"Bearer {aweber_resource['access_token']}"
        }
        params = {
            "ws.start": page_start,
            "ws.size": page_size
        }

        response = requests.get(base_url, headers=headers, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()  # Assuming the response is in JSON format and contains the subscriber lists
  id: |-
    synthetic_get-lists
  instructions: |-
    Get a paginated collection of subscriber lists. in aweber
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aweber
  resource_type_def: |-
    class aweber(TypedDict):
        consumer_key: str
        consumer_secret: str
        access_token: str
        access_token_secret: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the 'dext' integration
    class dext(TypedDict):
        api_key: str
        api_secret: str
        access_token: str

    # Define the main function with the dext resource and additional parameters
    def main(dext_resource: dext, client_id: str, start_date: str, end_date: str) -> Dict[str, List[Dict]]:
        # Construct the headers with the necessary authentication details
        headers = {
            'Authorization': f"Bearer {dext_resource['access_token']}",
            'x-api-key': dext_resource['api_key'],
            'x-api-secret': dext_resource['api_secret']
        }

        # Construct the API endpoint for getting client activity stats
        url = f"https://api.dext.com/some-endpoint/clients/{client_id}/activity-stats"

        # Define the parameters for the date range
        params = {
            'start_date': start_date,
            'end_date': end_date
        }

        # Make the API request
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response data
            data = response.json()
            # Return the parsed data
            return data
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function is not called here, it is only defined and exported.
  good: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the dext integration
    class dext(TypedDict):
        api_key: str
        client_id: str

    def main(dext_resource: dext, year: int, month: int) -> Dict[str, Any]:
        # Construct the API endpoint for retrieving activity stats
        base_url = "https://api.dext.com"
        endpoint = f"/clients/{dext_resource['client_id']}/activity-stats"
        url = f"{base_url}{endpoint}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {dext_resource['api_key']}"
        }

        # Set up the parameters for the API request
        params = {
            "year": year,
            "month": month
        }

        # Make the API request
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # The script ends here without calling the main function, as per the instructions.
  id: |-
    synthetic_get-client-activity-stats
  instructions: |-
    Retrieves the rolling annual and monthly-average Activity Stats for a particular client in dext
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dext
  resource_type_def: |-
    class dext(TypedDict):
        api_key: str
        api_secret: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { CalendarEvent as NodeCalendarEvent } from "npm:@types/node"; // Renamed to avoid conflict with CalendlyV2

    type CalendlyV2 = {
        apiKey: string;
        organization: string;
    }

    export async function main(calendlyResource: CalendlyV2, eventId: string): Promise<NodeCalendarEvent> {
        const CALENDLY_API_URL = `https://api.calendly.com/scheduled_events/${eventId}`;

        const response = await fetch(CALENDLY_API_URL, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${calendlyResource.apiKey}`,
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Error fetching event: ${response.status} ${response.statusText}`);
        }

        const event: NodeCalendarEvent = await response.json();
        return event;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:querystring";

    type CalendlyV2 = {
        apiKey: string;
    }

    export async function main(calendlyResource: CalendlyV2, eventUri: string) {
        const endpoint = `https://api.calendly.com${eventUri}`;
        const headers = {
            'Authorization': `Bearer ${calendlyResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(endpoint, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-event
  instructions: |-
    Gets information about an Event associated with a URI. in calendly v2
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CalendlyV2
  resource_type_def: |-
    type CalendlyV2 = {
        apiKey: string;
        organization: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import mux_python
    from mux_python.rest import ApiException

    # Define the resource type for the Mux integration
    class mux(TypedDict):
        access_token: str
        secret_key: str

    # Define the main function for creating an asset track
    def main(mux_resource: mux, asset_id: str, track_type: str, language_code: str, url: str):
        # Configure Mux client with credentials from the resource
        configuration = mux_python.Configuration()
        configuration.username = mux_resource['access_token']
        configuration.password = mux_resource['secret_key']

        # Create an instance of the API class
        assets_api = mux_python.AssetsApi(mux_python.ApiClient(configuration))

        # Define the track input
        input_settings = mux_python.CreateTrackInputSettings(url=url)
        create_track_request = mux_python.CreateTrackRequest(
            type=track_type,
            language_code=language_code,
            input_settings=input_settings
        )

        try:
            # Call the Mux API to create the asset track
            api_response = assets_api.create_asset_track(asset_id, create_track_request)
            return api_response
        except ApiException as e:
            print(f"Exception when calling Mux API: {e}")
            return None
  good: |-
    from typing import TypedDict
    import mux_python
    from mux_python.rest import ApiException

    # Define the resource type for the mux integration
    class mux(TypedDict):
        access_token: str
        secret_key: str

    # Define the main function for adding an asset track to an asset in mux
    def main(mux_resource: mux, asset_id: str, track_type: str, url: str, language_code: str, name: str, closed_captions: bool, passthrough: str = None):
        # Configure Mux client with credentials from the resource
        configuration = mux_python.Configuration()
        configuration.username = mux_resource['access_token']
        configuration.password = mux_resource['secret_key']

        # Create an instance of the Mux API
        assets_api = mux_python.AssetsApi(mux_python.ApiClient(configuration))

        # Define the track input
        input_settings = mux_python.CreateTrackInput(
            url=url,
            type=track_type,
            text_type="subtitles",
            language_code=language_code,
            name=name,
            closed_captions=closed_captions,
            passthrough=passthrough
        )

        # Add the track to the asset
        try:
            response = assets_api.create_asset_track(asset_id, input_settings)
            return response
        except ApiException as e:
            print(f"Exception when calling AssetsApi->create_asset_track: {e}")
            return None
  id: |-
    synthetic_create-asset-track
  instructions: |-
    Adds an asset track (for example, subtitles) to an asset in mux
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mux
  resource_type_def: |-
    class mux(TypedDict):
        access_token: str
        secret_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'missive' integration
    class missive(TypedDict):
        api_key: str  # API key for authentication

    # Main function to create a contact in Missive
    def main(missive_resource: missive, contact_name: str, contact_email: str):
        import requests  # Import requests or any other library if needed

        # Endpoint for creating a contact in Missive
        create_contact_endpoint = "https://missiveapp.com/api/contacts"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {missive_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Contact data to be created
        contact_data = {
            "name": contact_name,
            "email": contact_email
        }

        # Make the request to create the contact
        response = requests.post(create_contact_endpoint, headers=headers, json=contact_data)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created contact information
        else:
            response.raise_for_status()  # Raise an exception if there was an error
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the 'missive' integration
    class missive(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function to create a new contact in Missive
    def main(missive_resource: missive, name: str, email: str, phone: str = None, company: str = None) -> Any:
        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {missive_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the payload with the contact details
        payload = {
            'name': name,
            'email': email,
            'phone': phone,
            'company': company
        }

        # Remove None values from the payload
        payload = {k: v for k, v in payload.items() if v is not None}

        # Define the endpoint URL for creating a new contact
        url = "https://missiveapp.com/api/contacts"

        # Make the POST request to create a new contact
        response = requests.post(url, headers=headers, json=payload)

        # Return the response from the API
        return response.json()

    # Note: The function does not call itself, it's meant to be exported and used elsewhere.
  id: |-
    synthetic_create-contact
  instructions: |-
    Create a new contact in missive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    missive
  resource_type_def: |-
    class missive(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Bingx } from "npm:@bingx/bingx-api"; // Assuming there's an npm package for Bingx API

    type BingxResource = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for Bingx authentication/configuration
    }

    export async function main(bingxResource: BingxResource, symbol: string, limit: number) {
        // Initialize the Bingx API client with the provided credentials
        const bingxClient = new Bingx(bingxResource.apiKey, bingxResource.apiSecret);

        // Fetch the market depth for the given symbol and limit
        const marketDepth = await bingxClient.getMarketDepth(symbol, limit);

        // Return the market depth result
        return marketDepth;
    }
  good: |-
    import { hmac as generateHmac } from "npm:crypto";

    type Bingx = {
        apiKey: string;
        apiSecret: string;
        apiUrl: string;
    }

    export async function main(bingxResource: Bingx, symbol: string, limit: number = 5) {
        const { apiKey, apiSecret, apiUrl } = bingxResource;
        const timestamp = Date.now();
        const queryString = `symbol=${symbol}&limit=${limit}&timestamp=${timestamp}`;
        const signature = generateHmac('sha256', apiSecret, queryString, 'utf8', 'hex');

        const url = `${apiUrl}/openapi/quote/v1/depth?${queryString}&signature=${signature}`;
        const headers = {
            'X-MBX-APIKEY': apiKey
        };

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_market-get-market-depth
  instructions: |-
    Get Market Depth. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        apiSecret: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { AsticaAi } from "npm:@asticode/astica-ai";

    type AsticaAi = {
        apiKey: string;
    }

    export async function main(asticaAiResource: AsticaAi, audioFileUrl: string) {
        // Initialize the Astica AI client with the provided API key
        const asticaClient = new AsticaAi(asticaAiResource.apiKey);

        // Transcribe the audio file
        const transcriptionResult = await asticaClient.transcribe(audioFileUrl);

        // Return the transcription result
        return transcriptionResult;
    }
  good: |-
    // Importing necessary libraries
    import { AsticaAiClient as AsticaAiApiClient } from "npm:@asticode/astica-ai";

    type AsticaAi = {
        apiKey: string;
        endpoint: string;
    }

    export async function main( asticaAiResource: AsticaAi, audioFileUrl: string, languageCode: string = 'en-US') {
        // Initialize the AsticaAi client with the provided API key and endpoint
        const client = new AsticaAiApiClient(asticaAiResource.apiKey, asticaAiResource.endpoint);

        // Call the speech-to-text function of the AsticaAi client
        const response = await client.speechToText(audioFileUrl, languageCode);

        // Return the transcription result
        return response;
    }
  id: |-
    synthetic_speech-to-text
  instructions: |-
    Transcribe an audio file to text with Astica AI in astica ai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AsticaAi
  resource_type_def: |-
    type AsticaAi = {
        apiKey: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the monday API

    class monday(TypedDict):
        api_key: str
        api_url: str

    def main(monday_resource: monday, item_id: int, new_name: str) -> dict:
        headers = {
            'Authorization': monday_resource['api_key'],
            'Content-Type': 'application/json'
        }
        mutation = f'''
            mutation {{
                change_column_value (board_id: YOUR_BOARD_ID, item_id: {item_id}, column_id: "name", value: "{json.dumps(new_name)}") {{
                    id
                }}
            }}
        '''
        response = requests.post(
            url=monday_resource['api_url'],
            headers=headers,
            json={'query': mutation}
        )
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the monday integration
    class monday(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for updating an item name on monday.com
    def main(monday_resource: monday, item_id: int, new_name: str) -> dict:
        from monday import MondayClient as MondayApiClient  # Rename the imported MondayClient to avoid conflict

        # Initialize the Monday client with the API key from the resource
        client = MondayApiClient(monday_resource['api_key'])

        # Update the item name using the Monday client
        result = client.items.change_item_name(item_id=item_id, new_name=new_name)

        # Return the result of the update operation
        return result

    # The script ends here, and the main function is ready to be exported and used with the specified parameters.
  id: |-
    synthetic_update-item-name
  instructions: |-
    Update an item's name in monday
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    monday
  resource_type_def: |-
    class monday(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the helpcrunch integration
    class helpcrunch(TypedDict):
        api_key: str
        subdomain: str

    # Import any libraries you might need
    import requests

    # Define the main function for the helpcrunch integration
    def main(helpcrunch_resource: helpcrunch, customer_name: str, customer_email: str, additional_info: dict):
        # Construct the API endpoint
        api_endpoint = f"https://{helpcrunch_resource['subdomain']}.helpcrunch.com/api/public/customers"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {helpcrunch_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload with the customer information
        data = {
            "name": customer_name,
            "email": customer_email,
            **additional_info
        }

        # Make the POST request to create a new customer record
        response = requests.post(api_endpoint, json=data, headers=headers)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the helpcrunch integration
    class helpcrunch(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for creating a customer in HelpCrunch
    def main(helpcrunch_resource: helpcrunch, customer_email: str, customer_name: str, additional_data: dict = None):
        import requests  # Import requests or any other library if needed

        # HelpCrunch API endpoint for creating a customer
        url = f"https://{helpcrunch_resource['subdomain']}.helpcrunch.com/api/public/customers"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {helpcrunch_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the new customer
        data = {
            "email": customer_email,
            "name": customer_name
        }

        # If there's additional data, include it in the payload
        if additional_data:
            data.update(additional_data)

        # Make the POST request to create the customer
        response = requests.post(url, json=data, headers=headers)

        # Return the response from the HelpCrunch API
        return response.json()
  id: |-
    synthetic_create-customer
  instructions: |-
    Creates a new customer record within the Helpcrunch platform in helpcrunch
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helpcrunch
  resource_type_def: |-
    class helpcrunch(TypedDict):
        api_key: str
        subdomain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { Client } from "npm:@airplane/client";

    type Airplane = {
        apiKey: string,
        environmentId: string
    }

    export async function main(airplaneResource: Airplane, taskId: string, params: Record<string, any>) {
        const client = new Client({
            apiKey: airplaneResource.apiKey,
            environmentId: airplaneResource.environmentId,
        });

        const result = await client.run(taskId, params);

        return result;
    }
  good: |-
    // Import any libraries you need here
    // Assuming 'airplane' is an npm package that provides functionality related to the Airplane integration
    import airplane from "npm:airplane";

    type Airplane = {
        apiKey: string;
        // Add other properties needed for the Airplane integration
    }

    export async function main(airplaneResource: Airplane, promptValues: Record<string, any>) {
        // Ensure the API key is set for the Airplane integration
        airplane.setApiKey(airplaneResource.apiKey);

        // Submit the prompt with the provided values
        const result = await airplane.submitPrompt(promptValues);

        // Always return the result
        return result;
    }
  id: |-
    synthetic_submit-prompt
  instructions: |-
    Submit a prompt with a set of parameter values in airplane
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Airplane
  resource_type_def: |-
    type Airplane = {
        apiKey: string,
        environmentId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls to Jira's API

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        email: str
        api_token: str

    def main(jira_resource: jira, user_keys: List[str]) -> List[dict]:
        headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': f'Basic {jira_resource["api_token"]}'
        }

        user_details = []
        for user_key in user_keys:
            response = requests.get(
                f'{jira_resource["base_url"]}/rest/api/3/user?key={user_key}',
                headers=headers
            )
            response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code
            user_details.append(response.json())

        return user_details
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls to Jira API

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        email: str
        api_token: str

    def main(jira_resource: jira, project_key: str) -> List[dict]:
        # Construct the API endpoint for fetching users from a Jira project
        endpoint = f"{jira_resource['base_url']}/rest/api/3/user/assignable/search"

        # Prepare the authentication header
        auth = (jira_resource['email'], jira_resource['api_token'])

        # Prepare the query parameters
        params = {'project': project_key}

        # Make the HTTP GET request to the Jira API
        response = requests.get(endpoint, auth=auth, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of users
            return response.json()
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()
  id: |-
    synthetic_get-users
  instructions: |-
    Gets details of a list of users in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        email: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { OpenAIAPI } from "npm:@azure/ai-language-openai";

    type AzureOpenaiService = {
        apiKey: string,
        endpoint: string
    }

    export async function main(azureOpenaiService: AzureOpenaiService, prompt: string, maxTokens: number = 150) {
        // Initialize the OpenAI client
        const openaiClient = new OpenAIAPI({
            apiKey: azureOpenaiService.apiKey,
            endpoint: azureOpenaiService.endpoint
        });

        // Generate a response from the OpenAI service
        const response = await openaiClient.complete({
            prompt: prompt,
            maxTokens: maxTokens
        });

        // Return the result
        return response;
    }
  good: |-
    import { OpenAIApi } from "npm:@azure/ai-openai";

    type AzureOpenaiService = {
        apiKey: string,
        endpoint: string,
        model: "gpt-3.5-turbo" | "gpt-4"
    }

    export async function main(
        azureOpenaiServiceResource: AzureOpenaiService,
        prompt: string,
        maxTokens: number = 150,
        temperature: number = 0.7,
        topP: number = 1,
        frequencyPenalty: number = 0,
        presencePenalty: number = 0
    ) {
        const openai = new OpenAIApi({
            apiKey: azureOpenaiServiceResource.apiKey,
            endpoint: azureOpenaiServiceResource.endpoint
        });

        const completionParams = {
            model: azureOpenaiServiceResource.model,
            prompt: prompt,
            max_tokens: maxTokens,
            temperature: temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty
        };

        try {
            const completionResult = await openai.createCompletion(completionParams);
            return completionResult.data.choices[0].text;
        } catch (error) {
            console.error("Error creating completion with Azure OpenAI Service:", error);
            throw error;
        }
    }
  id: |-
    synthetic_chat
  instructions: |-
    Create completions for chat messages with the GPT-35-Turbo and GPT-4 models in azure openai service
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AzureOpenaiService
  resource_type_def: |-
    type AzureOpenaiService = {
        apiKey: string,
        endpoint: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BitbucketClient } from "npm:@bitbucket/client"; // Assuming this is the correct Bitbucket client package

    type Bitbucket = {
        username: string;
        appPassword: string;
    }

    export async function main(bitbucketResource: Bitbucket, workspace: string, repoSlug: string, filePath: string, ref?: string) {
        const bitbucket = new BitbucketClient({
            auth: {
                username: bitbucketResource.username,
                password: bitbucketResource.appPassword,
            },
        });

        const response = await bitbucket.repositories.getSrc({
            workspace: workspace,
            repo_slug: repoSlug,
            path: filePath,
            ref: ref,
        });

        // Assuming the file is not too large and can be converted to a string
        const content = Buffer.from(response.data.content, 'base64').toString('utf-8');

        return content;
    }
  good: |-
    import { Buffer } from "npm:buffer";

    type Bitbucket = {
        username: string;
        appPassword: string;
        workspace: string;
        repoSlug: string;
    }

    export async function main(bitbucketResource: Bitbucket, artifactName: string, downloadPath: string) {
        const authHeader = `Basic ${Buffer.from(`${bitbucketResource.username}:${bitbucketResource.appPassword}`).toString('base64')}`;
        const artifactUrl = `https://api.bitbucket.org/2.0/repositories/${bitbucketResource.workspace}/${bitbucketResource.repoSlug}/downloads/${artifactName}`;

        const response = await fetch(artifactUrl, {
            headers: {
                Authorization: authHeader,
            },
        });

        if (!response.ok) {
            throw new Error(`Failed to download artifact: ${response.statusText}`);
        }

        const data = await response.arrayBuffer();
        const content = Buffer.from(data).toString('binary');

        // Assuming downloadPath is a local file path where the user wants to save the artifact
        await Deno.writeFile(downloadPath, new Uint8Array(data));

        return {
            message: `Artifact ${artifactName} has been downloaded and saved to ${downloadPath}`,
            content: content,
        };
    }
  id: |-
    synthetic_get-file-from-repository
  instructions: |-
    Gets the actual file contents of a download artifact and not the artifact's metadata in bitbucket
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bitbucket
  resource_type_def: |-
    type Bitbucket = {
        username: string;
        appPassword: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the DigitalOcean API

    class digital_ocean(TypedDict):
        access_token: str

    def list_droplets(digital_ocean_resource: digital_ocean) -> List[dict]:
        headers = {
            "Authorization": f"Bearer {digital_ocean_resource['access_token']}",
            "Content-Type": "application/json"
        }
        response = requests.get("https://api.digitalocean.com/v2/droplets", headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        droplets = response.json().get('droplets', [])
        return droplets
  good: |-
    from typing import TypedDict, List
    import digitalocean as do

    # Rename the imported method if it conflicts with the resource type name
    DigitalOcean = do.Manager

    class digital_ocean(TypedDict):
        token: str

    def main(digital_ocean_resource: digital_ocean) -> List[dict]:
        manager = DigitalOcean(token=digital_ocean_resource['token'])
        droplets = manager.get_all_droplets()
        droplet_list = [{'name': droplet.name, 'id': droplet.id, 'status': droplet.status} for droplet in droplets]
        return droplet_list
  id: |-
    synthetic_list-all-droplets
  instructions: |-
    List all Droplets in digital ocean
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    digital_ocean
  resource_type_def: |-
    class digital_ocean(TypedDict):
        token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string) {
        // Initialize the Google Drive API client
        const oauth2Client = new google.auth.OAuth2(
            googleDriveResource.clientId,
            googleDriveResource.clientSecret,
            googleDriveResource.redirectUri
        );

        // Set the credentials with the provided refresh token
        oauth2Client.setCredentials({
            refresh_token: googleDriveResource.refreshToken
        });

        // Create a Google Drive instance with the authenticated OAuth2 client
        const drive = google.drive({
            version: 'v3',
            auth: oauth2Client
        });

        // Attempt to delete the file or folder
        const response = await drive.files.delete({
            fileId: fileId
        });

        // Return the result of the delete operation
        return response.data;
    }
  good: |-
    import { drive_v3, google } from "npm:@googleapis/drive";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;

        const oauth2Client = new google.auth.OAuth2(
            clientId,
            clientSecret,
            redirectUri
        );

        oauth2Client.setCredentials({
            refresh_token: refreshToken
        });

        const drive = google.drive({
            version: 'v3',
            auth: oauth2Client
        });

        const response = await drive.files.delete({
            fileId: fileId
        });

        return response.data;
    }
  id: |-
    synthetic_delete-file
  instructions: |-
    The file or folder to delete in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the Cloudflare API key integration
    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str

    # Define the main function with the resource type and any additional parameters
    def main(cloudflare_resource: cloudflare_api_key, zone_id: str, since: str, until: str) -> Any:
        # Construct the headers for authentication
        headers = {
            'X-Auth-Email': cloudflare_resource['email'],
            'X-Auth-Key': cloudflare_resource['api_key'],
            'Content-Type': 'application/json'
        }

        # Construct the URL for the Cloudflare Analytics API
        url = f"https://api.cloudflare.com/client/v4/zones/{zone_id}/analytics/dashboard?since={since}&until={until}"

        # Make the API request
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests library is needed for API calls

    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str
        account_id: str

    def main(cloudflare_resource: cloudflare_api_key, zone_id: str) -> dict:
        base_url = "https://api.cloudflare.com/client/v4"
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json"
        }

        endpoint = f"/accounts/{cloudflare_resource['account_id']}/storage/kv/namespaces/{zone_id}/analytics"
        response = requests.get(base_url + endpoint, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json()
  id: |-
    synthetic_query-worker-analytics
  instructions: |-
    Retrieves Workers KV request metrics for the given account in cloudflare api key
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudflare_api_key
  resource_type_def: |-
    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MondayClient } from "npm:@mondaydotcom/monday-sdk-js";

    type Monday = {
        apiKey: string;
    }

    export async function main(mondayResource: Monday, boardId: number, columnId: string, itemId: number, newValue: string | number) {
        const mondayClient = new MondayClient();
        mondayClient.setToken(mondayResource.apiKey);

        const mutation = `mutation ($boardId: Int!, $itemId: Int!, $columnId: String!, $value: JSON!) {
            change_column_value(board_id: $boardId, item_id: $itemId, column_id: $columnId, value: $value) {
                id
            }
        }`;

        const variables = {
            boardId: boardId,
            itemId: itemId,
            columnId: columnId,
            value: JSON.stringify(newValue)
        };

        try {
            const response = await mondayClient.api(mutation, { variables });
            return response.data;
        } catch (error) {
            console.error(error);
            throw new Error('Failed to update column value on Monday.com');
        }
    }
  good: |-
    import { MondayClient } from "npm:@mondaydotcom/monday-sdk-js";

    type Monday = {
        apiKey: string;
    }

    export async function main(mondayResource: Monday, itemId: number, columnValues: Record<string, any>) {
        const mondayClient = new MondayClient();
        mondayClient.setToken(mondayResource.apiKey);

        const mutation = `mutation ($itemId: Int!, $columnValues: JSON!) {
            change_multiple_column_values(item_id: $itemId, column_values: $columnValues) {
                id
            }
        }`;

        try {
            const response = await mondayClient.api(mutation, {
                variables: {
                    itemId: itemId,
                    columnValues: JSON.stringify(columnValues)
                }
            });

            return response.data;
        } catch (error) {
            console.error(error);
            throw new Error('Failed to update item in Monday.com');
        }
    }
  id: |-
    synthetic_update-column-values
  instructions: |-
    Update multiple column values of an item in monday
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Monday
  resource_type_def: |-
    type Monday = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    class data_stores(TypedDict):
        api_key: str
        store_url: str

    def main(data_stores_resource: data_stores, record_id: str, data_to_append: Dict[str, Any]):
        # Assuming there's a library to interact with the data store
        from data_store_client import append_to_record as ds_append_to_record

        # Append data to the record using the data store's API
        result = ds_append_to_record(
            api_key=data_stores_resource['api_key'],
            store_url=data_stores_resource['store_url'],
            record_id=record_id,
            data=data_to_append
        )

        return result
  good: |-
    from typing import TypedDict, Any, List

    # Define the resource type for the data_stores integration
    class data_stores(TypedDict):
        api_key: str
        store_id: str

    # Import any libraries you might need
    import requests  # Assuming requests is needed to interact with the data store API

    def main(data_stores_resource: data_stores, record_key: str, data_to_append: Any) -> List[Any]:
        # Define the endpoint for appending to a record
        endpoint = f"https://api.datastores.com/v1/stores/{data_stores_resource['store_id']}/records/{record_key}"

        # Prepare the headers for authentication
        headers = {
            "Authorization": f"Bearer {data_stores_resource['api_key']}"
        }

        # Prepare the payload for appending data
        payload = {
            "data": data_to_append
        }

        # Make a request to the data store API to append to the record
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the updated record
            return response.json()
        else:
            # Handle error cases
            response.raise_for_status()

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_append-to-record
  instructions: |-
    Append to a record in your data store. If the record does not exist, a new record will be created in an array format. in data stores
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    data_stores
  resource_type_def: |-
    class data_stores(TypedDict):
        api_key: str
        store_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { BitlyClient } from "npm:bitly";

    type Bitly = {
        accessToken: string;
    }

    export async function main(bitlyResource: Bitly, groupName: string) {
        const bitlyClient = new BitlyClient(bitlyResource.accessToken);

        const groups = await bitlyClient.getGroups();
        const group = groups.find(g => g.name === groupName);

        if (!group) {
            throw new Error(`Group with name ${groupName} not found.`);
        }

        return group.guid;
    }
  good: |-
    import { BitlyClient } from "npm:bitly";

    type Bitly = {
        accessToken: string,
        groupId: string
    }

    export async function main(bitlyResource: Bitly, size: number = 10, page: number = 1) {
        const bitly = new BitlyClient(bitlyResource.accessToken);

        try {
            const response = await bitly.bitlinks.list({ group_guid: bitlyResource.groupId, size, page });
            return response;
        } catch (error) {
            console.error('Error fetching Bitlinks:', error);
            throw error;
        }
    }
  id: |-
    synthetic_list-bitlink-by-group
  instructions: |-
    A GUID for a Bitly group in bitly
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bitly
  resource_type_def: |-
    type Bitly = {
        accessToken: string,
        groupId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library for HTML to Markdown conversion
    import TurndownService from "npm:turndown";

    // Define the resource type for the HelperFunctions integration
    type HelperFunctions = {
        apiKey: string;
    }

    // Define the main function that converts HTML to Slack's mrkdwn format
    export async function main(helperFunctionsResource: HelperFunctions, htmlContent: string): Promise<string> {
        // Initialize the Turndown service with Slack's mrkdwn options
        const turndownService = new TurndownService({
            headingStyle: 'atx',
            hr: '',
            bulletListMarker: '-',
            codeBlockStyle: 'fenced',
            fence: '```',
            emDelimiter: '_',
            strongDelimiter: '*',
            linkStyle: 'inlined',
            linkReferenceStyle: 'full'
        });

        // Convert the HTML content to Markdown
        const markdown = turndownService.turndown(htmlContent);

        // Return the converted Markdown (mrkdwn) text
        return markdown;
    }
  good: |-
    // Import any libraries you need here
    import { convert } from "npm:html-to-mrkdwn";

    type HelperFunctions = {
        apiKey: string; // Assuming the integration requires an API key for authentication
    }

    export async function main(helperFunctionsResource: HelperFunctions, htmlString: string) {
        // Use the imported library to convert HTML to Slack mrkdwn format
        const mrkdwn = convert(htmlString, {
            apiKey: helperFunctionsResource.apiKey
        });

        // Always return the result
        return mrkdwn;
    }
  id: |-
    synthetic_convert-html-to-slack-mrkdwn
  instructions: |-
    Converts an HTML string to the Slack mrkdwn format using in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming we need this to fetch data from a URL

    # Define the resource type for the gigasheet integration
    class gigasheet(TypedDict):
        api_key: str
        base_url: str

    def main(gigasheet_resource: gigasheet, data_url: str, sheet_id: str):
        # Fetch data from the provided URL
        response = requests.get(data_url)
        response.raise_for_status()  # Ensure we got a successful response
        data = response.content  # Assuming the data is in the response content

        # Prepare headers for authentication
        headers = {
            'Authorization': f"Bearer {gigasheet_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Prepare the endpoint URL for uploading data to Gigasheet
        upload_url = f"{gigasheet_resource['base_url']}/sheets/{sheet_id}/data"

        # Upload data to Gigasheet
        upload_response = requests.post(upload_url, headers=headers, data=data)
        upload_response.raise_for_status()  # Ensure the upload was successful

        # Return the response from Gigasheet
        return upload_response.json()
  good: |-
    from typing import TypedDict
    import requests

    class gigasheet(TypedDict):
        api_key: str

    def main(gigasheet_resource: gigasheet, data_url: str, file_name: str) -> str:
        headers = {
            'Authorization': f"Bearer {gigasheet_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        payload = {
            'url': data_url
        }

        response = requests.post(f'https://api.gigasheet.com/upload-from-url?file_name={file_name}', headers=headers, json=payload)

        if response.status_code == 200:
            return response.text
        else:
            return f"Error: {response.status_code} - {response.text}"
  id: |-
    synthetic_upload-data-from-url
  instructions: |-
    Uploads data from a URL to Gigasheet in gigasheet
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gigasheet
  resource_type_def: |-
    class gigasheet(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed to make API calls to Gitlab

    class gitlab(TypedDict):
        api_url: str
        private_token: str

    def main(gitlab_resource: gitlab, project_id: int) -> List[str]:
        headers = {'PRIVATE-TOKEN': gitlab_resource['private_token']}
        url = f"{gitlab_resource['api_url']}/projects/{project_id}/repository/branches"
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an error if the request fails
        branches = [branch['name'] for branch in response.json()]
        return branches

    # Example usage:
    # result = main(gitlab_resource={'api_url': 'https://gitlab.example.com/api/v4', 'private_token': 'your_private_token'}, project_id=123)
    # print(result)
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed to make HTTP calls to GitLab API

    class gitlab(TypedDict):
        api_url: str
        private_token: str

    def main(gitlab_resource: gitlab, project_id: int) -> List[str]:
        headers = {'PRIVATE-TOKEN': gitlab_resource['private_token']}
        url = f"{gitlab_resource['api_url']}/projects/{project_id}/repository/branches"
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code

        branches_data = response.json()
        branch_names = [branch['name'] for branch in branches_data]

        return branch_names

    # The function main is now defined and can be used with gitlab resources and a project ID.
  id: |-
    synthetic_list-repo-branches
  instructions: |-
    Get a list of repository branches from a project in gitlab
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        api_url: str
        private_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:querystring";

    type Mautic = {
        baseUrl: string;
        accessToken: string;
    }

    export async function main(mauticResource: Mautic, searchTerm: string) {
        const url = `${mauticResource.baseUrl}/api/campaigns?search=${encode(searchTerm)}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${mauticResource.accessToken}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { MauticAuth } from "npm:@mautic/authentication"; // Assuming this is a fictional npm package for Mautic authentication

    type Mautic = {
        baseUrl: string;
        accessToken: string;
        refreshToken: string;
        tokenType: string;
    }

    export async function main(mauticResource: Mautic, searchTerm: string) {
        const authHeader = `${mauticResource.tokenType} ${mauticResource.accessToken}`;
        const searchUrl = `${mauticResource.baseUrl}/api/campaigns?search=${encodeURIComponent(searchTerm)}`;

        const response = await fetch(searchUrl, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching campaigns: ${response.statusText}`);
        }

        const campaigns = await response.json();
        return campaigns;
    }
  id: |-
    synthetic_search-campaigns
  instructions: |-
    Gets a list of campaigns by a search term in mautic
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mautic
  resource_type_def: |-
    type Mautic = {
        baseUrl: string;
        accessToken: string;
        refreshToken: string;
        tokenType: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to the Notion API

    # Define the resource type for the Notion integration
    class notion(TypedDict):
        access_token: str
        version: str

    # Define the function to update page properties in Notion
    def main(notion_resource: notion, page_id: str, properties: Dict[str, Any]):
        # Set up the headers for the HTTP request to Notion API
        headers = {
            "Authorization": f"Bearer {notion_resource['access_token']}",
            "Notion-Version": notion_resource['version'],
            "Content-Type": "application/json",
        }

        # Set up the URL for updating the page properties
        url = f"https://api.notion.com/v1/pages/{page_id}"

        # Prepare the data payload with the properties to be updated
        data = {
            "properties": properties
        }

        # Make the HTTP request to update the page properties
        response = requests.patch(url, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated page properties as a JSON object
        else:
            # Handle the error case
            response.raise_for_status()

    # Example usage (do not include this in the script):
    # main(notion_resource={'access_token': 'secret_token', 'version': '2021-05-13'}, page_id='some-page-id', properties={'Name': {'title': [{'text': {'content': 'New Page Title'}}]}})
  good: |-
    from typing import TypedDict, Any, Dict
    import notion_client as notion_api

    class notion(TypedDict):
        access_token: str
        database_id: str

    def main(notion_resource: notion, page_id: str, properties_update: Dict[str, Any]):
        client = notion_api.Client(auth=notion_resource['access_token'])
        response = client.pages.update(page_id=page_id, properties=properties_update)
        return response
  id: |-
    synthetic_update-page
  instructions: |-
    Updates page property values for the specified page. Properties that are not set will remain unchanged. To append page content, use the *append block* action in notion
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        access_token: str
        database_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        token: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string, issueNumber: number) {
        const octokit = new Octokit({ auth: githubResource.token });

        const response = await octokit.issues.listAssignees({
            owner,
            repo,
            issue_number: issueNumber,
        });

        return response.data;
    }
  good: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string, issueNumber: number) {
        const octokit = new Octokit({ auth: githubResource.accessToken });

        const response = await octokit.issues.listAssignees({
            owner,
            repo,
            issue_number: issueNumber,
        });

        return response.data;
    }
  id: |-
    synthetic_get-issue-assignees
  instructions: |-
    Get assignees for an issue in a Gihub repo in github
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { FacebookGroups } from "npm:@types/facebook-js-sdk";

    type FacebookGroups = {
        accessToken: string;
    }

    export async function main(facebookGroupsResource: FacebookGroups, groupId: string, message: string) {
        const url = `https://graph.facebook.com/${groupId}/feed`;
        const params = {
            method: 'POST',
            body: JSON.stringify({
                message: message
            }),
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${facebookGroupsResource.accessToken}`
            }
        };

        const response = await fetch(url, params);
        const result = await response.json();

        return result;
    }
  good: |-
    import { FacebookGroupPost } from "npm:@types/facebook-js-sdk";

    type FacebookGroups = {
        accessToken: string;
        groupId: string;
    }

    export async function main(facebookGroupsResource: FacebookGroups, message: string, link?: string, imageUrl?: string): Promise<FacebookGroupPost> {
        const url = `https://graph.facebook.com/${facebookGroupsResource.groupId}/feed`;
        const body = new URLSearchParams({ message });

        if (link) {
            body.append('link', link);
        }

        if (imageUrl) {
            body.append('picture', imageUrl);
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${facebookGroupsResource.accessToken}`,
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: body.toString(),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-post
  instructions: |-
    Create a new post in a group in facebook groups
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FacebookGroups
  resource_type_def: |-
    type FacebookGroups = {
        accessToken: string;
        groupId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleDirectory = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        accessToken: string;
        refreshToken: string;
    }

    export async function main(googleDirectoryResource: GoogleDirectory, groupName: string, groupEmail: string, groupDescription: string) {
        const { clientId, clientSecret, redirectUri, accessToken, refreshToken } = googleDirectoryResource;

        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({
            access_token: accessToken,
            refresh_token: refreshToken,
        });

        const directory = google.admin({ version: 'directory_v1', auth: oauth2Client });

        const group = {
            email: groupEmail,
            name: groupName,
            description: groupDescription,
        };

        try {
            const result = await directory.groups.insert({
                requestBody: group
            });
            return result.data;
        } catch (error) {
            // Handle the error appropriately in your context
            throw error;
        }
    }
  good: |-
    import { admin_directory_v1, google } from "npm:googleapis";

    type GoogleDirectory = {
        clientEmail: string;
        privateKey: string;
        domain: string;
    }

    export async function main(googleDirectoryResource: GoogleDirectory, groupName: string, groupEmail: string, description?: string) {
        const { clientEmail, privateKey, domain } = googleDirectoryResource;

        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            ['https://www.googleapis.com/auth/admin.directory.group'],
            `admin@${domain}`
        );

        const directory = google.admin({ version: 'directory_v1', auth: jwtClient });

        const group = {
            email: groupEmail,
            name: groupName,
            description: description || '',
        };

        try {
            const result = await directory.groups.insert({ requestBody: group });
            return result.data;
        } catch (error) {
            // Handle the error appropriately in your context
            throw error;
        }
    }
  id: |-
    synthetic_create-group
  instructions: |-
    Creates a new group in google directory
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDirectory
  resource_type_def: |-
    type GoogleDirectory = {
        clientEmail: string;
        privateKey: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Imgur API

    class imgur(TypedDict):
        client_id: str
        client_secret: str
        access_token: str

    def main(imgur_resource: imgur, image_path: str, title: str = "", description: str = "") -> dict:
        headers = {
            'Authorization': f'Bearer {imgur_resource["access_token"]}'
        }
        data = {
            'title': title,
            'description': description
        }
        with open(image_path, 'rb') as image_file:
            files = {
                'image': image_file
            }
            response = requests.post('https://api.imgur.com/3/upload', headers=headers, data=data, files=files)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests

    class imgur(TypedDict):
        client_id: str
        access_token: str

    def main(imgur_resource: imgur, image_path: str, title: str = "", description: str = ""):
        headers = {
            'Authorization': f'Bearer {imgur_resource["access_token"]}'
        }
        data = {
            'title': title,
            'description': description
        }
        with open(image_path, 'rb') as image_file:
            files = {
                'image': image_file
            }
            response = requests.post('https://api.imgur.com/3/upload', headers=headers, data=data, files=files)
        return response.json()
  id: |-
    synthetic_upload-image
  instructions: |-
    Upload an image to Imgur in imgur
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    imgur
  resource_type_def: |-
    class imgur(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ImageAnnotatorClient } from "npm:@google-cloud/vision";

    type HuggingFace = {
        apiKey: string;
    }

    export async function main(huggingFaceResource: HuggingFace, imageUrl: string) {
        const client = new ImageAnnotatorClient({
            credentials: {
                api_key: huggingFaceResource.apiKey,
            },
        });

        const [result] = await client.objectLocalization({
            image: {
                source: { imageUri: imageUrl },
            },
        });

        const objects = result.localizedObjectAnnotations;
        const detectedObjects = objects.map(object => ({
            name: object.name,
            score: object.score,
            boundingPoly: object.boundingPoly,
        }));

        return detectedObjects;
    }
  good: |-
    // Importing necessary libraries
    import { HuggingFace } from "npm:@huggingface/node-question-answering";

    type HuggingFaceResource = {
        apiKey: string,
        model: string
    }

    export async function main(huggingFaceResource: HuggingFaceResource, imageUrl: string) {
        // Initialize the HuggingFace client with the API key
        const huggingFaceClient = new HuggingFace({ apiKey: huggingFaceResource.apiKey });

        // Prepare the payload for the request
        const payload = {
            inputs: {
                image: imageUrl
            },
            options: {
                wait_for_model: true
            }
        };

        // Send the request to the HuggingFace API to get predictions
        const response = await huggingFaceClient.predict(huggingFaceResource.model, payload);

        // Return the result which includes likelihood of classes and bounding boxes
        return response;
    }
  id: |-
    synthetic_object-detection
  instructions: |-
    This task reads some image input and outputs the likelihood of classes and bounding boxes of detected objects. in hugging face
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HuggingFace
  resource_type_def: |-
    type HuggingFace = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import dropbox as dbx_module

    class dropbox(TypedDict):
        access_token: str

    def main(dropbox: dropbox, path: str, settings: Optional[dbx_module.sharing.SharedLinkSettings] = None):
        dbx = dbx_module.Dropbox(dropbox['access_token'])

        # Check if a shared link already exists for the given path
        shared_links = dbx.sharing_list_shared_links(path=path).links
        shared_link_url = None
        if shared_links:
            # If a shared link exists, update its settings if settings are provided
            shared_link_url = shared_links[0].url
            if settings:
                dbx.sharing_modify_shared_link_settings(shared_link_url, settings)
        else:
            # If no shared link exists, create one with the provided settings
            shared_link_metadata = dbx.sharing_create_shared_link_with_settings(path, settings)
            shared_link_url = shared_link_metadata.url

        return shared_link_url
  good: |-
    from typing import TypedDict
    import dropbox

    class dropbox_resource(TypedDict):
        access_token: str

    def main(dropbox_resource: dropbox_resource, path: str, settings: Optional[dropbox.sharing.SharedLinkSettings] = None):
        dbx = dropbox.Dropbox(dropbox_resource['access_token'])

        # Check if a shared link already exists for the file/folder
        try:
            links = dbx.sharing_list_shared_links(path=path).links
            if links:
                # If a shared link exists, return the first one
                return links[0].url
        except dropbox.exceptions.ApiError as err:
            # Handle the error if something goes wrong
            print(f"API Error: {err}")
            return None

        # If no shared link exists, create one
        try:
            shared_link_metadata = dbx.sharing_create_shared_link_with_settings(path, settings)
            return shared_link_metadata.url
        except dropbox.exceptions.ApiError as err:
            # Handle the error if something goes wrong
            print(f"API Error: {err}")
            return None
  id: |-
    synthetic_create-update-share-link
  instructions: |-
    Creates or updates a public share link to the file or folder (It allows to share the file or folder with anyone) in dropbox
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dropbox
  resource_type_def: |-
    class dropbox(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign) -> List[Dict]:
        api_endpoint = f"{activecampaign_resource['api_url']}/api/3/lists"
        headers = {
            "Api-Token": activecampaign_resource['api_key']
        }

        response = requests.get(api_endpoint, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        return response.json().get('lists', [])

    # The script ends here, with the main function defined and ready to be used.
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign) -> List[dict]:
        endpoint = f"{activecampaign_resource['api_url'].rstrip('/')}/api/3/lists"
        headers = {
            "Api-Token": activecampaign_resource['api_key']
        }

        response = requests.get(endpoint, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json().get('lists', [])
  id: |-
    synthetic_get-all-lists
  instructions: |-
    Retrieves all lists. See the docs in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the fibery integration
    class fibery(TypedDict):
        api_token: str
        workspace_name: str

    # Main function to create an entity in Fibery
    def main(fibery_resource: fibery, entity_type: str, fields: Dict[str, Any]):
        import requests  # Import here to avoid conflicts with parameter names

        # Construct the API URL
        api_url = f"https://{fibery_resource['workspace_name']}.fibery.io/api/commands"

        # Prepare headers for the request
        headers = {
            "Authorization": f"Token {fibery_resource['api_token']}",
            "Content-Type": "application/json",
        }

        # Prepare the payload for creating the entity
        payload = {
            "command": "fibery.entity/create",
            "args": {
                "type": entity_type,
                "fields": fields
            }
        }

        # Make the request to create the entity
        response = requests.post(api_url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the response as a JSON object
        else:
            raise Exception(f"Error creating entity in Fibery: {response.text}")

    # Example usage:
    # result = main(fibery_resource={'api_token': 'your_api_token', 'workspace_name': 'your_workspace_name'},
    #               entity_type='App/Type',
    #               fields={'Title': 'New Entity', 'Description': 'Details of the new entity'})
    # print(result)
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Fibery API

    class fibery(TypedDict):
        api_url: str
        token: str

    def main(fibery_resource: fibery, entity_type: str, fields: Dict[str, Any]) -> Dict[str, Any]:
        headers = {
            'Authorization': f"Token {fibery_resource['token']}",
            'Content-Type': 'application/json'
        }
        url = f"{fibery_resource['api_url']}/api/commands"
        payload = {
            'command': 'fibery.entity/create',
            'args': {
                'type': entity_type,
                'fields': fields
            }
        }
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses
        return response.json()
  id: |-
    synthetic_create-entity
  instructions: |-
    Creates a new entity in fibery
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    fibery
  resource_type_def: |-
    class fibery(TypedDict):
        api_token: str
        workspace_name: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { LapostaClient } from "npm:laposta"; // Assuming there's an npm package for Laposta

    type Laposta = {
        apiKey: string;
    }

    export async function main(
        lapostaResource: Laposta,
        relationId: string,
        fieldsToUpdate: Record<string, any>
    ) {
        const laposta = new LapostaClient(lapostaResource.apiKey);
        const result = await laposta.updateRelation(relationId, fieldsToUpdate);
        return result;
    }
  good: |-
    import { LapostaClient as LapostaApiClient } from "npm:laposta"; // Renamed to avoid conflict with the resource type

    type Laposta = {
        apiKey: string;
    }

    export async function main(lapostaResource: Laposta, relationId: string, fieldsToUpdate: Record<string, any>) {
        const client = new LapostaApiClient(lapostaResource.apiKey);

        try {
            const response = await client.updateRelation(relationId, fieldsToUpdate);
            return response;
        } catch (error) {
            console.error('Failed to update relation:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-relation
  instructions: |-
    Updates a relation in laposta
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Laposta
  resource_type_def: |-
    type Laposta = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createTransport } from "npm:nodemailer";
    import * as smtpTransport from "npm:nodemailer-smtp-transport";

    type Mandrill = {
        apiKey: string,
        host: string,
        port: number,
        secure: boolean // true for 465, false for other ports
    }

    export async function main(
        mandrillResource: Mandrill,
        fromEmail: string,
        toEmail: string,
        subject: string,
        htmlBody: string,
        textBody?: string
    ) {
        const transporter = createTransport(smtpTransport({
            host: mandrillResource.host,
            port: mandrillResource.port,
            secure: mandrillResource.secure,
            auth: {
                user: 'apikey', // Mandrill uses 'apikey' as the user for SMTP authentication
                pass: mandrillResource.apiKey
            }
        }));

        const mailOptions = {
            from: fromEmail,
            to: toEmail,
            subject: subject,
            text: textBody,
            html: htmlBody
        };

        try {
            const info = await transporter.sendMail(mailOptions);
            return info;
        } catch (error) {
            throw error;
        }
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Mandrill = {
        apiKey: string;
    }

    export async function main(
        mandrillResource: Mandrill,
        toEmail: string,
        toName: string,
        fromEmail: string,
        fromName: string,
        subject: string,
        htmlContent: string,
        textContent: string,
        tags: string[] = []
    ) {
        const url = 'https://mandrillapp.com/api/1.0/messages/send.json';
        const headers = new Headers({
            'Content-Type': 'application/json',
            'Authorization': `Basic ${encode(`:${mandrillResource.apiKey}`)}`
        });

        const body = JSON.stringify({
            key: mandrillResource.apiKey,
            message: {
                html: htmlContent,
                text: textContent,
                subject: subject,
                from_email: fromEmail,
                from_name: fromName,
                to: [
                    {
                        email: toEmail,
                        name: toName,
                        type: 'to'
                    }
                ],
                tags: tags
            }
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_send-email
  instructions: |-
    Send an email using Mandrill. See API docs here: https://mandrillapp.com/api/docs/messages.curl.html#method=send in mandrill
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mandrill
  resource_type_def: |-
    type Mandrill = {
        apiKey: string,
        host: string,
        port: number,
        secure: boolean // true for 465, false for other ports
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Lead as CloseLead } from "npm:@close.io/client"; // Renamed to avoid conflict with the resource type

    type Close = {
        apiKey: string;
    }

    export async function main(closeResource: Close, searchTerm: string) {
        const closeClient = new CloseLead({ apiKey: closeResource.apiKey });

        const leads = await closeClient.searchLeads(searchTerm);

        return leads;
    }
  good: |-
    import { LeadSearchResponse, listLeads } from "npm:@close.io/closeio";

    type Close = {
        apiKey: string;
    }

    export async function main(closeResource: Close, searchField: string, searchWord: string): Promise<LeadSearchResponse> {
        const closeIo = new listLeads({ apiKey: closeResource.apiKey });

        const query = `${searchField}:"${searchWord}"`;
        const leads = await closeIo({ query });

        return leads;
    }
  id: |-
    synthetic_search-leads
  instructions: |-
    Searching leads with a given field and word, in close
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Close
  resource_type_def: |-
    type Close = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the 'ahrefs' integration
    class ahrefs(TypedDict):
        access_token: str
        account_id: str

    # Define the main function for the 'ahrefs' integration
    def main(ahrefs_resource: ahrefs, target_url: str, max_backlinks: int = 100) -> List[str]:
        # Import the necessary library for HTTP requests
        import requests

        # Define the API endpoint for getting backlinks
        endpoint = "https://apiv2.ahrefs.com"

        # Prepare the parameters for the API request
        params = {
            'token': ahrefs_resource['access_token'],
            'target': target_url,
            'limit': max_backlinks,
            'mode': 'domain',
            'output': 'json'
        }

        # Make the API request to get backlinks
        response = requests.get(f"{endpoint}/backlinks/one_per_domain", params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            # Extract the backlinks
            backlinks = [link['url_from'] for link in data['backlinks']]
            return backlinks
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function does not call itself, it's meant to be exported and used with the specified parameters.
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is the library used for HTTP requests

    # Define the resource type for the ahrefs integration
    class ahrefs(TypedDict):
        access_token: str
        target: str

    # Define the type for the backlink details
    class BacklinkDetail(TypedDict):
        referring_page_url: str
        anchor: str
        page_title: str
        ahrefs_rank: int

    def main(ahrefs_resource: ahrefs, limit: int = 1) -> List[BacklinkDetail]:
        # Prepare the API endpoint and headers for the request
        endpoint = f"https://apiv2.ahrefs.com?from=backlinks&target={ahrefs_resource['target']}&limit={limit}&order_by=ahrefs_rank:desc&output=json"
        headers = {
            "Authorization": f"Bearer {ahrefs_resource['access_token']}"
        }

        # Make the request to the ahrefs API
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            data = response.json()
            backlinks = data.get('refpages', [])

            # Extract the required details from each backlink
            backlink_details = [
                {
                    'referring_page_url': backlink['referring_page'],
                    'anchor': backlink['anchor'],
                    'page_title': backlink['page_title'],
                    'ahrefs_rank': backlink['ahrefs_rank']
                }
                for backlink in backlinks
            ]

            return backlink_details
        else:
            # Handle the error case
            response.raise_for_status()

    # Note: The function is not called here, it is just defined and ready to be exported.
  id: |-
    synthetic_get-backlinks-one-per-domain
  instructions: |-
    Get one backlink with the highest `ahrefs_rank` per referring domain for a target URL or domain (with details for the referring pages including anchor and page title). in ahrefs
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ahrefs
  resource_type_def: |-
    class ahrefs(TypedDict):
        access_token: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@asana";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, searchQuery: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);
        const searchResults = await client.workspaces.searchForTasks({
            query: searchQuery,
        });

        return searchResults;
    }
  good: |-
    import { Client } from "npm:@asana";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, projectName: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);
        const workspaces = await client.workspaces.findAll();

        for (const workspace of workspaces.data) {
            const projects = await client.projects.findByWorkspace(workspace.gid);
            for (const project of projects.data) {
                if (project.name === projectName) {
                    return project;
                }
            }
        }

        throw new Error(`Project with name "${projectName}" not found.`);
    }
  id: |-
    synthetic_search-projects
  instructions: |-
    Finds an existing project in asana
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asana
  resource_type_def: |-
    type Asana = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class figma(TypedDict):
        personal_access_token: str
        file_key: str

    def main(figma_resource: figma, file_key: str, comment: str, client_version: str):
        headers = {
            "X-Figma-Token": figma_resource['personal_access_token']
        }
        payload = {
            "message": comment,
            "client_version": client_version
        }
        url = f"https://api.figma.com/v1/files/{file_key}/comments"

        response = requests.post(url, headers=headers, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the Figma integration
    class figma(TypedDict):
        personal_access_token: str

    # Define the main function for posting a comment to a Figma file
    def main(figma_resource: figma, file_id: str, node_id: str, comment_text: str):
        import requests  # Import requests or any other HTTP library if needed

        # Construct the URL for the Figma API endpoint to post a comment
        url = f"https://api.figma.com/v1/files/{file_id}/comments"

        # Set up the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {figma_resource['personal_access_token']}"
        }

        # Define the payload for the POST request
        payload = {
            "message": comment_text,
            "node_id": node_id
        }

        # Make the POST request to the Figma API
        response = requests.post(url, headers=headers, json=payload)

        # Check if the request was successful and return the result
        if response.status_code == 201:
            return response.json()  # Return the JSON response if the comment was posted successfully
        else:
            raise Exception(f"Failed to post comment: {response.status_code} - {response.text}")

    # Example usage:
    # result = main(figma_resource={'personal_access_token': 'YOUR_TOKEN'}, file_id='YOUR_FILE_ID', node_id='YOUR_NODE_ID', comment_text='Your comment here')
    # print(result)
  id: |-
    synthetic_post-a-comment
  instructions: |-
    Posts a comment to a file in figma
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    figma
  resource_type_def: |-
    class figma(TypedDict):
        personal_access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the Microsoft Entra API

    class microsoft_entra_id(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
        access_token: str  # Assuming the OAuth2 token is provided

    def main(microsoft_entra_id_resource: microsoft_entra_id, search_query: str) -> List[dict]:
        base_url = f"https://graph.microsoft.com/v1.0/{microsoft_entra_id_resource['tenant_id']}/groups"
        headers = {
            "Authorization": f"Bearer {microsoft_entra_id_resource['access_token']}"
        }
        params = {
            "$filter": f"startswith(displayName, '{search_query}') or startswith(description, '{search_query}')"
        }

        response = requests.get(base_url, headers=headers, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json().get('value', [])

    # The main function is now defined and can be used with the appropriate microsoft_entra_id resource and search query.
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the microsoft_entra_id integration
    class microsoft_entra_id(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str

    # Define the main function with the resource type and additional parameters
    def main(microsoft_entra_id_resource: microsoft_entra_id, access_token: str, search_query: str) -> List[dict]:
        # Construct the API endpoint for searching groups
        endpoint = f"https://graph.microsoft.com/v1.0/groups?$search=\"{search_query}\""

        # Set up the headers with the authorization
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make the API call to search groups
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON to get the groups data
            groups_data = response.json().get('value', [])
            return groups_data
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()
  id: |-
    synthetic_search-groups
  instructions: |-
    Searches for groups by name or description in microsoft entra id
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_entra_id
  resource_type_def: |-
    class microsoft_entra_id(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to ConvertKit API

    class convertkit(TypedDict):
        api_secret: str
        api_key: str

    def main(convertkit_resource: convertkit, form_id: int, email: str, first_name: str = '', tags: list[str] = []):
        url = f"https://api.convertkit.com/v3/forms/{form_id}/subscribe"
        payload = {
            'email': email,
            'first_name': first_name,
            'api_key': convertkit_resource['api_key'],
            'tags': tags
        }
        response = requests.post(url, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the ConvertKit integration
    class convertkit(TypedDict):
        api_secret: str
        api_key: str

    # Define the main function to add a subscriber to a form
    def main(convertkit_resource: convertkit, form_id: int, email: str, first_name: str = '', tags: list[str] = []):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for adding a subscriber to a form
        endpoint = f"https://api.convertkit.com/v3/forms/{form_id}/subscribe"

        # Prepare the payload with the subscriber's information
        payload = {
            'email': email,
            'first_name': first_name,
            'api_key': convertkit_resource['api_key'],
            'tags': tags
        }

        # Make the POST request to add the subscriber
        response = requests.post(endpoint, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the response as JSON if successful
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # The main function is now defined and ready to be used with the required parameters.
  id: |-
    synthetic_add-subscriber-to-form
  instructions: |-
    Add subscriber to a form in convertkit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    convertkit
  resource_type_def: |-
    class convertkit(TypedDict):
        api_secret: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { MetatextAiPreBuildAiModelsApi } from "npm:@metatext/ai"; // Assuming this is the correct npm package

    // Define the resource type for the MetatextAiPreBuildAiModelsApi integration
    type MetatextAiPreBuildAiModelsApiResource = {
        apiKey: string;
        endpointUrl: string;
    }

    // Define the function signature with the resource and the text to analyze
    export async function main(
        metatextResource: MetatextAiPreBuildAiModelsApiResource,
        textToAnalyze: string
    ) {
        // Initialize the Metatext API client with the provided credentials
        const metatextClient = new MetatextAiPreBuildAiModelsApi({
            apiKey: metatextResource.apiKey,
            endpointUrl: metatextResource.endpointUrl
        });

        // Call the sentiment analysis method from the Metatext API
        const response = await metatextClient.sentimentAnalysis(textToAnalyze);

        // Return the sentiment analysis result
        return response;
    }
  good: |-
    import { SentimentAnalysisResponse } from "npm:@metatext.ai/prebuild-ai-models-api";
    import { Client } from "npm:@metatext.ai/prebuild-ai-models-api";

    type MetatextAiPreBuildAiModelsApi = {
        apiKey: string;
    }

    export async function main(
        metatextResource: MetatextAiPreBuildAiModelsApi,
        textToAnalyze: string
    ): Promise<SentimentAnalysisResponse> {
        const client = new Client(metatextResource.apiKey);
        const sentimentResponse = await client.sentimentAnalysis(textToAnalyze);
        return sentimentResponse;
    }
  id: |-
    synthetic_analyze-sentiment
  instructions: |-
    Determine the sentiment of the given text (positive, negative, or neutral). in metatext ai pre build ai models api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MetatextAiPreBuildAiModelsApi
  resource_type_def: |-
    type MetatextAiPreBuildAiModelsApi = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks/models";

    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, viewName: string) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(tableName);
        const view = table.getView(viewName);
        const records = await view.selectRecordsAsync();

        return records.records.map(record => record.getCellValueMap());
    }
  good: |-
    // Import any libraries you need here
    import { Base, Table, Record, FieldSet, Records } from "npm:@airtable/blocks/models";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }

    export async function main(
        airtableResource: AirtableOauth,
        tableName: string,
        viewName: string,
        sortField?: string,
        sortOrder?: 'asc' | 'desc',
        filterByFormula?: string
    ): Promise<Record<FieldSet>[]> {
        // Initialize Airtable base with the provided credentials
        const base = new Base({ apiKey: airtableResource.apiKey, baseId: airtableResource.baseId });
        const table = new Table(base, tableName);

        // Prepare the options for the select method
        const selectOptions: any = {
            view: viewName
        };

        if (sortField && sortOrder) {
            selectOptions.sort = [{ field: sortField, direction: sortOrder }];
        }

        if (filterByFormula) {
            selectOptions.filterByFormula = filterByFormula;
        }

        // Retrieve records with automatic pagination
        const records: Record<FieldSet>[] = [];
        let queryResult = await table.select(selectOptions).firstPage();

        while (queryResult) {
            records.push(...queryResult);
            queryResult = await queryResult.nextPage();
        }

        // Always return the result
        return records;
    }
  id: |-
    synthetic_list-records-in-view
  instructions: |-
    Retrieve records in a view with automatic pagination. Optionally sort and filter results. Only available for Enterprise accounts. in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls

    class github(TypedDict):
        access_token: str

    def main(github_resource: github, username: str) -> List[dict]:
        headers = {
            'Authorization': f'token {github_resource["access_token"]}',
            'Accept': 'application/vnd.github.v3+json'
        }
        url = f'https://api.github.com/users/{username}/gists'
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests library is used for HTTP requests

    class github(TypedDict):
        access_token: str

    def main(github_resource: github, username: str) -> List[dict]:
        headers = {
            'Authorization': f'token {github_resource["access_token"]}',
            'Accept': 'application/vnd.github.v3+json'
        }
        url = f'https://api.github.com/users/{username}/gists'
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()

    # The script ends here. The function main can now be exported and used with the required parameters.
  id: |-
    synthetic_list-gists-for-a-user
  instructions: |-
    Lists public gists for the specified user in github
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/base64";

    type Klazify = {
        apiKey: string;
    }

    export async function main(klazifyResource: Klazify, websiteUrl: string) {
        const apiUrl = 'https://api.klazify.com/v1/categorize';
        const headers = {
            'Authorization': `Basic ${encode(klazifyResource.apiKey)}`,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({ url: websiteUrl });

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  good: |-
    import { KlazifyClient as KlazifyApiClient } from "npm:klazify";

    type Klazify = {
        apiKey: string;
    }

    export async function main(klazifyResource: Klazify, websiteUrl: string) {
        const klazifyClient = new KlazifyApiClient(klazifyResource.apiKey);
        const categories = await klazifyClient.categorizeWebsite(websiteUrl);
        return categories;
    }
  id: |-
    synthetic_categorize-website
  instructions: |-
    Submit a website URL for categorization by the API. in klazify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Klazify
  resource_type_def: |-
    type Klazify = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP requests to the Outlook Calendar API

    # Define the resource type for the microsoft_outlook_calendar integration
    class microsoft_outlook_calendar(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(microsoft_outlook_calendar_resource: microsoft_outlook_calendar, event_id: str) -> dict:
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {microsoft_outlook_calendar_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Define the URL for deleting a calendar event in Microsoft Outlook Calendar
        url = f"https://graph.microsoft.com/v1.0/me/events/{event_id}"

        # Make the HTTP DELETE request to delete the event
        response = requests.delete(url, headers=headers)

        # Return the response as a dictionary
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the microsoft_outlook_calendar integration
    class microsoft_outlook_calendar(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Import any libraries you need here
    import requests  # Used for making HTTP requests

    # Define the main function
    def main(microsoft_outlook_calendar_resource: microsoft_outlook_calendar, event_id: str) -> dict:
        # Set up the headers for the HTTP request
        headers = {
            'Authorization': f"Bearer {microsoft_outlook_calendar_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Define the URL for deleting an event in the default calendar
        url = f"https://graph.microsoft.com/v1.0/me/events/{event_id}"

        # Make the HTTP DELETE request to delete the event
        response = requests.delete(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 204:
            return {"success": True, "message": "Event deleted successfully."}
        else:
            return {"success": False, "message": "Failed to delete the event.", "error": response.json()}

    # Note: The function does not call itself, it's meant to be exported and used with the specified parameters.
  id: |-
    synthetic_delete-calendar-event
  instructions: |-
    Delete an event in the user's default calendar in microsoft outlook calendar
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_outlook_calendar
  resource_type_def: |-
    class microsoft_outlook_calendar(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type ConstantContact = {
        apiKey: string;
        accessToken: string;
        apiEndpoint: string; // e.g., "https://api.constantcontact.com/v2"
    }

    export async function main(
        constantContactResource: ConstantContact,
        contactId: string,
        updatedContactData: {
            email: string;
            firstName?: string;
            lastName?: string;
            customFields?: Record<string, string>;
        }
    ) {
        // Construct the authorization header using the API key and access token
        const authHeader = `Basic ${encode(`${constantContactResource.apiKey}:${constantContactResource.accessToken}`)}`;

        // Construct the URL for updating the contact
        const updateUrl = `${constantContactResource.apiEndpoint}/contacts/${contactId}?api_key=${constantContactResource.apiKey}`;

        // Prepare the payload for the update request
        const payload = {
            email_addresses: [{ email_address: updatedContactData.email }],
            first_name: updatedContactData.firstName,
            last_name: updatedContactData.lastName,
            custom_fields: updatedContactData.customFields
                ? Object.entries(updatedContactData.customFields).map(([key, value]) => ({ label: key, value }))
                : undefined
        };

        // Make the PUT request to update the contact
        const response = await fetch(updateUrl, {
            method: 'PUT',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        // Check if the request was successful
        if (!response.ok) {
            // If not successful, throw an error with the status
            throw new Error(`Failed to update contact: ${response.status} ${response.statusText}`);
        }

        // Parse the response body as JSON
        const updatedContact = await response.json();

        // Return the updated contact information
        return updatedContact;
    }
  good: |-
    import { ConstantContact as ConstantContactClient } from "npm:@hutsoninc/constant-contact";

    type ConstantContact = {
        apiKey: string;
        accessToken: string;
        apiEndpoint?: string;
    }

    export async function main(
        constantContact: ConstantContact,
        contactId: string,
        updateFields: { email: string; firstName?: string; lastName?: string; listIds?: string[] }
    ) {
        const client = new ConstantContactClient(
            constantContact.apiKey,
            constantContact.accessToken,
            constantContact.apiEndpoint
        );

        const updatedContact = await client.updateContact(contactId, updateFields);

        return updatedContact;
    }
  id: |-
    synthetic_update-contact
  instructions: |-
    Update an existing contact in constant contact
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    ConstantContact
  resource_type_def: |-
    type ConstantContact = {
        apiKey: string;
        accessToken: string;
        apiEndpoint?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AgileCrmClient as AgileCrmApiClient } from "npm:agilecrm";

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, dealName: string, dealValue: number, dealCurrency: string, contactEmail: string) {
        const client = new AgileCrmApiClient(agileCrmResource.domain, agileCrmResource.email, agileCrmResource.apiKey);

        const deal = {
            name: dealName,
            expected_value: dealValue,
            currency: dealCurrency,
            contact_email: contactEmail
        };

        try {
            const result = await client.deals.create(deal);
            return result;
        } catch (error) {
            console.error('Failed to create deal in AgileCRM:', error);
            throw error;
        }
    }
  good: |-
    import { AgileCrmClient } from "npm:agile-crm-wrapper";

    type AgileCrm = {
        apiKey: string;
        email: string;
        domain: string;
    }

    export async function main(agileCrmResource: AgileCrm, dealName: string, dealValue: number, dealCurrency: string, contactEmail: string) {
        const client = new AgileCrmClient({
            apiKey: agileCrmResource.apiKey,
            email: agileCrmResource.email,
            domain: agileCrmResource.domain
        });

        const deal = {
            name: dealName,
            expected_value: dealValue,
            currency: dealCurrency,
            contact_email: contactEmail
        };

        try {
            const result = await client.deals.create(deal);
            return result;
        } catch (error) {
            console.error('Failed to create a new deal in Agile CRM:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-deal
  instructions: |-
    Create a new deal in Agile CRM in agile crm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AgileCrm
  resource_type_def: |-
    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Clickup = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(
        clickupResource: Clickup,
        taskId: string,
        customFieldId: string,
        customFieldValue: string | number | boolean
    ) {
        const url = `https://api.clickup.com/api/v2/task/${taskId}/field/${customFieldId}`;
        const headers = {
            "Authorization": clickupResource.apiKey,
            "Content-Type": "application/json"
        };
        const body = JSON.stringify({
            value: customFieldValue
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error setting custom field value: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { ClickUp as ClickUpAPI } from "npm:clickup-api";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, taskId: string, customFieldId: string, fieldValue: any) {
        const clickup = new ClickUpAPI(clickupResource.apiKey);

        const result = await clickup.Tasks.update_custom_field(taskId, customFieldId, fieldValue);

        return result;
    }
  id: |-
    synthetic_update-task-custom-field
  instructions: |-
    Update custom field value of a task. See the docs in **Custom Fields / Set Custom Field Value** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:airtable";

    type Airtable = {
        apiKey: string;
        baseId: string;
    }

    export async function main(airtableResource: Airtable, tableName: string, recordId: string, fieldsToUpdate: { [key: string]: any }) {
        const base = new Base({ apiKey: airtableResource.apiKey })(airtableResource.baseId);
        const table = base(tableName);

        try {
            const updatedRecord = await table.update(recordId, fieldsToUpdate);
            return updatedRecord;
        } catch (error) {
            console.error('Error updating record in Airtable:', error);
            throw error;
        }
    }
  good: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableResource = {
        apiKey: string;
        baseId: string;
        tableName: string;
    }

    export async function main(airtableResource: AirtableResource, recordId: string, updatedFields: { [fieldName: string]: any }) {
        const { apiKey, baseId, tableName } = airtableResource;
        const endpoint = `https://api.airtable.com/v0/${baseId}/${encodeURIComponent(tableName)}/${recordId}`;
        const headers = {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(endpoint, {
            method: 'PATCH',
            headers: headers,
            body: JSON.stringify({ fields: updatedFields })
        });

        if (!response.ok) {
            throw new Error(`Error updating record: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_update-record
  instructions: |-
    Update a single record in a table by Record ID. in airtable
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
        apiKey: string;
        baseId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { OAuth2Client } from "npm:google-auth-library";

    type GoogleDirectory = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDirectoryResource: GoogleDirectory, userEmail: string) {
        // Initialize OAuth2 client
        const oAuth2Client = new OAuth2Client(
            googleDirectoryResource.clientId,
            googleDirectoryResource.clientSecret,
            googleDirectoryResource.redirectUri
        );

        // Set credentials for the OAuth2 client
        oAuth2Client.setCredentials({
            refresh_token: googleDirectoryResource.refreshToken
        });

        // Define the Google Directory API endpoint
        const apiEndpoint = `https://www.googleapis.com/admin/directory/v1/users/${encodeURIComponent(userEmail)}`;

        // Retrieve user information from Google Directory
        const response = await fetch(apiEndpoint, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${(await oAuth2Client.getAccessToken()).token}`
            }
        });

        // Check for a successful response
        if (!response.ok) {
            throw new Error(`Failed to retrieve user information: ${response.status} ${response.statusText}`);
        }

        // Parse the response body as JSON
        const userInfo = await response.json();

        // Return the user information
        return userInfo;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleDirectory = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        accessToken: string;
        refreshToken: string;
    }

    export async function main(googleDirectoryResource: GoogleDirectory, userEmail: string) {
        const { clientId, clientSecret, redirectUri, accessToken, refreshToken } = googleDirectoryResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({
            access_token: accessToken,
            refresh_token: refreshToken,
        });

        const directory = google.admin({ version: 'directory_v1', auth: oauth2Client });
        const user = await directory.users.get({
            userKey: userEmail,
        });

        return user.data;
    }
  id: |-
    synthetic_get-user
  instructions: |-
    Retrieves information about a user in google directory
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDirectory
  resource_type_def: |-
    type GoogleDirectory = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        accessToken: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, campaign_id: str) -> dict:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        endpoint = f"/campaigns/{campaign_id}"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        response = requests.get(f"{base_url}{endpoint}", headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    # Define the resource type for the Mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # Mailchimp API endpoints are prefixed with a server identifier

    def main(mailchimp_resource: mailchimp, campaign_id: str) -> Dict[str, Any]:
        # Base URL for Mailchimp API, constructed using the server prefix from the resource
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"

        # Endpoint for getting a specific campaign
        campaign_endpoint = f"{base_url}/campaigns/{campaign_id}"

        # Mailchimp API authentication via HTTP Basic Auth, using 'anystring' as username and API key as password
        auth = ('anystring', mailchimp_resource['api_key'])

        # Make the HTTP GET request to retrieve the campaign
        response = requests.get(campaign_endpoint, auth=auth)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the campaign data as JSON
            return response.json()
        else:
            # Handle errors (e.g., campaign not found, authentication error)
            response.raise_for_status()
  id: |-
    synthetic_get-campaign
  instructions: |-
    Gets metadata of a specific campaign in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # Mailchimp API endpoints are prefixed with a server identifier
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the jw_player integration
    class jw_player(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating media on JW Player platform
    def main(jw_player_credentials: jw_player, media_file_path: str, title: str, description: str = "") -> Any:
        # Import the necessary library for JW Player API interaction
        from jwplatform import Client

        # Create a JW Platform client instance using the provided credentials
        jw_client = Client(jw_player_credentials['api_key'], jw_player_credentials['api_secret'])

        # Create a video object on JW Player
        video_create_response = jw_client.videos.create(
            title=title,
            description=description
        )

        # Extract the upload URL and path from the response
        upload_url = video_create_response['link']
        upload_path = video_create_response['path']

        # Upload the media file to JW Player
        with open(media_file_path, 'rb') as media_file:
            files = {'file': media_file}
            upload_response = jw_client.videos.upload(upload_path, upload_url, files)

        # Return the response from the upload process
        return upload_response

    # Note: The script assumes that the 'jwplatform' library is installed and available for import.
    # The user must provide the 'media_file_path', 'title', and optionally 'description' when calling the main function.
  good: |-
    from typing import TypedDict, Optional
    import requests

    class jw_player(TypedDict):
        api_key: str
        api_secret: str
        site_id: str

    def main(jw_player_resource: jw_player, media_url: str, title: str, description: Optional[str] = None, fetch: bool = True):
        base_url = "https://api.jwplayer.com/v2/sites/{site_id}/media/"
        headers = {
            "Authorization": f"Bearer {jw_player_resource['api_secret']}",
            "Content-Type": "application/json"
        }
        payload = {
            "upload": {
                "method": "fetch" if fetch else "external"
            },
            "metadata": {
                "title": title,
                "description": description or ""
            }
        }
        if fetch:
            payload["upload"]["download_url"] = media_url
        else:
            payload["upload"]["external_method"] = "single"

        response = requests.post(base_url.format(site_id=jw_player_resource['site_id']), json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_create-media
  instructions: |-
    Creates a new media file in JW Player using fetch or external upload methods in jw player
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jw_player
  resource_type_def: |-
    class jw_player(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Hostaway } from "npm:hostaway";

    type Hostaway = {
        apiKey: string;
        accountId: string;
    }

    export async function main(hostawayResource: Hostaway, guestId: number, message: string) {
        // Initialize the Hostaway API client
        const hostawayClient = new Hostaway({
            apiKey: hostawayResource.apiKey,
            accountId: hostawayResource.accountId
        });

        // Send a message to the guest
        const response = await hostawayClient.sendMessageToGuest(guestId, message);

        // Return the result
        return response;
    }
  good: |-
    // Importing necessary libraries
    import { HostawayApi } from "npm:hostaway";

    type Hostaway = {
        apiKey: string,
        accountId: string
    }

    export async function main(hostawayResource: Hostaway, guestId: number, listingId: number, message: string) {
        // Initialize the Hostaway API client
        const hostawayApi = new HostawayApi({
            apiKey: hostawayResource.apiKey,
            accountId: hostawayResource.accountId
        });

        // Send a conversation message to the guest
        const response = await hostawayApi.sendMessage(guestId, listingId, message);

        // Return the result
        return response;
    }
  id: |-
    synthetic_send-message-to-guest
  instructions: |-
    Send a conversation message to a guest in Hostaway in hostaway
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hostaway
  resource_type_def: |-
    type Hostaway = {
        apiKey: string;
        accountId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { verify } from "npm:email-verifier";

    type Bouncer = {
        apiKey: string;
    }

    export async function main(bouncerResource: Bouncer, emailToVerify: string) {
        const verifier = new verify(bouncerResource.apiKey);
        const result = await verifier.verify(emailToVerify);
        return result;
    }
  good: |-
    import { verify as verifyEmail } from "npm:bouncer";

    type Bouncer = {
        apiKey: string;
    }

    export async function main(bouncerResource: Bouncer, emailToVerify: string) {
        const result = await verifyEmail(emailToVerify, { apiKey: bouncerResource.apiKey });
        return result;
    }
  id: |-
    synthetic_verify-email
  instructions: |-
    Verify an email in bouncer
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bouncer
  resource_type_def: |-
    type Bouncer = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { KlazifyClient } from "npm:klazify";

    type Klazify = {
        apiKey: string;
    }

    export async function main(klazifyResource: Klazify, domain: string) {
        const klazifyClient = new KlazifyClient(klazifyResource.apiKey);
        const domainInfo = await klazifyClient.getDomainInfo(domain);
        return domainInfo;
    }
  good: |-
    import { Klazify } from "npm:klazify";

    type Klazify = {
        apiKey: string;
    }

    export async function main(klazifyResource: Klazify, companyName: string) {
        const klazify = new Klazify(klazifyResource.apiKey);
        const domainInfo = await klazify.getCompanyDomainInfo(companyName);
        return domainInfo;
    }
  id: |-
    synthetic_get-company-domain-info
  instructions: |-
    Get information about a company's domain. in klazify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Klazify
  resource_type_def: |-
    type Klazify = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type AeroWorkflow = {
        apiKey: string;
        endpoint: string;
    }

    export async function main(aeroWorkflowResource: AeroWorkflow, taskName: string, taskDescription: string, dueDate: string, assigneeId: string) {
        const taskPayload = {
            id: uuidv4(),
            name: taskName,
            description: taskDescription,
            due_date: dueDate,
            assignee_id: assigneeId
        };

        const response = await fetch(`${aeroWorkflowResource.endpoint}/tasks`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${aeroWorkflowResource.apiKey}`
            },
            body: JSON.stringify(taskPayload)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { AeroWorkflow } from 'npm:aero-workflow-sdk'; // Assuming 'aero-workflow-sdk' is the npm package for AeroWorkflow

    // Define the resource type for AeroWorkflow integration
    type AeroWorkflowResource = {
        apiKey: string;
        apiSecret: string;
        baseUrl: string; // Assuming the base URL is needed for API requests
    }

    // Define the parameters for creating a task in AeroWorkflow
    type CreateTaskParams = {
        taskName: string;
        description?: string;
        dueDate: string; // ISO 8601 format date string
        assigneeId: string;
        // Add other task-specific parameters as needed
    }

    export async function main(aeroWorkflowResource: AeroWorkflowResource, createTaskParams: CreateTaskParams) {
        // Initialize the AeroWorkflow SDK with the provided credentials
        const aeroWorkflow = new AeroWorkflow(aeroWorkflowResource.apiKey, aeroWorkflowResource.apiSecret, aeroWorkflowResource.baseUrl);

        // Create the task in AeroWorkflow using the parameters provided
        const result = await aeroWorkflow.createTask({
            name: createTaskParams.taskName,
            description: createTaskParams.description,
            dueDate: createTaskParams.dueDate,
            assigneeId: createTaskParams.assigneeId,
            // Include other task-specific parameters here
        });

        // Always return the result
        return result;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a task in aero workflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AeroWorkflow
  resource_type_def: |-
    type AeroWorkflow = {
        apiKey: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make API calls

    # Define the resource type for the aftership integration
    class aftership(TypedDict):
        api_key: str

    def main(aftership_resource: aftership, tracking_id: str) -> dict:
        # Set up the headers with the API key
        headers = {
            "aftership-api-key": aftership_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Define the URL for the tracking data endpoint
        url = f"https://api.aftership.com/v4/trackings/{tracking_id}"

        # Make the GET request to the aftership API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the tracking data
            return response.json()
        else:
            # Handle errors (e.g., invalid API key, tracking ID not found)
            return {"error": response.json()}
  good: |-
    from typing import TypedDict

    # Define the resource type for the aftership integration
    class aftership(TypedDict):
        api_key: str

    # Define the main function for the aftership integration
    def main(aftership_resource: aftership, tracking_number: str, slug: str):
        # Import the requests library here to avoid conflicts with any parameter names
        import requests

        # Construct the headers with the API key from the aftership resource
        headers = {
            'aftership-api-key': aftership_resource['api_key'],
            'Content-Type': 'application/json'
        }

        # Construct the URL for the tracking endpoint
        url = f'https://api.aftership.com/v4/trackings/{slug}/{tracking_number}'

        # Make the GET request to the Aftership API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the tracking data
            tracking_data = response.json()
            return tracking_data
        else:
            # If the request failed, raise an exception with the error message
            raise Exception(f"Failed to get tracking data: {response.text}")

    # Example usage:
    # result = main(aftership_resource={'api_key': 'your_api_key'}, tracking_number='your_tracking_number', slug='your_slug')
    # print(result)
  id: |-
    synthetic_get-tracking
  instructions: |-
    Obtains an existing tracking system's data by ID in aftership
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aftership
  resource_type_def: |-
    class aftership(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { connect } from "npm:amqplib";

    type Amqp = {
        hostname: string;
        port: number;
        username: string;
        password: string;
        vhost?: string;
    }

    export async function main(amqpResource: Amqp, queueName: string, message: string) {
        const open = connect({
            protocol: 'amqp',
            hostname: amqpResource.hostname,
            port: amqpResource.port,
            username: amqpResource.username,
            password: amqpResource.password,
            vhost: amqpResource.vhost || '/'
        });

        const conn = await open;
        const channel = await conn.createChannel();
        await channel.assertQueue(queueName, { durable: false });
        channel.sendToQueue(queueName, Buffer.from(message));
        console.log(" [x] Sent '%s'", message);
        await channel.close();
        await conn.close();
    }
  good: |-
    import { connect } from "npm:amqplib";

    type Amqp = {
        hostname: string;
        port: number;
        username: string;
        password: string;
        vhost?: string;
    }

    export async function main(amqpResource: Amqp, queueName: string, message: string) {
        const open = connect({
            protocol: 'amqp',
            hostname: amqpResource.hostname,
            port: amqpResource.port,
            username: amqpResource.username,
            password: amqpResource.password,
            vhost: amqpResource.vhost || '/'
        });

        const conn = await open;
        const channel = await conn.createChannel();
        await channel.assertQueue(queueName, { durable: true });
        channel.sendToQueue(queueName, Buffer.from(message));
        await channel.close();
        await conn.close();

        return { success: true, message: `Message sent to queue ${queueName}` };
    }
  id: |-
    synthetic_send-message
  instructions: |-
    Send a new message to an queue. in amqp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amqp
  resource_type_def: |-
    type Amqp = {
        hostname: string;
        port: number;
        username: string;
        password: string;
        vhost?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bot } from "npm:discordeno";

    type DiscordBot = {
        token: string;
        botId: string;
    }

    export async function main(discordBotResource: DiscordBot, intents: number[]) {
        const bot = new Bot({
            token: discordBotResource.token,
            intents: intents, // Intents are now passed as a parameter
            botId: BigInt(discordBotResource.botId),
        });

        // Assuming the bot is already connected and ready to list channels
        const channels = await bot.helpers.getChannels(BigInt(discordBotResource.botId));

        return channels.map(channel => ({
            id: channel.id.toString(),
            name: channel.name,
            type: channel.type,
        }));
    }
  good: |-
    import { Bot, GatewayIntentBits } from "npm:discord.js";

    type DiscordBot = {
        token: string;
    }

    export async function main(discordBotResource: DiscordBot) {
        const bot = new Bot({
            intents: [GatewayIntentBits.Guilds]
        });

        bot.token = discordBotResource.token;

        try {
            await bot.login(bot.token);
            const channels = await bot.channels.fetch();

            // Convert the collection of channels to an array of simple objects
            const channelList = channels.map(channel => ({
                id: channel.id,
                name: channel.name,
                type: channel.type,
                guildId: channel.guildId,
                position: channel.position
            }));

            return channelList;
        } catch (error) {
            console.error("Failed to fetch channels:", error);
            throw error;
        }
    }
  id: |-
    synthetic_list-channels
  instructions: |-
    Return a list of channels in discord bot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DiscordBot
  resource_type_def: |-
    type DiscordBot = {
        token: string;
        botId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftEntraId = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(microsoftEntraIdResource: MicrosoftEntraId, groupId: string, memberId: string) {
        const client = Client.init({
            authProvider: (done) => {
                // Here you would normally implement the authentication flow to get the access token
                // For the purpose of this script, we assume that the access token is already obtained and passed via the resource
                done(null, microsoftEntraIdResource.clientSecret); // This should be the access token, not the client secret in a real scenario
            }
        });

        const result = await client.api(`/groups/${groupId}/members/${memberId}/$ref`).delete();

        return result;
    }
  good: |-
    import { HttpClient } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftEntraId = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(microsoftEntraIdResource: MicrosoftEntraId, groupId: string, memberId: string) {
        const client = HttpClient.init({
            authProvider: async (done) => {
                // Here you would normally implement the OAuth2 flow to get the access token
                // For this script, we assume that the access token is already included in the resource
                done(null, microsoftEntraIdResource.clientSecret); // Replace with actual token retrieval logic
            }
        }, {
            defaultVersion: 'v1.0',
            debugLogging: true
        });

        const url = `https://graph.microsoft.com/v1.0/groups/${groupId}/members/${memberId}/$ref`;

        try {
            const response = await client.api(url).delete();
            return response; // The result of the DELETE operation
        } catch (error) {
            // Handle error appropriately
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_remove-member-from-group
  instructions: |-
    Removes a member from a group Microsoft Entra ID in microsoft entra id
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftEntraId
  resource_type_def: |-
    type MicrosoftEntraId = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@asana";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, workspaceId: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);
        const projects = await client.projects.findByWorkspace(workspaceId);

        return projects;
    }
  good: |-
    import { Client } from "npm:@asana";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, userGid: string, workspaceGid: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);
        const projects = await client.projects.findByWorkspace(workspaceGid, { opt_fields: 'name,owner' });
        const userProjects = projects.filter(project => project.owner && project.owner.gid === userGid);

        return userProjects;
    }
  id: |-
    synthetic_search-user-projects
  instructions: |-
    Return list of projects given the user and workspace gid in asana
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asana
  resource_type_def: |-
    type Asana = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type HelperFunctions = {
        apiKey: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, jsonInput: string) {
        const jsonObject = JSON.parse(jsonInput);
        const prettyJson = JSON.stringify(jsonObject, null, 2);
        return prettyJson;
    }
  good: |-
    type HelperFunctions = {
        // No specific properties needed for this integration as it's a generic helper function
    }

    export async function main(helperFunctionsResource: HelperFunctions, valueToPrint: any, indentation: number = 2) {
        const prettyPrintedValue = JSON.stringify(valueToPrint, null, indentation);
        console.log(prettyPrintedValue);
        return prettyPrintedValue;
    }
  id: |-
    synthetic_prettify-json
  instructions: |-
    Pretty print a JavaScript object or value in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:nationbuilder";

    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }

    export async function main(nationbuilderResource: Nationbuilder, personId: number, updateData: Record<string, any>) {
        const client = new Client({
            accessToken: nationbuilderResource.accessToken,
            nationSlug: nationbuilderResource.nationSlug,
        });

        const result = await client.people.update(personId, updateData);
        return result;
    }
  good: |-
    import { Client } from "npm:nationbuilder";

    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }

    export async function main(nationbuilderResource: Nationbuilder, personId: number, updateFields: Record<string, any>) {
        const client = new Client({
            accessToken: nationbuilderResource.accessToken,
            nationSlug: nationbuilderResource.nationSlug,
        });

        const result = await client.people.update(personId, updateFields);

        return result;
    }
  id: |-
    synthetic_update-person
  instructions: |-
    Update a specific person with the provided data in nationbuilder
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nationbuilder
  resource_type_def: |-
    type Nationbuilder = {
        accessToken: string;
        nationSlug: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SESClient, SendEmailCommand } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        toAddresses: string[],
        fromAddress: string,
        subject: string,
        body: string
    ) {
        const sesClient = new SESClient({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Destination: {
                ToAddresses: toAddresses,
            },
            Message: {
                Body: {
                    Text: {
                        Charset: "UTF-8",
                        Data: body,
                    },
                },
                Subject: {
                    Charset: 'UTF-8',
                    Data: subject,
                },
            },
            Source: fromAddress,
        };

        const command = new SendEmailCommand(params);

        try {
            const response = await sesClient.send(command);
            return response;
        } catch (error) {
            // Handle error appropriately in your context
            throw error;
        }
    }
  good: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        toAddresses: string[],
        fromAddress: string,
        subject: string,
        bodyHtml: string,
        bodyText?: string
    ) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Destination: {
                ToAddresses: toAddresses,
            },
            Message: {
                Body: {
                    Html: {
                        Charset: "UTF-8",
                        Data: bodyHtml,
                    },
                    ...(bodyText && {
                        Text: {
                            Charset: "UTF-8",
                            Data: bodyText,
                        },
                    }),
                },
                Subject: {
                    Charset: 'UTF-8',
                    Data: subject,
                },
            },
            Source: fromAddress,
        };

        try {
            const data = await ses.sendEmail(params);
            return data;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_send-email
  instructions: |-
    Send an email using Amazon SES. Supports simple email messaging in amazon ses
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AmazonSes
  resource_type_def: |-
    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import google.cloud.dialogflow_v2 as dialogflow

    # Define the resource type for the google_dialogflow integration
    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str

    # Define the main function with the resource type and any additional parameters
    def main(dialogflow_resource: google_dialogflow, display_name: str, kind: str = 'KIND_MAP'):
        # Create a Dialogflow client using the provided credentials
        credentials = dialogflow.types.InputConfig(
            gcs_source=dialogflow.types.GcsSources(
                uris=[dialogflow_resource['private_key']]
            )
        )
        client = dialogflow.EntityTypesClient(credentials=credentials)

        # Define the parent path for the Dialogflow agent
        parent = client.project_agent_path(dialogflow_resource['project_id'])

        # Create an entity type object
        entity_type = dialogflow.types.EntityType(
            display_name=display_name,
            kind=kind
        )

        # Use the Dialogflow client to create a new entity type
        response = client.create_entity_type(parent, entity_type)

        # Return the response from the API call
        return response
  good: |-
    from typing import TypedDict
    import google.cloud.dialogflow_v2 as dialogflow

    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str

    def main(dialogflow_resource: google_dialogflow, display_name: str, kind: str = 'KIND_MAP'):
        client = dialogflow.EntityTypesClient.from_service_account_json({
            "type": "service_account",
            "project_id": dialogflow_resource['project_id'],
            "private_key_id": "some_private_key_id",
            "private_key": dialogflow_resource['private_key'],
            "client_email": dialogflow_resource['client_email'],
            "client_id": "",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": ""
        })

        parent = client.project_agent_path(dialogflow_resource['project_id'])
        entity_type = dialogflow.types.EntityType(
            display_name=display_name,
            kind=dialogflow.types.EntityType.Kind[kind]
        )

        response = client.create_entity_type(parent, entity_type)

        return response
  id: |-
    synthetic_create-entity-type
  instructions: |-
    Creates an Entity Type, and in google dialogflow
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_dialogflow
  resource_type_def: |-
    class google_dialogflow(TypedDict):
        project_id: str
        client_email: str
        private_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { DynamoDBClient, CreateTableCommand, AttributeDefinitionList, KeySchemaElementList, ProvisionedThroughput } from "@aws-sdk/client-dynamodb";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(awsResource: Aws, tableName: string, attributeDefinitions: AttributeDefinitionList, keySchema: KeySchemaElementList, provisionedThroughput: ProvisionedThroughput) {
        const client = new DynamoDBClient({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
            },
            region: awsResource.region,
        });

        const createTableCommand = new CreateTableCommand({
            TableName: tableName,
            AttributeDefinitions: attributeDefinitions,
            KeySchema: keySchema,
            ProvisionedThroughput: provisionedThroughput,
        });

        const response = await client.send(createTableCommand);
        return response;
    }
  good: |-
    import { DynamoDB } from "npm:aws-sdk";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(awsResource: Aws, tableName: string, sortKeyName: string) {
        const dynamoDb = new DynamoDB({
            accessKeyId: awsResource.accessKeyId,
            secretAccessKey: awsResource.secretAccessKey,
            region: awsResource.region
        });

        const params = {
            TableName: tableName
        };

        try {
            const { Table } = await dynamoDb.describeTable(params).promise();
            const sortKey = Table.KeySchema.find(element => element.AttributeName === sortKeyName && element.KeyType === 'RANGE');
            const sortKeyType = sortKey ? Table.AttributeDefinitions.find(def => def.AttributeName === sortKeyName)?.AttributeType : null;

            return {
                sortKeyName,
                sortKeyType
            };
        } catch (error) {
            console.error("Error fetching sort key data type:", error);
            throw error;
        }
    }
  id: |-
    synthetic_dynamodb-create-table
  instructions: |-
    The data type of the sort key in aws
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aws
  resource_type_def: |-
    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { fetch } from "npm:@types/node-fetch";

    type Intuiface = {
        apiKey: string;
        experienceId: string;
    }

    export async function main(intuifaceResource: Intuiface, additionalParam: string) {
        const url = `https://api.intuiface.com/experiences/${intuifaceResource.experienceId}/available-experiences`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'API-Key': intuifaceResource.apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const experiences = await response.json();
        return experiences;
    }
  good: |-
    // Import any libraries you need here
    import { Intuiface as IntuifaceClient } from 'npm:intuiface-api-client'; // Renamed imported class to avoid conflict

    type Intuiface = {
        apiKey: string;
    }

    export async function main(intuifaceResource: Intuiface) {
        // Initialize the Intuiface client with the API key
        const intuifaceClient = new IntuifaceClient(intuifaceResource.apiKey);

        // Fetch the list of available experiences
        const experiences = await intuifaceClient.getExperiences();

        // Return the list of experiences
        return experiences;
    }
  id: |-
    synthetic_available-experiences
  instructions: |-
    Get a list of available experiences that can receive a message. in intuiface
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Intuiface
  resource_type_def: |-
    type Intuiface = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { S3Client, PutObjectCommand } from "npm:@aws-sdk/client-s3";

    type HelperFunctions = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
        bucket: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, objectKey: string, objectBody: string | Uint8Array | Buffer, contentType: string) {
        // Initialize the S3 client with the credentials from the HelperFunctions resource
        const s3 = new S3Client({
            credentials: {
                accessKeyId: helperFunctionsResource.accessKeyId,
                secretAccessKey: helperFunctionsResource.secretAccessKey,
                sessionToken: helperFunctionsResource.sessionToken,
            },
            region: helperFunctionsResource.region,
        });

        // Create the parameters for the PutObjectCommand
        const putObjectParams = {
            Bucket: helperFunctionsResource.bucket,
            Key: objectKey,
            Body: objectBody,
            ContentType: contentType,
        };

        // Send the object to Amazon S3
        const command = new PutObjectCommand(putObjectParams);
        const response = await s3.send(command);

        // Return the result of the operation
        return response;
    }
  good: |-
    import { S3Client, PutObjectCommand } from "npm:@aws-sdk/client-s3";

    type HelperFunctions = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, bucketName: string, objectKey: string, fileContent: Buffer | Uint8Array | Blob | string, contentType: string) {
        const s3 = new S3Client({
            credentials: {
                accessKeyId: helperFunctionsResource.accessKeyId,
                secretAccessKey: helperFunctionsResource.secretAccessKey,
                sessionToken: helperFunctionsResource.sessionToken,
            },
            region: helperFunctionsResource.region,
        });

        const putObjectParams = {
            Bucket: bucketName,
            Key: objectKey,
            Body: fileContent,
            ContentType: contentType,
        };

        const command = new PutObjectCommand(putObjectParams);

        try {
            const response = await s3.send(command);
            return response;
        } catch (error) {
            console.error("Error uploading to S3:", error);
            throw error;
        }
    }
  id: |-
    synthetic_send-to-s3
  instructions: |-
    Send data to Amazon S3 using Pipedream's destination integration. See https://docs.pipedream.com/destinations/s3/ in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { NexweaveApi } from "npm:nexweave"; // Assuming there's a Nexweave npm package for the sake of example

    type Nexweave = {
        apiKey: string,
        apiSecret: string,
        templateId: string,
        campaignId: string
    }

    export async function main(nexweaveResource: Nexweave, imageUrl: string, targetAudience: string) {
        // Initialize Nexweave API client with the provided credentials
        const nexweaveClient = new NexweaveApi(nexweaveResource.apiKey, nexweaveResource.apiSecret);

        // Create an image experience from a template
        const experienceData = {
            templateId: nexweaveResource.templateId,
            campaignId: nexweaveResource.campaignId,
            imageUrl: imageUrl,
            targetAudience: targetAudience
        };

        try {
            const result = await nexweaveClient.createImageExperience(experienceData);
            return result;
        } catch (error) {
            console.error('Error creating image experience:', error);
            throw error;
        }
    }
  good: |-
    import { Nexweave as NexweaveClient } from 'npm:nexweave';

    type Nexweave = {
        apiKey: string,
        apiSecret: string
    }

    export async function main(nexweaveResource: Nexweave, campaignId: string, templateId: string, imageUrl: string, variables: Record<string, any>) {
        const nexweaveClient = new NexweaveClient({
            apiKey: nexweaveResource.apiKey,
            apiSecret: nexweaveResource.apiSecret
        });

        const experienceData = {
            templateId,
            imageUrl,
            variables
        };

        try {
            const response = await nexweaveClient.createImageExperience(campaignId, experienceData);
            return response;
        } catch (error) {
            console.error('Error creating image experience:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-image-experience-from-template
  instructions: |-
    Creates an image experience from a template in nexweave
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nexweave
  resource_type_def: |-
    type Nexweave = {
        apiKey: string,
        apiSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type BadgerMaps = {
        apiKey: string;
        accountId: string;
    }

    export async function main(badgerMapsResource: BadgerMaps, accountData: Record<string, any>) {
        const url = `https://api.badgermapping.com/v1/accounts/${badgerMapsResource.accountId}`;
        const headers = {
            "Authorization": `Basic ${encode(badgerMapsResource.apiKey)}`,
            "Content-Type": "application/json"
        };

        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(accountData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    type BadgerMaps = {
        apiKey: string;
    }

    export async function main(badgerMapsResource: BadgerMaps, accountId: string, updateFields: Record<string, any>) {
        const url = `https://api.badgermapping.com/v1/accounts/${accountId}`;
        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${badgerMapsResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateFields)
        });

        if (!response.ok) {
            throw new Error(`Failed to update account: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-account
  instructions: |-
    Updates an account. in badger maps
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BadgerMaps
  resource_type_def: |-
    type BadgerMaps = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { DigitalOcean as DigitalOceanClient } from "npm:@pulumi/digitalocean";

    type DigitalOcean = {
        accessToken: string;
    }

    export async function main(digitalOceanResource: DigitalOcean, domainName: string) {
        const digitalOcean = new DigitalOceanClient({ token: digitalOceanResource.accessToken });

        const domain = await digitalOcean.domains.create({
            name: domainName
        });

        return domain;
    }
  good: |-
    import { DigitalOcean } from "npm:@pulumi/digitalocean";

    type DigitalOceanResource = {
        accessToken: string;
    }

    export async function main(digitalOceanResource: DigitalOceanResource, domainName: string) {
        const digitalOcean = new DigitalOcean({ token: digitalOceanResource.accessToken });

        const domain = await digitalOcean.domains.create({
            name: domainName
        });

        return domain;
    }
  id: |-
    synthetic_create-domain
  instructions: |-
    Create a new domain in digital ocean
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DigitalOcean
  resource_type_def: |-
    type DigitalOcean = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type GorgiasOauth = {
        accessToken: string,
        subdomain: string
    }

    export async function main(gorgiasResource: GorgiasOauth, customerId: number, customerData: { email?: string, name?: string, phone?: string }) {
        const url = `https://${gorgiasResource.subdomain}.gorgias.com/api/customers/${customerId}`;
        const headers = {
            "Authorization": `Bearer ${gorgiasResource.accessToken}`,
            "Content-Type": "application/json"
        };
        const body = JSON.stringify(customerData);

        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type GorgiasOauth = {
        accessToken: string,
        subdomain: string
    }

    export async function main(
        gorgiasResource: GorgiasOauth,
        customerId: number,
        customerData: { name?: string, email?: string, phone?: string }
    ) {
        const url = `https://${gorgiasResource.subdomain}.gorgias.com/api/customers/${customerId}`;
        const headers = {
            'Authorization': `Bearer ${gorgiasResource.accessToken}`,
            'Content-Type': 'application/json'
        };
        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(customerData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-customer
  instructions: |-
    Update a customer in gorgias oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GorgiasOauth
  resource_type_def: |-
    type GorgiasOauth = {
        accessToken: string,
        subdomain: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Listmonk = {
        host: string;
        apiKey: string;
    }

    export async function main(listmonkResource: Listmonk, campaignName: string, campaignSubject: string, fromEmail: string, content: string, listIds: number[]) {
        // Construct the API endpoint
        const endpoint = `${listmonkResource.host}/api/campaigns`;

        // Prepare the authorization header
        const authHeader = `Basic ${encode(`${listmonkResource.apiKey}:`)}`;

        // Prepare the request body
        const body = JSON.stringify({
            name: campaignName,
            subject: campaignSubject,
            from_email: fromEmail,
            content: content,
            type: 'regular',
            lists: listIds,
        });

        // Make the API request to create a new campaign
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader,
            },
            body: body,
        });

        // Parse the response
        const result = await response.json();

        // Return the result
        return result;
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Listmonk = {
        host: string;
        apiKey: string;
    }

    export async function main(listmonkResource: Listmonk, campaignName: string, subject: string, fromEmail: string, content: string, listIds: number[]) {
        const url = `${listmonkResource.host}/api/campaigns`;
        const authHeader = `Basic ${encode(`${listmonkResource.apiKey}:`)}`;

        const campaignData = {
            name: campaignName,
            subject: subject,
            from_email: fromEmail,
            content: content,
            lists: listIds,
            type: 'regular', // Assuming a regular campaign type for simplicity
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader,
            },
            body: JSON.stringify(campaignData),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-campaign
  instructions: |-
    Creates a new campaign in Listmonk in listmonk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Listmonk
  resource_type_def: |-
    type Listmonk = {
        host: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Businesslogic = {
        apiKey: string;
        endpointUrl: string;
    }

    export async function main(businesslogicResource: Businesslogic, requestData: any, requestMethod: string = 'GET') {
        const response = await fetch(businesslogicResource.endpointUrl, {
            method: requestMethod,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${businesslogicResource.apiKey}`
            },
            body: requestMethod !== 'GET' ? JSON.stringify(requestData) : undefined
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { Workbook } from "npm:xlsx";

    type Businesslogic = {
        documentPath: string; // Path to the Excel document
    }

    export async function main(businesslogicResource: Businesslogic, inputParameters: { [key: string]: any }) {
        // Load the workbook from the specified path
        const workbook = Workbook.readFile(businesslogicResource.documentPath);
        const sheetName = workbook.SheetNames[0]; // Assuming we're working with the first sheet
        const worksheet = workbook.Sheets[sheetName];

        // Write input parameters to the worksheet
        for (const cell in inputParameters) {
            if (Object.prototype.hasOwnProperty.call(worksheet, cell)) {
                worksheet[cell].v = inputParameters[cell];
            }
        }

        // Calculate the workbook with the new inputs
        XLSX_CALC(workbook);

        // Assuming the output is in a defined cell, for example, 'B10'
        const outputCellRef = 'B10';
        const output = worksheet[outputCellRef].v;

        // Return the calculated output
        return output;
    }
  id: |-
    synthetic_execute-endpoint
  instructions: |-
    Executes provided input parameters in the uploaded Excel document to retrieve the calculated output. in businesslogic
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Businesslogic
  resource_type_def: |-
    type Businesslogic = {
        apiKey: string;
        endpointUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { ClickUp as ClickUpClient } from "npm:@yakovmeister/clickup";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, taskId: string, commentText: string) {
        const clickUpClient = new ClickUpClient(clickupResource.apiKey);

        const result = await clickUpClient.Task.addComment(taskId, { comment: commentText });

        return result;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, viewId: string, commentText: string) {
        const url = `https://api.clickup.com/api/v2/view/${viewId}/comment`;
        const headers = {
            'Authorization': clickupResource.apiKey,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            comment_text: commentText
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_create-view-comment
  instructions: |-
    Creates a view comment. See the docs in **Comments / Create Chat View Comment** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Mailchimp as MailchimpAPI } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimp: Mailchimp, listId: string) {
        MailchimpAPI.setConfig({
            apiKey: mailchimp.apiKey,
            server: mailchimp.serverPrefix,
        });

        try {
            const response = await MailchimpAPI.campaigns.list({
                list_id: listId,
            });
            return response;
        } catch (error) {
            console.error('Error searching campaigns:', error);
            throw error;
        }
    }
  good: |-
    import { Mailchimp } from "npm:@mailchimp/mailchimp_marketing";

    type MailchimpResource = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: MailchimpResource) {
        Mailchimp.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        try {
            const response = await Mailchimp.campaigns.list();
            return response;
        } catch (error) {
            console.error('Error fetching campaigns from Mailchimp:', error);
            throw error;
        }
    }
  id: |-
    synthetic_search-campaign
  instructions: |-
    Searches for the campaigns in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to LinkedIn API

    class linkedin(TypedDict):
        access_token: str
        organization_urn: str

    def main(linkedin_resource: linkedin, organization_urn: str) -> List[dict]:
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}"
        }
        url = f"https://api.linkedin.com/v2/organizationAcls?q=roleAssignee&role=ADMINISTRATOR&state=APPROVED&organization={organization_urn}"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

        admin_members = response.json().get('elements', [])
        return admin_members

    # The script ends here. The function main can now be exported and used with the appropriate parameters.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function to get organization administrators
    def main(linkedin_resource: linkedin, organization_id: str) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Define the API endpoint for getting organization administrators
        api_url = f"https://api.linkedin.com/v2/organizations/{organization_id}/administrators"

        # Set up the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {linkedin_resource['access_token']}"
        }

        # Make the API request to LinkedIn
        response = requests.get(api_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the list of administrators
            return response.json().get('elements', [])
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_get-organization-administrators
  instructions: |-
    Gets the administator members of an organization, given the organization urn in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HumorApi } from "npm:@your-org/humor-api-client"; // Assuming there's an npm package for the HumorApi client

    type HumorApi = {
        apiKey: string;
    }

    export async function main(humorApiResource: HumorApi, jokeOrMemeId: string, rating: number) {
        const humorApiClient = new HumorApi(humorApiResource.apiKey);
        const result = await humorApiClient.rateJokeOrMeme(jokeOrMemeId, rating);
        return result;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type HumorApi = {
        apiKey: string;
        apiEndpoint: string;
    }

    export async function main(humorApiResource: HumorApi, jokeId: string, vote: 'upvote' | 'downvote') {
        const url = `${humorApiResource.apiEndpoint}/jokes/${jokeId}/${vote}`;
        const headers = {
            'Authorization': `Basic ${encode(humorApiResource.apiKey)}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_rate-joke-or-meme
  instructions: |-
    Rate a joke or a meme with your upvote or downvote. in humor api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HumorApi
  resource_type_def: |-
    type HumorApi = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Associations, SimplePublicObject } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(
        hubspotResource: Hubspot,
        fromObjectType: string,
        toObjectType: string,
        fromObjectId: string,
        toObjectId: string,
        associationType: string
    ) {
        const hubspotClient = new Associations(hubspotResource.apiKey);

        const result = await hubspotClient.create(fromObjectType, toObjectType, fromObjectId, toObjectId, associationType);

        return result;
    }
  good: |-
    import { createClient } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, fromObjectType: string, toObjectType: string, fromObjectId: string, toObjectId: string, associationType: string) {
        const hubspotClient = createClient({ apiKey: hubspotResource.apiKey });

        const result = await hubspotClient.crm.associations.batchApi.create(fromObjectType, toObjectType, {
            inputs: [
                {
                    from: {
                        id: fromObjectId
                    },
                    to: {
                        id: toObjectId
                    },
                    type: associationType
                }
            ]
        });

        return result;
    }
  id: |-
    synthetic_create-associations
  instructions: |-
    Create associations between objects in hubspot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Buffer } from "npm:buffer";

    type Imgbb = {
        apiKey: string;
    }

    export async function main(imgbbResource: Imgbb, imageBuffer: Buffer, imageName: string) {
        const formData = new FormData();
        formData.append('image', imageBuffer.toString('base64'));
        formData.append('name', imageName);

        const response = await fetch('https://api.imgbb.com/1/upload?key=' + imgbbResource.apiKey, {
            method: 'POST',
            body: formData,
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Imgbb = {
        apiKey: string;
    }

    export async function main(imgbbResource: Imgbb, image: Uint8Array, imageName: string, expiration?: number) {
        const base64Image = encode(image);
        const formData = new FormData();
        formData.append('image', base64Image);
        formData.append('name', imageName);
        if (expiration) {
            formData.append('expiration', expiration.toString());
        }

        const response = await fetch('https://api.imgbb.com/1/upload?key=' + imgbbResource.apiKey, {
            method: 'POST',
            body: formData
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_upload-picture
  instructions: |-
    Upload a picture to imgbb in imgbb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Imgbb
  resource_type_def: |-
    type Imgbb = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleDocs = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleDocsResource: GoogleDocs, documentId: string, searchText: string, replaceText: string) {
        const { apiKey, accessToken } = googleDocsResource;
        const docs = google.docs({ version: 'v1', auth: apiKey });

        // Retrieve the document to find all instances of the searchText
        const document = await docs.documents.get({
            documentId: documentId,
            accessToken: accessToken
        });

        // Find all instances of searchText in the document
        const requests = [];
        const content = document.data.body.content;
        for (const element of content) {
            if (element.paragraph) {
                for (const paragraphElement of element.paragraph.elements) {
                    if (paragraphElement.textRun && paragraphElement.textRun.content.includes(searchText)) {
                        const startIndex = paragraphElement.startIndex;
                        const endIndex = paragraphElement.endIndex;
                        const textRunContent = paragraphElement.textRun.content;
                        const parts = textRunContent.split(searchText);

                        let currentIndex = startIndex;
                        for (let i = 0; i < parts.length - 1; i++) {
                            // Add the replace request for this instance
                            requests.push({
                                replaceAllText: {
                                    containsText: {
                                        text: searchText,
                                        matchCase: true,
                                    },
                                    replaceText: replaceText,
                                    range: {
                                        startIndex: currentIndex,
                                        endIndex: currentIndex + searchText.length
                                    }
                                }
                            });
                            currentIndex += parts[i].length + searchText.length;
                        }
                    }
                }
            }
        }

        // Make the replacements in the document
        if (requests.length > 0) {
            await docs.documents.batchUpdate({
                documentId: documentId,
                requestBody: {
                    requests: requests
                },
                accessToken: accessToken
            });
        }

        return { success: true, message: "Text replacement completed." };
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleDocs = {
        accessToken: string;
    }

    export async function main(googleDocsResource: GoogleDocs, documentId: string, textToReplace: string, replacementText: string) {
        const docs = google.docs({
            version: 'v1',
            auth: googleDocsResource.accessToken
        });

        const batchUpdateRequest = {
            documentId: documentId,
            resource: {
                requests: [
                    {
                        replaceAllText: {
                            containsText: {
                                text: textToReplace,
                                matchCase: true,
                            },
                            replaceText: replacementText,
                        },
                    },
                ],
            },
        };

        try {
            const response = await docs.documents.batchUpdate(batchUpdateRequest);
            return response.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  id: |-
    synthetic_replace-text
  instructions: |-
    Replace all instances of matched text in a existing document in google docs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDocs
  resource_type_def: |-
    type GoogleDocs = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to CentralStationCRM API

    class centralstationcrm(TypedDict):
        api_key: str
        base_url: str

    def main(centralstationcrm_resource: centralstationcrm, first_name: str, last_name: str, email: str, company: str = None, phone: str = None):
        url = f"{centralstationcrm_resource['base_url']}/people"
        headers = {
            "Authorization": f"Token token={centralstationcrm_resource['api_key']}",
            "Content-Type": "application/json"
        }
        data = {
            "person": {
                "first_name": first_name,
                "last_name": last_name,
                "email": email,
                "company": company,
                "phone": phone
            }
        }
        response = requests.post(url, json=data, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'centralstationcrm' integration
    class centralstationcrm(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for creating a person in CentralStationCRM
    def main(centralstationcrm_resource: centralstationcrm, first_name: str, last_name: str, email: str, company: str = None, phone: str = None):
        import requests  # Import requests or any other library if needed

        # Construct the URL for creating a person
        url = f"{centralstationcrm_resource['base_url']}/people"

        # Prepare the data for the new person
        person_data = {
            'first_name': first_name,
            'last_name': last_name,
            'email': email,
            'company': company,
            'phone': phone
        }

        # Remove None values from the data dictionary
        person_data = {k: v for k, v in person_data.items() if v is not None}

        # Make the request to create a new person
        response = requests.post(url, json=person_data, headers={'Authorization': f"Bearer {centralstationcrm_resource['api_key']}"})

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created person's data
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # The main function is not called here, as per the instructions
  id: |-
    synthetic_create-person
  instructions: |-
    Creates a new person in CentralStationCRM in centralstationcrm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    centralstationcrm
  resource_type_def: |-
    class centralstationcrm(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to Bitbucket API

    # Define the resource type for the Bitbucket integration
    class bitbucket(TypedDict):
        api_base_url: str
        workspace: str
        repo_slug: str
        oauth_token: str

    def main(bitbucket_resource: bitbucket, issue_id: int, comment_body: str) -> Any:
        # Construct the URL for creating a new issue comment
        url = f"{bitbucket_resource['api_base_url']}/repositories/{bitbucket_resource['workspace']}/{bitbucket_resource['repo_slug']}/issues/{issue_id}/comments/"

        # Prepare the headers with the OAuth token
        headers = {
            "Authorization": f"Bearer {bitbucket_resource['oauth_token']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the comment body
        payload = {
            "content": {
                "raw": comment_body
            }
        }

        # Make the POST request to create a new comment
        response = requests.post(url, json=payload, headers=headers)

        # Return the response from the Bitbucket API
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the Bitbucket integration
    class bitbucket(TypedDict):
        api_url: str
        access_token: str

    def main(bitbucket_resource: bitbucket, repository_full_name: str, issue_id: int, comment_body: str) -> dict:
        import requests

        # Construct the URL for the Bitbucket API to create an issue comment
        url = f"{bitbucket_resource['api_url']}/repositories/{repository_full_name}/issues/{issue_id}/comments/"

        # Prepare the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {bitbucket_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the comment body
        payload = {
            "content": {
                "raw": comment_body
            }
        }

        # Make the POST request to the Bitbucket API to create the comment
        response = requests.post(url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created comment as a JSON object
        else:
            raise Exception(f"Failed to create comment: {response.status_code} {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_create-issue-comment
  instructions: |-
    Creates a new issue comment in bitbucket
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitbucket
  resource_type_def: |-
    class bitbucket(TypedDict):
        api_url: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'kanban_tool' integration
    class kanban_tool(TypedDict):
        api_key: str

    # Define the main function for creating a task in Kanban Tool
    def main(kanban_tool_resource: kanban_tool, board_id: str, workspace_id: str, task_name: str, task_description: str, column_id: str, swimlane_id: str) -> Any:
        # Assuming there is a library to interact with Kanban Tool API
        import kanban_tool_api_client as kt_client

        # Initialize the Kanban Tool client with the provided API key
        client = kt_client.Client(api_key=kanban_tool_resource['api_key'])

        # Create the task on the specified board and workspace
        task = client.create_task(
            board_id=board_id,
            workspace_id=workspace_id,
            name=task_name,
            description=task_description,
            column_id=column_id,
            swimlane_id=swimlane_id
        )

        # Return the result of the task creation
        return task
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
        workflow_id: str

    # Define the main function for creating a task in the kanban tool
    def main(kanban_tool_resource: kanban_tool, task_name: str, task_description: str, column_id: str, swimlane_id: str, priority: int) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a task
        api_endpoint = f"https://kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks.json"

        # Prepare the headers and payload for the API request
        headers = {
            'X-KanbanToolToken': kanban_tool_resource['api_key']
        }
        payload = {
            'task[workflow_stage_id]': column_id,
            'task[swimlane_id]': swimlane_id,
            'task[name]': task_name,
            'task[description]': task_description,
            'task[priority]': priority
        }

        # Make the API request to create the task
        response = requests.post(api_endpoint, headers=headers, data=payload)

        # Return the API response
        return response.json()
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a task in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API calls

    class eodhd_apis(TypedDict):
        api_token: str

    def main(eodhd_resource: eodhd_apis, company_symbol: str):
        base_url = "https://eodhistoricaldata.com/api/fundamentals/"
        headers = {
            "Content-Type": "application/json"
        }
        params = {
            "api_token": eodhd_resource['api_token'],
            "filter": "Financials::Balance_Sheet::yearly"  # Assuming we want yearly balance sheets
        }

        response = requests.get(f"{base_url}{company_symbol}", headers=headers, params=params)
        financial_statements = response.json()

        return financial_statements
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the eodhd_apis integration
    class eodhd_apis(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function with the resource type and additional parameters
    def main(eodhd_resource: eodhd_apis, company_ticker: str, financials_type: str = 'income') -> Dict[str, Any]:
        base_url = "https://eodhistoricaldata.com/api/fundamentals/"
        headers = {
            "Content-Type": "application/json"
        }
        params = {
            "api_token": eodhd_resource['api_key'],
            "filter": financials_type
        }

        # Construct the URL for the API call
        url = f"{base_url}{company_ticker.upper()}"

        # Make the API call
        response = requests.get(url, headers=headers, params=params)

        # Check if the response is successful
        if response.status_code == 200:
            return response.json()  # Return the JSON response
        else:
            response.raise_for_status()  # Raise an exception for any HTTP errors

    # Example usage:
    # result = main(eodhd_resource={'api_key': 'YOUR_API_KEY'}, company_ticker='AAPL', financials_type='income')
    # print(result)
  id: |-
    synthetic_get-company-financials
  instructions: |-
    Obtain financial statements for a specific company in eodhd apis
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    eodhd_apis
  resource_type_def: |-
    class eodhd_apis(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed to fetch data from the Gryd API

    class gryd(TypedDict):
        api_key: str
        base_url: str

    def main(gryd_resource: gryd, vehicle_id: str) -> Any:
        headers = {
            'Authorization': f"Bearer {gryd_resource['api_key']}"
        }
        response = requests.get(f"{gryd_resource['base_url']}/vehicles/{vehicle_id}", headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'gryd' integration
    class gryd(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for the 'gryd' integration to get vehicle data
    def main(gryd_resource: gryd, vehicle_id: str) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the URL to access the vehicle data
        url = f"{gryd_resource['base_url']}/vehicles/{vehicle_id}"

        # Set up the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {gryd_resource['api_key']}"
        }

        # Make the request to the 'gryd' API to get the vehicle data
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the vehicle data as JSON if the request was successful
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()
  id: |-
    synthetic_get-vehicle-data
  instructions: |-
    Fetches data for a specific vehicle from the Gryd API in gryd
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gryd
  resource_type_def: |-
    class gryd(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch as fetchFromDeno } from "npm:@deno/fetch";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, limit: number = 50) {
        const url = `${bybitResource.endpoint}/v2/public/trading-records?symbol=${symbol}&limit=${limit}`;

        try {
            const response = await fetchFromDeno(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching Bybit market recent trading records:', error);
            throw error;
        }
    }
  good: |-
    // Import any libraries you need here
    import { Bybit } from 'npm:@bybit-api/bybit-api';

    type Bybit = {
        apiKey: string;
        secret: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, limit: number = 50) {
        const bybitClient = new Bybit({
            key: bybitResource.apiKey,
            secret: bybitResource.secret,
            // Assuming we're working with the REST API and not the WebSocket API
            // and that we're using the inverse perpetual endpoint
            // Adjust the endpoint if necessary for your use case
            restInversePerpetualOptions: {
                baseURL: 'https://api.bybit.com',
            },
        });

        try {
            const trades = await bybitClient.getTrades({
                symbol: symbol,
                limit: limit,
            });

            return trades;
        } catch (error) {
            console.error('Error fetching recent trades:', error);
            throw error;
        }
    }
  id: |-
    synthetic_linear-market-recent-trading-records
  instructions: |-
    Get recent trades in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the lemlist integration
    class lemlist(TypedDict):
        api_key: str  # API key for authentication

    # Main function to get a lead from lemlist
    def main(lemlist_resource: lemlist, lead_id: str) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Base URL for lemlist API
        base_url = "https://api.lemlist.com/api"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {lemlist_resource['api_key']}"
        }

        # Endpoint to get a specific lead
        endpoint = f"/leads/{lead_id}"

        # Make the API request to get the lead
        response = requests.get(base_url + endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the lead information
            return response.json()
        else:
            # Handle errors (e.g., lead not found, authentication error)
            return {"error": response.json(), "status_code": response.status_code}

    # The script ends here, with no calls to the main function as per the instructions.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to lemlist API

    class lemlist(TypedDict):
        api_key: str

    def main(lemlist_resource: lemlist, lead_email: str):
        base_url = "https://api.lemlist.com/api"
        headers = {
            "Authorization": f"Bearer {lemlist_resource['api_key']}",
            "Content-Type": "application/json"
        }

        response = requests.get(f"{base_url}/leads", headers=headers, params={"email": lead_email})
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json()
  id: |-
    synthetic_get-lead
  instructions: |-
    This action retrieves all the information of a specific lead using its email in lemlist
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    lemlist
  resource_type_def: |-
    class lemlist(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { WebSocket } from "npm:ws";

    type Intuiface = {
        playerWebSocketUrl: string; // The WebSocket URL to connect to the Intuiface Player
    }

    export async function main(intuifaceResource: Intuiface, message: string) {
        // Create a WebSocket connection to the Intuiface Player
        const ws = new WebSocket(intuifaceResource.playerWebSocketUrl);

        // Wait for the WebSocket connection to open
        await new Promise<void>((resolve, reject) => {
            ws.on('open', () => {
                resolve();
            });
            ws.on('error', (err) => {
                reject(err);
            });
        });

        // Send the message to the Intuiface Player
        ws.send(message);

        // Close the WebSocket connection
        ws.close();

        // Return a success message
        return `Message sent to Intuiface Player: ${message}`;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Intuiface = {
        apiKey: string;
        experienceId: string;
        interfaceAssetId: string;
    }

    export async function main(intuifaceResource: Intuiface, message: string, targetScene?: string) {
        const apiUrl = `https://api.intuiface.com/experiences/${intuifaceResource.experienceId}/interfaceassets/${intuifaceResource.interfaceAssetId}/commands`;

        const headers = {
            'Authorization': `Basic ${encode(intuifaceResource.apiKey)}`,
            'Content-Type': 'application/json'
        };

        const body = JSON.stringify({
            methodName: "SendMessage",
            parameterList: {
                message: message,
                ...(targetScene && { targetScene: targetScene })
            }
        });

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: body
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Error sending message to Intuiface:', error);
            throw error;
        }
    }
  id: |-
    synthetic_send-message
  instructions: |-
    Send messages to any connected Intuiface Player running an experience that embeds the. in intuiface
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Intuiface
  resource_type_def: |-
    type Intuiface = {
        apiKey: string;
        experienceId: string;
        interfaceAssetId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to HubSpot API

    # Define the resource type for the HubSpot integration
    class hubspot(TypedDict):
        api_key: str

    def main(hubspot_resource: hubspot, contact_id: str) -> Dict[str, Any]:
        # HubSpot API endpoint to get a contact by ID
        endpoint = f"https://api.hubapi.com/contacts/v1/contact/vid/{contact_id}/profile"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {hubspot_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the GET request to retrieve the contact information
        response = requests.get(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the contact information as a dictionary
            return response.json()
        else:
            # Handle errors (e.g., contact not found, authentication error)
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to HubSpot API

    class hubspot(TypedDict):
        api_key: str

    def main(hubspot_resource: hubspot, contact_id: str, properties: Optional[list[str]] = None) -> dict:
        base_url = "https://api.hubapi.com"
        contact_endpoint = f"/crm/v3/objects/contacts/{contact_id}"
        params = {
            "hapikey": hubspot_resource['api_key'],
            "properties": properties if properties else []
        }

        response = requests.get(f"{base_url}{contact_endpoint}", params=params)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  id: |-
    synthetic_get-contact
  instructions: |-
    Gets a contact in hubspot
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import lusha  # Assuming 'lusha' is a library for the Lusha API

    # Renaming the imported lusha method if it conflicts with the resource type name
    from lusha import search as lusha_search

    class lusha(TypedDict):
        api_key: str

    def main(lusha_resource: lusha, search_term: str, search_type: Optional[str] = 'personal') -> dict:
        # Configure the Lusha API with the provided API key
        lusha_api = lusha_search.Lusha(api_key=lusha_resource['api_key'])

        # Perform the search for the contact using the search term and type
        result = lusha_api.search_contact(search_term, search_type)

        # Return the search result
        return result
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the lusha integration
    class lusha(TypedDict):
        api_key: str

    # Define the main function for the lusha integration
    def main(lusha_resource: lusha, email: str, phone: Optional[str] = None):
        import requests  # Import requests or any other library if needed

        # Base URL for the Lusha API
        base_url = "https://api.lusha.co"
        # Endpoint for finding contact information
        find_contact_endpoint = "/contact"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {lusha_resource['api_key']}"
        }

        # Prepare the parameters for the request
        params = {
            "email": email
        }
        if phone:
            params["phone"] = phone

        # Make the request to the Lusha API
        response = requests.get(f"{base_url}{find_contact_endpoint}", headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  id: |-
    synthetic_find-contact
  instructions: |-
    Search for a contact in lusha
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    lusha
  resource_type_def: |-
    class lusha(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the baselinker integration
    class baselinker(TypedDict):
        api_token: str

    # Define the main function for adding a new order to BaseLinker
    def main(baselinker_resource: baselinker, order_data: Dict[str, Any]) -> Dict[str, Any]:
        import requests  # Import here to avoid conflicts with parameter names

        # BaseLinker API endpoint for adding a new order
        api_endpoint = "https://api.baselinker.com/connector.php"

        # Prepare the payload for the API request
        payload = {
            'token': baselinker_resource['api_token'],
            'method': 'addOrder',
            'parameters': order_data
        }

        # Make the API request to add a new order
        response = requests.post(api_endpoint, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON
            response_data = response.json()
            # Return the response data
            return response_data
        else:
            # Return an error message if the request failed
            return {'error': 'Failed to add order to BaseLinker', 'status_code': response.status_code}

    # Example usage:
    # result = main(baselinker_resource={'api_token': 'your_api_token'}, order_data={'additional_info': 'New order details'})
    # print(result)
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the baselinker integration
    class baselinker(TypedDict):
        token: str  # API token for authentication

    # Define the main function for creating an order in baselinker
    def main(baselinker_resource: baselinker, order_data: Dict[str, Any]) -> Dict[str, Any]:
        import requests  # Import here to avoid conflicts with parameter names

        # Endpoint for creating an order in baselinker
        create_order_endpoint = "https://api.baselinker.com/connector.php"

        # Prepare the payload for the API request
        payload = {
            'token': baselinker_resource['token'],
            'method': 'addOrder',
            'parameters': order_data
        }

        # Make the API request to create an order
        response = requests.post(create_order_endpoint, json=payload)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response to JSON
            response_data = response.json()
            # Return the response data
            return response_data
        else:
            # Return an error message if the request failed
            return {'error': 'Failed to create order', 'status_code': response.status_code}
  id: |-
    synthetic_create-order
  instructions: |-
    It allows adding a new order to the BaseLinker order manager. in baselinker
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    baselinker
  resource_type_def: |-
    class baselinker(TypedDict):
        token: str  # API token for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@netlify/js-client";

    type Netlify = {
        accessToken: string;
    }

    export async function main(netlifyResource: Netlify, siteId: string) {
        const netlifyClient = new Client({ accessToken: netlifyResource.accessToken });
        const site = await netlifyClient.getSite({ site_id: siteId });
        return site;
    }
  good: |-
    import { NetlifyClient } from "npm:@netlify/js-client";

    type Netlify = {
        accessToken: string;
    }

    export async function main(netlifyResource: Netlify, siteId: string) {
        const client = new NetlifyClient({
            accessToken: netlifyResource.accessToken,
        });

        const site = await client.getSite({ site_id: siteId });

        return site;
    }
  id: |-
    synthetic_get-site
  instructions: |-
    Get a specified site in netlify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Netlify
  resource_type_def: |-
    type Netlify = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the lemlist integration
    class lemlist(TypedDict):
        api_key: str

    # Define the main function for the lemlist integration
    def main(lemlist_resource: lemlist, lead_email: str, campaign_id: str) -> bool:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for unsubscribing a lead from a campaign
        unsubscribe_endpoint = f"https://api.lemlist.com/api/campaigns/{campaign_id}/unsubscribes"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {lemlist_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the lead's email
        payload = {
            "email": lead_email
        }

        # Make the POST request to unsubscribe the lead
        response = requests.post(unsubscribe_endpoint, json=payload, headers=headers)

        # Check if the request was successful and return the result
        return response.status_code == 200
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to lemlist API

    class lemlist(TypedDict):
        api_key: str

    def main(lemlist_resource: lemlist, lead_email: str, campaign_id: str) -> dict:
        headers = {
            'Authorization': f"Bearer {lemlist_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Check if the lead belongs to the specified campaign
        campaign_leads_url = f"https://api.lemlist.com/api/campaigns/{campaign_id}/leads"
        response = requests.get(campaign_leads_url, headers=headers)
        response.raise_for_status()
        leads = response.json()

        # Find the lead in the campaign
        lead = next((item for item in leads if item['email'] == lead_email), None)

        # If the lead is found in the campaign, unsubscribe from all campaigns
        if lead:
            unsubscribe_url = f"https://api.lemlist.com/api/leads/{lead['id']}/unsubscribeAll"
            unsubscribe_response = requests.post(unsubscribe_url, headers=headers)
            unsubscribe_response.raise_for_status()
            return {"status": "success", "message": "Lead unsubscribed from all campaigns"}
        else:
            return {"status": "failed", "message": "Lead not found in the specified campaign"}

    # Note: The function is not called here, it is just defined and ready to be used.
  id: |-
    synthetic_unsubscribe-lead-from-a-campaign
  instructions: |-
    This action will unsubscribe a lead from all campaigns if he belongs to the specified campaign in lemlist
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    lemlist
  resource_type_def: |-
    class lemlist(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    from transformers import pipeline as hugging_face_pipeline

    class hugging_face(TypedDict):
        api_key: str

    def main(hugging_face_resource: hugging_face, text_to_summarize: str, model: str = "sshleifer/distilbart-cnn-12-6", min_length: int = 50, max_length: int = 200):
        summarizer = hugging_face_pipeline("summarization", model=model, tokenizer=model, framework="pt", use_auth_token=hugging_face_resource['api_key'])
        summary = summarizer(text_to_summarize, min_length=min_length, max_length=max_length)
        return summary
  good: |-
    from typing import TypedDict
    from transformers import pipeline

    class hugging_face(TypedDict):
        api_key: str

    def main(hugging_face_resource: hugging_face, text_to_summarize: str, model: str = "sshleifer/distilbart-cnn-12-6", max_length: int = 130, min_length: int = 30):
        summarizer = pipeline("summarization", model=model, tokenizer=model, framework="pt")
        summary = summarizer(text_to_summarize, max_length=max_length, min_length=min_length, truncation=True)
        return summary
  id: |-
    synthetic_text-summarization
  instructions: |-
    This task is well known to summarize longer text into shorter text. Be careful, some models have a maximum length of input. That means that the summary cannot handle full books for instance. Be careful when choosing your model. in hugging face
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hugging_face
  resource_type_def: |-
    class hugging_face(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'laposta' integration
    class laposta(TypedDict):
        api_key: str

    def main(laposta_resource: laposta, member_id: str, list_id: str, relation_data: dict) -> dict:
        import requests  # Import here to avoid conflicts with any parameter names

        # Base URL for Laposta API
        base_url = "https://api.laposta.nl/v2"

        # Headers for authentication
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Bearer {laposta_resource['api_key']}"
        }

        # Endpoint for creating a relation
        endpoint = f"/member/{member_id}/relation"

        # Make the request to create a relation
        response = requests.post(f"{base_url}{endpoint}", headers=headers, json={'list_id': list_id, **relation_data})

        # Return the response as a dictionary
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'laposta' integration
    class laposta(TypedDict):
        api_key: str

    # Define the main function for creating a relation in Laposta
    def main(laposta_resource: laposta, relation_data: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Laposta API endpoint to create a relation
        url = "https://api.laposta.nl/v2/relations"

        # Prepare the headers with the API key
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Bearer {laposta_resource['api_key']}"
        }

        # Make the request to create a relation in Laposta
        response = requests.post(url, headers=headers, json=relation_data)

        # Return the response from the API call
        return response.json()

    # Example usage:
    # result = main(laposta_resource={'api_key': 'your_api_key'}, relation_data={'email': 'email@example.com', 'custom_fields': {'field1': 'value1'}})
    # print(result)
  id: |-
    synthetic_create-relation
  instructions: |-
    Creates a relation in laposta
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    laposta
  resource_type_def: |-
    class laposta(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { GorgiasClient } from "npm:gorgias";

    type GorgiasOauth = {
        accessToken: string;
        domain: string;
    }

    export async function main(gorgiasResource: GorgiasOauth, customerId: number) {
        const gorgias = new GorgiasClient({
            accessToken: gorgiasResource.accessToken,
            domain: gorgiasResource.domain
        });

        const customer = await gorgias.customers.get(customerId);

        return customer;
    }
  good: |-
    // Import any libraries you need here
    import { GorgiasClient } from "npm:gorgias";

    type GorgiasOauth = {
        accessToken: string;
        subdomain: string;
    }

    export async function main(gorgiasResource: GorgiasOauth, customerId: number) {
        const gorgias = new GorgiasClient({
            accessToken: gorgiasResource.accessToken,
            subdomain: gorgiasResource.subdomain
        });

        const customer = await gorgias.customers.get(customerId);

        return customer;
    }
  id: |-
    synthetic_retrieve-customer
  instructions: |-
    Retrieve a customer in gorgias oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GorgiasOauth
  resource_type_def: |-
    type GorgiasOauth = {
        accessToken: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional, Dict, Any
    import requests  # Assuming requests is needed for HTTP requests to JIRA API

    # Define the resource type for the jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    # Define the function signature with the resource and additional parameters
    def main(
        jira_resource: jira,
        issue_key: str,
        transition_id: Optional[int] = None,
        fields_to_update: Optional[Dict[str, Any]] = None,
        additional_headers: Optional[Dict[str, str]] = None
    ):
        # Prepare the headers for authentication
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {jira_resource['username']}:{jira_resource['api_token']}"
        }

        # If there are additional headers, update the headers dictionary
        if additional_headers:
            headers.update(additional_headers)

        # Prepare the API endpoint URL
        url = f"{jira_resource['base_url']}/rest/api/2/issue/{issue_key}"

        # Prepare the payload for the request
        payload = {}
        if transition_id is not None:
            payload["transition"] = {"id": transition_id}
        if fields_to_update is not None:
            payload["fields"] = fields_to_update

        # Make the request to update the issue
        response = requests.put(url, json=payload, headers=headers)

        # Check for successful update
        if response.status_code == 204:
            return {"success": True, "message": "Issue updated successfully."}
        else:
            # Return the error message if the update failed
            return {"success": False, "message": response.text}

    # Note: The function is not called here, it is only defined and exported.
  good: |-
    from typing import TypedDict, Any
    import requests

    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, issue_key: str, fields_to_update: dict, transition_id: str = None) -> Any:
        issue_url = f"{jira_resource['base_url']}/rest/api/2/issue/{issue_key}"
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {jira_resource['api_token']}"
        }
        payload = {
            "fields": fields_to_update
        }
        response = requests.put(issue_url, json=payload, headers=headers)
        if transition_id:
            transition_url = f"{issue_url}/transitions"
            transition_payload = {
                "transition": {
                    "id": transition_id
                }
            }
            transition_response = requests.post(transition_url, json=transition_payload, headers=headers)
            return transition_response.json()
        return response.json()
  id: |-
    synthetic_update-issue
  instructions: |-
    Updates an issue. A transition may be applied and issue properties updated as part of the edit, in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is used for HTTP requests

    # Define the resource type for the mautic integration
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str

    def main(mautic_resource: mautic, contact_id: int, updated_fields: dict, patch: Optional[bool] = True):
        """
        Updates a contact in Mautic with the given contact ID and updated fields.

        :param mautic_resource: A dictionary containing the base URL and credentials for Mautic.
        :param contact_id: The ID of the contact to update.
        :param updated_fields: A dictionary of the fields to update.
        :param patch: A boolean indicating whether to use PATCH (True) or PUT (False) method.
        :return: The response from the Mautic API.
        """
        url = f"{mautic_resource['base_url']}/api/contacts/{contact_id}/edit"
        headers = {
            'Content-Type': 'application/json'
        }
        auth = (mautic_resource['username'], mautic_resource['password'])

        if patch:
            response = requests.patch(url, json=updated_fields, headers=headers, auth=auth)
        else:
            response = requests.put(url, json=updated_fields, headers=headers, auth=auth)

        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Mautic API

    # Define the resource type for the Mautic integration
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str
        access_token: str  # Assuming OAuth2 access token is provided

    # Define the main function for updating a contact in Mautic
    def main(
        mautic_resource: mautic,
        contact_id: int,
        update_fields: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Update a contact in Mautic with the given fields.

        :param mautic_resource: A dictionary containing the Mautic instance's base URL, username, password, and access token.
        :param contact_id: The ID of the contact to update.
        :param update_fields: A dictionary of the fields to update for the contact.
        :return: The response from the Mautic API.
        """
        # Construct the API endpoint for updating a contact
        endpoint = f"{mautic_resource['base_url']}/api/contacts/{contact_id}/edit"

        # Prepare the headers for OAuth2 authentication
        headers = {
            'Authorization': f'Bearer {mautic_resource["access_token"]}'
        }

        # Make the request to update the contact
        response = requests.patch(endpoint, headers=headers, json=update_fields)

        # Return the JSON response from the API
        return response.json()

    # Note: The function is not called here, it is just defined and exported.
  id: |-
    synthetic_update-contact
  instructions: |-
    Updates a contact in mautic
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mautic
  resource_type_def: |-
    class mautic(TypedDict):
        base_url: str
        username: str
        password: str
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import time

    class delay(TypedDict):
        pass  # No specific properties needed for a simple delay

    def main(delay_resource: delay, delay_seconds: int) -> None:
        time.sleep(delay_seconds)
        return
  good: |-
    from typing import TypedDict
    import time

    class delay(TypedDict):
        pass

    def main(delay_resource: delay, duration_seconds: int) -> None:
        time.sleep(duration_seconds)
        return
  id: |-
    synthetic_workflow-delay
  instructions: |-
    Delay the execution of your workflow for a specific amount of time (does not count against your compute time). in delay
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    delay
  resource_type_def: |-
    class delay(TypedDict):
        pass
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the HubSpot integration
    class hubspot(TypedDict):
        api_key: str

    def main(hubspot_resource: hubspot, file_id: str) -> str:
        import requests  # Import here to avoid conflicts with any parameter names

        # Construct the API endpoint for retrieving file metadata
        endpoint = f"https://api.hubapi.com/files/v3/files/{file_id}"
        headers = {
            "Authorization": f"Bearer {hubspot_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to HubSpot API to get file details
        response = requests.get(endpoint, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP error responses

        # Extract the public URL from the response
        file_metadata = response.json()
        public_url = file_metadata.get('url', '')

        # Return the public URL of the file
        return public_url
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Hubspot API

    class hubspot(TypedDict):
        api_key: str

    def main(hubspot_resource: hubspot, file_id: str) -> str:
        # Construct the URL for accessing the file
        url = f"https://api.hubapi.com/filemanager/api/v2/files/{file_id}?hapikey={hubspot_resource['api_key']}"

        # Make the GET request to retrieve file details
        response = requests.get(url)
        response.raise_for_status()  # Raise an exception for HTTP error responses

        # Extract the URL from the response
        file_details = response.json()
        public_url = file_details.get('url', '')

        return public_url

    # Example usage:
    # public_url = main(hubspot_resource={'api_key': 'your-hubspot-api-key'}, file_id='your-file-id')
    # print(public_url)
  id: |-
    synthetic_get-file-public-url
  instructions: |-
    Get a publicly available URL for a file that was uploaded using a Hubspot form in hubspot
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ChatMessage } from "npm:@microsoft/microsoft-graph-types";
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
        graphEndpoint: string;
    }

    export async function main(
        microsoftTeamsResource: MicrosoftTeams,
        accessToken: string, // Moved accessToken to function parameters
        chatId: string,
        messageContent: string
    ) {
        // Initialize the Microsoft Graph client with the provided access token
        const client = Client.init({
            authProvider: (done) => {
                done(null, accessToken); // Use the accessToken parameter
            }
        });

        // Create the chat message object
        const chatMessage: ChatMessage = {
            body: {
                content: messageContent
            }
        };

        // Send the chat message to the specified chatId
        const result = await client.api(`/chats/${chatId}/messages`)
            .version('v1.0')
            .post(chatMessage);

        return result;
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
        scope: string;
        teamId: string;
        channelId: string;
    }

    export async function main(microsoftTeamsResource: MicrosoftTeams, message: string) {
        // Initialize Microsoft Graph client
        const client = Client.init({
            authProvider: async (done) => {
                // Implement authentication logic to get the access token
                const token = await getAccessToken(microsoftTeamsResource);
                done(null, token); // Pass the token to the Microsoft Graph client
            }
        });

        // Construct the message payload
        const messagePayload = {
            body: {
                content: message
            }
        };

        // Send the message to the specified team's channel
        const result = await client.api(`/teams/${microsoftTeamsResource.teamId}/channels/${microsoftTeamsResource.channelId}/messages`)
            .version('v1.0')
            .post(messagePayload);

        return result;
    }

    // Helper function to obtain an access token
    async function getAccessToken(resource: MicrosoftTeams): Promise<string> {
        const tokenResponse = await fetch(resource.tokenEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
                'client_id': resource.clientId,
                'scope': resource.scope,
                'client_secret': resource.clientSecret,
                'grant_type': 'client_credentials',
                'tenant': resource.tenantId
            })
        });

        if (!tokenResponse.ok) {
            throw new Error(`Token endpoint returned an error: ${tokenResponse.statusText}`);
        }

        const tokenData = await tokenResponse.json();
        return tokenData.access_token;
    }
  id: |-
    synthetic_send-chat-message
  instructions: |-
    Send a message to a team&#39;s chat in microsoft teams
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftTeams
  resource_type_def: |-
    type MicrosoftTeams = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
        graphEndpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed to interact with nocodb API

    class nocodb(TypedDict):
        api_url: str
        api_key: str
        project_id: str

    def main(nocodb_resource: nocodb, table_name: str) -> List[Any]:
        headers = {
            'xc-auth': nocodb_resource['api_key']
        }
        url = f"{nocodb_resource['api_url']}/api/v1/db/data/{nocodb_resource['project_id']}/{table_name}"
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  good: |-
    from typing import TypedDict, List, Any
    import requests as http_requests

    # Define the resource type for the nocodb integration
    class nocodb(TypedDict):
        api_key: str
        base_url: str
        project_id: str

    def main(nocodb_resource: nocodb, table_name: str, criteria: dict) -> List[Any]:
        # Construct the API endpoint for listing records in a table
        endpoint = f"{nocodb_resource['base_url']}/api/v1/db/data/{nocodb_resource['project_id']}/{table_name}"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {nocodb_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the GET request to list records matching the criteria
        response = http_requests.get(endpoint, headers=headers, params={'where': criteria})

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the records
            return response.json().get('data', [])
        else:
            # If the request failed, raise an exception with the error message
            response.raise_for_status()

    # Example usage:
    # records = main(nocodb_resource={'api_key': 'your_api_key', 'base_url': 'https://api.nocodb.com', 'project_id': 'your_project_id'}, table_name='your_table_name', criteria={'column_name': 'value'})
    # print(records)
  id: |-
    synthetic_list-records-matching-criteria
  instructions: |-
    This action lists all rows in a table in nocodb
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nocodb
  resource_type_def: |-
    class nocodb(TypedDict):
        api_key: str
        base_url: str
        project_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    from pymongo import MongoClient
    from pymongo.collection import Collection as MongoCollection

    # Rename the imported Collection to avoid conflict with the resource type name
    MongoCollectionRenamed = MongoCollection

    class mongodb(TypedDict):
        host: str
        port: int
        username: str
        password: str
        authSource: str
        database: str

    def main(mongodb_resource: mongodb, collection_name: str, document_id: str) -> bool:
        client = MongoClient(
            host=mongodb_resource['host'],
            port=mongodb_resource['port'],
            username=mongodb_resource['username'],
            password=mongodb_resource['password'],
            authSource=mongodb_resource['authSource']
        )

        db = client[mongodb_resource['database']]
        collection = MongoCollectionRenamed(db, collection_name)

        result = collection.delete_one({'_id': document_id})

        return result.deleted_count > 0
  good: |-
    from typing import TypedDict
    from pymongo import MongoClient  # Assuming pymongo is the library used for MongoDB operations

    # Define the resource type for the mongodb integration
    class mongodb(TypedDict):
        host: str
        port: int
        username: str
        password: str
        auth_source: str  # The database to authenticate against
        auth_mechanism: str  # The authentication mechanism

    # The main function that deletes a document from a MongoDB collection
    def main(mongodb_resource: mongodb, database_name: str, collection_name: str, document_filter: dict):
        # Create a MongoDB client instance
        client = MongoClient(
            host=mongodb_resource['host'],
            port=mongodb_resource['port'],
            username=mongodb_resource['username'],
            password=mongodb_resource['password'],
            authSource=mongodb_resource['auth_source'],
            authMechanism=mongodb_resource['auth_mechanism']
        )

        # Access the specified database and collection
        db = client[database_name]
        collection = db[collection_name]

        # Delete the document matching the filter
        result = collection.delete_one(document_filter)

        # Close the client connection
        client.close()

        # Return the result of the delete operation
        return result.deleted_count
  id: |-
    synthetic_delete-document
  instructions: |-
    Delete a single document by ID in mongodb
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mongodb
  resource_type_def: |-
    class mongodb(TypedDict):
        host: str
        port: int
        username: str
        password: str
        auth_source: str  # The database to authenticate against
        auth_mechanism: str  # The authentication mechanism
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import datetime  # Assuming we need this for handling dates

    # Define the resource type for the google_calendar integration
    class google_calendar(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str
        token_uri: str
        calendar_id: str  # Assuming calendar_id is needed for all scripts

    # Define the main function with the resource and any additional parameters
    def main(google_calendar_resource: google_calendar, start_time: datetime.datetime, end_time: datetime.datetime) -> List[dict]:
        # Assuming we have a library to interact with Google Calendar API
        from googleapiclient.discovery import build  # Import the Google Calendar API library

        # Build the service object for the Google Calendar API
        service = build('calendar', 'v3', credentials={
            'client_id': google_calendar_resource['client_id'],
            'client_secret': google_calendar_resource['client_secret'],
            'access_token': google_calendar_resource['access_token'],
            'refresh_token': google_calendar_resource['refresh_token'],
            'token_uri': google_calendar_resource['token_uri'],
        })

        # Call the Calendar API to fetch events
        events_result = service.events().list(
            calendarId=google_calendar_resource['calendar_id'],
            timeMin=start_time.isoformat() + 'Z',  # 'Z' indicates UTC time
            timeMax=end_time.isoformat() + 'Z',
            singleEvents=True,
            orderBy='startTime'
        ).execute()

        # Retrieve the events from the response
        events = events_result.get('items', [])

        # Return the list of events
        return events
  good: |-
    from typing import TypedDict, List
    import googleapiclient.discovery  # Assuming Google Calendar API is used

    # Define the resource type for the google_calendar integration
    class google_calendar(TypedDict):
        api_key: str
        calendar_id: str

    def main(google_calendar_resource: google_calendar, max_results: int = 10) -> List[dict]:
        service = googleapiclient.discovery.build('calendar', 'v3', developerKey=google_calendar_resource['api_key'])

        events_result = service.events().list(calendarId=google_calendar_resource['calendar_id'],
                                              maxResults=max_results,
                                              singleEvents=True,
                                              orderBy='startTime').execute()
        events = events_result.get('items', [])

        return events
  id: |-
    synthetic_list-events
  instructions: |-
    Retrieve a list of event from the Google Calendar in google calendar
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_calendar
  resource_type_def: |-
    class google_calendar(TypedDict):
        api_key: str
        calendar_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(
        dialogflowResource: GoogleDialogflow,
        sessionId: string,
        queryInput: { text: { text: string, languageCode: string } }
    ) {
        const sessionClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail,
            },
            projectId: dialogflowResource.projectId,
        });

        const sessionPath = sessionClient.projectAgentSessionPath(
            dialogflowResource.projectId,
            sessionId
        );

        const request = {
            session: sessionPath,
            queryInput: queryInput,
        };

        const [response] = await sessionClient.detectIntent(request);
        const result = response.queryResult;

        return result;
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(googleDialogflowResource: GoogleDialogflow, intentId: string, languageCode: string = 'en') {
        const dialogflowClient = new SessionsClient({
            credentials: {
                client_email: googleDialogflowResource.clientEmail,
                private_key: googleDialogflowResource.privateKey,
            },
            projectId: googleDialogflowResource.projectId,
        });

        const sessionPath = dialogflowClient.projectAgentSessionPath(googleDialogflowResource.projectId, 'dummy_session');
        const intentPath = `${sessionPath}/intents/${intentId}`;

        const request = {
            name: intentPath,
            intentView: 'INTENT_VIEW_FULL',
            languageCode: languageCode,
        };

        const [intent] = await dialogflowClient.intentsClient.getIntent(request);

        return intent;
    }
  id: |-
    synthetic_get-intent
  instructions: |-
    Retrieves an intent and [client API][https://googleapis.dev/nodejs/dialogflow/latest/google.cloud.dialogflow.v2beta1.Intents.html#getIntent2] in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed for HTTP requests to LinkedIn API

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(linkedin_resource: linkedin, organization_id: str) -> Dict[str, Any]:
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}"
        }

        # Define the URL for the LinkedIn API endpoint to get organization access control information
        url = f"https://api.linkedin.com/v2/organizationAccessControl?q=organization&organization={organization_id}"

        # Make the HTTP GET request to the LinkedIn API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Return an error message if the request failed
            return {'error': 'Failed to retrieve organization access control information', 'status_code': response.status_code}

    # Note: The function is not called here, it is only defined and exported.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token for LinkedIn API

    # Define the function to get a member's organization access control information
    def main(linkedin_resource: linkedin, member_id: str) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Define the endpoint URL for fetching organization access control information
        url = f"https://api.linkedin.com/v2/organizationalEntityAcls?q=roleAssignee&roleAssignee={member_id}"

        # Set up the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {linkedin_resource['access_token']}"
        }

        # Make the HTTP GET request to the LinkedIn API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the relevant information
            return response.json().get('elements', [])
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # The main function is now defined and can be used with the required parameters.
  id: |-
    synthetic_get-member-organization-access-control
  instructions: |-
    Gets the organization access control information of the current authenticated member in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token for LinkedIn API
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Define the resource type for the google_chat integration
    class google_chat(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the Google Chat API client library, renaming it if it conflicts with 'google_chat'
    from googleapiclient.discovery import build as build_google_chat_client

    def main(google_chat_resource: google_chat, space_id: str, member_id: str):
        # Initialize the Google Chat API client with the provided access token
        service = build_google_chat_client('chat', 'v1', credentials=None, developerKey=google_chat_resource['access_token'])

        # Use the Google Chat API to get details about a membership
        membership = service.spaces().members().get(parent=space_id, name=member_id).execute()

        # Return the membership details
        return membership
  good: |-
    from typing import TypedDict, Any, Dict

    class google_chat(TypedDict):
        pass

    def main(google_chat_resource: google_chat, service_account_info: Dict[str, Any], space_id: str, member_id: str) -> Dict[str, Any]:
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build, Resource

        # Authenticate with Google Chat using service account info
        credentials = Credentials.from_service_account_info(service_account_info)
        service: Resource = build('chat', 'v1', credentials=credentials)

        # Retrieve the member from the specified space
        member = service.spaces().members().get(parent=space_id, name=member_id).execute()

        return member
  id: |-
    synthetic_get-member
  instructions: |-
    Returns details about a membership in google chat
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_chat
  resource_type_def: |-
    class google_chat(TypedDict):
        pass
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type FormstackDocuments = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(formstackDocumentsResource: FormstackDocuments, documentId: string, mergeFields: Record<string, any>) {
        const url = `${formstackDocumentsResource.baseUrl}/documents/${documentId}/merge`;
        const headers = {
            'Authorization': `Basic ${encode(formstackDocumentsResource.apiKey + ':')}`,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            merge_fields: mergeFields
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type FormstackDocuments = {
        apiKey: string;
        subdomain: string;
    }

    export async function main(formstackDocumentsResource: FormstackDocuments, documentId: string) {
        const apiUrl = `https://${formstackDocumentsResource.subdomain}.webmerge.me/api/documents/${documentId}`;
        const headers = {
            'Authorization': `Basic ${encode(formstackDocumentsResource.apiKey + ':')}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const documentDetails = await response.json();
        return documentDetails;
    }
  id: |-
    synthetic_get-document
  instructions: |-
    Get the details of the specified document in formstack documents
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FormstackDocuments
  resource_type_def: |-
    type FormstackDocuments = {
        apiKey: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import cohere

    class cohere_platform(TypedDict):
        api_key: str

    def main(cohere_resource: cohere_platform, prompt: str, model: str = 'large', temperature: float = 0.5, max_tokens: int = 50):
        co = cohere.Client(cohere_resource['api_key'])
        response = co.generate(
            model=model,
            prompt=prompt,
            temperature=temperature,
            max_tokens=max_tokens
        )
        return response.text
  good: |-
    from typing import TypedDict
    import cohere  # Assuming cohere is the library for the cohere_platform integration

    class cohere_platform(TypedDict):
        api_key: str

    def main(cohere_resource: cohere_platform, prompt: str, model: str = 'large', temperature: float = 0.5, max_tokens: int = 50):
        co = cohere.Client(cohere_resource['api_key'])
        response = co.generate(
            model=model,
            prompt=prompt,
            temperature=temperature,
            max_tokens=max_tokens
        )
        return response.text
  id: |-
    synthetic_generate-text
  instructions: |-
    This action generates realistic text conditioned on a given input in cohere platform
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cohere_platform
  resource_type_def: |-
    class cohere_platform(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign, email: str) -> Optional[dict]:
        endpoint = f"{activecampaign_resource['api_url']}/api/3/contacts"
        headers = {
            "Api-Token": activecampaign_resource['api_key'],
            "Content-Type": "application/json"
        }
        params = {
            "email": email
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            data = response.json()
            contacts = data.get('contacts')
            if contacts:
                return contacts[0]  # Return the first contact found
            else:
                return None  # No contact found
        else:
            response.raise_for_status()  # Raise an HTTPError if the HTTP request returned an unsuccessful status code

    # The main function is not called, as per the instructions.
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for API interaction

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign, email: str) -> Optional[dict]:
        endpoint = f"{activecampaign_resource['api_url'].rstrip('/')}/api/3/contacts"
        headers = {
            "Api-Token": activecampaign_resource['api_key'],
            "Content-Type": "application/json"
        }
        params = {
            "email": email
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            data = response.json()
            contacts = data.get('contacts')
            if contacts:
                return contacts[0]  # Return the first contact that matches the email
            else:
                return None  # No contact found
        else:
            response.raise_for_status()  # Raise an HTTPError if the HTTP request returned an unsuccessful status code

    # The main function is now defined and can be used with the required activecampaign resource and an email address.
  id: |-
    synthetic_find-contact
  instructions: |-
    Finds a contact. See the docs. in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to Mixmax API

    class mixmax(TypedDict):
        api_key: str

    def main(mixmax_resource: mixmax) -> List[dict]:
        headers = {
            'X-API-Token': mixmax_resource['api_key'],
            'Content-Type': 'application/json'
        }
        response = requests.get('https://api.mixmax.com/v1/contacts', headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        contacts = response.json()

        return contacts

    # The script ends here. The main function can now be exported and used with the appropriate mixmax resource.
  good: |-
    from typing import TypedDict, List, Dict

    # Define the resource type for the mixmax integration
    class mixmax(TypedDict):
        api_key: str

    # Define the main function for getting contacts from mixmax
    def main(mixmax_resource: mixmax, search_query: str = '') -> List[Dict]:
        import requests  # Import requests or any other necessary library here

        # Construct the API endpoint for mixmax contacts
        api_endpoint = "https://api.mixmax.com/v1/contacts"

        # Set up the headers with the API key from the resource
        headers = {
            "X-API-Token": mixmax_resource['api_key']
        }

        # Set up the parameters for the request
        params = {
            "q": search_query  # Search query parameter, empty by default
        }

        # Make the GET request to the Mixmax API
        response = requests.get(api_endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of contacts
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an empty list)
            response.raise_for_status()

    # The script ends here, with no call to the main function as per the instructions.
  id: |-
    synthetic_get-contacts
  instructions: |-
    Lists all your Mixmax Contacts (ie people you've emailed using Mixmax). Does not currently return contacts shared with you via shared contact groups (a performance limitiation) in mixmax
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mixmax
  resource_type_def: |-
    class mixmax(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary library for Mastodon API interaction
    import fetch from "npm:node-fetch";

    type Mastodon = {
        instanceUrl: string;
        accessToken: string;
    }

    export async function main(mastodonResource: Mastodon, statusId: string) {
        const url = `${mastodonResource.instanceUrl}/api/v1/statuses/${statusId}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${mastodonResource.accessToken}`
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching status: ${response.statusText}`);
        }

        const statusInfo = await response.json();
        return statusInfo;
    }
  good: |-
    // Importing necessary libraries
    import { Mastodon as MastodonAPI } from "npm:mastodon-api";

    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodon: Mastodon, statusId: string) {
        const mastodonClient = new MastodonAPI({
            access_token: mastodon.accessToken,
            api_url: mastodon.apiUrl
        });

        try {
            const response = await mastodonClient.get(`statuses/${statusId}`);
            return response.data;
        } catch (error) {
            console.error('Error fetching status:', error);
            throw error;
        }
    }
  id: |-
    synthetic_view-single-status
  instructions: |-
    Obtain information about a status in mastodon
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mastodon
  resource_type_def: |-
    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
        tableName: string;
    }

    export async function main(airtableResource: AirtableOauth, recordId: string | null, recordData: { [key: string]: any }) {
        const base = new Base(airtableResource.apiKey);
        const table = base.getTable(airtableResource.tableName);

        let result;
        if (recordId) {
            // Update the existing record
            result = await table.updateRecordAsync(recordId, recordData);
        } else {
            // Create a new record
            result = await table.createRecordAsync(recordData);
        }

        return result;
    }
  good: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, recordData: { [key: string]: any }, recordId?: string) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(tableName);

        let result;
        if (recordId) {
            // Update an existing record
            result = await table.updateRecordAsync(recordId, recordData);
        } else {
            // Create a new record
            result = await table.createRecordAsync(recordData);
        }

        return result;
    }
  id: |-
    synthetic_create-or-update-record
  instructions: |-
    Updates a record if `recordId` is provided or adds a record to a table. in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import monkeylearn as ml_module

    class monkeylearn(TypedDict):
        api_key: str

    def main(monkeylearn_resource: monkeylearn, extractor_id: str, texts: List[str]):
        ml = ml_module.MonkeyLearn(monkeylearn_resource['api_key'])
        result = ml.extractors.extract(extractor_id, texts)
        return result
  good: |-
    from typing import TypedDict, List
    import monkeylearn as ml_module

    class monkeylearn(TypedDict):
        api_key: str

    def main(monkeylearn_resource: monkeylearn, texts: List[str], model_id: str = 'ex_YCya9nrn') -> List[str]:
        ml = ml_module.MonkeyLearn(monkeylearn_resource['api_key'])
        result = ml.extractors.extract(model_id, texts)
        extracted_data = [extraction.result for extraction in result.body]
        return extracted_data
  id: |-
    synthetic_extract-text
  instructions: |-
    Extracts information from texts with a given extractor in monkeylearn
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    monkeylearn
  resource_type_def: |-
    class monkeylearn(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MondayClient } from "npm:@mondaydotcom/monday-sdk-js";

    type Monday = {
        apiKey: string;
        boardId: number;
    }

    export async function main(mondayResource: Monday, groupName: string) {
        const mondayClient = new MondayClient();
        mondayClient.setToken(mondayResource.apiKey);

        const query = `mutation ($boardId: Int!, $groupName: String!) {
            create_group (board_id: $boardId, group_name: $groupName) {
                id
            }
        }`;

        const variables = {
            boardId: mondayResource.boardId,
            groupName: groupName
        };

        try {
            const response = await mondayClient.api(query, { variables });
            return response.data.create_group;
        } catch (error) {
            console.error(error);
            throw new Error('Failed to create a new group in the specified Monday board.');
        }
    }
  good: |-
    import { MondayClient as MondayApiClient } from "npm:@mondaydotcom/monday-sdk-js";

    type Monday = {
        apiKey: string;
    }

    export async function main(mondayResource: Monday, groupName: string, boardId: number) {
        const mondayClient = new MondayApiClient();
        mondayClient.setToken(mondayResource.apiKey);

        const query = `mutation ($boardId: Int!, $groupName: String!) {
            create_group (board_id: $boardId, group_name: $groupName) {
                id
            }
        }`;

        const variables = {
            boardId: boardId,
            groupName: groupName
        };

        try {
            const response = await mondayClient.api(query, { variables });
            return response.data.create_group;
        } catch (error) {
            console.error(error);
            throw new Error('Failed to create group on Monday.com');
        }
    }
  id: |-
    synthetic_create-group
  instructions: |-
    Creates a new group in a specific board in monday
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Monday
  resource_type_def: |-
    type Monday = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Confection = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(confectionResource: Confection, uuid: string) {
        const url = `https://api.confection.io/data/${uuid}`;
        const headers = {
            'Authorization': `Bearer ${confectionResource.apiKey}:${confectionResource.apiSecret}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Confection = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(confectionResource: Confection, uuid: string) {
        const url = `https://api.confection.io/v1/details/${uuid}`;
        const headers = {
            'Authorization': `Bearer ${confectionResource.apiKey}:${confectionResource.apiSecret}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-uuid-details
  instructions: |-
    Provide the UUID to retrieve details of. in confection
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Confection
  resource_type_def: |-
    type Confection = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import datetime

    # Assuming 'google_calendar' is a module that could be imported
    # but since it conflicts with the resource type name, we rename it.
    import google_calendar as gc_module

    class google_calendar(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str
        token_uri: str

    def main(google_calendar_resource: google_calendar, calendar_id: str, time_min: datetime.datetime, time_max: datetime.datetime, items: List[Dict[str, str]]):
        # Set up the credentials for the Google Calendar API
        credentials = {
            'client_id': google_calendar_resource['client_id'],
            'client_secret': google_calendar_resource['client_secret'],
            'access_token': google_calendar_resource['access_token'],
            'refresh_token': google_calendar_resource['refresh_token'],
            'token_uri': google_calendar_resource['token_uri']
        }

        # Initialize the Google Calendar service with the credentials
        service = gc_module.CalendarService(credentials)

        # Prepare the request body for the free/busy query
        body = {
            'timeMin': time_min.isoformat(),
            'timeMax': time_max.isoformat(),
            'items': [{'id': calendar_id}] + items
        }

        # Use the service to query the free/busy information
        free_busy_result = service.freebusy().query(body=body).execute()

        # Return the result of the free/busy query
        return free_busy_result
  good: |-
    from typing import TypedDict, List, Dict
    import datetime

    # Assuming 'googleapiclient.discovery' is the library needed for Google Calendar API
    from googleapiclient.discovery import build as google_build

    # Define the resource type for the google_calendar integration
    class google_calendar(TypedDict):
        api_key: str
        service_account_info: Dict

    # Define the main function with the required parameters
    def main(google_calendar_resource: google_calendar,
             calendar_id: str,
             time_min: datetime.datetime,
             time_max: datetime.datetime,
             time_zone: str = 'UTC') -> List[Dict]:

        # Build the Google Calendar service
        service = google_build('calendar', 'v3', developerKey=google_calendar_resource['api_key'])

        # Call the freebusy query method from the Google Calendar API
        body = {
            "timeMin": time_min.isoformat(),
            "timeMax": time_max.isoformat(),
            "timeZone": time_zone,
            "items": [{"id": calendar_id}]
        }
        eventsResult = service.freebusy().query(body=body).execute()

        # Extract the free/busy details from the response
        free_busy_details = eventsResult.get('calendars', {}).get(calendar_id, {}).get('busy', [])

        # Return the free/busy details
        return free_busy_details

    # Note: The function is not called here, as per the instructions.
  id: |-
    synthetic_query-free-busy-calendars
  instructions: |-
    Retrieve free/busy calendar details from Google Calendar in google calendar
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_calendar
  resource_type_def: |-
    class google_calendar(TypedDict):
        client_id: str
        client_secret: str
        access_token: str
        refresh_token: str
        token_uri: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Ongage = {
        apiUrl: string,
        username: string,
        password: string,
        accountCode: string
    }

    export async function main(
        ongageResource: Ongage,
        listId: string,
        email: string,
        fieldsToUpdate: Record<string, any>
    ) {
        const credentials = `${ongageResource.username}:${ongageResource.password}`;
        const encodedCredentials = encode(credentials);
        const url = `${ongageResource.apiUrl}/lists/${listId}/contacts/${email}`;

        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X_USERNAME': ongageResource.username,
                'X_PASSWORD': ongageResource.password,
                'X_ACCOUNT_CODE': ongageResource.accountCode,
                'Authorization': `Basic ${encodedCredentials}`
            },
            body: JSON.stringify(fieldsToUpdate)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:base-64";

    type Ongage = {
        apiUrl: string,
        username: string,
        password: string,
        accountCode: string
    }

    export async function main(
        ongageResource: Ongage,
        listId: string,
        subscriberEmail: string,
        fieldsToUpdate: Record<string, any>
    ) {
        const credentials = `${ongageResource.username}:${ongageResource.password}`;
        const encodedCredentials = encode(credentials);
        const url = `${ongageResource.apiUrl}/lists/${listId}/contacts/${subscriberEmail}`;
        const headers = {
            'Content-Type': 'application/json',
            'X_USERNAME': ongageResource.username,
            'X_PASSWORD': ongageResource.password,
            'X_ACCOUNT_CODE': ongageResource.accountCode,
            'Authorization': `Basic ${encodedCredentials}`
        };

        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(fieldsToUpdate)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-subscriber
  instructions: |-
    Update a list subscriber in Ongage. in ongage
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ongage
  resource_type_def: |-
    type Ongage = {
        apiUrl: string,
        username: string,
        password: string,
        accountCode: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ConnectionPool } from "mssql";

    type AzureSql = {
        connectionString: string;
    }

    export async function main(azureSqlResource: AzureSql, query: string) {
        const pool = new ConnectionPool(azureSqlResource.connectionString);
        await pool.connect();
        const result = await pool.request().query(query);
        await pool.close();
        return result.recordset;
    }
  good: |-
    import { ConnectionPool } from "npm:mssql";

    type AzureSql = {
        server: string;
        database: string;
        user: string;
        password: string;
        encrypt: boolean;
    }

    export async function main(azureSqlResource: AzureSql, query: string) {
        const pool = new ConnectionPool({
            server: azureSqlResource.server,
            database: azureSqlResource.database,
            user: azureSqlResource.user,
            password: azureSqlResource.password,
            options: {
                encrypt: azureSqlResource.encrypt, // for Azure SQL Database
            },
        });

        try {
            await pool.connect();
            const result = await pool.request().query(query);
            return result.recordset;
        } catch (err) {
            // handle error here; possibly rethrow or return a custom error message
            throw err;
        } finally {
            pool.close(); // always close the connection pool
        }
    }
  id: |-
    synthetic_execute-query
  instructions: |-
    Executes a SQL query and returns the results in azure sql
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AzureSql
  resource_type_def: |-
    type AzureSql = {
        connectionString: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AskNicely as AskNicelyClient } from "npm:asknicely"; // Renamed imported class to avoid conflict

    type Asknicely = {
        apiKey: string,
        domain: string
    }

    export async function main(asknicelyResource: Asknicely, startDate: string, endDate: string) {
        const askNicelyClient = new AskNicelyClient(asknicelyResource.apiKey, asknicelyResource.domain);

        const responses = await askNicelyClient.getResponses({
            start_date: startDate,
            end_date: endDate
        });

        return responses;
    }
  good: |-
    import { fetch } from "npm:@deno/fetch";

    type AskNicely = {
        apiKey: string;
        domain: string;
    }

    export async function main(askNicelyResource: AskNicely, contactEmail: string) {
        const url = `https://${askNicelyResource.domain}.asknice.ly/api/v1/contacts/${encodeURIComponent(contactEmail)}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Basic ${btoa(askNicelyResource.apiKey + ':')}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const contactDetails = await response.json();
        return contactDetails;
    }
  id: |-
    synthetic_get-responses
  instructions: |-
    Get the details of a particular contact in asknicely
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asknicely
  resource_type_def: |-
    type Asknicely = {
        apiKey: string,
        domain: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mixmax API

    class mixmax(TypedDict):
        api_key: str

    def main(mixmax_resource: mixmax, contact_id: str, updated_contact_info: dict):
        headers = {
            'Authorization': f'Bearer {mixmax_resource["api_key"]}',
            'Content-Type': 'application/json'
        }
        url = f'https://api.mixmax.com/v1/contacts/{contact_id}'
        response = requests.put(url, headers=headers, json=updated_contact_info)

        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the mixmax integration
    class mixmax(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for updating a contact in mixmax
    def main(mixmax_resource: mixmax, contact_id: str, update_fields: dict[str, Any]):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a contact
        api_endpoint = f"https://api.mixmax.com/v1/contacts/{contact_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Content-Type": "application/json",
            "X-API-Token": mixmax_resource['api_key']
        }

        # Make the request to update the contact with the given fields
        response = requests.patch(api_endpoint, json=update_fields, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated contact information
        else:
            # Handle the error case appropriately
            response.raise_for_status()
  id: |-
    synthetic_update-contact
  instructions: |-
    Update a specific contact in mixmax
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mixmax
  resource_type_def: |-
    class mixmax(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import json
    from typing import TypedDict, Any

    class helper_functions(TypedDict):
        api_key: str

    def main(helper_functions_resource: helper_functions, json_data: Any) -> str:
        pretty_json = json.dumps(json_data, indent=4, sort_keys=True)
        return pretty_json
  good: |-
    from typing import TypedDict, Any
    import json

    class helper_functions(TypedDict):
        # Assuming the helper_functions integration requires an API key for authentication
        api_key: str

    def main(helper_functions_resource: helper_functions, value_to_pretty_print: Any, indent: int = 4):
        pretty_printed_value = json.dumps(value_to_pretty_print, indent=indent)
        print(pretty_printed_value)
        return pretty_printed_value

    # The main function is not called here, as per the instructions.
  id: |-
    synthetic_prettify-json
  instructions: |-
    Pretty print a JavaScript object or value in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make API calls

    class gryd(TypedDict):
        api_key: str
        base_url: str

    def main(gryd_resource: gryd, vehicle_registration_number: str) -> dict:
        headers = {
            'Authorization': f"Bearer {gryd_resource['api_key']}"
        }
        response = requests.get(
            f"{gryd_resource['base_url']}/mot-data/{vehicle_registration_number}",
            headers=headers
        )
        response.raise_for_status()  # This will raise an error for non-2xx responses
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the 'gryd' integration
    class gryd(TypedDict):
        api_key: str
        base_url: str

    # Define the main function with the resource type and additional parameters
    def main(gryd_resource: gryd, vehicle_registration_number: str) -> Dict[str, Any]:
        headers = {
            'X-Api-Key': gryd_resource['api_key']
        }
        url = f"{gryd_resource['base_url']}/vehicles/{vehicle_registration_number}/mot"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  id: |-
    synthetic_get-vehicle-mot-data
  instructions: |-
    Fetches MOT data for a specific vehicle from the Gryd API in gryd
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gryd
  resource_type_def: |-
    class gryd(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import iauditor_by_safetyculture as iauditor_api  # Renamed imported module to avoid conflict

    class iauditor_by_safetyculture(TypedDict):
        api_token: str

    def main(iauditor_resource: iauditor_by_safetyculture, audit_id: str, report_format: str = 'PDF') -> bytes:
        api = iauditor_api.IAuditor(api_token=iauditor_resource['api_token'])
        report = api.generate_report(audit_id, report_format)
        return report
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests

    class iauditor_by_safetyculture(TypedDict):
        api_token: str
        base_url: str

    def main(iauditor_resource: iauditor_by_safetyculture, inspection_id: str) -> str:
        headers = {
            'Authorization': f"Bearer {iauditor_resource['api_token']}",
            'Content-Type': 'application/json'
        }

        response = requests.get(
            f"{iauditor_resource['base_url']}/inspections/{inspection_id}/web_report_link",
            headers=headers
        )

        response.raise_for_status()  # This will raise an exception for HTTP error codes

        report_link_data = response.json()
        return report_link_data.get('link')

    # The script ends here. The function main can now be exported and used with the required parameters.
  id: |-
    synthetic_generate-pdf-report
  instructions: |-
    Retrieve the web report link for the specified inspection. This will return the existing link if one has been generated before, or generate a new one if one does not exist already in iauditor by safetyculture
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    iauditor_by_safetyculture
  resource_type_def: |-
    class iauditor_by_safetyculture(TypedDict):
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GmailCustomOauth = {
        clientEmail: string;
        privateKey: string;
        scopes: string[];
    }

    export async function main(gmailResource: GmailCustomOauth, userEmail: string, newSignature: string) {
        const { clientEmail, privateKey, scopes } = gmailResource;

        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            scopes
        );

        await jwtClient.authorize();

        const gmail = google.gmail({ version: 'v1', auth: jwtClient });

        const res = await gmail.users.settings.sendAs.update({
            userId: userEmail,
            sendAsEmail: userEmail,
            requestBody: {
                signature: newSignature
            }
        });

        return res.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GmailCustomOauth = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
    }

    export async function main(gmailResource: GmailCustomOauth, newSignature: string) {
        const { clientId, clientSecret, refreshToken, accessToken } = gmailResource;
        const gmail = google.gmail({ version: 'v1', auth: new google.auth.OAuth2(clientId, clientSecret, '') });

        gmail.auth.setCredentials({
            refresh_token: refreshToken,
            access_token: accessToken,
        });

        const res = await gmail.users.settings.sendAs.update({
            userId: 'me',
            sendAsEmail: 'me',
            resource: {
                signature: newSignature
            }
        });

        return res.data;
    }
  id: |-
    synthetic_update-primary-signature
  instructions: |-
    Update the signature for the primary email address in gmail custom oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GmailCustomOauth
  resource_type_def: |-
    type GmailCustomOauth = {
        clientEmail: string;
        privateKey: string;
        scopes: string[];
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Freshdesk = {
        apiKey: string,
        domain: string
    }

    export async function main(freshdeskResource: Freshdesk, subject: string, description: string, email: string, priority: number, status: number) {
        const url = `https://${freshdeskResource.domain}.freshdesk.com/api/v2/tickets`;
        const authHeader = `Basic ${encode(`${freshdeskResource.apiKey}:X`)}`;

        const ticketData = {
            subject: subject,
            description: description,
            email: email,
            priority: priority,
            status: status
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(ticketData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { createClient } from "npm:@freshdesk/api";

    type Freshdesk = {
        apiKey: string;
        domain: string;
    }

    export async function main(freshdeskResource: Freshdesk, subject: string, description: string, email: string, priority: number, status: number) {
        const client = createClient({
            apiKey: freshdeskResource.apiKey,
            domain: freshdeskResource.domain,
        });

        const ticketData = {
            subject: subject,
            description: description,
            email: email,
            priority: priority,
            status: status,
        };

        const result = await client.tickets.create(ticketData);

        return result;
    }
  id: |-
    synthetic_create-ticket
  instructions: |-
    Create a ticket in freshdesk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Freshdesk
  resource_type_def: |-
    type Freshdesk = {
        apiKey: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Page } from "npm:@types/facebook-js-sdk";

    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }

    export async function main(facebookPagesResource: FacebookPages, postId: string, message: string) {
        const url = `https://graph.facebook.com/v14.0/${facebookPagesResource.pageId}_${postId}?message=${encodeURIComponent(message)}&access_token=${facebookPagesResource.accessToken}`;
        const response = await fetch(url, {
            method: 'POST',
        });

        const result = await response.json();
        return result;
    }
  good: |-
    // Importing necessary libraries
    import { PageAccessToken } from "npm:@types/facebook-js-sdk";

    type FacebookPages = {
        pageId: string;
        accessToken: string;
    }

    export async function main(facebookPagesResource: FacebookPages, postId: string, commentId: string, newCommentText: string) {
        const url = `https://graph.facebook.com/v14.0/${postId}_${commentId}?message=${encodeURIComponent(newCommentText)}&access_token=${facebookPagesResource.accessToken}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_update-comment
  instructions: |-
    Updates an existing comment on a post on a Facebook Page in facebook pages
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FacebookPages
  resource_type_def: |-
    type FacebookPages = {
        accessToken: string;
        pageId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the jp_funda integration
    class jp_funda(TypedDict):
        api_key: str
        base_url: str

    # Define the main function with the resource type and any additional parameters
    def main(jp_funda_resource: jp_funda, search_query: str, max_results: int = 10) -> List[Any]:
        headers = {
            'Authorization': f"Bearer {jp_funda_resource['api_key']}"
        }
        search_url = f"{jp_funda_resource['base_url']}/search"
        params = {
            'query': search_query,
            'limit': max_results
        }

        response = requests.get(search_url, headers=headers, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()  # Assuming the API returns JSON

    # The script ends here, with no call to the main function, as per the instructions.
  good: |-
    from typing import TypedDict, Optional
    from datetime import datetime
    import requests  # Assuming requests is needed to retrieve data from an API

    class jp_funda(TypedDict):
        api_key: str
        base_url: str

    def main(jp_funda_resource: jp_funda, report_date: datetime) -> Optional[dict]:
        url = f"{jp_funda_resource['base_url']}/securities_reports"
        headers = {
            "Authorization": f"Bearer {jp_funda_resource['api_key']}"
        }
        params = {
            "report_date": report_date.strftime("%Y-%m-%d")
        }
        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()
            return None
  id: |-
    synthetic_search-listings
  instructions: |-
    Retrieve data by specifying the date the securities report was published in jp funda
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jp_funda
  resource_type_def: |-
    class jp_funda(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Drata as DrataClient } from "npm:@drata/sdk"; // Renamed imported Drata to DrataClient to avoid conflict

    type Drata = {
        apiKey: string,
        apiSecret: string
    }

    export async function main(drata: Drata, controlName: string, controlDescription: string) {
        // Initialize the Drata client with the provided credentials
        const drataClient = new DrataClient({
            apiKey: drata.apiKey,
            apiSecret: drata.apiSecret
        });

        // Create a new control in Drata
        const result = await drataClient.createControl({
            name: controlName,
            description: controlDescription
        });

        // Return the result of the control creation
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { DrataClient } from "npm:@drata/sdk"; // Assuming there's an npm package named @drata/sdk for Drata API

    type Drata = {
        apiKey: string;
        // Add any other properties required for Drata authentication/configuration
    }

    export async function main(drataResource: Drata, controlName: string) {
        // Initialize the Drata client with the API key from the resource
        const drataClient = new DrataClient({ apiKey: drataResource.apiKey });

        // Fetch the control information from Drata using the control name
        const controlInfo = await drataClient.getControlByName(controlName);

        // Return the control information
        return controlInfo;
    }
  id: |-
    synthetic_create-control
  instructions: |-
    The name of the control. in drata
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Drata
  resource_type_def: |-
    type Drata = {
        apiKey: string,
        apiSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the activecampaign integration
    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    # Define the main function for creating a note in ActiveCampaign
    def main(activecampaign_resource: activecampaign, contact_id: int, note_text: str, note_type: int = 0) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a note
        endpoint = f"{activecampaign_resource['api_url'].rstrip('/')}/api/3/notes"

        # Prepare the headers and payload for the API request
        headers = {
            'Api-Token': activecampaign_resource['api_key'],
            'Content-Type': 'application/json'
        }
        payload = {
            'note': {
                'contact': contact_id,
                'note': note_text,
                'type': note_type
            }
        }

        # Make the API request to create a note
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check for a successful response and return the result
        if response.status_code == 201:
            return response.json()
        else:
            # Handle error responses
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Active Campaign API

    # Define the resource type for the activecampaign integration
    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    # Define the function to add a note to an Active Campaign object
    def main(activecampaign_resource: activecampaign, object_type: str, object_id: int, note: str) -> Dict[str, Any]:
        # Construct the endpoint URL based on the object type
        endpoint = f"{activecampaign_resource['api_url']}/api/3/{object_type}s/{object_id}/notes"

        # Prepare the headers and data payload for the POST request
        headers = {
            'Api-Token': activecampaign_resource['api_key'],
            'Content-Type': 'application/json'
        }
        data = {
            "note": {
                "note": note,
                "relid": object_id,
                "reltype": object_type.capitalize()
            }
        }

        # Make the POST request to add the note
        response = requests.post(endpoint, json=data, headers=headers)

        # Check if the request was successful and return the result
        if response.status_code == 201:
            return response.json()
        else:
            # If the request failed, return the status code and error message
            return {
                "status_code": response.status_code,
                "error": response.json()
            }

    # Example usage:
    # result = main(activecampaign_resource={'api_url': 'https://youraccount.api-us1.com', 'api_key': 'your_api_key'}, object_type='contact', object_id=123, note='This is a note.')
    # print(result)
  id: |-
    synthetic_create-note
  instructions: |-
    Adds a note, arbitrary information to a contact, deal, or other Active Campaign objects. See the docs. in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Assuming helper_functions is a module that contains a method we need to rename
    import helper_functions as hf_module

    # Renaming the conflicting method
    compare_arrays = hf_module.compare_arrays

    class helper_functions(TypedDict):
        # Assuming the helper_functions integration requires an API key for authentication
        api_key: str

    def main(helper_functions_resource: helper_functions, array1: List[int], array2: List[int]) -> bool:
        # Assuming the compare_arrays method from the helper_functions integration
        # compares two arrays and returns True if they are equal, False otherwise.
        result = compare_arrays(array1, array2, api_key=helper_functions_resource['api_key'])
        return result
  good: |-
    from typing import TypedDict, List, Set

    # Define the resource type for the 'helper_functions' integration
    class helper_functions(TypedDict):
        api_key: str  # Assuming API key is needed for authentication

    # Define the main function with the resource type and additional parameters
    def main(helper_functions_resource: helper_functions, array1: List[int], array2: List[int], operation: str) -> Set[int]:
        set1 = set(array1)
        set2 = set(array2)

        if operation == 'difference':
            return set1 - set2
        elif operation == 'intersection':
            return set1 & set2
        elif operation == 'union':
            return set1 | set2
        elif operation == 'symmetric_difference':
            return set1 ^ set2
        else:
            raise ValueError("Invalid operation specified. Choose from 'difference', 'intersection', 'union', 'symmetric_difference'.")

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_compare-arrays
  instructions: |-
    Get the difference, intersection, union, or symetric difference of two arrays/sets. in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        # Assuming the helper_functions integration requires an API key for authentication
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Codereadr = {
        apiKey: string;
    }

    export async function main(codereadrResource: Codereadr, serviceId: string, barcodeValue: string, newBarcodeValue: string) {
        const url = `https://api.codereadr.com/api/`;
        const method = barcodeValue ? 'post' : 'put'; // 'post' to add, 'put' to update
        const endpoint = barcodeValue ? 'barcode' : `barcode/${barcodeValue}`;

        const headers = {
            'Authorization': `Basic ${encode(codereadrResource.apiKey + ':')}`,
            'Content-Type': 'application/x-www-form-urlencoded'
        };

        const body = `service_id=${serviceId}&value=${newBarcodeValue}`;

        const response = await fetch(url + endpoint, {
            method: method,
            headers: headers,
            body: body
        });

        const result = await response.json();

        return result;
    }
  good: |-
    import { encode as base64Encode } from "npm:@stablelib/base64";

    type Codereadr = {
        apiKey: string;
        serviceId: string;
    }

    export async function main(codereadrResource: Codereadr, barcodeValue: string, databaseId: string, newBarcodeValue?: string) {
        const url = `https://api.codereadr.com/api/`;
        const method = newBarcodeValue ? 'post' : 'put';
        const endpoint = newBarcodeValue ? 'barcode' : `barcode/${barcodeValue}`;
        const body = newBarcodeValue ? { value: newBarcodeValue } : {};

        const response = await fetch(`${url}${endpoint}`, {
            method: method,
            headers: {
                'Authorization': `Basic ${base64Encode(codereadrResource.apiKey + ':')}`,
                'Content-Type': 'application/json',
                'Service-ID': codereadrResource.serviceId
            },
            body: JSON.stringify({
                ...body,
                service_id: codereadrResource.serviceId,
                database_id: databaseId
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-update-barcode-value
  instructions: |-
    Adds or updates a barcode value in the selected database in codereadr
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Codereadr
  resource_type_def: |-
    type Codereadr = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:querystring";

    type Megaventory = {
        apiKey: string;
        apiUrl: string;
    };

    export async function main(
        megaventoryResource: Megaventory,
        purchaseOrderDetails: {
            PurchaseOrderNo: string;
            SupplierClientID: number;
            PurchaseOrderStatus: string;
            PurchaseOrderDetails: Array<{
                InventoryLocationID: number;
                ProductID: number;
                PurchaseOrderRowQuantity: number;
                PurchaseOrderRowUnitCostWithoutTaxOrDiscount: number;
            }>;
        }
    ) {
        const requestBody = {
            APIKEY: megaventoryResource.apiKey,
            mvPurchaseOrder: purchaseOrderDetails,
            mvRecordAction: "InsertOrUpdate"
        };

        const response = await fetch(`${megaventoryResource.apiUrl}/PurchaseOrder/Update`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: encode(requestBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  good: |-
    // Import necessary libraries
    import { encode } from "npm:querystring";

    type Megaventory = {
        apiKey: string;
        accountUrl: string;
    }

    export async function main(
        megaventoryResource: Megaventory,
        purchaseOrder: {
            SupplierClientID: number;
            PurchaseOrderDetails: Array<{
                InventoryLocationID: number;
                ProductID: number;
                PurchaseOrderRowQuantity: number;
                PurchaseOrderRowUnitPriceWithoutTaxOrDiscount: number;
            }>;
            PurchaseOrderStatus: string;
            PurchaseOrderReferenceNo?: string;
            PurchaseOrderComments?: string;
        }
    ) {
        const { apiKey, accountUrl } = megaventoryResource;
        const endpoint = `${accountUrl}/PurchaseOrder/SupplierPurchaseOrderUpdate`;

        const body = {
            APIKEY: apiKey,
            mvPurchaseOrder: purchaseOrder,
            mvRecordAction: "InsertOrUpdate"
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: encode(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_insert-or-update-purchase-order
  instructions: |-
    Insert or update a purchase order in the database. in megaventory
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Megaventory
  resource_type_def: |-
    type Megaventory = {
        apiKey: string;
        accountUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ClickUp as ClickUpClient } from "npm:clickup.js";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, teamId: string, customFieldId: string) {
        const clickUpClient = new ClickUpClient(clickupResource.apiKey);

        const customFields = await clickUpClient.CustomFields.getCustomField(teamId, customFieldId);

        return customFields;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Clickup = {
        accessToken: string;
    }

    export async function main(clickupResource: Clickup, teamId: string) {
        const url = `https://api.clickup.com/api/v2/team/${teamId}/field`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': clickupResource.accessToken,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching custom fields: ${response.statusText}`);
        }

        const customFields = await response.json();
        return customFields;
    }
  id: |-
    synthetic_get-custom-fields
  instructions: |-
    Get a list of custom fields. See the docs in **Custom Fields / Get Accessible Custom Fields** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { NordigenClient } from "npm:nordigen";

    type Nordigen = {
        accessToken: string,
        accountId: string
    }

    export async function main(nordigenResource: Nordigen) {
        // Initialize Nordigen client with the access token
        const nordigenClient = new NordigenClient({ accessToken: nordigenResource.accessToken });

        // Retrieve the account balances using the Nordigen client and the account ID
        const balances = await nordigenClient.getAccountBalances(nordigenResource.accountId);

        // Return the result
        return balances;
    }
  good: |-
    import { NordigenClient as NordigenApiClient } from "npm:nordigen";

    type Nordigen = {
        accessToken: string,
        secretId: string,
        secretKey: string
    }

    export async function main(nordigenResource: Nordigen, accountId: string) {
        const nordigenClient = new NordigenApiClient({
            secretId: nordigenResource.secretId,
            secretKey: nordigenResource.secretKey,
            accessToken: nordigenResource.accessToken
        });

        const accountBalances = await nordigenClient.getAccountBalances(accountId);

        return accountBalances;
    }
  id: |-
    synthetic_get-account-balances
  instructions: |-
    Get the balances of a Nordigen account in nordigen
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nordigen
  resource_type_def: |-
    type Nordigen = {
        accessToken: string,
        secretId: string,
        secretKey: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Insightly = {
        apiKey: string;
    }

    export async function main(insightlyResource: Insightly, firstName: string, lastName: string, email: string, tags?: string[]) {
        const endpoint = 'https://api.insightly.com/v3.1/Contacts';
        const authHeader = `Basic ${encode(insightlyResource.apiKey + ':')}`;

        const contactData = {
            FIRST_NAME: firstName,
            LAST_NAME: lastName,
            EMAIL_ADDRESS: email,
            TAGS: tags?.map(tag => ({ TAG_NAME: tag })) || []
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(contactData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Insightly = {
        apiKey: string;
    }

    export async function main(insightlyResource: Insightly, firstName: string, lastName: string, email: string, tags: string[] = []) {
        const apiUrl = 'https://api.insightly.com/v3.1/Contacts';
        const authHeader = `Basic ${encode(insightlyResource.apiKey + ":")}`;

        const contactData = {
            FIRST_NAME: firstName,
            LAST_NAME: lastName,
            EMAIL_ADDRESS: email,
            TAGS: tags.map(tag => ({ TAG_NAME: tag }))
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(contactData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-contact
  instructions: |-
    Creates a new contact in insightly
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Insightly
  resource_type_def: |-
    type Insightly = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, contactId: string, workflowId: string) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });
        const result = await hubspotClient.crm.contacts.basicApi.getById(contactId);
        const contactProperties = result.body.properties;

        if (!contactProperties) {
            throw new Error('Contact not found');
        }

        await hubspotClient.automation.actionsApi.enroll(workflowId, { inputs: [{ id: contactId }] });

        return { message: `Contact with ID ${contactId} has been enrolled in workflow ${workflowId}.` };
    }
  good: |-
    // Import necessary libraries
    import { Hubspot } from "npm:@hubspot/api-client";

    type HubspotResource = {
        apiKey: string;
    }

    export async function main(hubspotResource: HubspotResource, contactId: string, workflowId: string) {
        const hubspotClient = new Hubspot({ apiKey: hubspotResource.apiKey });
        const path = `/automation/v3/workflows/${workflowId}/enrollments/contacts/${contactId}`;
        const requestOptions = {
            method: 'POST',
            body: JSON.stringify({}),
            headers: {
                'Content-Type': 'application/json'
            }
        };

        try {
            const response = await hubspotClient.apiRequest({
                method: requestOptions.method,
                path: path,
                body: requestOptions.body,
                headers: requestOptions.headers
            });
            return response;
        } catch (error) {
            // Handle error appropriately
            console.error('Error enrolling contact to workflow:', error);
            throw error;
        }
    }
  id: |-
    synthetic_enroll-contact-into-workflow
  instructions: |-
    Add a contact to a workflow. Note: The Workflows API currently only supports contact-based workflows in hubspot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { ActiveCampaign as ACClient } from "npm:@activecampaign/api";

    type Activecampaign = {
        apiUrl: string;
        apiKey: string;
    }

    export async function main(activecampaignResource: Activecampaign, email: string, firstName: string, lastName: string, phone?: string) {
        // Initialize ActiveCampaign client
        const ac = new ACClient(activecampaignResource.apiUrl, activecampaignResource.apiKey);

        // Create contact object
        const contact = {
            email: email,
            firstName: firstName,
            lastName: lastName,
            phone: phone
        };

        // Add or update the contact in ActiveCampaign
        const response = await ac.contacts.createOrUpdate(contact);

        // Return the result
        return response;
    }
  good: |-
    import { ActiveCampaign } from "npm:@activecampaign/api";

    type Activecampaign = {
        apiUrl: string;
        apiKey: string;
    }

    export async function main(activecampaignResource: Activecampaign, email: string, firstName: string, lastName: string, phone?: string) {
        const ac = new ActiveCampaign(activecampaignResource.apiUrl, activecampaignResource.apiKey);

        const contactData = {
            email: email,
            firstName: firstName,
            lastName: lastName,
            phone: phone
        };

        try {
            const response = await ac.contacts.create(contactData);
            return response;
        } catch (error) {
            console.error('Error creating new contact in ActiveCampaign:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-contact
  instructions: |-
    Create a new contact. See the docs. in activecampaign
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Activecampaign
  resource_type_def: |-
    type Activecampaign = {
        apiUrl: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type HelperFunctions = {
        apiKey: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, iso8601DateTime: string) {
        const formattedDateTime = new Date(iso8601DateTime).toLocaleString('en-US', {
            timeZone: 'UTC',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
        }).replace(/(\d+)\/(\d+)\/(\d+), (\d+):(\d+):(\d+)/, '$3-$1-$2T$4:$5:$6Z');

        return formattedDateTime;
    }
  good: |-
    import moment from "npm:moment";

    type HelperFunctions = {
        // Assuming the HelperFunctions integration requires no specific credentials or configuration
    }

    export async function main(helperFunctionsResource: HelperFunctions, isoDate: string) {
        const formattedDateTime = moment(isoDate).format('MM/DD/YYYY HH:mm:ss');
        const formattedDate = moment(isoDate).format('MM/DD/YYYY');
        const formattedTime = moment(isoDate).format('HH:mm:ss');

        return {
            dateTime: formattedDateTime,
            date: formattedDate,
            time: formattedTime
        };
    }
  id: |-
    synthetic_format-iso8601-datetime
  instructions: |-
    Use the moment.js npm package to format an ISO8601 date/time as Google Sheets friendly formats. This action exports an object with compound date/time, date-only, and time-only values. in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Agendor = {
        apiToken: string;
    }

    export async function main(agendorResource: Agendor, organizationName: string, additionalInfo?: Record<string, any>) {
        const url = 'https://api.agendor.com.br/v3/organizations';
        const headers = {
            'Authorization': `Token ${agendorResource.apiToken}`,
            'Content-Type': 'application/json',
        };
        const body = JSON.stringify({
            name: organizationName,
            ...additionalInfo,
        });

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: body
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Error creating organization in Agendor:', error);
            throw error;
        }
    }
  good: |-
    import { AgendorClient as AgendorApiClient } from "npm:agendor";

    type Agendor = {
        token: string;
    }

    export async function main(agendorResource: Agendor, organizationName: string, additionalInfo?: Record<string, any>) {
        const agendorClient = new AgendorApiClient(agendorResource.token);

        const organizationData = {
            name: organizationName,
            ...additionalInfo
        };

        const result = await agendorClient.createOrganization(organizationData);

        return result;
    }
  id: |-
    synthetic_create-organization
  instructions: |-
    Create Organization. in agendor
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Agendor
  resource_type_def: |-
    type Agendor = {
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the clickup integration
    class clickup(TypedDict):
        api_key: str

    # Define the main function with the resource type and any additional parameters
    def main(clickup_resource: clickup, task_id: str) -> List[dict]:
        # Set up the headers for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Define the endpoint URL for getting task comments
        url = f"https://api.clickup.com/api/v2/task/{task_id}/comment"

        # Make the HTTP request to get the comments for the task
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the comments
            return response.json().get('data', [])
        else:
            # Handle errors (you could raise an exception or return an empty list)
            return []
  good: |-
    from typing import TypedDict, List, Dict

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    # Define the main function to get task comments from ClickUp
    def main(clickup_resource: clickup, task_id: str) -> List[Dict]:
        import requests  # Import requests or any other library if needed

        # Base URL for ClickUp API
        base_url = "https://api.clickup.com/api/v2"

        # Headers for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Endpoint for getting task comments
        task_comments_url = f"{base_url}/task/{task_id}/comment"

        # Make the API call to get the comments for the specified task
        response = requests.get(task_comments_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the comments
            comments_data = response.json()
            return comments_data.get('data', [])
        else:
            # Handle errors (e.g., task not found, authentication error)
            response.raise_for_status()

    # The main function is now defined and can be used with the required parameters.
  id: |-
    synthetic_get-task-comments
  instructions: |-
    Get a task comments. See the docs in **Comments / Get Task Comments** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import metaphor  # Assuming metaphor is a library that we need to import

    # Define the resource type for the metaphor integration
    class metaphor(TypedDict):
        api_key: str  # API key for authentication

    # Define the function signature with the required parameters
    def main(metaphor_resource: metaphor, query: str, max_results: int = 10) -> List[str]:
        # Assuming metaphor has a method called search that takes a query and returns a list of results
        # and that it requires an API key for authentication which is set in a configuration method.

        # Set up the metaphor client with the provided API key
        metaphor_client = metaphor.Client(api_key=metaphor_resource['api_key'])

        # Perform the search with the provided query
        search_results = metaphor_client.search(query, max_results=max_results)

        # Return the list of relevant results
        return search_results
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the 'metaphor' integration
    class metaphor(TypedDict):
        api_key: str

    # Main function to search using the 'metaphor' integration
    def main(metaphor_resource: metaphor, query: str, page: int = 1, limit: int = 10) -> Dict[str, Any]:
        import requests  # Import requests or any other library needed for HTTP requests

        # Construct the search URL and headers using the provided API key
        search_url = "https://api.metaphor.com/v1/search"
        headers = {
            "Authorization": f"Bearer {metaphor_resource['api_key']}"
        }

        # Define the parameters for the search
        params = {
            "query": query,
            "page": page,
            "limit": limit
        }

        # Perform the search request
        response = requests.get(search_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()

    # The script ends here, with no call to the main function as per the instructions.
  id: |-
    synthetic_search
  instructions: |-
    Perform a search with a Metaphor prompt-engineered query and retrieve a list of relevant results in metaphor
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    metaphor
  resource_type_def: |-
    class metaphor(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the Amara API

    class amara(TypedDict):
        api_key: str

    def main(amara_resource: amara) -> List[dict]:
        headers = {
            'X-api-key': amara_resource['api_key'],
            'Content-Type': 'application/json'
        }
        response = requests.get('https://amara.org/api/teams/', headers=headers)
        response.raise_for_status()  # This will raise an error if the request failed
        teams = response.json()
        return teams['objects']  # Assuming the API returns a list of teams under 'objects' key
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the 'amara' integration
    class amara(TypedDict):
        api_key: str

    def main(amara_resource: amara, team_type: str = 'all') -> List[str]:
        import requests  # Import here to avoid conflicts with the resource type name

        # Base URL for Amara API
        base_url = 'https://amara.org/api2/partners/teams/'

        # Prepare the headers with the API key
        headers = {
            'X-api-key': amara_resource['api_key'],
            'Content-Type': 'application/json'
        }

        # Prepare the parameters for the request
        params = {
            'type': team_type
        }

        # Make the request to list teams
        response = requests.get(base_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            teams_data = response.json()
            # Extract the list of team names
            team_names = [team['name'] for team in teams_data['objects']]
            return team_names
        else:
            # Handle errors (you could also raise an exception here)
            return f'Error: {response.status_code} - {response.text}'

    # Note: The function is not called here, it's just defined and ready to be used.
  id: |-
    synthetic_list-teams
  instructions: |-
    List teams in amara
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    amara
  resource_type_def: |-
    class amara(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Response } from "npm:@deno/standard@0.148.0/http/mod.ts";

    type OnesignalRestApi = {
        apiKey: string,
        appId: string
    }

    export async function main(onesignalRestApi: OnesignalRestApi) {
        const url = `https://onesignal.com/api/v1/players?app_id=${onesignalRestApi.appId}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Basic ${onesignalRestApi.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching devices: ${response.status} ${response.statusText}`);
        }

        const devices = await response.json();
        return devices;
    }
  good: |-
    import { OneSignal } from "npm:@onesignal/node-onesignal";

    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }

    export async function main(onesignalResource: OnesignalRestApi, limit: number = 50, offset: number = 0) {
        const oneSignalClient = new OneSignal({
            appId: onesignalResource.appId,
            restApiKey: onesignalResource.restApiKey
        });

        try {
            const response = await oneSignalClient.viewDevices({
                limit,
                offset
            });
            return response;
        } catch (error) {
            console.error('Error fetching devices:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-devices
  instructions: |-
    Get all devices in onesignal rest api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    OnesignalRestApi
  resource_type_def: |-
    type OnesignalRestApi = {
        appId: string;
        restApiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'hive' integration
    class hive(TypedDict):
        api_key: str

    # Define the main function for the 'hive' integration
    def main(hive_resource: hive, workspace_id: str, action_name: str, action_description: str = '', assignee_id: str = None):
        # Assuming a library 'hive_api' is used to interact with the Hive API
        from hive_api import create_action as create_hive_action  # Rename if there's a conflict

        # Use the credentials from the 'hive_resource' to authenticate
        api_key = hive_resource['api_key']

        # Create the action in the specified workspace
        result = create_hive_action(
            api_key=api_key,
            workspace_id=workspace_id,
            action_name=action_name,
            action_description=action_description,
            assignee_id=assignee_id
        )

        # Return the result of the action creation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the hive integration
    class hive(TypedDict):
        api_key: str
        workspace_id: str

    # Define the main function for creating an action in a given workspace
    def main(hive_resource: hive, action_name: str, action_description: str = '', assignee_id: str = None):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating an action
        endpoint = f"https://api.hive.com/api/v1/workspace/{hive_resource['workspace_id']}/actions"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Bearer {hive_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'actionName': action_name,
            'description': action_description,
            'assigneeId': assignee_id
        }

        # Make the API request to create the action
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check for a successful response and return the result
        if response.status_code == 200:
            return response.json()  # Return the created action details
        else:
            raise Exception(f"Error creating action: {response.text}")  # Raise an exception if the call failed

    # Note: The function does not call itself, it's ready to be exported and used with the required parameters.
  id: |-
    synthetic_create-action-for-workspace
  instructions: |-
    Create an action for given workspace in hive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hive
  resource_type_def: |-
    class hive(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the dreamstudio integration
    class dreamstudio(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function with the resource and additional parameters
    def main(dreamstudio_resource: dreamstudio, image_url: str, modification_type: str, modification_value: Any) -> Any:
        # Construct the API endpoint URL
        api_endpoint = "https://api.dreamstudio.ai/modify-image"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {dreamstudio_resource['api_key']}"
        }

        # Set up the payload with the image URL and modification details
        payload = {
            "image_url": image_url,
            "modification_type": modification_type,
            "modification_value": modification_value
        }

        # Make the HTTP POST request to the API
        response = requests.post(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the modified image or relevant result
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is used for HTTP requests

    # Define the resource type for the dreamstudio integration
    class dreamstudio(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function with the resource type and additional parameters
    def main(dreamstudio_resource: dreamstudio, prompt: str, num_images: int = 1, width: int = 512, height: int = 512) -> Any:
        # DreamStudio API endpoint for image generation
        url = "https://api.dreamstudio.ai/generate"

        # Headers for the request including the API key for authentication
        headers = {
            "Authorization": f"Bearer {dreamstudio_resource['api_key']}"
        }

        # Data payload for the request including the prompt and image parameters
        data = {
            "prompt": prompt,
            "num_images": num_images,
            "width": width,
            "height": height
        }

        # Make the POST request to the DreamStudio API
        response = requests.post(url, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response content (image data)
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": response.text}

    # Example usage (do not include this in the script):
    # dreamstudio_credentials = dreamstudio(api_key="your_api_key_here")
    # result = main(dreamstudio_credentials, "A futuristic city skyline at sunset", num_images=3)
    # print(result)
  id: |-
    synthetic_modify-image
  instructions: |-
    Modify an image based on a text prompt in dreamstudio
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dreamstudio
  resource_type_def: |-
    class dreamstudio(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Lemlist = {
        apiKey: string;
    }

    export async function main(lemlistResource: Lemlist, leadEmail: string) {
        const lemlistApiUrl = 'https://api.lemlist.com/api/campaigns';

        // Fetch all campaigns
        const campaignsResponse = await fetch(lemlistApiUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${lemlistResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!campaignsResponse.ok) {
            throw new Error(`Error fetching campaigns: ${campaignsResponse.statusText}`);
        }

        const campaigns = await campaignsResponse.json();

        // Pause lead from all campaigns
        const pauseLeadPromises = campaigns.map(async (campaign: any) => {
            const pauseLeadUrl = `${lemlistApiUrl}/${campaign._id}/leads/${leadEmail}/pause`;

            const pauseResponse = await fetch(pauseLeadUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${lemlistResource.apiKey}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!pauseResponse.ok) {
                throw new Error(`Error pausing lead in campaign ${campaign.name}: ${pauseResponse.statusText}`);
            }

            return pauseResponse.json();
        });

        // Wait for all leads to be paused
        const results = await Promise.all(pauseLeadPromises);

        return results;
    }
  good: |-
    // Import necessary libraries
    import { fetch } from "npm:@deno/fetch";

    type Lemlist = {
        apiKey: string;
    }

    export async function main(lemlistResource: Lemlist, leadEmail: string) {
        const url = `https://api.lemlist.com/api/campaigns`;

        // Set up headers for the API request
        const headers = {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${lemlistResource.apiKey}`
        };

        try {
            // Fetch all campaigns
            const campaignsResponse = await fetch(url, { headers });
            if (!campaignsResponse.ok) {
                throw new Error(`Error fetching campaigns: ${campaignsResponse.statusText}`);
            }
            const campaigns = await campaignsResponse.json();

            // Pause the lead in all campaigns
            const pausePromises = campaigns.map(async (campaign: any) => {
                const pauseUrl = `https://api.lemlist.com/api/campaigns/${campaign._id}/leads/${leadEmail}/pause`;
                const pauseResponse = await fetch(pauseUrl, {
                    method: 'POST',
                    headers
                });

                if (!pauseResponse.ok) {
                    throw new Error(`Error pausing lead in campaign ${campaign.name}: ${pauseResponse.statusText}`);
                }

                return pauseResponse.json();
            });

            // Wait for all pause operations to complete
            const results = await Promise.all(pausePromises);

            // Return the results
            return results;
        } catch (error) {
            // Handle any errors that occurred during the process
            console.error("An error occurred while pausing the lead:", error);
            throw error;
        }
    }
  id: |-
    synthetic_pause-lead-from-all-campaigns
  instructions: |-
    This action pauses a specific lead using its email in all campaigns in lemlist
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lemlist
  resource_type_def: |-
    type Lemlist = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the bingx integration
    class bingx(TypedDict):
        api_key: str
        api_secret: str
        # Add any other properties needed for authentication

    # Define the main function for placing a new order in bingx
    def main(bingx_resource: bingx, symbol: str, order_type: str, quantity: float, price: float) -> Any:
        # Construct the request to place a new order in bingx
        endpoint = "https://api.bingx.com/v1/order"  # Example endpoint, replace with actual bingx order endpoint
        headers = {
            "Api-Key": bingx_resource['api_key'],
            "Api-Secret": bingx_resource['api_secret'],
            # Add any other headers required for authentication
        }
        payload = {
            "symbol": symbol,
            "type": order_type,
            "quantity": quantity,
            "price": price,
            # Add any other parameters required for the order
        }

        # Send the request to the bingx API
        response = requests.post(endpoint, headers=headers, json=payload)

        # Return the response from the API
        return response.json()

    # Note: The actual endpoint, headers, and payload structure need to be adjusted
    # according to the bingx API documentation.
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the BingX integration
    class bingx(TypedDict):
        api_key: str
        secret_key: str
        # Add any other properties needed for authentication

    # Define the main function for placing a new order on BingX
    def main(bingx_resource: bingx, symbol: str, order_type: str, quantity: float, price: Optional[float] = None):
        # Import the necessary library for making HTTP requests
        import requests

        # Define the endpoint for creating a new order
        endpoint = "https://api.bingx.com/v1/order"

        # Construct the headers with the API key
        headers = {
            "X-BingX-APIKEY": bingx_resource['api_key'],
            # Add any other headers required for the API
        }

        # Construct the payload for the new order
        payload = {
            "symbol": symbol,
            "type": order_type,
            "quantity": quantity,
            # Include the price if it's necessary for the order type
        }
        if price is not None:
            payload["price"] = price

        # Make the POST request to create a new order
        response = requests.post(endpoint, headers=headers, json=payload)

        # Return the response from the API
        return response.json()
  id: |-
    synthetic_trade-new-order
  instructions: |-
    Place a New Order in bingx
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bingx
  resource_type_def: |-
    class bingx(TypedDict):
        api_key: str
        secret_key: str
        # Add any other properties needed for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string) {
        const octokit = new Octokit({
            auth: githubResource.accessToken,
        });

        const response = await octokit.repos.get({
            owner,
            repo,
        });

        return response.data;
    }
  good: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string) {
        const octokit = new Octokit({
            auth: githubResource.accessToken,
        });

        try {
            const response = await octokit.repos.get({
                owner,
                repo,
            });

            return response.data;
        } catch (error) {
            // Handle errors (e.g., repository not found, access denied)
            console.error("Error fetching repository:", error);
            throw error;
        }
    }
  id: |-
    synthetic_get-repository
  instructions: |-
    Get specific repository in github
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type ClockworkRecruiting = {
        apiKey: string,
        firmId: string
    }

    export async function main(clockworkResource: ClockworkRecruiting, personData: { firstName: string, lastName: string, email: string, jobTitle?: string, company?: string }) {
        const url = `https://api.clockworkrecruiting.com/${clockworkResource.firmId}/people`;
        const authHeader = `Basic ${encode(`${clockworkResource.apiKey}:`)}`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                firstName: personData.firstName,
                lastName: personData.lastName,
                email: personData.email,
                title: personData.jobTitle,
                company: personData.company
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { ClockworkClient } from "npm:clockwork-recruiting-client";

    type ClockworkRecruiting = {
        apiKey: string;
    }

    export async function main(clockworkRecruitingResource: ClockworkRecruiting, firmId: number, personDetails: { firstName: string, lastName: string, email: string, jobTitle?: string }) {
        const client = new ClockworkClient(clockworkRecruitingResource.apiKey);

        const newPerson = await client.createPerson(firmId, {
            firstName: personDetails.firstName,
            lastName: personDetails.lastName,
            email: personDetails.email,
            jobTitle: personDetails.jobTitle,
        });

        return newPerson;
    }
  id: |-
    synthetic_create-person
  instructions: |-
    Create a new person with provided data in clockwork recruiting
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    ClockworkRecruiting
  resource_type_def: |-
    type ClockworkRecruiting = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { NudgifyClient } from "npm:nudgify-node";

    type Nudgify = {
        apiKey: string,
        siteId: string
    }

    export async function main(nudgifyResource: Nudgify, streamId: string, message: string, linkText?: string, linkUrl?: string) {
        // Initialize the Nudgify client with the provided API key
        const client = new NudgifyClient(nudgifyResource.apiKey);

        // Create the purchase nudge
        const nudge = {
            message: message,
            linkText: linkText,
            linkUrl: linkUrl
        };

        // Send the nudge to the specified stream
        const result = await client.createNudge(nudgifyResource.siteId, streamId, nudge);

        // Return the result
        return result;
    }
  good: |-
    import { NudgifyClient } from "npm:nudgify-node";

    type Nudgify = {
        apiKey: string,
        siteId: string
    }

    export async function main(nudgifyResource: Nudgify, productId: string, productName: string, productPrice: number, nudgeText: string, nudgeType: string = 'info', displayDuration: number = 5000) {
        const client = new NudgifyClient(nudgifyResource.apiKey);

        const nudge = {
            siteId: nudgifyResource.siteId,
            type: nudgeType,
            text: nudgeText.replace('{productName}', productName).replace('{productPrice}', productPrice.toString()),
            duration: displayDuration
        };

        const response = await client.createNudge(nudge);

        return response;
    }
  id: |-
    synthetic_create-purchase-nudge
  instructions: |-
    Creates a purchase nudge in nudgify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nudgify
  resource_type_def: |-
    type Nudgify = {
        apiKey: string,
        siteId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { EodhdApis } from 'npm:eodhd-apis-client'; // Assuming there's an npm package for Eodhd APIs

    type EodhdApis = {
        apiKey: string;
        // Add any other properties needed for EodhdApis integration
    }

    export async function main(eodhdResource: EodhdApis, companySymbol: string) {
        // Initialize the EodhdApis client with the provided apiKey
        const eodhdClient = new EodhdApis(eodhdResource.apiKey);

        // Fetch the financial statements for the specified company
        const financialStatements = await eodhdClient.getFinancialStatements(companySymbol);

        // Return the financial statements
        return financialStatements;
    }
  good: |-
    import { EodhdApis as EodhdApisClient } from "npm:eodhistoricaldata-api"; // Renamed the imported class to avoid conflict

    type EodhdApis = {
        apiKey: string;
    }

    export async function main(eodhdApisResource: EodhdApis, companySymbol: string) {
        const eodhdApis = new EodhdApisClient(eodhdApisResource.apiKey);
        const financials = await eodhdApis.getCompanyFinancials(companySymbol);

        return financials;
    }
  id: |-
    synthetic_get-company-financials
  instructions: |-
    Obtain financial statements for a specific company in eodhd apis
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    EodhdApis
  resource_type_def: |-
    type EodhdApis = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Define the resource type for the 'agendor' integration
    class agendor(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the 'agendor' integration
    def main(agendor_resource: agendor, organization_name: str, page: Optional[int] = 1):
        import requests  # Import requests or any other library if needed

        # Base URL for the Agendor API
        base_url = "https://api.agendor.com.br/v3"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Token {agendor_resource['api_key']}:{agendor_resource['api_secret']}"
        }

        # Prepare the parameters for the request
        params = {
            "page": page,
            "name": organization_name
        }

        # Make the request to the Agendor API to find the organization
        response = requests.get(f"{base_url}/organizations", headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if the organization is found
            return response.json()
        else:
            # Return an error message if the request failed
            return {"error": "Failed to retrieve organization", "status_code": response.status_code}

    # Note: The function does not call itself, it's ready to be exported and used with the specified parameters.
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the 'agendor' integration
    class agendor(TypedDict):
        api_token: str

    # Define the main function for the 'agendor' integration
    def main(agendor_resource: agendor, organization_name: str, page: Optional[int] = 1):
        import requests  # Import requests or any other library if needed

        # Base URL for Agendor API
        base_url = "https://api.agendor.com.br/v3"

        # Headers for authentication
        headers = {
            "Authorization": f"Token {agendor_resource['api_token']}"
        }

        # Endpoint for searching organizations
        search_url = f"{base_url}/organizations"

        # Parameters for the search
        params = {
            "page": page,
            "name": organization_name
        }

        # Make the request to Agendor API
        response = requests.get(search_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response containing the organization details
            return response.json()
        else:
            # Handle errors (e.g., organization not found, API errors)
            response.raise_for_status()

    # Note: The function is not called here, it is only defined and ready to be used.
  id: |-
    synthetic_find-organization
  instructions: |-
    Find Organization. in agendor
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    agendor
  resource_type_def: |-
    class agendor(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP calls

    class geodb_cities(TypedDict):
        api_key: str

    def main(geodb_cities_resource: geodb_cities, base_url: str, country_code: str, language: Optional[str] = 'en'):
        url = f"{base_url}/v1/geo/countries/{country_code}"
        params = {
            'apiKey': geodb_cities_resource['api_key'],
            'language': language
        }
        response = requests.get(url, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the geodb_cities integration
    class geodb_cities(TypedDict):
        api_key: str
        base_url: str

    # Define the main function with the resource type and additional parameters
    def main(geodb_cities_resource: geodb_cities, country_code: str) -> dict:
        # Construct the URL for the API call
        url = f"{geodb_cities_resource['base_url']}/v1/geo/countries/{country_code}"

        # Set up the headers with the API key
        headers = {
            'X-RapidAPI-Key': geodb_cities_resource['api_key']
        }

        # Make the API call
        response = requests.get(url, headers=headers)

        # Check if the response is successful
        if response.status_code == 200:
            # Parse the response to JSON
            country_details = response.json()

            # Extract the number of regions from the data
            num_regions = len(country_details.get('data', {}).get('regions', []))

            # Add the number of regions to the country details
            country_details['num_regions'] = num_regions

            # Return the country details with the number of regions
            return country_details
        else:
            # If the response is not successful, return an error message
            return {'error': 'Failed to retrieve country details', 'status_code': response.status_code}

    # Note: The function is not called here, it is just defined and ready to be exported.
  id: |-
    synthetic_get-country-details
  instructions: |-
    Get the details for a specific country, including number of regions. in geodb cities
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    geodb_cities
  resource_type_def: |-
    class geodb_cities(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Jira's API

    # Define the resource type for the jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
        project_key: str

    def main(jira_resource: jira, issue_key: str, comment_body: str):
        # Construct the URL for the Jira API endpoint to add a comment to an issue
        url = f"{jira_resource['base_url']}/rest/api/2/issue/{issue_key}/comment"

        # Set up the headers for authentication and content type
        headers = {
            "Authorization": f"Basic {jira_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Define the payload with the comment body
        payload = {
            "body": comment_body
        }

        # Make the POST request to add the comment
        response = requests.post(url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return {"success": True, "message": "Comment added successfully."}
        else:
            return {"success": False, "message": "Failed to add comment.", "error": response.text}
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls to JIRA API

    # Define the resource type for the JIRA integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, issue_key: str, comment_body: str) -> dict:
        # Construct the URL for the JIRA issue comment API
        url = f"{jira_resource['base_url']}/rest/api/2/issue/{issue_key}/comment"

        # Set up the headers for authentication and content type
        headers = {
            "Authorization": f"Basic {jira_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Define the payload for the comment
        payload = {
            "body": comment_body
        }

        # Make the POST request to add a comment to the issue
        response = requests.post(url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the JSON response if the comment was added successfully
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # Note: The main function is not called here, it is just defined and exported.
  id: |-
    synthetic_add-comment-to-issue
  instructions: |-
    Adds a new comment to an issue, in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials

    # Define the resource type for the google_sheets integration
    class google_sheets(TypedDict):
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str

    # Define the main function for creating a spreadsheet
    def main(google_sheets_resource: google_sheets, spreadsheet_title: str) -> Any:
        # Use the provided google_sheets_resource to authenticate with the Google Sheets API
        credentials = ServiceAccountCredentials.from_json_keyfile_dict(google_sheets_resource)
        gc = gspread.authorize(credentials)

        # Create a new spreadsheet with the given title
        spreadsheet = gc.create(spreadsheet_title)

        # Return the created spreadsheet object or its relevant metadata
        return {
            'spreadsheet_id': spreadsheet.id,
            'spreadsheet_url': spreadsheet.url
        }

    # Example usage:
    # result = main(google_sheets_resource, "My New Spreadsheet")
    # print(result)
  good: |-
    from typing import TypedDict, Optional
    import gspread  # Assuming gspread library is used for Google Sheets API

    # Rename the imported client to avoid conflict with the resource type name
    from gspread import Client as GSpreadClient

    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict

    def main(google_sheets_resource: google_sheets, title: str, template_spreadsheet_id: Optional[str] = None):
        gc = gspread.service_account_from_dict(google_sheets_resource['service_account_info'])

        if template_spreadsheet_id:
            template = gc.open_by_key(template_spreadsheet_id)
            new_spreadsheet = template.duplicate(title=title)
        else:
            new_spreadsheet = gc.create(title)

        return new_spreadsheet.url
  id: |-
    synthetic_create-spreadsheet
  instructions: |-
    Create a blank spreadsheet or duplicate an existing spreadsheet in google sheets
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_sheets
  resource_type_def: |-
    class google_sheets(TypedDict):
        project_id: str
        private_key_id: str
        private_key: str
        client_email: str
        client_id: str
        auth_uri: str
        token_uri: str
        auth_provider_x509_cert_url: str
        client_x509_cert_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'motion' integration
    class motion(TypedDict):
        api_key: str
        workspace_id: str

    # Import requests but rename it to avoid conflicts with any potential 'requests' property in the resource
    import requests as http_requests

    def main(motion_resource: motion, task_id: str) -> dict:
        # Construct the API endpoint for deleting a task
        endpoint = f"https://api.motion.io/workspaces/{motion_resource['workspace_id']}/tasks/{task_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {motion_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the DELETE request to the Motion API to delete the task
        response = http_requests.delete(endpoint, headers=headers)

        # Return the response as a dictionary
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'motion' integration
    class motion(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    def main(motion_resource: motion, task_id: str) -> bool:
        import requests  # Import here to avoid conflicts with any parameter names

        # Construct the API endpoint for deleting a task
        delete_task_endpoint = f"{motion_resource['base_url']}/tasks/{task_id}"

        # Set up the headers with the necessary API credentials
        headers = {
            "Authorization": f"Bearer {motion_resource['api_key']}",
            "Api-Secret": motion_resource['api_secret']
        }

        # Make the DELETE request to the motion API
        response = requests.delete(delete_task_endpoint, headers=headers)

        # Check if the deletion was successful
        if response.status_code == 204:
            return True  # Task was successfully deleted
        else:
            response.raise_for_status()  # Raise an exception if an error occurred

    # The main function is now ready to be exported and used with the 'motion' integration
  id: |-
    synthetic_delete-task
  instructions: |-
    Delete a specific task by Id in motion
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    motion
  resource_type_def: |-
    class motion(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import elevenlabs_api_client as el_client

    class elevenlabs(TypedDict):
        api_key: str
        api_secret: str

    def main(elevenlabs_resource: elevenlabs, text: str, voice_id: Optional[str] = None, output_format: Optional[str] = 'mp3') -> bytes:
        client = el_client.Client(api_key=elevenlabs_resource['api_key'], api_secret=elevenlabs_resource['api_secret'])

        synthesis_options = {
            'text': text,
            'voice_id': voice_id,
            'output_format': output_format
        }

        audio_content = client.synthesize_speech(**synthesis_options)

        return audio_content
  good: |-
    from typing import TypedDict, Any
    import elevenlabs_api_client  # Hypothetical library for ElevenLabs API

    # Rename the imported method if it conflicts with the resource type name
    from elevenlabs_api_client import retrieve_audio as retrieve_audio_from_elevenlabs

    class elevenlabs(TypedDict):
        api_key: str
        api_secret: str

    def main(elevenlabs_resource: elevenlabs, audio_id: str) -> Any:
        # Initialize the ElevenLabs client with the provided credentials
        client = elevenlabs_api_client.Client(api_key=elevenlabs_resource['api_key'], api_secret=elevenlabs_resource['api_secret'])

        # Retrieve the audio file using the ElevenLabs client
        audio_file = retrieve_audio_from_elevenlabs(client, audio_id)

        # Return the audio file
        return audio_file
  id: |-
    synthetic_text-to-speech
  instructions: |-
    Retrieve an audio file in elevenlabs
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    elevenlabs
  resource_type_def: |-
    class elevenlabs(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'endorsal' integration
    class endorsal(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for creating a testimonial
    def main(
        endorsal_resource: endorsal,
        customer_name: str,
        customer_position: str,
        customer_company: str,
        testimonial_text: str,
        rating: int,
        tags: list[str] = []
    ) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint
        api_endpoint = f"https://{endorsal_resource['subdomain']}.endorsal.io/api/testimonials"

        # Prepare the data for the testimonial
        testimonial_data = {
            "name": customer_name,
            "position": customer_position,
            "company": customer_company,
            "testimonial": testimonial_text,
            "rating": rating,
            "tags": tags
        }

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {endorsal_resource['api_key']}"
        }

        # Make the request to create a testimonial
        response = requests.post(api_endpoint, json=testimonial_data, headers=headers)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to the Endorsal API

    # Define the resource type for the 'endorsal' integration
    class endorsal(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for creating a new testimonial in Endorsal
    def main(
        endorsal_resource: endorsal,
        testimonial_text: str,
        customer_name: str,
        customer_email: str,
        customer_position: str = "",
        customer_company: str = "",
        customer_photo_url: str = "",
        tags: list[str] = []
    ) -> Any:
        # Construct the API endpoint for creating a new testimonial
        url = f"https://{endorsal_resource['subdomain']}.endorsal.io/api/testimonials"

        # Prepare the data for the new testimonial
        data = {
            "testimonial": testimonial_text,
            "customer": {
                "name": customer_name,
                "email": customer_email,
                "position": customer_position,
                "company": customer_company,
                "photo_url": customer_photo_url
            },
            "tags": tags
        }

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {endorsal_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the POST request to create the new testimonial
        response = requests.post(url, json=data, headers=headers)

        # Return the response from the API
        return response.json()

    # Note: The function is not called here, it is just defined and exported.
  id: |-
    synthetic_create-testimonial
  instructions: |-
    Creates a new testimonial in endorsal
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    endorsal
  resource_type_def: |-
    class endorsal(TypedDict):
        api_key: str
        subdomain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client as DiscordClient } from "npm:discord.js";

    type Discord = {
        token: string,
        clientId: string
    }

    export async function main(discordResource: Discord, guildId: string, channelId: string, message: string) {
        const client = new DiscordClient();

        try {
            await client.login(discordResource.token);
            const channel = await client.channels.fetch(channelId);
            if (!channel.isText()) {
                throw new Error('The channel must be a text channel');
            }
            const sentMessage = await channel.send(message);
            return sentMessage;
        } finally {
            client.destroy();
        }
    }
  good: |-
    import { encode } from "npm:base-64";

    type Discord = {
        botToken: string;
    }

    export async function main(discordResource: Discord, channelId: string, message: string) {
        const url = `https://discord.com/api/v9/channels/${channelId}/messages`;
        const headers = {
            "Authorization": `Bot ${discordResource.botToken}`,
            "Content-Type": "application/json"
        };
        const body = JSON.stringify({
            content: message
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        return response.json();
    }
  id: |-
    synthetic_send-message
  instructions: |-
    Send a simple message to a Discord channel in discord
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Discord
  resource_type_def: |-
    type Discord = {
        token: string,
        clientId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Lighthouse as LighthouseClient } from "npm:@lhci/utils";

    type Lighthouse = {
        apiKey: string,
        projectId: string
    }

    export async function main(lighthouse: Lighthouse, urlToAudit: string, config?: any) {
        // Initialize the Lighthouse client
        const lhciClient = new LighthouseClient({
            apiKey: lighthouse.apiKey,
            projectId: lighthouse.projectId
        });

        // Run the Lighthouse audit
        const result = await lhciClient.runAudit({
            url: urlToAudit,
            config: config // Optional configuration for the audit
        });

        // Return the audit result
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { Lighthouse } from "npm:@google-cloud/lighthouse";

    type LighthouseResource = {
        projectId: string,
        clientEmail: string,
        privateKey: string
    }

    export async function main(lighthouseResource: LighthouseResource, projectName: string) {
        // Initialize the Lighthouse client with credentials
        const lighthouseClient = new Lighthouse({
            projectId: lighthouseResource.projectId,
            credentials: {
                client_email: lighthouseResource.clientEmail,
                private_key: lighthouseResource.privateKey
            }
        });

        // Create a new project
        const newProject = await lighthouseClient.projects.create({
            project: {
                displayName: projectName
            }
        });

        // Return the result
        return newProject;
    }
  id: |-
    synthetic_create-project
  instructions: |-
    Creates a project in lighthouse
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lighthouse
  resource_type_def: |-
    type Lighthouse = {
        apiKey: string,
        projectId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Aweber as AweberAPI } from "npm:@aweber/aweber-js";

    type Aweber = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }

    export async function main(aweber: Aweber, account_id: string) {
        const aweberClient = new AweberAPI({
            accessToken: aweber.accessToken,
            refreshToken: aweber.refreshToken,
            clientId: aweber.clientId,
            clientSecret: aweber.clientSecret
        });

        try {
            const response = await aweberClient.get(`/accounts/${account_id}/lists`);
            return response;
        } catch (error) {
            console.error('Error fetching lists:', error);
            throw error;
        }
    }
  good: |-
    import { encode } from "npm:base-64";

    type Aweber = {
        consumerKey: string;
        consumerSecret: string;
        accessToken: string;
        tokenSecret: string;
        accountId: string;
    }

    export async function main(aweberResource: Aweber, page: number = 1, pageSize: number = 20) {
        const url = `https://api.aweber.com/1.0/accounts/${aweberResource.accountId}/lists?page=${page}&ws.size=${pageSize}`;
        const authHeader = `Bearer ${aweberResource.accessToken}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-lists
  instructions: |-
    Get a paginated collection of subscriber lists. in aweber
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aweber
  resource_type_def: |-
    type Aweber = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Cardly = {
        apiKey: string;
        apiSecret: string;
        endpointUrl: string;
    }

    export async function main(cardlyResource: Cardly, contactName: string, contactEmail: string, contactPhone?: string) {
        const contactId = uuidv4(); // Generate a unique identifier for the contact
        const contactData = {
            id: contactId,
            name: contactName,
            email: contactEmail,
            phone: contactPhone,
        };

        const response = await fetch(`${cardlyResource.endpointUrl}/contacts`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${cardlyResource.apiKey}:${cardlyResource.apiSecret}`
            },
            body: JSON.stringify(contactData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json(); // Return the result of the contact creation
    }
  good: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Cardly = {
        apiKey: string;
        apiEndpoint: string;
    }

    export async function main(cardlyResource: Cardly, contactName: string, contactEmail: string, contactPhone?: string) {
        const newContact = {
            id: uuidv4(), // Generate a unique ID for the contact
            name: contactName,
            email: contactEmail,
            phone: contactPhone
        };

        const response = await fetch(`${cardlyResource.apiEndpoint}/contacts`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${cardlyResource.apiKey}`
            },
            body: JSON.stringify(newContact)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-contact
  instructions: |-
    Creates a new contact in Cardly in cardly
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Cardly
  resource_type_def: |-
    type Cardly = {
        apiKey: string;
        apiSecret: string;
        endpointUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bot, Message } from "npm:discordeno";

    type DiscordBot = {
        token: string,
        botId: string,
        guildId: string
    }

    export async function main(discordBotResource: DiscordBot, channelId: string, messageContent: string) {
        const bot = new Bot({
            token: discordBotResource.token,
            intents: [], // Specify the necessary intents for your bot
            botId: discordBotResource.botId,
        });

        await bot.helpers.sendMessage(channelId, { content: messageContent });
    }
  good: |-
    import { Client, Intents } from "npm:discord.js";

    type DiscordBot = {
        token: string;
    }

    export async function main(discordBotResource: DiscordBot, channelId: string, messageId: string) {
        const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

        client.login(discordBotResource.token);

        const channel = await client.channels.fetch(channelId);
        if (!channel.isText()) {
            throw new Error('The channel must be a text-based channel');
        }

        const message = await channel.messages.fetch(messageId);
        await client.destroy(); // Clean up the client after fetching the message

        return message.content;
    }
  id: |-
    synthetic_get-message
  instructions: |-
    Return a specific message in a channel in discord bot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DiscordBot
  resource_type_def: |-
    type DiscordBot = {
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Bitly API

    class bitly(TypedDict):
        access_token: str

    def main(bitly_resource: bitly, long_url: str) -> str:
        headers = {
            'Authorization': f"Bearer {bitly_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'long_url': long_url
        }
        response = requests.post('https://api-ssl.bitly.com/v4/shorten', json=payload, headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()['link']
  good: |-
    from typing import TypedDict

    # Define the resource type for the bitly integration
    class bitly(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the requests library, if it conflicts with a resource name, rename it
    import requests as req

    def main(bitly_resource: bitly, url_to_shorten: str) -> str:
        # Endpoint for the Bitly API to shorten a URL
        api_endpoint = "https://api-ssl.bitly.com/v4/shorten"

        # Prepare the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {bitly_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Prepare the data with the URL to shorten
        data = {
            "long_url": url_to_shorten
        }

        # Make the POST request to the Bitly API
        response = req.post(api_endpoint, json=data, headers=headers)

        # Raise an exception if the request failed
        response.raise_for_status()

        # Parse the response to get the shortened URL
        shortened_url = response.json().get("link")

        # Return the shortened URL
        return shortened_url
  id: |-
    synthetic_create-bitlink
  instructions: |-
    URL to shorten in bitly
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitly
  resource_type_def: |-
    class bitly(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Companycam as CompanycamClient } from "npm:companycam-client"; // Renamed the imported method to avoid conflict

    type Companycam = {
        apiKey: string;
        // Add other authentication/configuration properties as needed
    }

    export async function main(companycamResource: Companycam, projectName: string) {
        const client = new CompanycamClient(companycamResource.apiKey);
        const result = await client.createProject({ name: projectName });
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Companycam = {
        apiKey: string;
    }

    export async function main(companycamResource: Companycam, projectName: string, projectAddress?: string) {
        const url = 'https://api.companycam.com/v3/projects';
        const body = {
            name: projectName,
            uuid: uuidv4(),
            address: projectAddress
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${companycamResource.apiKey}`
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-project
  instructions: |-
    Add a new project. in companycam
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Companycam
  resource_type_def: |-
    type Companycam = {
        apiKey: string;
        // Add other authentication/configuration properties as needed
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'amara' integration
    class amara(TypedDict):
        api_key: str  # API key for authentication

    # Main function to add a video in Amara
    def main(amara_resource: amara, video_url: str, team: str, project: str, language: str):
        # Assuming the existence of a library to interact with Amara API
        from amara_api import add_video  # If this conflicts with an existing name, rename as follows:
        # from amara_api import add_video as amara_add_video

        # Use the Amara API to add a video
        result = add_video(
            api_key=amara_resource['api_key'],
            video_url=video_url,
            team=team,
            project=project,
            language=language
        )

        # Return the result of the API call
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'amara' integration
    class amara(TypedDict):
        api_key: str  # API key for authentication

    # Main function to add a video to Amara platform
    def main(amara_resource: amara, video_url: str, team: str, project: str, language: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for adding a video
        api_endpoint = "https://amara.org/api/videos/"

        # Prepare the headers with the API key for authentication
        headers = {
            "X-api-key": amara_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Prepare the data payload with the video URL and other details
        data = {
            "team": team,
            "project": project,
            "language": language,
            "video_url": video_url
        }

        # Make the POST request to add the video
        response = requests.post(api_endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the JSON response if the video was added successfully
        else:
            raise Exception(f"Error adding video: {response.status_code} - {response.text}")

    # Example usage:
    # result = main(amara_resource={'api_key': 'your_api_key'}, video_url='http://example.com/video.mp4', team='your_team', project='your_project', language='en')
    # print(result)
  id: |-
    synthetic_add-video
  instructions: |-
    Add a video in amara
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    amara
  resource_type_def: |-
    class amara(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Freshdesk API

    # Define the resource type for the freshdesk integration
    class freshdesk(TypedDict):
        api_key: str
        domain: str

    # Define the main function for creating a ticket in Freshdesk
    def main(freshdesk_resource: freshdesk, subject: str, description: str, email: str, priority: int, status: int):
        # Construct the API endpoint
        api_endpoint = f"https://{freshdesk_resource['domain']}.freshdesk.com/api/v2/tickets"

        # Set up the headers for authentication and content type
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {freshdesk_resource['api_key']}"
        }

        # Create the payload for the new ticket
        payload = {
            "subject": subject,
            "description": description,
            "email": email,
            "priority": priority,
            "status": status
        }

        # Make the POST request to create a new ticket
        response = requests.post(api_endpoint, json=payload, headers=headers)

        # Check for successful response and return the result
        if response.status_code == 201:
            return response.json()  # Return the created ticket information as JSON
        else:
            response.raise_for_status()  # Raise an exception if the API call failed

    # Note: The main function is not called here, as per the instructions.
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the freshdesk integration
    class freshdesk(TypedDict):
        api_key: str
        domain: str

    def main(freshdesk_resource: freshdesk, subject: str, description: str, email: str, priority: int, status: int) -> Any:
        # Construct the API endpoint
        endpoint = f"https://{freshdesk_resource['domain']}.freshdesk.com/api/v2/tickets"

        # Set up the headers for authentication and content type
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {freshdesk_resource['api_key']}"
        }

        # Create the payload for the new ticket
        payload = {
            "subject": subject,
            "description": description,
            "email": email,
            "priority": priority,
            "status": status
        }

        # Make the API call to create a new ticket
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check for successful response and return the result
        if response.status_code == 201:
            return response.json()
        else:
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_create-ticket
  instructions: |-
    Create a ticket in freshdesk
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    freshdesk
  resource_type_def: |-
    class freshdesk(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class inoreader(TypedDict):
        app_id: str
        app_key: str
        access_token: str

    def main(inoreader_resource: inoreader, feed_url: str) -> dict:
        headers = {
            'AppId': inoreader_resource['app_id'],
            'AppKey': inoreader_resource['app_key'],
            'Authorization': f'Bearer {inoreader_resource['access_token']}'
        }
        payload = {
            'feed_url': feed_url
        }
        response = requests.post('https://www.inoreader.com/reader/api/0/subscription/quickadd', headers=headers, data=payload)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls

    class inoreader(TypedDict):
        app_id: str
        app_key: str
        access_token: str

    def main(inoreader_resource: inoreader, feed_url: str) -> dict:
        headers = {
            'AppId': inoreader_resource['app_id'],
            'AppKey': inoreader_resource['app_key'],
            'Authorization': f'Bearer {inoreader_resource["access_token"]}'
        }

        subscribe_url = 'https://www.inoreader.com/reader/api/0/subscription/quickadd'
        payload = {
            'quickadd': feed_url
        }

        response = requests.post(subscribe_url, headers=headers, data=payload)
        return response.json()
  id: |-
    synthetic_subscribe-to-feed
  instructions: |-
    Subscribe to a feed in inoreader
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    inoreader
  resource_type_def: |-
    class inoreader(TypedDict):
        app_id: str
        app_key: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Memberstack as MemberstackClient } from "npm:memberstack";

    type Memberstack = {
        apiKey: string;
        subdomain: string;
    }

    export async function main(memberstack: Memberstack, memberId: string) {
        const memberstackClient = new MemberstackClient(memberstack.apiKey, memberstack.subdomain);
        const memberDetails = await memberstackClient.getMember(memberId);
        return memberDetails;
    }
  good: |-
    // Import any libraries you need here
    import { Memberstack } from 'npm:memberstack'; // Assuming 'memberstack' is the npm package name

    type MemberstackResource = {
        apiKey: string;
        subdomain: string;
    }

    export async function main(memberstackResource: MemberstackResource, memberId: string) {
        // Initialize the Memberstack client with the provided resource
        const memberstackClient = new Memberstack({
            apiKey: memberstackResource.apiKey,
            subdomain: memberstackResource.subdomain
        });

        // Retrieve the member by ID
        const member = await memberstackClient.getMemberById(memberId);

        // Always return the result
        return member;
    }
  id: |-
    synthetic_find-member
  instructions: |-
    Retrieves a member by ID in memberstack
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Memberstack
  resource_type_def: |-
    type Memberstack = {
        apiKey: string;
        subdomain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { LinkedIn } from 'npm:@typefully/linkedin';

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, content: string, url?: string, article?: string) {
        const linkedInClient = new LinkedIn(linkedinResource.accessToken);

        // Construct the post body
        const postBody: { text: string, content?: { url: string } } = { text: content };

        // Add URL or article if provided
        if (url) {
            postBody.content = { url };
        } else if (article) {
            postBody.content = { url: article };
        }

        // Post to LinkedIn
        const response = await linkedInClient.post(postBody);

        // Return the result
        return response;
    }
  good: |-
    // Importing necessary libraries
    import { Client } from "npm:@linkedin/rest-api-client";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, organizationId: string, shareText: string, shareUrl?: string) {
        // Initialize the LinkedIn client with the access token
        const client = new Client({ accessToken: linkedinResource.accessToken });

        // Construct the post body
        const postBody: any = {
            author: `urn:li:organization:${organizationId}`,
            lifecycleState: 'PUBLISHED',
            specificContent: {
                "com.linkedin.ugc.ShareContent": {
                    shareCommentary: {
                        text: shareText
                    },
                    shareMediaCategory: 'NONE'
                }
            },
            visibility: {
                "com.linkedin.ugc.MemberNetworkVisibility": 'PUBLIC'
            }
        };

        // If a share URL is provided, modify the post body to include the URL
        if (shareUrl) {
            postBody.specificContent["com.linkedin.ugc.ShareContent"].media = [
                {
                    status: 'READY',
                    originalUrl: shareUrl
                }
            ];
            postBody.specificContent["com.linkedin.ugc.ShareContent"].shareMediaCategory = 'ARTICLE';
        }

        // Make the API call to create the post
        const response = await client.ugcPosts.createPost(postBody);

        // Return the result
        return response;
    }
  id: |-
    synthetic_create-text-post-organization
  instructions: |-
    Create post on LinkedIn using text, URL or article for more information in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@frontapp/plugin-sdk";

    type Frontapp = {
        apiKey: string;
    }

    export async function main(frontappResource: Frontapp, customMessage: string, recipient: string, subject: string) {
        const client = new Client({ token: frontappResource.apiKey });

        const result = await client.conversations.create({
            subject: subject,
            body: customMessage,
            to: [recipient],
            // Additional parameters like cc, bcc, etc. can be added as needed
        });

        return result;
    }
  good: |-
    // Import necessary libraries
    import { Client } from "npm:@frontapp/plugin-sdk";

    type Frontapp = {
        apiKey: string;
    }

    export async function main(frontappResource: Frontapp, recipient: string, subject: string, body: string) {
        // Initialize Frontapp client with the provided API key
        const client = new Client({ token: frontappResource.apiKey });

        // Create and send a custom message using the Frontapp client
        const result = await client.conversations.sendMessage({
            to: [recipient],
            subject: subject,
            body: body,
            // Additional options can be specified here if needed
        });

        // Return the result of the message sending operation
        return result;
    }
  id: |-
    synthetic_receive-custom-messages
  instructions: |-
    Receive a custom message in Front. in frontapp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Frontapp
  resource_type_def: |-
    type Frontapp = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { LinkedIn } from "npm:@typefully/linkedin";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, parentCommentUrn: string) {
        const linkedInClient = new LinkedIn(linkedinResource.accessToken);

        const comments = await linkedInClient.getComments({
            parentCommentUrn: parentCommentUrn
        });

        return comments;
    }
  good: |-
    // Import necessary libraries
    import { LinkedInClient } from "npm:@linkedin/client";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, parentCommentUrn: string) {
        const linkedInClient = new LinkedInClient(linkedinResource.accessToken);

        // Retrieve comments on a specific comment (parentCommentUrn)
        const comments = await linkedInClient.getCommentsOnComment(parentCommentUrn);

        return comments;
    }
  id: |-
    synthetic_retrieve-comments-on-comments
  instructions: |-
    Retrieves comments on comments, given the parent comment urn in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Assuming the badger_maps integration requires an API key for authentication
    class badger_maps(TypedDict):
        api_key: str

    def main(badger_maps_resource: badger_maps, search_query: str, max_results: Optional[int] = 10):
        # Import the library for HTTP requests
        import requests

        # Define the base URL for the Badger Maps API
        base_url = "https://api.badgermaps.com/v1"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {badger_maps_resource['api_key']}"
        }

        # Prepare the search endpoint and parameters
        search_endpoint = f"{base_url}/user/search"
        params = {
            "query": search_query,
            "maxResults": max_results
        }

        # Make the GET request to the Badger Maps API
        response = requests.get(search_endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            raise Exception(f"Badger Maps API request failed with status code {response.status_code}: {response.text}")

    # The main function is now ready to be used with the badger_maps_resource and search parameters.
  good: |-
    from typing import TypedDict, Union, Optional
    import requests  # Assuming requests is needed for API interaction

    class badger_maps(TypedDict):
        api_key: str
        base_url: str

    def main(badger_maps_resource: badger_maps, user_identifier: Union[str, int], search_by: str = 'email') -> Optional[dict]:
        headers = {
            'Authorization': f"Bearer {badger_maps_resource['api_key']}"
        }
        search_endpoint = f"{badger_maps_resource['base_url']}/users/search"
        search_params = {
            search_by: user_identifier
        }

        response = requests.get(search_endpoint, headers=headers, params=search_params)

        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()
            return None

    # Example usage:
    # result = main(badger_maps_resource={'api_key': 'your_api_key', 'base_url': 'https://api.badgermaps.com/v1'}, user_identifier='user@example.com')
  id: |-
    synthetic_search-user
  instructions: |-
    Find an existing Badger User at your company by User's email address or internal ID. in badger maps
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    badger_maps
  resource_type_def: |-
    class badger_maps(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
    }

    export async function main(notionResource: Notion, blockId: string) {
        const notion = new Client({ auth: notionResource.authToken });

        const response = await notion.blocks.retrieve({
            block_id: blockId,
        });

        return response;
    }
  good: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
    }

    export async function main(notionResource: Notion, blockId: string) {
        const notion = new Client({ auth: notionResource.authToken });

        const response = await notion.blocks.retrieve({
            block_id: blockId,
        });

        return response;
    }
  id: |-
    synthetic_retrieve-block
  instructions: |-
    Retrieves a block. A block object represents content within Notion. Blocks can be text, lists, media, and more. A page is also a type of block in notion
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
        authToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Cloudinary } from "npm:cloudinary-core";

    type CloudinaryResource = {
        cloudName: string;
        apiKey: string;
        apiSecret: string;
    }

    export async function main(cloudinaryResource: CloudinaryResource, date: string) {
        // Initialize Cloudinary with the provided credentials
        const cloudinary = new Cloudinary({
            cloud_name: cloudinaryResource.cloudName,
            api_key: cloudinaryResource.apiKey,
            api_secret: cloudinaryResource.apiSecret
        });

        // Construct the URL for the usage report
        const usageReportUrl = cloudinary.url("usage", {
            resource_type: 'image',
            type: 'upload',
            start_date: date, // Assuming 'date' is in the format 'YYYY-MM-DD'
            end_date: date
        });

        // Fetch the usage report
        const response = await fetch(usageReportUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Basic ${Buffer.from(`${cloudinaryResource.apiKey}:${cloudinaryResource.apiSecret}`).toString('base64')}`
            }
        });

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse the response as JSON
        const usageDetails = await response.json();

        // Return the usage details
        return usageDetails;
    }
  good: |-
    import { Cloudinary as CloudinaryCore } from "npm:cloudinary-core";

    type Cloudinary = {
        cloudName: string;
        apiKey: string;
        apiSecret: string;
    }

    export async function main(cloudinaryConfig: Cloudinary, date: string) {
        const cloudinary = new CloudinaryCore({
            cloud_name: cloudinaryConfig.cloudName,
            api_key: cloudinaryConfig.apiKey,
            api_secret: cloudinaryConfig.apiSecret
        });

        const apiUrl = cloudinary.api_url('usage', {
            date: date
        });

        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Basic ${Buffer.from(`${cloudinaryConfig.apiKey}:${cloudinaryConfig.apiSecret}`).toString('base64')}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-account-usage-details
  instructions: |-
    Enables you to get a report on the status of your Cloudinary account usage details, including storage, credits, bandwidth, requests, number of resources, and add-on usage in cloudinary
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Cloudinary
  resource_type_def: |-
    type Cloudinary = {
        cloudName: string;
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP calls to Coda API

    class coda(TypedDict):
        api_token: str

    def main(coda_resource: coda, doc_id: str, table_id_or_name: str) -> List[dict]:
        base_url = "https://coda.io/apis/v1"
        headers = {
            "Authorization": f"Bearer {coda_resource['api_token']}",
            "Content-Type": "application/json"
        }

        response = requests.get(
            f"{base_url}/docs/{doc_id}/tables/{table_id_or_name}/rows",
            headers=headers
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        rows = response.json().get('items', [])
        return rows
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API calls

    class coda(TypedDict):
        api_token: str

    def main(coda_resource: coda, user_id: str) -> List[dict]:
        headers = {
            'Authorization': f'Bearer {coda_resource["api_token"]}',
            'Content-Type': 'application/json'
        }
        url = f'https://coda.io/apis/v1/docs?isOwner=true&query=user:{user_id}'
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        docs = response.json().get('items', [])
        return docs

    # The script ends here, and the function is not called.
  id: |-
    synthetic_list-docs
  instructions: |-
    Returns a list of docs accessible by the user. These are returned in the same order as on the docs page: reverse chronological by the latest event relevant to the user (last viewed, edited, or shared) in coda
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    coda
  resource_type_def: |-
    class coda(TypedDict):
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'dock_certs' integration
    class dock_certs(TypedDict):
        api_key: str
        api_secret: str

    def main(dock_certs_resource: dock_certs, credential_id: str) -> bool:
        # Assuming 'requests' is needed for HTTP requests
        import requests as http_requests

        # Construct the API endpoint to revoke a credential
        revoke_endpoint = f"https://api.dockcerts.com/credentials/{credential_id}/revoke"

        # Set up the headers with the API key and secret from the resource
        headers = {
            "Authorization": f"ApiKey {dock_certs_resource['api_key']}:{dock_certs_resource['api_secret']}"
        }

        # Make the HTTP POST request to revoke the credential
        response = http_requests.post(revoke_endpoint, headers=headers)

        # Check if the request was successful (HTTP status code 200)
        if response.status_code == 200:
            return True  # Credential successfully revoked
        else:
            return False  # Failed to revoke the credential

    # Note: The function is not called here, it's just defined and ready to be exported.
  good: |-
    from typing import TypedDict

    # Define the resource type for the dock_certs integration
    class dock_certs(TypedDict):
        api_key: str
        api_secret: str

    def main(dock_certs_resource: dock_certs, credential_id: str) -> bool:
        # Assuming there is a library to interact with dock_certs
        from dock_certs_api import revoke_credential as revoke_credential_api

        # Use the API to revoke the credential
        result = revoke_credential_api(
            api_key=dock_certs_resource['api_key'],
            api_secret=dock_certs_resource['api_secret'],
            credential_id=credential_id
        )

        # Return the result of the revocation
        return result
  id: |-
    synthetic_revoke-credential
  instructions: |-
    Revoke an existing credential in dock certs
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dock_certs
  resource_type_def: |-
    class dock_certs(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks"; // Assuming @airtable/blocks is the correct npm package for Airtable

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
        tableName: string;
    }

    export async function main(airtableResource: AirtableOauth, recordId: string, recordData: { [key: string]: any }) {
        const base = new Base({ apiKey: airtableResource.apiKey });

        const table = base.getTable(airtableResource.tableName);
        let record = null;

        try {
            // Try to retrieve the record by ID
            record = await table.selectRecordAsync(recordId);
        } catch (error) {
            console.error("Error fetching record:", error);
        }

        if (record) {
            // If the record exists, return it
            return record;
        } else {
            // If the record does not exist, create a new one
            const createdRecord = await table.createRecordAsync(recordData);
            return createdRecord;
        }
    }
  good: |-
    import { Base } from "npm:airtable";

    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }

    export async function main(
        airtableResource: AirtableOauth,
        tableName: string,
        recordId: string,
        fields: { [key: string]: any }
    ) {
        const base = new Base({ apiKey: airtableResource.apiKey });

        try {
            // Try to retrieve the existing record
            const record = await base(tableName).find(recordId);
            return record;
        } catch (error) {
            // If the record does not exist, create a new one
            if (error.statusCode === 404) {
                const newRecord = await base(tableName).create(fields);
                return newRecord;
            } else {
                // If there is another error, throw it
                throw error;
            }
        }
    }
  id: |-
    synthetic_get-record-or-create
  instructions: |-
    Get a record from a table by record ID or create a new register. in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, projectIdOrKey: string) {
        const { host, email, apiToken } = jiraResource;
        const auth = Buffer.from(`${email}:${apiToken}`).toString('base64');

        const response = await request('DELETE /rest/api/3/project/{projectIdOrKey}', {
            headers: {
                'Authorization': `Basic ${auth}`,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            baseUrl: host,
            projectIdOrKey: projectIdOrKey
        });

        return response;
    }
  good: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        baseUrl: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, projectIdOrKey: string) {
        const auth = Buffer.from(`${jiraResource.email}:${jiraResource.apiToken}`).toString('base64');
        const response = await request('DELETE /rest/api/3/project/{projectIdOrKey}', {
            baseUrl: jiraResource.baseUrl,
            headers: {
                Authorization: `Basic ${auth}`,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            projectIdOrKey: projectIdOrKey
        });

        return response;
    }
  id: |-
    synthetic_delete-project
  instructions: |-
    Deletes a project, in jira
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jira
  resource_type_def: |-
    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'html_css_to_image' integration
    class html_css_to_image(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the 'html_css_to_image' integration
    def main(resource: html_css_to_image, image_url: str) -> str:
        # Assuming a library 'html_css_to_image_api' is used for the integration
        from html_css_to_image_api import create_image_from_url as create_image_from_url_api

        # Use the credentials from the resource to authenticate with the API
        api_client = create_image_from_url_api(
            api_key=resource['api_key'],
            api_secret=resource['api_secret']
        )

        # Call the API to create an image from the provided URL
        result = api_client.create_image(url=image_url)

        # Return the result, which could be a URL to the created image or an image ID
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'html_css_to_image' integration
    class html_css_to_image(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for the 'html_css_to_image' integration
    def main(html_css_to_image_resource: html_css_to_image, html_content: str, css_content: str, output_format: str = 'png') -> str:
        import requests  # Import requests or any other library if needed

        # API endpoint for the HTML/CSS to Image conversion service
        api_endpoint = "https://hcti.io/v1/image"

        # Prepare the data for the API request
        data = {
            'html': html_content,
            'css': css_content,
            'output': output_format
        }

        # Prepare the headers for authentication
        headers = {
            'Authorization': f'Basic {html_css_to_image_resource["api_key"]}:{html_css_to_image_resource["api_secret"]}'
        }

        # Make the API request to convert HTML/CSS to an image
        response = requests.post(api_endpoint, data=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the URL of the generated image
            return response.json()['url']
        else:
            # Handle errors (you could also raise an exception here)
            return f"Error: {response.status_code} - {response.text}"

    # Note: The function is not called here, it is just defined and ready to be used with the required parameters.
  id: |-
    synthetic_create-image-from-url
  instructions: |-
    Create Image From URL. in html css to image
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    html_css_to_image
  resource_type_def: |-
    class html_css_to_image(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the discord_bot integration
    class discord_bot(TypedDict):
        token: str  # Bot token for authentication
        client_id: str  # Client ID of the bot

    # Import discord library, if there's a conflict with an imported method, rename the method
    import discord
    from discord.ext import commands

    # Define the main function for deleting a message in a Discord bot
    def main(discord_bot_resource: discord_bot, channel_id: int, message_id: int):
        # Initialize the bot with the provided token
        bot = commands.Bot(command_prefix='!')

        # Define a coroutine to delete the message
        async def delete_message():
            # Get the channel and message objects
            channel = bot.get_channel(channel_id)
            message = await channel.fetch_message(message_id)

            # Delete the message
            await message.delete()

        # Run the bot and execute the delete_message coroutine
        bot.run(discord_bot_resource['token'])
        bot.loop.create_task(delete_message())

        # Return a success message
        return f"Message with ID {message_id} in channel {channel_id} has been deleted."

    # Note: The actual deletion will be performed asynchronously when the bot is running.
    # The function returns a message immediately, but the action will complete in the background.
  good: |-
    from typing import TypedDict

    # Define the resource type for the discord_bot integration
    class discord_bot(TypedDict):
        token: str  # Bot token for authentication

    # Define the main function for the discord_bot integration
    def main(discord_bot_resource: discord_bot, message_id: str, channel_id: str) -> bool:
        import discord  # Import the discord library

        # Create a client instance using the bot token
        client = discord.Client()

        @client.event
        async def on_ready():
            # Fetch the channel where the message to delete is located
            channel = client.get_channel(int(channel_id))
            if channel:
                # Fetch the message to delete
                message = await channel.fetch_message(int(message_id))
                if message:
                    # Delete the message
                    await message.delete()
                    # Disconnect the bot after deleting the message
                    await client.close()
                    return True
            return False

        # Run the bot
        client.run(discord_bot_resource['token'])

    # Note: The function will not be called here, it is just defined and exported.
  id: |-
    synthetic_delete-message
  instructions: |-
    Delete a message in discord bot
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    discord_bot
  resource_type_def: |-
    class discord_bot(TypedDict):
        token: str  # Bot token for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Mailwizz = {
        apiUrl: string;
        publicKey: string;
        privateKey: string;
    }

    export async function main(mailwizzResource: Mailwizz, listId: string, email: string, details: { [key: string]: string }) {
        const timestamp = new Date().toUTCString();
        const signatureString = `GET ${mailwizzResource.apiUrl}/lists/${listId}/subscribers${timestamp}${mailwizzResource.publicKey}`;
        const signature = encode(signatureString);

        const subscriberData = {
            EMAIL: email,
            ...details
        };

        const response = await fetch(`${mailwizzResource.apiUrl}/lists/${listId}/subscribers`, {
            method: 'POST',
            headers: {
                'X-MW-PUBLIC-KEY': mailwizzResource.publicKey,
                'X-MW-TIMESTAMP': timestamp,
                'X-MW-SIGNATURE': signature,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(subscriberData)
        });

        const result = await response.json();
        return result;
    }
  good: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Mailwizz = {
        apiUrl: string;
        publicKey: string;
        privateKey: string;
    }

    export async function main(mailwizzResource: Mailwizz, email: string, listId: string, details: { [key: string]: string }) {
        // Construct the URL for adding a subscriber
        const url = `${mailwizzResource.apiUrl}/lists/${listId}/subscribers`;

        // Prepare the data to be sent in the request
        const subscriberData = {
            EMAIL: email,
            ...details
        };

        // Generate the signature for the request
        const timestamp = Math.floor(Date.now() / 1000);
        const signatureString = `POST ${url} ${mailwizzResource.publicKey}:${timestamp}`;
        const signature = encode(signatureString);

        // Set up the headers for the request
        const headers = new Headers({
            'Content-Type': 'application/json',
            'X-MW-PUBLIC-KEY': mailwizzResource.publicKey,
            'X-MW-TIMESTAMP': timestamp.toString(),
            'X-MW-SIGNATURE': signature
        });

        // Make the request to add the subscriber
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(subscriberData)
        });

        // Parse the response
        const result = await response.json();

        // Return the result
        return result;
    }
  id: |-
    synthetic_add-subscriber
  instructions: |-
    Create a new subscriber to a list in mailwizz
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailwizz
  resource_type_def: |-
    type Mailwizz = {
        apiUrl: string;
        publicKey: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the dictionary_api integration
    class dictionary_api(TypedDict):
        api_key: str  # API key for authentication with the dictionary_api service

    # Define the main function for getting a word definition from dictionary_api
    def main(dictionary_api_resource: dictionary_api, word: str) -> str:
        import requests  # Import requests or any other library needed for HTTP requests

        # Construct the API endpoint URL
        url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word}"

        # Make the HTTP request to get the word definition
        response = requests.get(url, headers={"Authorization": f"Bearer {dictionary_api_resource['api_key']}"})

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            # Extract the definition from the response
            definitions = data[0]['meanings'][0]['definitions'][0]['definition']
            return definitions
        else:
            # Handle errors (e.g., word not found or API issues)
            return f"Error: Unable to retrieve definition for '{word}'. Status code: {response.status_code}"

    # The script ends here, with no calls to the main function, as per the instructions.
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests library is used for HTTP requests

    class dictionary_api(TypedDict):
        api_key: str
        endpoint: str

    def main(dictionary_resource: dictionary_api, word: str, language: str = "en") -> Optional[str]:
        url = f"{dictionary_resource['endpoint']}/v2/entries/{language}/{word}"
        headers = {
            "Authorization": f"Bearer {dictionary_resource['api_key']}"
        }
        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            definitions = response.json()
            # Assuming the API returns a list of entries, and each entry contains a list of meanings
            # and each meaning contains a list of definitions.
            if definitions and len(definitions) > 0 and 'meanings' in definitions[0]:
                first_meaning = definitions[0]['meanings'][0]
                if 'definitions' in first_meaning and len(first_meaning['definitions']) > 0:
                    return first_meaning['definitions'][0]['definition']
            return None
        else:
            response.raise_for_status()
  id: |-
    synthetic_get-word-definition
  instructions: |-
    Get the definition for an English word in dictionary api
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dictionary_api
  resource_type_def: |-
    class dictionary_api(TypedDict):
        api_key: str  # API key for authentication with the dictionary_api service
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the botconversa integration
    class botconversa(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function to create a new subscriber in botconversa
    def main(botconversa_resource: botconversa, subscriber_email: str, subscriber_name: str):
        # Assuming there's a library to interact with botconversa API
        import botconversa_api_client as bc_client

        # Initialize the botconversa API client with the provided credentials
        client = bc_client.Client(api_key=botconversa_resource['api_key'], api_secret=botconversa_resource['api_secret'])

        # Create a new subscriber
        subscriber_data = {
            'email': subscriber_email,
            'name': subscriber_name
        }
        result = client.create_subscriber(subscriber_data)

        # Return the result of the subscriber creation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'botconversa' integration
    class botconversa(TypedDict):
        api_key: str
        api_secret: str

    # Main function to create a subscriber in the 'botconversa' platform
    def main(botconversa_resource: botconversa, subscriber_name: str, subscriber_email: str):
        # Assuming there's a library to interact with botconversa
        from botconversa_api import create_subscriber

        # Use the credentials from the resource to authenticate
        auth_credentials = {
            'api_key': botconversa_resource['api_key'],
            'api_secret': botconversa_resource['api_secret']
        }

        # Call the method to create a subscriber with the provided name and email
        result = create_subscriber(auth_credentials, subscriber_name, subscriber_email)

        # Return the result of the subscriber creation
        return result
  id: |-
    synthetic_create-subscriber
  instructions: |-
    Create a new subscriber in botconversa
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    botconversa
  resource_type_def: |-
    class botconversa(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type Lemlist = {
        apiKey: string;
    }

    export async function main(lemlistResource: Lemlist, campaignId: string, email: string) {
        const unsubscribeUrl = `https://api.lemlist.com/api/campaigns/${campaignId}/unsubscribe`;

        const response = await fetch(unsubscribeUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${lemlistResource.apiKey}`
            },
            body: JSON.stringify({ email })
        });

        if (!response.ok) {
            throw new Error(`Failed to unsubscribe lead: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Lemlist = {
        apiKey: string;
        baseUrl: string;
    }

    export async function main(lemlistResource: Lemlist, leadEmail: string, campaignId: string) {
        const { apiKey, baseUrl } = lemlistResource;

        // Check if the lead belongs to the specified campaign
        const campaignLeadsUrl = `${baseUrl}/campaigns/${campaignId}/leads`;
        const leadResponse = await fetch(campaignLeadsUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!leadResponse.ok) {
            throw new Error(`Failed to get leads from campaign: ${leadResponse.statusText}`);
        }

        const leads = await leadResponse.json();
        const lead = leads.find((l: any) => l.email === leadEmail);

        if (!lead) {
            return { message: `Lead with email ${leadEmail} not found in campaign ${campaignId}.` };
        }

        // Unsubscribe the lead from all campaigns
        const unsubscribeUrl = `${baseUrl}/leads/${lead._id}/unsubscribeAll`;
        const unsubscribeResponse = await fetch(unsubscribeUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!unsubscribeResponse.ok) {
            throw new Error(`Failed to unsubscribe lead: ${unsubscribeResponse.statusText}`);
        }

        return { message: `Lead with email ${leadEmail} has been unsubscribed from all campaigns.` };
    }
  id: |-
    synthetic_unsubscribe-lead-from-a-campaign
  instructions: |-
    This action will unsubscribe a lead from all campaigns if he belongs to the specified campaign in lemlist
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lemlist
  resource_type_def: |-
    type Lemlist = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client as AsanaClient } from "npm:@asana/client";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, projectId: string, sectionName: string, taskName: string, taskNotes?: string) {
        const client = AsanaClient.create().useAccessToken(asanaResource.accessToken);

        // Find the section ID within the project
        const sections = await client.sections.findByProject(projectId);
        const section = sections.find(s => s.name === sectionName);
        if (!section) {
            throw new Error(`Section "${sectionName}" not found in project with ID "${projectId}".`);
        }

        // Create a task in the specified section
        const task = await client.tasks.createInWorkspace(section.workspace.id, {
            name: taskName,
            notes: taskNotes,
            projects: [projectId],
            memberships: [
                {
                    project: projectId,
                    section: section.gid
                }
            ]
        });

        return task;
    }
  good: |-
    import { Client } from "npm:@asana/client";

    type AsanaResource = {
        accessToken: string;
        workspaceId: string;
        projectId: string;
    };

    export async function main(
        asanaResource: AsanaResource,
        taskId: string,
        sectionId: string
    ) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);

        // Remove the task from other sections in the project
        const sections = await client.sections.findByProject(asanaResource.projectId);
        for (const section of sections) {
            if (section.gid !== sectionId) {
                await client.sections.removeTask(section.gid, { task: taskId });
            }
        }

        // Add the task to the specified section
        const result = await client.sections.addTask(sectionId, { task: taskId });

        return result;
    }
  id: |-
    synthetic_add-task-to-section
  instructions: |-
    Add a task to a specific, existing section. This will remove the task from other sections of the project in asana
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asana
  resource_type_def: |-
    type Asana = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { LinkedInClient } from "npm:linkedin-client"; // Hypothetical npm package for LinkedIn API

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin, memberId: string) {
        const client = new LinkedInClient(linkedinResource.accessToken);

        const accessControlInfo = await client.getMemberOrganizationAccessControl(memberId);

        return accessControlInfo;
    }
  good: |-
    import { LinkedInClient } from "npm:@linkedin/client-rest";

    type Linkedin = {
        accessToken: string;
    }

    export async function main(linkedinResource: Linkedin) {
        const client = new LinkedInClient(linkedinResource.accessToken);

        const organizationAccessControlInfo = await client.getOrganizationAccessControlInformation();

        return organizationAccessControlInfo;
    }
  id: |-
    synthetic_get-member-organization-access-control
  instructions: |-
    Gets the organization access control information of the current authenticated member in linkedin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Headers } from "npm:@deno/headers";

    type CloudflareApiKey = {
        email: string;
        apiKey: string;
        accountId: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, namespaceName: string) {
        const url = `https://api.cloudflare.com/client/v4/accounts/${cloudflareResource.accountId}/storage/kv/namespaces`;
        const headers = new Headers({
            "X-Auth-Email": cloudflareResource.email,
            "X-Auth-Key": cloudflareResource.apiKey,
            "Content-Type": "application/json",
        });

        const body = JSON.stringify({ title: namespaceName });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { createNamespace } from "npm:@cloudflare/workerskv";

    type CloudflareApiKey = {
        accountId: string;
        apiKey: string;
        email: string;
    }

    export async function main(cloudflareResource: CloudflareApiKey, namespaceName: string) {
        const url = `https://api.cloudflare.com/client/v4/accounts/${cloudflareResource.accountId}/storage/kv/namespaces`;
        const body = JSON.stringify({ title: namespaceName });

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'X-Auth-Email': cloudflareResource.email,
                'X-Auth-Key': cloudflareResource.apiKey,
                'Content-Type': 'application/json',
            },
            body: body
        });

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_create-namespace
  instructions: |-
    Create a new Namespace in an account in cloudflare api key
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CloudflareApiKey
  resource_type_def: |-
    type CloudflareApiKey = {
        accountId: string;
        apiKey: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import monday as monday_lib  # Assuming 'monday' is the name of the imported library

    # Define the resource type for the 'monday' integration
    class monday(TypedDict):
        api_key: str

    def main(monday_resource: monday, board_id: int, group_id: str, column_title: str, column_type: str):
        # Initialize the Monday client with the API key from the resource
        monday_client = monday_lib.MondayClient(monday_resource['api_key'])

        # Create the column on the specified board and group
        result = monday_client.columns.create_column(board_id, group_id, column_title, column_type)

        # Return the result of the column creation
        return result
  good: |-
    from typing import TypedDict
    import monday as monday_lib  # Renamed imported module to avoid conflict

    class monday(TypedDict):
        api_key: str

    def main(monday_resource: monday, board_id: str, column_title: str, column_type: str, column_settings: dict = None):
        # Initialize the Monday client with the API key
        client = monday_lib.MondayClient(monday_resource['api_key'])

        # Create the column on the specified board
        result = client.columns.create_column(
            board_id=board_id,
            title=column_title,
            column_type=column_type,
            settings_str=column_settings
        )

        # Return the result of the column creation
        return result
  id: |-
    synthetic_create-column
  instructions: |-
    Creates a column in monday
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    monday
  resource_type_def: |-
    class monday(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { HttpClient } from "npm:@angular/common/http";

    // Defining the Clickup resource type with properties needed for authentication
    type Clickup = {
        accessToken: string;
    }

    // The main function to get spaces from Clickup
    export async function main(clickupResource: Clickup) {
        // Define the API endpoint for Clickup spaces
        const clickupApiUrl = 'https://api.clickup.com/api/v2/space';

        // Set up the headers for the HTTP request
        const headers = {
            'Authorization': clickupResource.accessToken,
            'Content-Type': 'application/json'
        };

        // Create an instance of HttpClient
        const httpClient = new HttpClient();

        // Perform the GET request to the Clickup API to retrieve spaces
        try {
            const response = await httpClient.get(clickupApiUrl, { headers: headers });
            // Parse the response and return the spaces
            const spaces = await response.json();
            return spaces;
        } catch (error) {
            // Handle any errors that occur during the API request
            console.error('Error fetching Clickup spaces:', error);
            throw error;
        }
    }
  good: |-
    // Importing the necessary library for making HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, teamId: string) {
        const url = `https://api.clickup.com/api/v2/team/${teamId}/space`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': clickupResource.apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching spaces: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_get-spaces
  instructions: |-
    Get a list of spaces in a workplace. See the docs in **Spaces / Get Spaces** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed for HTTP requests to Airtable API

    # Define the resource type for the airtable_oauth integration
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str

    def main(airtable_resource: airtable_oauth, table_name: str, view: str) -> List[Any]:
        # Construct the URL for the Airtable API endpoint
        url = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{table_name}"

        # Set up the headers with the authorization
        headers = {
            "Authorization": f"Bearer {airtable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Set up the parameters for the request, including the view
        params = {
            "view": view
        }

        # Make the GET request to the Airtable API
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the records
            return response.json().get('records', [])
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()
  good: |-
    from typing import TypedDict, List, Optional
    import requests

    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str
        table_name: str

    def main(airtable_resource: airtable_oauth, view: str, sort_field: Optional[str] = None, sort_direction: Optional[str] = 'asc', filter_by_formula: Optional[str] = None) -> List[dict]:
        headers = {
            'Authorization': f"Bearer {airtable_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        params = {
            'view': view
        }
        if sort_field:
            params['sort[0][field]'] = sort_field
            params['sort[0][direction]'] = sort_direction
        if filter_by_formula:
            params['filterByFormula'] = filter_by_formula

        records = []
        url = f"https://api.airtable.com/v0/{airtable_resource['base_id']}/{airtable_resource['table_name']}"

        while True:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()
            records.extend(data.get('records', []))

            if 'offset' in data:
                params['offset'] = data['offset']
            else:
                break

        return records
  id: |-
    synthetic_list-records-in-view
  instructions: |-
    Retrieve records in a view with automatic pagination. Optionally sort and filter results. Only available for Enterprise accounts. in airtable oauth
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    airtable_oauth
  resource_type_def: |-
    class airtable_oauth(TypedDict):
        api_key: str
        base_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
        workspace_id: str

    # Define the main function for moving a task in the kanban tool
    def main(kanban_tool_resource: kanban_tool, task_id: str, column_id: str) -> bool:
        # Assuming there is a library to interact with Kanban Tool API
        from kanban_api_client import KanbanClient, KanbanClientError

        # Create a client instance with the provided credentials
        client = KanbanClient(
            api_key=kanban_tool_resource['api_key'],
            board_id=kanban_tool_resource['board_id'],
            workspace_id=kanban_tool_resource['workspace_id']
        )

        try:
            # Move the task to the specified column
            result = client.move_task(task_id, column_id)
            return result
        except KanbanClientError as e:
            # Handle any errors that occur during the API call
            print(f"An error occurred: {e}")
            return False
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
        workspace_id: str

    # Define the main function for moving a task in the kanban_tool
    def main(kanban_tool_resource: kanban_tool, task_id: str, column_id: str, swimlane_id: str = None) -> Any:
        # Import the necessary library for HTTP requests
        import requests

        # Construct the API endpoint for moving a task
        move_task_endpoint = f"https://kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}/move"

        # Prepare the headers and payload for the API request
        headers = {
            'X-KanbanToolToken': kanban_tool_resource['api_key']
        }
        payload = {
            'task[workflow_stage_id]': column_id
        }
        if swimlane_id:
            payload['task[swimlane_id]'] = swimlane_id

        # Make the API request to move the task
        response = requests.post(move_task_endpoint, headers=headers, data=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the response as JSON if successful
        else:
            raise Exception(f"Failed to move task: {response.status_code} {response.text}")  # Raise an exception if the request failed

    # Note: The function does not call itself, it's meant to be exported and used with the specified parameters.
  id: |-
    synthetic_move-task
  instructions: |-
    Moves a task in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
        workspace_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Clerk as ClerkSDK, ClerkResource as ClerkSDKResource } from "npm:@clerk/clerk-sdk-node";

    type Clerk = {
        apiKey: string;
    }

    export async function main(clerkResource: Clerk, userId: string, userData: Record<string, any>) {
        const clerk = new ClerkSDK({ apiKey: clerkResource.apiKey });

        try {
            const user = await clerk.users.updateUser(userId, userData);
            return user;
        } catch (error) {
            console.error("Failed to update user:", error);
            throw error;
        }
    }
  good: |-
    // Import any libraries you need here
    import { Clerk, Users } from "npm:@clerk/clerk-sdk-node";

    type ClerkResource = {
        apiKey: string;
    }

    export async function main(clerkResource: ClerkResource, userId: string, primaryEmailAddressId: string, primaryPhoneNumberId: string) {
        // Initialize Clerk with the provided API key
        const clerk = new Clerk({ apiKey: clerkResource.apiKey });

        // Update the user's primary contact identifiers
        const updatedUser = await clerk.users.updateUser(userId, {
            primaryEmailAddressId: primaryEmailAddressId,
            primaryPhoneNumberId: primaryPhoneNumberId
        });

        // Return the updated user object
        return updatedUser;
    }
  id: |-
    synthetic_update-user
  instructions: |-
    Update a user's attributes. You can set the user's primary contact identifiers (email address and phone numbers) by updating the `Primary Email Address Id` and `Primary Phone Number Id` attributes respectively. Both IDs should correspond to verified identifications that belong to the user in clerk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clerk
  resource_type_def: |-
    type Clerk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls to Jira's API

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, project_key: str, version_name: str, description: str = '', release_date: str = None):
        # Construct the URL for the Jira API endpoint to create a new version
        url = f"{jira_resource['base_url']}/rest/api/3/version"

        # Prepare the authentication header
        auth = (jira_resource['username'], jira_resource['api_token'])

        # Prepare the payload for the new version
        payload = {
            "name": version_name,
            "description": description,
            "archived": False,
            "released": False,
            "project": project_key,
            "releaseDate": release_date
        }

        # Make the request to create a new version in Jira
        response = requests.post(url, json=payload, auth=auth)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the JSON response if the version was created successfully
        else:
            raise Exception(f"Failed to create version in Jira: {response.status_code} {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP calls to Jira's REST API

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
        project_key: str

    # Define the main function for creating a project version in Jira
    def main(jira_resource: jira, version_name: str, version_description: str = '', start_date: str = None, release_date: str = None):
        # Construct the API endpoint for creating a new version
        url = f"{jira_resource['base_url']}/rest/api/3/version"

        # Prepare the authentication header
        auth = (jira_resource['username'], jira_resource['api_token'])

        # Prepare the payload for the new version
        payload = {
            "name": version_name,
            "description": version_description,
            "archived": False,
            "released": False,
            "startDate": start_date,
            "releaseDate": release_date,
            "project": jira_resource['project_key']
        }

        # Make the POST request to create the new version
        response = requests.post(url, json=payload, auth=auth)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created version's data
        else:
            raise Exception(f"Failed to create version in Jira: {response.status_code} - {response.text}")

    # Example usage:
    # result = main(jira_resource={'base_url': 'https://your-domain.atlassian.net', 'username': 'your-username', 'api_token': 'your-api-token', 'project_key': 'PROJ'}, version_name='1.0.0', version_description='Initial release', start_date='2023-01-01', release_date='2023-12-31')
    # print(result)
  id: |-
    synthetic_create-version
  instructions: |-
    Creates a project version., in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MongoClient } from "npm:mongodb";

    type Mongodb = {
        uri: string,
        dbName: string,
        collectionName: string
    }

    export async function main(mongodbResource: Mongodb, query: Record<string, unknown> = {}) {
        const client = new MongoClient(mongodbResource.uri);
        try {
            await client.connect();
            const database = client.db(mongodbResource.dbName);
            const collection = database.collection(mongodbResource.collectionName);

            const documents = await collection.find(query).toArray();
            return documents;
        } finally {
            await client.close();
        }
    }
  good: |-
    import { MongoClient } from "npm:mongodb";

    type Mongodb = {
        uri: string,
        dbName: string
    }

    export async function main(mongodbResource: Mongodb, collectionName: string, searchQuery: Record<string, unknown>) {
        const client = new MongoClient(mongodbResource.uri);
        try {
            await client.connect();
            const database = client.db(mongodbResource.dbName);
            const collection = database.collection(collectionName);
            const searchResults = await collection.find(searchQuery).toArray();
            return searchResults;
        } finally {
            await client.close();
        }
    }
  id: |-
    synthetic_search-documents
  instructions: |-
    Search for specific documents or return all documents in mongodb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mongodb
  resource_type_def: |-
    type Mongodb = {
        uri: string,
        dbName: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls to Mailchimp

    # Define the resource type for the Mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, campaign_id: str) -> Any:
        # Construct the API endpoint for the campaign report
        api_endpoint = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0/reports/{campaign_id}"

        # Set up the headers for the HTTP request
        headers = {
            'Authorization': f"Bearer {mailchimp_resource['api_key']}"
        }

        # Make the HTTP GET request to retrieve the campaign report
        response = requests.get(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # Mailchimp API endpoints are prefixed with a server (e.g., 'us1', 'us2', etc.)

    def main(mailchimp_resource: mailchimp, campaign_id: str) -> Any:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        campaign_report_url = f"{base_url}/reports/{campaign_id}"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        response = requests.get(campaign_report_url, headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  id: |-
    synthetic_get-campaign-report
  instructions: |-
    Gets a campaign report in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import boto3
    from botocore.client import Config

    # Define the resource type for the digitalocean_spaces integration
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str

    def main(digitalocean_spaces_resource: digitalocean_spaces, bucket_name: str, file_keys: list[str]):
        # Initialize a session using DigitalOcean Spaces credentials
        session = boto3.session.Session()
        client = session.client('s3',
                                region_name=digitalocean_spaces_resource['region_name'],
                                endpoint_url=digitalocean_spaces_resource['endpoint_url'],
                                aws_access_key_id=digitalocean_spaces_resource['access_key_id'],
                                aws_secret_access_key=digitalocean_spaces_resource['secret_access_key'],
                                config=Config(signature_version='s3v4'))

        # Delete the files from the specified bucket
        delete_responses = []
        for key in file_keys:
            response = client.delete_object(Bucket=bucket_name, Key=key)
            delete_responses.append(response)

        return delete_responses
  good: |-
    from typing import TypedDict
    import boto3
    from botocore.client import Config

    # Define the resource type for the digitalocean_spaces integration
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str

    def main(digitalocean_spaces_resource: digitalocean_spaces, bucket_name: str, file_keys: list[str]):
        # Initialize a session using DigitalOcean Spaces credentials
        session = boto3.session.Session()
        client = session.client('s3',
                                region_name=digitalocean_spaces_resource['region_name'],
                                endpoint_url=digitalocean_spaces_resource['endpoint_url'],
                                aws_access_key_id=digitalocean_spaces_resource['access_key_id'],
                                aws_secret_access_key=digitalocean_spaces_resource['secret_access_key'],
                                config=Config(signature_version='s3v4'))

        # Delete the specified files from the given bucket
        delete_responses = []
        for key in file_keys:
            response = client.delete_object(Bucket=bucket_name, Key=key)
            delete_responses.append(response)

        return delete_responses
  id: |-
    synthetic_delete-files
  instructions: |-
    Delete files in a bucket. in digitalocean spaces
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    digitalocean_spaces
  resource_type_def: |-
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MailerSend as MailerSendClient, EmailParams } from "npm:@mailersend/mailersend";

    type Mailersend = {
        apiKey: string;
    }

    export async function main(
        mailersendResource: Mailersend,
        toEmail: string,
        fromEmail: string,
        templateId: string,
        variables: Record<string, any>
    ) {
        const mailer = new MailerSendClient({
            api_key: mailersendResource.apiKey,
        });

        const emailParams = new EmailParams()
            .setFrom(fromEmail)
            .setTo([toEmail])
            .setTemplateId(templateId)
            .setVariables(variables);

        try {
            const response = await mailer.send(emailParams);
            return response;
        } catch (error) {
            console.error('Error sending email:', error);
            throw error;
        }
    }
  good: |-
    import { MailerSend, EmailParams } from "npm:@mailersend/mailersend";

    type Mailersend = {
        apiKey: string;
    }

    export async function main(
        mailersendResource: Mailersend,
        recipientEmail: string,
        templateId: string,
        variables: Record<string, any>,
        fromEmail: string,
        fromName: string,
        subject: string
    ) {
        const mailer = new MailerSend({
            api_key: mailersendResource.apiKey,
        });

        const emailParams = new EmailParams()
            .setFrom(fromEmail)
            .setFromName(fromName)
            .setTo([recipientEmail])
            .setSubject(subject)
            .setTemplateId(templateId)
            .setVariables(variables);

        try {
            const response = await mailer.send(emailParams);
            return response;
        } catch (error) {
            console.error('Error sending email:', error);
            throw error;
        }
    }
  id: |-
    synthetic_send-email-from-template
  instructions: |-
    This action sends a personalized e-mail to the specified recipient using templates in mailersend
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailersend
  resource_type_def: |-
    type Mailersend = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import gorillastack  # Assuming gorillastack is a library that we need

    # Define the resource type for the gorillastack integration
    class gorillastack_resource(TypedDict):
        api_key: str
        team_id: str

    # Define the main function with the gorillastack_resource and additional parameters
    def main(gorillastack_resource: gorillastack_resource, template_definition: dict, region: str):
        # Assuming there is a GorillaStack SDK with a method to deploy a template
        # If there's a conflict with the method name, it would be renamed, but here it's assumed there's no conflict
        gs_client = gorillastack.Client(api_key=gorillastack_resource['api_key'], team_id=gorillastack_resource['team_id'])
        result = gs_client.deploy_template(template_definition=template_definition, region=region)

        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the gorillastack integration
    class gorillastack(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for deploying a template with gorillastack
    def main(gorillastack_resource: gorillastack, template_id: str, region: str, parameters: dict):
        # Assuming that there is a GorillaStack SDK that we can use to interact with the service
        from gorillastack_sdk import GorillaStackClient, deploy_template as gs_deploy_template  # hypothetical import

        # Initialize the GorillaStack client with the provided credentials
        client = GorillaStackClient(api_key=gorillastack_resource['api_key'], api_secret=gorillastack_resource['api_secret'])

        # Deploy the template using the client
        deployment_result = gs_deploy_template(client, template_id, region, parameters)

        # Return the result of the deployment
        return deployment_result
  id: |-
    synthetic_deploy-template
  instructions: |-
    Deploy a template definition in gorillastack
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gorillastack
  resource_type_def: |-
    class gorillastack(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import gspread  # Assuming gspread is used for Google Sheets API

    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict

    def main(google_sheets_resource: google_sheets, spreadsheet_id: str, worksheet_name: str, note_text: str, cell_location: str):
        gc = gspread.service_account_from_dict(google_sheets_resource['service_account_info'])
        sh = gc.open_by_key(spreadsheet_id)
        worksheet = sh.worksheet(worksheet_name)
        worksheet.add_note(cell_location, note_text)
        return f"Note added to {cell_location} in '{worksheet_name}' worksheet."
  good: |-
    from typing import TypedDict
    import gspread  # Assuming gspread library is used for Google Sheets API

    # Rename the imported method if it conflicts with the resource type name
    from gspread.models import Spreadsheet as GSpreadSpreadsheet

    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict

    def main(google_sheets_resource: google_sheets, spreadsheet_id: str, sheet_name: str, cell: str, note: str) -> None:
        gc = gspread.service_account_from_dict(google_sheets_resource['service_account_info'])
        spreadsheet: GSpreadSpreadsheet = gc.open_by_key(spreadsheet_id)
        worksheet = spreadsheet.worksheet(sheet_name)
        worksheet.set_note(cell, note)
        return None

    # Example usage:
    # main(
    #     google_sheets_resource={
    #         'api_key': 'YOUR_API_KEY',
    #         'service_account_info': {
    #             'type': 'service_account',
    #             'project_id': 'your-project-id',
    #             'private_key_id': 'your-private-key-id',
    #             'private_key': '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n',
    #             'client_email': 'your-service-account-email',
    #             'client_id': 'your-client-id',
    #             'auth_uri': 'https://accounts.google.com/o/oauth2/auth',
    #             'token_uri': 'https://oauth2.googleapis.com/token',
    #             'auth_provider_x509_cert_url': 'https://www.googleapis.com/oauth2/v1/certs',
    #             'client_x509_cert_url': 'https://www.googleapis.com/robot/v1/metadata/x509/your-service-account-email'
    #         }
    #     },
    #     spreadsheet_id='your-spreadsheet-id',
    #     sheet_name='Sheet1',
    #     cell='A1',
    #     note='This is a note'
    # )
  id: |-
    synthetic_insert-anchored-note
  instructions: |-
    Insert a note on a spreadsheet cell in google sheets
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_sheets
  resource_type_def: |-
    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the clockwork_recruiting integration
    class clockwork_recruiting(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for the clockwork_recruiting integration
    def main(clockwork_resource: clockwork_recruiting, person_id: str, email_address: str, email_type: str = 'work'):
        # Assuming there is a library to interact with Clockwork Recruiting API
        import clockwork_api_client as clockwork

        # If the clockwork module has a method that conflicts with the resource name, rename it
        # For example, if there is a method called 'clockwork_recruiting', rename it as follows:
        # from clockwork_api_client import clockwork_recruiting as clockwork_recruiting_method

        # Set up the API client with the provided API key and base URL
        client = clockwork.Client(api_key=clockwork_resource['api_key'], base_url=clockwork_resource['base_url'])

        # Create the email address for the specific person
        result = client.create_email_address(person_id=person_id, email_address=email_address, email_type=email_type)

        # Return the result of the operation
        return result

    # The script ends here, with the main function defined and ready to be used with the required parameters.
  good: |-
    from typing import TypedDict, Optional

    # Define the resource type for the clockwork_recruiting integration
    class clockwork_recruiting(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for adding a person's email
    def main(clockwork_resource: clockwork_recruiting, person_id: int, email_address: str, email_type: Optional[str] = None):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for adding an email to a person
        endpoint = f"{clockwork_resource['base_url']}/people/{person_id}/emails"

        # Prepare the data to be sent in the API request
        data = {
            'email': {
                'address': email_address,
                'email_type': email_type
            }
        }

        # Make the API request to add the email
        response = requests.post(
            url=endpoint,
            json=data,
            headers={'Authorization': f"Bearer {clockwork_resource['api_key']}"}
        )

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the response JSON if the email was added successfully
        else:
            response.raise_for_status()  # Raise an exception if the API request failed

    # Note: The function does not call itself, it's meant to be exported and used with the specified parameters.
  id: |-
    synthetic_add-person-email
  instructions: |-
    Create an email address to a specific person in clockwork recruiting
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clockwork_recruiting
  resource_type_def: |-
    class clockwork_recruiting(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Main function to create a board in Miro using the miro_custom_app integration
    def main(miro_resource: miro_custom_app, board_title: str, board_description: str = "", board_url: str = ""):
        import requests  # Import requests or any other library if needed

        # API endpoint to create a board in Miro
        api_endpoint = "https://api.miro.com/v1/boards/"

        # Headers for the API request including the OAuth2 token
        headers = {
            "Authorization": f"Bearer {miro_resource['access_token']}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        # Data payload for the API request to create a board
        data = {
            "name": board_title,
            "description": board_description
        }

        # Make the API request to create a board
        response = requests.post(api_endpoint, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the created board's information
            return response.json()
        else:
            # Handle errors (e.g., display error message)
            response.raise_for_status()
  good: |-
    from typing import TypedDict

    # Define the resource type for the miro_custom_app integration
    class miro_custom_app(TypedDict):
        access_token: str  # OAuth2 Access Token
        team_id: str       # ID of the Miro team

    # Import any additional libraries you might need
    import requests

    # Define the main function for creating a Miro board
    def main(miro_custom_app_resource: miro_custom_app, board_title: str, board_description: str = ""):
        # Construct the API endpoint for creating a new board
        api_url = f"https://api.miro.com/v1/teams/{miro_custom_app_resource['team_id']}/boards"

        # Set up the headers with the authorization token
        headers = {
            "Authorization": f"Bearer {miro_custom_app_resource['access_token']}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        # Define the payload with the board title and description
        payload = {
            "name": board_title,
            "description": board_description
        }

        # Make a POST request to create the board
        response = requests.post(api_url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the created board's information
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception)
            response.raise_for_status()
  id: |-
    synthetic_create-board
  instructions: |-
    Creates a Miro board. in miro custom app
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    miro_custom_app
  resource_type_def: |-
    class miro_custom_app(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SMTPClient } from "npm:@deno_mail/smtp";

    type Holded = {
        smtpHost: string;
        smtpPort: number;
        smtpUsername: string;
        smtpPassword: string;
        useTLS: boolean;
    }

    export async function main(
        holdedResource: Holded,
        to: string,
        subject: string,
        body: string,
        from?: string,
        cc?: string[],
        bcc?: string[]
    ) {
        const client = new SMTPClient({
            hostname: holdedResource.smtpHost,
            port: holdedResource.smtpPort,
            username: holdedResource.smtpUsername,
            password: holdedResource.smtpPassword,
            connectTimeout: 10000,
            tls: holdedResource.useTLS,
        });

        await client.connect();

        const message = {
            from: from || holdedResource.smtpUsername, // Default sender address to the SMTP username if not provided
            to: to,
            cc: cc,
            bcc: bcc,
            subject: subject,
            content: body,
        };

        await client.send(message);
        await client.close();
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Holded = {
        apiKey: string;
        companyName: string;
    }

    export async function main(
        holdedResource: Holded,
        contactEmail: string,
        documentContent: Uint8Array,
        documentName: string,
        subject: string,
        body: string
    ) {
        const base64Document = encode(documentContent);
        const emailEndpoint = `https://api.holded.com/api/${holdedResource.companyName}/mailer/send`;

        const emailData = {
            to: contactEmail,
            subject: subject,
            body: body,
            attachments: [
                {
                    filename: documentName,
                    content: base64Document,
                    encoding: 'base64'
                }
            ]
        };

        const response = await fetch(emailEndpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${holdedResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(emailData)
        });

        if (!response.ok) {
            throw new Error(`Failed to send email: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_send-email
  instructions: |-
    Deliver an email with a document to a contact through Holded. in holded
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Holded
  resource_type_def: |-
    type Holded = {
        smtpHost: string;
        smtpPort: number;
        smtpUsername: string;
        smtpPassword: string;
        useTLS: boolean;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the nocrm_io integration
    class nocrm_io(TypedDict):
        api_key: str

    def main(nocrm_io_resource: nocrm_io, lead_id: str, new_status: str) -> bool:
        import requests  # Import here to avoid conflicts with the resource type name

        # Construct the API endpoint for updating a lead status
        api_endpoint = f"https://api.nocrm.io/v1/leads/{lead_id}/status"

        # Prepare the headers and payload for the API request
        headers = {
            "Authorization": f"Token {nocrm_io_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "status": new_status
        }

        # Make the API request to update the lead status
        response = requests.put(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful and return the result
        return response.status_code == 200

    # The main function is now ready to be exported and used with the nocrm_io integration.
  good: |-
    from typing import TypedDict

    # Define the resource type for the nocrm_io integration
    class nocrm_io(TypedDict):
        api_key: str

    def main(nocrm_io_resource: nocrm_io, lead_id: str, new_status: str) -> dict:
        import requests  # Import here to avoid conflicts with any parameter names

        # Construct the API endpoint for updating a lead's status
        endpoint = f"https://api.nocrm.io/v1/leads/{lead_id}"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Token {nocrm_io_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'status': new_status
        }

        # Make the API request to update the lead's status
        response = requests.patch(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated lead information
        else:
            # Handle the error case
            return {
                'error': 'Failed to update lead status',
                'status_code': response.status_code,
                'details': response.text
            }
  id: |-
    synthetic_update-lead-status
  instructions: |-
    Updates a lead status in nocrm io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nocrm_io
  resource_type_def: |-
    class nocrm_io(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the freshdesk integration
    class freshdesk(TypedDict):
        api_key: str
        domain: str

    def main(freshdesk_resource: freshdesk, page: int = 1, per_page: int = 30) -> List[Any]:
        # Construct the API endpoint
        endpoint = f"https://{freshdesk_resource['domain']}.freshdesk.com/api/v2/tickets"

        # Set up authentication and headers
        credentials = (freshdesk_resource['api_key'], "X")  # Password is 'X' as it's not needed with API key
        headers = {
            "Content-Type": "application/json"
        }

        # Set up pagination parameters
        params = {
            'page': page,
            'per_page': per_page
        }

        # Make the API request to list the tickets
        response = requests.get(endpoint, auth=credentials, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of tickets
            return response.json()
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {'error': response.json()}
  good: |-
    from typing import TypedDict, List, Optional
    import requests

    class freshdesk(TypedDict):
        api_key: str
        domain: str

    def main(freshdesk_resource: freshdesk,
             updated_since: Optional[str] = None,
             tags: Optional[List[str]] = None,
             requester_id: Optional[int] = None,
             company_id: Optional[int] = None,
             deleted: Optional[bool] = False):

        base_url = f"https://{freshdesk_resource['domain']}.freshdesk.com/api/v2/tickets"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {freshdesk_resource['api_key']}"
        }

        params = {
            "updated_since": updated_since,
            "tags": ",".join(tags) if tags else None,
            "requester_id": requester_id,
            "company_id": company_id,
            "deleted": "true" if deleted else "false"
        }

        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(base_url, headers=headers, params=params)
        response.raise_for_status()  # Raise an exception for HTTP errors

        return response.json()
  id: |-
    synthetic_list-all-tickets
  instructions: |-
    Use filters to view only specific tickets (those which match the criteria that you choose). By default, only tickets that have not been deleted or marked as spam will be returned, unless you use the 'deleted' filter. in freshdesk
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    freshdesk
  resource_type_def: |-
    class freshdesk(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { NangoIntegration } from "npm:nango";

    type Nango = {
        apiKey: string;
        // Add other properties relevant to Nango authentication/configuration
    }

    export async function main(nangoResource: Nango, integrationName: string, integrationConfig: object) {
        // Instantiate the Nango client with the provided API key
        const nangoClient = new NangoIntegration(nangoResource.apiKey);

        // Create a new integration in Nango using the provided name and configuration
        const result = await nangoClient.createIntegration(integrationName, integrationConfig);

        // Return the result of the integration creation
        return result;
    }
  good: |-
    import { NangoClient as NangoApiClient } from "npm:nango";

    type Nango = {
        apiKey: string;
    }

    export async function main(nangoResource: Nango, integrationName: string, integrationConfig: object) {
        const nangoClient = new NangoApiClient({ apiKey: nangoResource.apiKey });
        const result = await nangoClient.createIntegration(integrationName, integrationConfig);
        return result;
    }
  id: |-
    synthetic_create-integration
  instructions: |-
    Create a new Integration in nango
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Nango
  resource_type_def: |-
    type Nango = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, spaceName: string, isPrivate: boolean) {
        const url = 'https://api.clickup.com/api/v2/team/{team_id}/space';
        const headers = {
            'Authorization': clickupResource.apiKey,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            'name': spaceName,
            'private': isPrivate
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { Client } from "npm:@clickup/client"; // Importing Clickup client from npm

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, spaceName: string, teamId: string) {
        const client = new Client(clickupResource.apiKey);

        const result = await client.createSpace(teamId, {
            name: spaceName,
        });

        return result;
    }
  id: |-
    synthetic_create-space
  instructions: |-
    Creates a new space. See the docs in **Spaces / Create Space** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library to handle HTTP requests
    import { request } from "npm:@octokit/request";

    type Figma = {
        accessToken: string;
        fileId: string;
    }

    export async function main(figmaResource: Figma, nodeId: string, comment: string) {
        const result = await request('POST /v1/files/:file_key/comments', {
            headers: {
                'X-FIGMA-TOKEN': figmaResource.accessToken
            },
            file_key: figmaResource.fileId,
            node_id: nodeId,
            message: comment
        });

        return result;
    }
  good: |-
    import { FigmaClient } from "npm:@figma-js/client";

    type Figma = {
        accessToken: string;
    }

    export async function main(figmaResource: Figma, fileId: string, comment: string, frameId?: string) {
        const figma = FigmaClient({
            personalAccessToken: figmaResource.accessToken
        });

        const commentPayload = {
            message: comment,
            client_meta: frameId ? { node_id: frameId } : undefined
        };

        const result = await figma.postComment(fileId, commentPayload);

        return result;
    }
  id: |-
    synthetic_post-a-comment
  instructions: |-
    Posts a comment to a file in figma
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Figma
  resource_type_def: |-
    type Figma = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the 'fibery' integration
    class fibery(TypedDict):
        api_token: str
        workspace_name: str

    # Define the main function for listing fields of a specific entity type in Fibery
    def main(fibery_resource: fibery, entity_type_name: str) -> List[str]:
        import requests  # Import requests or another HTTP library if needed

        # Construct the API endpoint for listing fields
        api_url = f"https://{fibery_resource['workspace_name']}.fibery.io/api/fields"

        # Set up the headers with the API token for authentication
        headers = {
            "Authorization": f"Token {fibery_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Make the request to the Fibery API to get the fields for the specified entity type
        response = requests.get(api_url, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP error responses

        # Parse the response to get the fields for the specified entity type
        fields_data = response.json()
        entity_fields = [field['name'] for field in fields_data if field['type'] == entity_type_name]

        # Return the list of field names
        return entity_fields

    # The script ends here, with the main function defined and ready to be used.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the 'fibery' integration
    class fibery(TypedDict):
        api_token: str
        workspace_name: str

    # Import any libraries you need here
    import requests

    # Define the main function
    def main(fibery_resource: fibery, entity_type: str) -> List[str]:
        # Construct the API endpoint for listing fields of an entity type
        api_url = f"https://{fibery_resource['workspace_name']}.fibery.io/api/commands"
        headers = {
            "Authorization": f"Token {fibery_resource['api_token']}",
            "Content-Type": "application/json"
        }
        payload = {
            "command": "fibery.entity/query",
            "args": {
                "query": {
                    "q/from": entity_type,
                    "q/select": ["fibery/field"],
                    "q/limit": "q/no-limit"
                }
            }
        }

        # Make the API request
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP errors

        # Extract the field names from the response
        fields_data = response.json()
        field_names = [field['fibery/field'] for field in fields_data]

        # Return the list of field names
        return field_names

    # Note: The function does not call itself, it's ready to be exported and used with the appropriate parameters.
  id: |-
    synthetic_list-fields-for-entity-type
  instructions: |-
    Lists fields for an entity type in fibery
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    fibery
  resource_type_def: |-
    class fibery(TypedDict):
        api_token: str
        workspace_name: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the aero_workflow integration
    class aero_workflow(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for the Email Aero script
    def main(aero_workflow_resource: aero_workflow, recipient_email: str, email_subject: str, email_body: str):
        # Assuming that there is a library to send emails via Aero Workflow
        import aero_email_sender as aes

        # Use the aero_workflow resource to authenticate and send an email
        aes.configure(api_key=aero_workflow_resource['api_key'], base_url=aero_workflow_resource['base_url'])
        result = aes.send_email(to=recipient_email, subject=email_subject, body=email_body)

        # Return the result of the email sending operation
        return result

    # The script ends here, and the main function is ready to be used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the aero_workflow integration
    class aero_workflow(TypedDict):
        api_key: str
        workflow_id: str

    # Define the main function for creating an email aero in the aero workflow
    def main(aero_workflow_resource: aero_workflow, email_subject: str, email_body: str, recipient_email: str):
        # Import the necessary library for making HTTP requests
        import requests

        # Define the endpoint for creating an email aero
        create_email_aero_endpoint = f"https://api.aeroworkflow.com/workflows/{aero_workflow_resource['workflow_id']}/aeros"

        # Prepare the headers for the API request
        headers = {
            "Authorization": f"Bearer {aero_workflow_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload for the API request
        payload = {
            "type": "email",
            "subject": email_subject,
            "body": email_body,
            "recipient": recipient_email
        }

        # Make the API request to create the email aero
        response = requests.post(create_email_aero_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created email aero details
        else:
            raise Exception(f"Error creating email aero: {response.status_code} - {response.text}")

    # The main function is now defined and ready to be used with the specified parameters.
  id: |-
    synthetic_create-email-aero
  instructions: |-
    Creates an email aero in aero workflow
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aero_workflow
  resource_type_def: |-
    class aero_workflow(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { format } from "npm:date-fns-tz";

    type HelperFunctions = {
        timezone: string; // The target timezone for the current time
    }

    export async function main(helperFunctionsResource: HelperFunctions) {
        // Get the current time in the target timezone
        const currentTime = new Date();
        const timezoneFormattedTime = format(currentTime, "yyyy-MM-dd'T'HH:mm:ssXXX", { timeZone: helperFunctionsResource.timezone });

        // Return the timezone formatted time
        return timezoneFormattedTime;
    }
  good: |-
    // Import necessary libraries
    import { format } from "npm:date-fns-tz";

    type HelperFunctions = {
        // Properties needed for authentication/configuration
    }

    export async function main(helperFunctionsResource: HelperFunctions, timezone: string, dateFormat: string = "yyyy-MM-dd'T'HH:mm:ssXXX") {
        // Get the current date-time in the specified timezone
        const currentTime = format(new Date(), dateFormat, { timeZone: timezone });

        // Return the current time
        return currentTime;
    }
  id: |-
    synthetic_get-current-time-in-specific-timezone
  instructions: |-
    Returns the current time, tied to this workflow invocation, in the target timezone in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        // Properties needed for authentication/configuration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import googleapiclient.discovery

    # Define the resource type for the google_calendar integration
    class google_calendar(TypedDict):
        api_key: str
        access_token: str

    def main(google_calendar_resource: google_calendar, event_id: str, summary: Optional[str] = None, location: Optional[str] = None, description: Optional[str] = None, start_time: Optional[str] = None, end_time: Optional[str] = None):
        # Create a service object for the Google Calendar API
        service = googleapiclient.discovery.build('calendar', 'v3', developerKey=google_calendar_resource['api_key'])

        # Create the event update body
        event_update_body = {}
        if summary:
            event_update_body['summary'] = summary
        if location:
            event_update_body['location'] = location
        if description:
            event_update_body['description'] = description
        if start_time:
            event_update_body['start'] = {'dateTime': start_time}
        if end_time:
            event_update_body['end'] = {'dateTime': end_time}

        # Update the event
        updated_event = service.events().update(calendarId='primary', eventId=event_id, body=event_update_body).execute()

        # Return the updated event
        return updated_event
  good: |-
    from typing import TypedDict
    import googleapiclient.discovery

    class google_calendar(TypedDict):
        api_key: str
        calendar_id: str

    def main(google_calendar_resource: google_calendar, event_id: str, updated_event_data: dict):
        service = googleapiclient.discovery.build('calendar', 'v3', developerKey=google_calendar_resource['api_key'])
        event = service.events().update(calendarId=google_calendar_resource['calendar_id'], eventId=event_id, body=updated_event_data).execute()
        return event
  id: |-
    synthetic_update-event
  instructions: |-
    Update an event from Google Calendar in google calendar
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_calendar
  resource_type_def: |-
    class google_calendar(TypedDict):
        api_key: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { createApi } from "npm:@generatedphotos/api";

    type GeneratedPhotos = {
        apiKey: string;
    }

    export async function main(generatedPhotosResource: GeneratedPhotos, imageUrl: string, numberOfFaces: number) {
        // Initialize the Generated Photos API client
        const api = createApi(generatedPhotosResource.apiKey);

        // Call the API to generate faces similar to the provided image URL
        const response = await api.generateFaces({
            template: imageUrl,
            quantity: numberOfFaces
        });

        // Return the result which should be an array of generated face URLs
        return response;
    }
  good: |-
    // Importing necessary libraries
    import { createApi } from "npm:@generated-photos/api";

    type GeneratedPhotos = {
        apiKey: string;
    }

    export async function main(generatedPhotosResource: GeneratedPhotos, imageUrl: string, numberOfSimilarFaces: number) {
        const api = createApi({ apiKey: generatedPhotosResource.apiKey });

        try {
            const response = await api.generateSimilarPhotos({
                url: imageUrl,
                numResults: numberOfSimilarFaces
            });

            return response;
        } catch (error) {
            console.error('Error generating similar faces:', error);
            throw error;
        }
    }
  id: |-
    synthetic_generate-similar-faces-by-url
  instructions: |-
    Generates faces similar to an image URL with the Generated Photos API in generated photos
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GeneratedPhotos
  resource_type_def: |-
    type GeneratedPhotos = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { GetemailsClient } from "npm:getemails-api-client";

    type Getemails = {
        apiKey: string;
    }

    export async function main(getemailsResource: Getemails, emailAddress: string) {
        const client = new GetemailsClient(getemailsResource.apiKey);
        const status = await client.findEmailStatus(emailAddress);
        return status;
    }
  good: |-
    // Import any libraries you need here

    type Getemails = {
        apiKey: string;
    }

    export async function main(getemailsResource: Getemails, requestId: string) {
        const url = `https://api.getemails.com/api/v1/emailfindstatus/${requestId}`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getemailsResource.apiKey}`
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_status-find-email
  instructions: |-
    Use this Api when you want to know the status of any previous find-email Api request. in getemails
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Getemails
  resource_type_def: |-
    type Getemails = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { CalComBooking } from "npm:@calcom/sdk"; // Assuming @calcom/sdk is the npm package for CalCom

    type CalCom = {
        apiKey: string;
        // Add any other properties needed for CalCom integration
    }

    export async function main(calComResource: CalCom, bookingId: string) {
        // Initialize the CalCom client with the provided API key
        const calComClient = new CalComBooking(calComResource.apiKey);

        // Retrieve the booking by its ID
        const booking = await calComClient.getBooking(bookingId);

        // Always return the result
        return booking;
    }
  good: |-
    // Import any libraries you might need here
    import { CalComClient } from "npm:calcom";

    type CalCom = {
        apiKey: string;
        calendarId: string;
    }

    export async function main(calComResource: CalCom, bookingId: string) {
        const client = new CalComClient(calComResource.apiKey);
        const booking = await client.getBooking(calComResource.calendarId, bookingId);

        return booking;
    }
  id: |-
    synthetic_get-booking
  instructions: |-
    Retrieve a booking by its ID in cal com
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CalCom
  resource_type_def: |-
    type CalCom = {
        apiKey: string;
        calendarId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Deepgram as DeepgramSDK } from "npm:@deepgram/sdk";

    type Deepgram = {
        apiKey: string;
    }

    export async function main(deepgramResource: Deepgram) {
        const deepgram = new DeepgramSDK(deepgramResource.apiKey);
        try {
            const response = await deepgram.projects.list();
            return response;
        } catch (error) {
            console.error('Error listing Deepgram projects:', error);
            throw error;
        }
    }
  good: |-
    import { Deepgram } from "npm:@deepgram/sdk";

    type DeepgramResource = {
        apiKey: string;
    }

    export async function main(deepgramResource: DeepgramResource, projectId: string) {
        const deepgram = new Deepgram(deepgramResource.apiKey);
        const projectInfo = await deepgram.projects.get(projectId);
        return projectInfo;
    }
  id: |-
    synthetic_list-projects
  instructions: |-
    Retrieves basic information about the specified project in deepgram
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Deepgram
  resource_type_def: |-
    type Deepgram = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the CompanyCam integration
    class companycam(TypedDict):
        api_key: str  # Assuming API key is needed for authentication

    # Import any additional libraries you might need here
    # If any imports conflict with 'companycam', rename the imported method
    # Example: from some_library import some_method as some_method_renamed

    def main(companycam_resource: companycam, project_name: str, project_description: str = '', additional_info: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Add a new project in CompanyCam.

        :param companycam_resource: A dictionary containing the API key for CompanyCam authentication.
        :param project_name: The name of the new project.
        :param project_description: An optional description of the new project.
        :param additional_info: An optional dictionary with additional project information.
        :return: A dictionary with the result of the project creation operation.
        """
        # Here you would implement the logic to add a new project to CompanyCam
        # using the provided credentials and parameters.
        # This might involve setting up an API client, making a POST request, etc.

        # Example (pseudo-code):
        # api_client = CompanyCamAPIClient(api_key=companycam_resource['api_key'])
        # result = api_client.create_project(name=project_name, description=project_description, additional_info=additional_info)

        # For the purpose of this template, we'll return a mock result
        result = {
            'success': True,
            'message': 'Project created successfully',
            'project_id': '12345',  # This would be the actual project ID returned by the API
        }

        return result

    # Note: The actual implementation details would depend on the CompanyCam API documentation.
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'companycam' integration
    class companycam(TypedDict):
        api_key: str  # Assuming API key is used for authentication

    # Main function to add a project to CompanyCam
    def main(companycam_resource: companycam, project_name: str, project_address: str):
        import requests  # Import here to avoid conflicts with parameter names

        # Endpoint for creating a project in CompanyCam
        create_project_url = "https://api.companycam.com/projects"

        # Headers to authenticate the request
        headers = {
            "Authorization": f"Bearer {companycam_resource['api_key']}"
        }

        # Data payload for creating a new project
        data = {
            "name": project_name,
            "address": project_address
        }

        # Make the request to create a new project
        response = requests.post(create_project_url, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created project details
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {"error": response.text, "status_code": response.status_code}
  id: |-
    synthetic_add-project
  instructions: |-
    Add a new project. in companycam
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    companycam
  resource_type_def: |-
    class companycam(TypedDict):
        api_key: str  # Assuming API key is used for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        accessToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileName: string, templateFileId: string, folderId?: string) {
        const drive = google.drive({ version: 'v3', auth: googleDriveResource.accessToken });
        const copyTitle = fileName;
        const requestBody = {
            name: copyTitle,
            parents: folderId ? [folderId] : [],
        };

        try {
            const response = await drive.files.copy({
                fileId: templateFileId,
                requestBody,
                fields: 'id',
            });

            const fileCopyId = response.data.id;
            return { success: true, fileCopyId };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(
        googleDriveResource: GoogleDrive,
        templateFileId: string,
        newFileName: string,
        placeholders?: Record<string, string>
    ) {
        const { apiKey, accessToken } = googleDriveResource;
        const drive = google.drive({ version: 'v3', auth: apiKey });

        // Copy the template file
        const copyResponse = await drive.files.copy({
            fileId: templateFileId,
            requestBody: {
                name: newFileName,
            },
            fields: 'id',
        });

        const newFileId = copyResponse.data.id;

        if (!newFileId) {
            throw new Error('Failed to create a copy of the template.');
        }

        // If placeholders are provided, replace them in the new document
        if (placeholders) {
            const docs = google.docs({ version: 'v1', auth: accessToken });
            const batchUpdateRequest: drive_v3.Params$Resource$Documents$Batchupdate = {
                documentId: newFileId,
                requestBody: {
                    requests: Object.entries(placeholders).map(([key, value]) => ({
                        replaceAllText: {
                            containsText: {
                                text: `{{${key}}}`,
                                matchCase: true,
                            },
                            replaceText: value,
                        },
                    })),
                },
            };

            await docs.documents.batchUpdate(batchUpdateRequest);
        }

        return {
            newFileId,
            newFileName,
            placeholdersReplaced: !!placeholders,
        };
    }
  id: |-
    synthetic_create-file-from-template
  instructions: |-
    Create a new Google Docs file from a template. Optionally include placeholders in the template document that will get replaced from this action in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the bloom_growth integration
    class bloom_growth(TypedDict):
        api_key: str
        api_secret: str

    def main(bloom_growth_resource: bloom_growth, task_title: str, task_description: str, due_date: str):
        # Assuming there's a library to interact with the bloom_growth API
        from bloom_growth_api import create_task as create_bloom_task

        # Create a new task using the bloom_growth API
        new_task = create_bloom_task(
            api_key=bloom_growth_resource['api_key'],
            api_secret=bloom_growth_resource['api_secret'],
            title=task_title,
            description=task_description,
            due_date=due_date
        )

        # Return the result of the task creation
        return new_task
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the bloom_growth integration
    class bloom_growth(TypedDict):
        api_key: str
        api_secret: str

    # Import any additional libraries you might need
    import requests

    # Define the main function with the resource type and any additional parameters
    def main(bloom_growth_resource: bloom_growth, meeting_title: str, meeting_date: str, meeting_time: str, attendees: list[str], notes: str) -> Any:
        # Construct the API endpoint URL
        api_url = "https://api.bloomgrowth.com/meetings"

        # Prepare the headers with the necessary authentication details
        headers = {
            "Authorization": f"Bearer {bloom_growth_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the meeting details
        payload = {
            "title": meeting_title,
            "date": meeting_date,
            "time": meeting_time,
            "attendees": attendees,
            "notes": notes
        }

        # Make a POST request to create a new meeting to-do
        response = requests.post(api_url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created meeting to-do details
        else:
            raise Exception(f"Error creating meeting to-do: {response.status_code} - {response.text}")

    # Example usage:
    # result = main(bloom_growth_resource={'api_key': 'your_api_key', 'api_secret': 'your_api_secret'}, meeting_title='Weekly Sync', meeting_date='2023-04-10', meeting_time='10:00', attendees=['alice@example.com', 'bob@example.com'], notes='Discuss weekly progress')
    # print(result)
  id: |-
    synthetic_create-to-do
  instructions: |-
    Create a new meeting to-do in bloom growth
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bloom_growth
  resource_type_def: |-
    class bloom_growth(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here

    type DataStores = {
        apiKey: string;
        storeId: string;
    }

    export async function main(dataStoresResource: DataStores, recordId: string): Promise<string[]> {
        const url = `https://api.datastores.com/stores/${dataStoresResource.storeId}/records/${recordId}/keys`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${dataStoresResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data.keys;
    }
  good: |-
    type DataStores = {
        apiKey: string;
        storeId: string;
    }

    export async function main(dataStoresResource: DataStores, query: string) {
        const baseUrl = `https://api.datastores.com/stores/${dataStoresResource.storeId}/records`;
        const headers = {
            'Authorization': `Bearer ${dataStoresResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(`${baseUrl}?query=${encodeURIComponent(query)}`, {
                method: 'GET',
                headers: headers
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const recordKeys = data.records.map((record: any) => record.key);
            return recordKeys;
        } catch (error) {
            console.error('Error fetching record keys:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-record-keys
  instructions: |-
    Get all record keys in your that mathces with your query. The memory consumption of the workflow can be affected, since this action will be exposing, to the workflow, the entire data from the selected datastore in data stores
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DataStores
  resource_type_def: |-
    type DataStores = {
        apiKey: string;
        storeId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { HttpClient } from "npm:@microsoft/microsoft-graph-client";

    type Microsofttodo = {
        accessToken: string;
    }

    export async function main(microsofttodoResource: Microsofttodo, taskId: string, taskTitle: string, taskContent?: string, dueDateTime?: string) {
        const client = HttpClient.init({
            authProvider: (done) => {
                done(null, microsofttodoResource.accessToken);
            }
        });

        const taskDetails = {
            title: taskTitle,
            ...(taskContent && { body: { content: taskContent, contentType: "text" } }),
            ...(dueDateTime && { dueDateTime: { dateTime: dueDateTime, timeZone: "UTC" } })
        };

        try {
            const result = await client.api(`/me/todo/lists/tasks/${taskId}`)
                .header("Content-Type", "application/json")
                .patch(taskDetails);

            return result;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  good: |-
    // Importing necessary libraries
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Microsofttodo = {
        accessToken: string;
    }

    export async function main(microsofttodoResource: Microsofttodo, taskId: string, taskUpdates: { title?: string, dueDateTime?: string, importance?: string, status?: string }) {
        // Create a Microsoft Graph client
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsofttodoResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Define the endpoint for updating a task
        const endpoint = `/me/todo/lists/tasks/${taskId}`;

        // Prepare the update payload
        const updatePayload = {
            ...(taskUpdates.title && { title: taskUpdates.title }),
            ...(taskUpdates.dueDateTime && { dueDateTime: { dateTime: taskUpdates.dueDateTime, timeZone: "UTC" } }),
            ...(taskUpdates.importance && { importance: taskUpdates.importance }),
            ...(taskUpdates.status && { status: taskUpdates.status }),
        };

        // Update the task using the Microsoft Graph client
        const result = await client.api(endpoint).update(updatePayload);

        // Return the result of the update operation
        return result;
    }
  id: |-
    synthetic_update-task
  instructions: |-
    Updates an existing task in Microsoft To Do. in microsofttodo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Microsofttodo
  resource_type_def: |-
    type Microsofttodo = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests
    import time

    class bybit(TypedDict):
        api_key: str
        api_secret: str

    def main(bybit_resource: bybit, symbol: str, endpoint: str) -> dict:
        url = f"{endpoint}/v2/public/open-interest"
        params = {
            'api_key': bybit_resource['api_key'],
            'symbol': symbol,
            'timestamp': int(time.time() * 1000)
        }
        params['sign'] = generate_signature(bybit_resource['api_secret'], params)

        response = requests.get(url, params=params)
        return response.json()

    def generate_signature(secret: str, params: dict) -> str:
        return 'signature_placeholder'
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the bybit API

    class bybit(TypedDict):
        api_key: str
        api_secret: str

    def main(bybit_resource: bybit):
        # Assuming the endpoint for getting unsettled contracts is something like '/open-contracts'
        # and that it requires API key and secret for authentication.
        # The actual endpoint and method of authentication may differ.

        url = "https://api.bybit.com/v2/private/position/list"
        headers = {
            "Content-Type": "application/json",
            "api-key": bybit_resource['api_key'],
            "api-signature": bybit_resource['api_secret']
        }

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        contracts_data = response.json()

        # Assuming the response contains a list of contracts under a key 'result'
        # and each contract has a 'size' field indicating the number of contracts.
        total_unsettled_contracts = sum(contract['size'] for contract in contracts_data['result'])

        return total_unsettled_contracts
  id: |-
    synthetic_generic-market-open-interest
  instructions: |-
    Gets the total amount of unsettled contracts. In other words, the total number of contracts held  in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the 'kanban_tool' integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str

    # Define the main function that will be exported
    def main(kanban_tool_resource: kanban_tool, task_id: str) -> Dict[str, Any]:
        # Import the requests library, rename it if it conflicts with 'requests' from the resource type
        import requests as http_requests

        # Construct the API endpoint for getting task details
        api_endpoint = f"https://kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}"

        # Prepare the headers with the API key for authentication
        headers = {
            'X-KanbanToolToken': kanban_tool_resource['api_key']
        }

        # Make the GET request to the Kanban Tool API to get the task details
        response = http_requests.get(api_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the task details as a dictionary
            return response.json()
        else:
            # If the request failed, raise an exception with the status code and error message
            response.raise_for_status()

    # The main function is now defined and can be used with the required 'kanban_tool' resource type
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed to make API calls to Kanban Tool

    class kanban_tool(TypedDict):
        api_key: str
        domain: str
        board_id: str

    def main(kanban_tool_resource: kanban_tool, task_id: str) -> Dict[str, Any]:
        base_url = f"https://{kanban_tool_resource['domain']}.kanbantool.com"
        api_endpoint = f"/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}.json"
        headers = {
            "X-KanbanToolToken": kanban_tool_resource['api_key']
        }

        response = requests.get(base_url + api_endpoint, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        return response.json()
  id: |-
    synthetic_get-task-details
  instructions: |-
    Gets details of a selected task in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type LoopReturns = {
        apiKey: string;
        storeDomain: string;
    }

    export async function main(loopReturnsResource: LoopReturns, returnId: string) {
        const url = `https://${loopReturnsResource.storeDomain}/api/v1/returns/${returnId}/process`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${loopReturnsResource.apiKey}`
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { LoopReturns as LoopReturnsSDK } from "npm:@loopreturns/sdk";

    type LoopReturns = {
        apiKey: string,
        apiSecret: string,
    }

    export async function main(loopReturnsConfig: LoopReturns, orderId: string, reason: string, notes?: string) {
        const loopReturns = new LoopReturnsSDK(loopReturnsConfig.apiKey, loopReturnsConfig.apiSecret);

        const result = await loopReturns.processReturn(orderId, reason, notes);

        return result;
    }
  id: |-
    synthetic_process-return
  instructions: |-
    Starts the processing of a return inside Loop. Return ID is a required prop to initiate the process in loop returns
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    LoopReturns
  resource_type_def: |-
    type LoopReturns = {
        apiKey: string,
        apiSecret: string,
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Logging } from "npm:@google-cloud/logging";

    type GoogleCloud = {
        projectId: string,
        clientEmail: string,
        privateKey: string
    }

    export async function main(googleCloudResource: GoogleCloud, logName: string, logEntryData: any, logSeverity: 'DEFAULT' | 'DEBUG' | 'INFO' | 'NOTICE' | 'WARNING' | 'ERROR' | 'CRITICAL' | 'ALERT' | 'EMERGENCY' = 'DEFAULT') {
        const logging = new Logging({
            projectId: googleCloudResource.projectId,
            credentials: {
                client_email: googleCloudResource.clientEmail,
                private_key: googleCloudResource.privateKey.replace(/\\n/g, '\n')
            }
        });

        const log = logging.log(logName);
        const metadata = {
            resource: { type: 'global' },
            severity: logSeverity,
        };
        const entry = log.entry(metadata, logEntryData);

        await log.write(entry);
    }
  good: |-
    import { Logging } from "npm:@google-cloud/logging";

    type GoogleCloud = {
        projectId: string;
        credentials: {
            client_email: string;
            private_key: string;
        };
    }

    export async function main(googleCloudResource: GoogleCloud, logName: string, logEntryData: any, severity: 'DEFAULT' | 'DEBUG' | 'INFO' | 'NOTICE' | 'WARNING' | 'ERROR' | 'CRITICAL' | 'ALERT' | 'EMERGENCY' = 'DEFAULT') {
        const logging = new Logging({
            projectId: googleCloudResource.projectId,
            credentials: googleCloudResource.credentials,
        });

        const log = logging.log(logName);
        const metadata = {
            resource: { type: 'global' },
            severity: severity,
        };
        const entry = log.entry(metadata, logEntryData);

        await log.write(entry);
        return { result: 'Log entry created successfully.' };
    }
  id: |-
    synthetic_logging-write-log
  instructions: |-
    Writes log data to the Logging service, in google cloud
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleCloud
  resource_type_def: |-
    type GoogleCloud = {
        projectId: string;
        credentials: {
            client_email: string;
            private_key: string;
        };
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to the Outlook Calendar API

    class microsoft_outlook_calendar(TypedDict):
        access_token: str
        api_endpoint: str

    def main(microsoft_outlook_calendar_resource: microsoft_outlook_calendar, event_id: str,
             updated_title: Optional[str] = None, updated_start_time: Optional[str] = None,
             updated_end_time: Optional[str] = None, updated_description: Optional[str] = None):
        headers = {
            'Authorization': f"Bearer {microsoft_outlook_calendar_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        update_payload = {}
        if updated_title is not None:
            update_payload['subject'] = updated_title
        if updated_start_time is not None:
            update_payload['start'] = {'dateTime': updated_start_time, 'timeZone': 'UTC'}
        if updated_end_time is not_none:
            update_payload['end'] = {'dateTime': updated_end_time, 'timeZone': 'UTC'}
        if updated_description is not None:
            update_payload['body'] = {'contentType': 'HTML', 'content': updated_description}

        response = requests.patch(
            f"{microsoft_outlook_calendar_resource['api_endpoint']}/me/events/{event_id}",
            headers=headers,
            json=update_payload
        )

        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the microsoft_outlook_calendar integration
    class microsoft_outlook_calendar(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the resource type and additional parameters
    def main(outlook_calendar_resource: microsoft_outlook_calendar, event_id: str, updated_event_details: dict):
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f'Bearer {outlook_calendar_resource["access_token"]}',
            'Content-Type': 'application/json'
        }

        # Define the API endpoint for updating a calendar event
        update_event_endpoint = f'https://graph.microsoft.com/v1.0/me/events/{event_id}'

        # Make the API request to update the event
        response = requests.patch(update_event_endpoint, headers=headers, json=updated_event_details)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated event details
        else:
            response.raise_for_status()  # Raise an exception if there was an error
  id: |-
    synthetic_update-calendar-event
  instructions: |-
    Update an event in the user's default calendar in microsoft outlook calendar
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_outlook_calendar
  resource_type_def: |-
    class microsoft_outlook_calendar(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const endpoint = `https://api.bybit.com/v2/public/funding/prev-funding-rate?symbol=${symbol}`;
        const response = await fetch(endpoint);
        const data = await response.json();

        if (!response.ok) {
            throw new Error(`Error fetching funding rate: ${data.ret_msg}`);
        }

        return data.result;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string) {
        const url = `${bybitResource.endpoint}/v2/public/funding/prev-funding-rate?symbol=${symbol}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching previous funding rate:', error);
            throw error;
        }
    }
  id: |-
    synthetic_linear-market-previous-funding-rate
  instructions: |-
    The funding rate is generated every 8 hours at 00:00 UTC, 08:00 UTC and 16:00 UTC. For example, in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to Jira API

    # Define the resource type for the jira integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, issue_key: str, attachment_paths: List[str]):
        headers = {
            "Authorization": f"Basic {jira_resource['username']}:{jira_resource['api_token']}",
            "X-Atlassian-Token": "no-check"
        }

        # URL for the Jira API endpoint to add attachments to an issue
        url = f"{jira_resource['base_url']}/rest/api/2/issue/{issue_key}/attachments"

        # Prepare the list of files to be uploaded
        files = [('file', (open(attachment_path, 'rb'))) for attachment_path in attachment_paths]

        # Make the request to add attachments
        response = requests.post(url, headers=headers, files=files)

        # Close all the files that were opened
        for _, file_handle in files:
            file_handle.close()

        # Return the response from the Jira API
        return response.json()
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to JIRA API

    # Define the resource type for the JIRA integration
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    # Define the function to add multiple attachments to a JIRA issue
    def main(jira_resource: jira, issue_key: str, attachment_paths: List[str], project_key: str):
        # Prepare the headers for authentication
        headers = {
            'Authorization': f'Basic {jira_resource["username"]}:{jira_resource["api_token"]}',
            'X-Atlassian-Token': 'no-check'
        }

        # Prepare the URL for the JIRA API endpoint to add attachments
        url = f'{jira_resource["base_url"]}/rest/api/2/issue/{issue_key}/attachments'

        # Prepare the list of files to be uploaded
        files = [('file', (open(path, 'rb'))) for path in attachment_paths]

        # Make the request to add attachments
        response = requests.post(url, headers=headers, files=files)

        # Check for successful response and return accordingly
        if response.status_code == 200:
            return response.json()  # Return the response from JIRA API
        else:
            raise Exception(f'Failed to add attachments: {response.content}')

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_add-multiple-attachments-to-issue
  instructions: |-
    Adds multiple attachments to an issue, in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the LinkedIn resource and additional parameters
    def main(linkedin_resource: linkedin, post_id: str, comment_id: str, count: int = 10, start: int = 0) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Endpoint to retrieve comments on a comment for a LinkedIn post
        url = f"https://api.linkedin.com/v2/socialActions/{post_id}/comments/{comment_id}/comments"

        # Prepare the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {linkedin_resource['access_token']}"
        }

        # Prepare the parameters for the request
        params = {
            "count": count,
            "start": start
        }

        # Make the request to LinkedIn API
        response = requests.get(url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response to JSON and return the comments
            return response.json().get('elements', [])
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function does not call itself, it's ready to be exported and used with the appropriate parameters.
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the linkedin integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the resource type and any additional parameters
    def main(linkedin_resource: linkedin, parent_comment_urn: str) -> List[Dict]:
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}"
        }

        # LinkedIn API endpoint to retrieve comments on a comment
        url = f"https://api.linkedin.com/v2/socialActions/{parent_comment_urn}/comments"

        # Make the HTTP GET request to LinkedIn API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON to get the comments data
            comments_data = response.json().get('elements', [])
            return comments_data
        else:
            # Handle error responses
            response.raise_for_status()

    # Example usage:
    # result = main(linkedin_resource={'access_token': 'your-access-token'}, parent_comment_urn='urn:li:comment:(activity:1234567890123456789,1234567890123456)')
    # print(result)
  id: |-
    synthetic_retrieve-comments-on-comments
  instructions: |-
    Retrieves comments on comments, given the parent comment urn in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AmaraCredentials } from "npm:@types/amara"; // Hypothetical npm package for Amara types

    type Amara = {
        apiKey: string;
    }

    export async function main(amaraResource: Amara, videoId: string, languageCode: string, team: string) {
        const apiUrl = `https://amara.org/api/videos/${videoId}/languages/${languageCode}/subtitles/`;

        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'X-api-key': amaraResource.apiKey,
                'X-api-username': team
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const subtitlesData = await response.json();
        return subtitlesData;
    }
  good: |-
    // Importing necessary libraries
    import { Amara } from "npm:@types/amara-api"; // Assuming there's a type definition for Amara API

    // Define the resource type for the Amara integration
    type AmaraResource = {
        apiKey: string;
    }

    // Define the main function to fetch subtitles data from Amara
    export async function main(amaraResource: AmaraResource, videoId: string, languageCode: string) {
        // Construct the API endpoint to fetch subtitles
        const subtitlesEndpoint = `https://amara.org/api/videos/${videoId}/languages/${languageCode}/subtitles/`;

        // Set up the headers for the API request
        const headers = {
            'X-api-key': amaraResource.apiKey,
            'Content-Type': 'application/json'
        };

        // Perform the fetch request to get subtitles data
        try {
            const response = await fetch(subtitlesEndpoint, { headers: headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const subtitlesData = await response.json();

            // Return the subtitles data
            return subtitlesData;
        } catch (error) {
            console.error("Failed to fetch subtitles data from Amara:", error);
            throw error;
        }
    }
  id: |-
    synthetic_fetch-subtitles-data
  instructions: |-
    Fetch subtitles data in amara
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amara
  resource_type_def: |-
    type Amara = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:querystring";

    type Klaviyo = {
        apiKey: string;
    }

    export async function main(klaviyoResource: Klaviyo, listId: string, email: string, properties?: Record<string, any>) {
        const endpoint = `https://a.klaviyo.com/api/v2/list/${listId}/members`;
        const body = {
            api_key: klaviyoResource.apiKey,
            profiles: JSON.stringify([
                {
                    email: email,
                    ...(properties || {})
                }
            ])
        };
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: encode(body)
        });

        if (!response.ok) {
            throw new Error(`Failed to add member to Klaviyo list: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { KlaviyoClient } from "npm:@klaviyo/client";

    type Klaviyo = {
        apiKey: string;
    }

    export async function main(klaviyoResource: Klaviyo, listId: string, email: string, properties?: Record<string, any>) {
        const klaviyoClient = new KlaviyoClient({ api_key: klaviyoResource.apiKey });

        const memberData = {
            email: email,
            properties: properties || {}
        };

        try {
            const response = await klaviyoClient.lists.addMembersToList({
                listId: listId,
                profiles: [memberData]
            });
            return response;
        } catch (error) {
            console.error('Failed to add member to list:', error);
            throw error;
        }
    }
  id: |-
    synthetic_add-member-to-list
  instructions: |-
    Add member to a specific list in klaviyo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Klaviyo
  resource_type_def: |-
    type Klaviyo = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign, email: str, first_name: str, last_name: str, phone: str = '', tags: str = ''):
        url = f"{activecampaign_resource['api_url']}/api/3/contacts"
        headers = {
            'Api-Token': activecampaign_resource['api_key'],
            'Content-Type': 'application/json'
        }
        data = {
            'contact': {
                'email': email,
                'firstName': first_name,
                'lastName': last_name,
                'phone': phone,
                'tags': tags
            }
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'activecampaign' integration
    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    # Define the main function for creating an account in ActiveCampaign
    def main(activecampaign_resource: activecampaign, email: str, first_name: str, last_name: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a contact
        endpoint = f"{activecampaign_resource['api_url'].rstrip('/')}/api/3/contacts"

        # Prepare the data for the new contact
        data = {
            "contact": {
                "email": email,
                "firstName": first_name,
                "lastName": last_name
            }
        }

        # Prepare the headers for the API request
        headers = {
            "Api-Token": activecampaign_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Make the API request to create a new contact
        response = requests.post(endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return {"success": True, "contact": response.json()}
        else:
            return {"success": False, "error": response.text}
  id: |-
    synthetic_create-account
  instructions: |-
    Create a new account. See the docs. in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Lemlist = {
        apiKey: string;
    }

    export async function main(lemlistResource: Lemlist, apiUrl: string, leadEmail: string, interestedStatus: boolean) {
        const authHeader = `Basic ${encode(lemlistResource.apiKey)}`;
        const endpoint = `${apiUrl}/leads`;

        try {
            const response = await fetch(endpoint, {
                method: 'GET',
                headers: {
                    'Authorization': authHeader,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const leads = await response.json();
            const lead = leads.find((l: any) => l.email === leadEmail);

            if (!lead) {
                throw new Error(`Lead with email ${leadEmail} not found.`);
            }

            const updateResponse = await fetch(`${endpoint}/${lead._id}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': authHeader,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    interested: interestedStatus
                })
            });

            if (!updateResponse.ok) {
                throw new Error(`HTTP error! status: ${updateResponse.status}`);
            }

            const updatedLead = await updateResponse.json();
            return updatedLead;
        } catch (error) {
            console.error('There was an error!', error);
        }
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type Lemlist = {
        apiKey: string;
    }

    export async function main(lemlistResource: Lemlist, leadEmail: string) {
        const baseUrl = 'https://api.lemlist.com/api/campaigns';

        // Fetch all campaigns
        const campaignsResponse = await fetch(`${baseUrl}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${lemlistResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!campaignsResponse.ok) {
            throw new Error(`Error fetching campaigns: ${campaignsResponse.statusText}`);
        }

        const campaigns = await campaignsResponse.json();

        // Iterate over campaigns and mark the lead as interested
        for (const campaign of campaigns) {
            const markAsInterestedResponse = await fetch(`${baseUrl}/${campaign._id}/leads/interest`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${lemlistResource.apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ email: leadEmail })
            });

            if (!markAsInterestedResponse.ok) {
                throw new Error(`Error marking lead as interested in campaign ${campaign._id}: ${markAsInterestedResponse.statusText}`);
            }
        }

        // Return a success message
        return `Lead with email ${leadEmail} marked as interested in all campaigns.`;
    }
  id: |-
    synthetic_mark-lead-from-all-campaigns-as-interested
  instructions: |-
    This action marks a specific lead as interested using its email in all campaigns in lemlist
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Lemlist
  resource_type_def: |-
    type Lemlist = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to the Mailchimp API

    # Define the resource type for the mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # The Mailchimp API endpoint prefix, e.g., 'us1', 'us2', etc.

    def main(mailchimp_resource: mailchimp, campaign_id: str, audience_list_ids: List[str]) -> dict:
        """
        Sends a campaign draft to the audience signed up for the campaign in Mailchimp.

        :param mailchimp_resource: A dictionary containing the Mailchimp API key and server prefix.
        :param campaign_id: The unique identifier for the campaign draft to be sent.
        :param audience_list_ids: A list of audience list IDs to which the campaign will be sent.
        :return: A dictionary containing the API response.
        """
        # Construct the base URL for the Mailchimp API
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"

        # Set up the headers for the HTTP request
        headers = {
            'Authorization': f"Bearer {mailchimp_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Send the campaign to each audience list
        for list_id in audience_list_ids:
            # Construct the URL for sending the campaign to the current list
            send_url = f"{base_url}/campaigns/{campaign_id}/actions/send"

            # Make the POST request to send the campaign
            response = requests.post(send_url, headers=headers)

            # Check if the request was successful
            if response.status_code != 204:
                # If not successful, return the error response
                return {
                    'status': 'error',
                    'message': 'Failed to send campaign',
                    'details': response.json()
                }

        # If all requests were successful, return a success response
        return {
            'status': 'success',
            'message': 'Campaign sent to all specified audience lists'
        }

    # Note: The function is not called here, it is only defined and ready to be exported.
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    # Define the resource type for the Mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # The Mailchimp API endpoint prefix, e.g., 'us6'

    def main(mailchimp_resource: mailchimp, campaign_id: str, to_send: bool):
        """
        Send a campaign using the Mailchimp API.

        :param mailchimp_resource: A dictionary containing the 'api_key' and 'server_prefix' for Mailchimp.
        :param campaign_id: The unique id for the campaign to send.
        :param to_send: A boolean indicating whether to send the campaign immediately.
        :return: The response from the Mailchimp API.
        """
        # Construct the API endpoint for sending a campaign
        api_endpoint = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/send"

        # Set up the headers for authorization
        headers = {
            'Authorization': f'Bearer {mailchimp_resource['api_key']}'
        }

        # Send the campaign based on the to_send parameter
        if to_send:
            response = requests.post(api_endpoint, headers=headers)
            return response.json()
        else:
            return {'message': 'Campaign not sent, to_send parameter is set to False.'}
  id: |-
    synthetic_send-campaign
  instructions: |-
    Sends a campaign draft to the audience signed up for the campaign in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # The Mailchimp API endpoint prefix, e.g., 'us6'
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the required npm library for Mastodon API
    import MastodonAPI from "npm:@mastodon/api";

    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodon: Mastodon, statusId: string) {
        const client = new MastodonAPI({
            access_token: mastodon.accessToken,
            timeout_ms: 60 * 1000,  // 60sec
            api_url: mastodon.apiUrl
        });

        const endpoint = `/api/v1/statuses/${statusId}/unpin`;
        const response = await client.post(endpoint);

        return response.data;
    }
  good: |-
    // Importing necessary libraries
    import { Mastodon } from "npm:mastodon-api";

    type MastodonResource = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodonResource: MastodonResource, statusId: string) {
        const mastodonClient = new Mastodon({
            access_token: mastodonResource.accessToken,
            api_url: mastodonResource.apiUrl
        });

        const endpoint = `/api/v1/statuses/${statusId}/unpin`;

        try {
            const response = await mastodonClient.post(endpoint);
            return response.data;
        } catch (error) {
            console.error('Error unfeaturing status:', error);
            throw error;
        }
    }
  id: |-
    synthetic_unpin-status
  instructions: |-
    Unfeature a status from the top of your profile in mastodon
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mastodon
  resource_type_def: |-
    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'loopmessage' integration
    class loopmessage(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function to send a reaction using the 'loopmessage' integration
    def main(loopmessage_resource: loopmessage, message_id: str, reaction_type: str):
        # Import the necessary library for HTTP requests
        import requests

        # Define the endpoint for sending a reaction
        reaction_endpoint = "https://api.loopmessage.com/v1/messages/{}/reactions".format(message_id)

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": "Bearer {}".format(loopmessage_resource['api_key']),
            "X-API-Secret": loopmessage_resource['api_secret']
        }

        # Prepare the payload with the reaction type
        payload = {
            "type": reaction_type
        }

        # Send the POST request to the endpoint
        response = requests.post(reaction_endpoint, headers=headers, json=payload)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the 'loopmessage' integration
    class loopmessage(TypedDict):
        api_key: str
        api_secret: str
        # Add any other necessary authentication/configuration properties here

    # Define the main function for the 'loopmessage' integration
    def main(loopmessage_resource: loopmessage, recipient_id: str, message_content: str, reaction_type: str, max_attempts: int = 3) -> Dict[str, Any]:
        # Import any libraries needed for the integration
        import requests
        from time import sleep

        # Define the endpoint for submitting to the sending queue
        submit_endpoint = "https://api.loopmessage.com/submit"

        # Define the headers for authentication
        headers = {
            "Authorization": f"Bearer {loopmessage_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Define the payload for the request
        payload = {
            "recipient_id": recipient_id,
            "message_content": message_content,
            "reaction_type": reaction_type
        }

        # Initialize the result dictionary
        result = {
            "success": False,
            "attempts": 0,
            "response": None
        }

        # Attempt to send the message in a loop, up to max_attempts times
        for attempt in range(max_attempts):
            try:
                response = requests.post(submit_endpoint, json=payload, headers=headers)
                result['attempts'] += 1

                # Check if the request was successful
                if response.status_code == 200:
                    result['success'] = True
                    result['response'] = response.json()
                    break
                else:
                    # Log the error response
                    result['response'] = response.json()
            except requests.RequestException as e:
                # Log the exception
                result['response'] = str(e)

            # Wait before the next attempt
            sleep(1)

        # Return the result of the sending attempt
        return result

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_send-reaction
  instructions: |-
    Action to submit your request to the sending queue. When a request in the queue will be ready to send a reaction in iMessage, an attempt will be made to deliver it to the recipient in loopmessage
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    loopmessage
  resource_type_def: |-
    class loopmessage(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Drip = {
        accountId: string;
        apiToken: string;
    }

    export async function main(dripResource: Drip, email: string, newSubscriberProperties: Record<string, any>) {
        const endpoint = `https://api.getdrip.com/v2/${dripResource.accountId}/subscribers`;
        const authHeader = `Basic ${encode(`${dripResource.apiToken}:`)}`;

        const body = {
            subscribers: [
                {
                    email: email,
                    ...newSubscriberProperties
                }
            ]
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`Error creating/updating subscriber: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { DripClient } from "npm:drip-nodejs";

    type Drip = {
        accountId: string;
        accessToken: string;
    }

    export async function main(dripResource: Drip, subscriberEmail: string, customFields: Record<string, any>, tags: string[] = [], newEmail?: string) {
        const dripClient = new DripClient({
            accountId: dripResource.accountId,
            accessToken: dripResource.accessToken,
        });

        const subscriberData = {
            email: subscriberEmail,
            new_email: newEmail,
            custom_fields: customFields,
            tags: tags,
        };

        try {
            const response = await dripClient.updateCreateSubscriber(subscriberData);
            return response;
        } catch (error) {
            console.error('Failed to create or update subscriber:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-or-update-subscriber
  instructions: |-
    Creates a new subscriber. If the email already exists, it will update the existing subscriber in drip
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Drip
  resource_type_def: |-
    type Drip = {
        accountId: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createEventSource as createHookdeckEventSource } from "npm:@hookdeck/client";

    type Hookdeck = {
        apiKey: string;
        sourceId: string;
    }

    export async function main(hookdeckResource: Hookdeck, destinationUrl: string, events: string[]) {
        const hookdeckClient = createHookdeckEventSource({
            apiKey: hookdeckResource.apiKey,
            sourceId: hookdeckResource.sourceId,
        });

        const connection = await hookdeckClient.createConnection({
            destination: destinationUrl,
            events: events,
        });

        return connection;
    }
  good: |-
    // Import necessary libraries
    import { Hookdeck } from "npm:@hookdeck/client";

    type HookdeckResource = {
        apiKey: string;
    }

    export async function main(hookdeckResource: HookdeckResource, sourceId: string, destinationId: string, events: string[]) {
        // Initialize Hookdeck client with the provided API key
        const hookdeckClient = new Hookdeck(hookdeckResource.apiKey);

        // Create a connection on Hookdeck
        const connection = await hookdeckClient.connections.create({
            source: sourceId,
            destination: destinationId,
            events: events
        });

        // Return the result
        return connection;
    }
  id: |-
    synthetic_create-connection
  instructions: |-
    This endpoint creates a connection. in hookdeck
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hookdeck
  resource_type_def: |-
    type Hookdeck = {
        apiKey: string;
        sourceId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string, newContent: string, mimeType: string) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;

        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        const response = await drive.files.update({
            fileId: fileId,
            media: {
                mimeType: mimeType,
                body: newContent
            }
        });

        return response.data;
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string, localFilePath: string, mimeType: string) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;

        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        const fileMetadata = {
            'mimeType': mimeType,
        };

        const media = {
            mimeType: mimeType,
            body: Deno.openSync(localFilePath),
        };

        const response = await drive.files.update({
            fileId: fileId,
            media: media,
            resource: fileMetadata,
            fields: 'id'
        });

        return response.data;
    }
  id: |-
    synthetic_replace-file
  instructions: |-
    Upload a file that replaces an existing file for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string, issueNumber: number, issueTitle: string, issueBody: string) {
        const octokit = new Octokit({
            auth: githubResource.accessToken,
        });

        const response = await octokit.issues.update({
            owner,
            repo,
            issue_number: issueNumber,
            title: issueTitle,
            body: issueBody,
        });

        return response.data;
    }
  good: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(githubResource: Github, owner: string, repo: string, issueNumber: number, issueTitle: string, issueBody: string) {
        const octokit = new Octokit({
            auth: githubResource.accessToken,
        });

        const response = await octokit.issues.update({
            owner,
            repo,
            issue_number: issueNumber,
            title: issueTitle,
            body: issueBody,
        });

        return response.data;
    }
  id: |-
    synthetic_update-issue
  instructions: |-
    Update a new issue in a Gihub repo in github
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the fetch API interface for TypeScript
    /// <reference lib="dom" />

    type DataPoliceUk = {
        apiKey: string; // Assuming an API key is required for authentication
        baseUrl: string; // Base URL for the DataPoliceUK API
    }

    export async function main(dataPoliceUkResource: DataPoliceUk, area: string): Promise<any> {
        const url = `${dataPoliceUkResource.baseUrl}/forces?area=${encodeURIComponent(area)}`;

        const response = await fetch(url, {
            headers: {
                'Authorization': `Bearer ${dataPoliceUkResource.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    type DataPoliceUk = {
        apiKey: string;
    }

    export async function main(dataPoliceUkResource: DataPoliceUk, force: string) {
        const url = `https://data.police.uk/api/forces/${force}/people`;
        const headers = {
            "Authorization": `Bearer ${dataPoliceUkResource.apiKey}`
        };

        const response = await fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_fetch-forces
  instructions: |-
    Get a list of police forces and contact information within a particular area in data police uk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DataPoliceUk
  resource_type_def: |-
    type DataPoliceUk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'nudgify' integration
    class nudgify(TypedDict):
        api_key: str
        site_id: str

    # Main function to create a purchase nudge
    def main(nudgify_resource: nudgify, product_name: str, product_url: str, image_url: str, nudge_text: str):
        # Assuming a library 'nudgify_api' is used to interact with the Nudgify API
        from nudgify_api import create_nudge as create_nudge_api

        # Use the credentials from the resource to authenticate with the Nudgify API
        api_key = nudgify_resource['api_key']
        site_id = nudgify_resource['site_id']

        # Create the nudge with the provided parameters
        nudge_data = {
            'site_id': site_id,
            'product_name': product_name,
            'product_url': product_url,
            'image_url': image_url,
            'nudge_text': nudge_text
        }

        # Call the Nudgify API to create the nudge
        result = create_nudge_api(api_key, nudge_data)

        # Return the result of the API call
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the nudgify integration
    class nudgify(TypedDict):
        api_key: str
        site_id: str

    # Define the main function for creating a purchase nudge in nudgify
    def main(nudgify_resource: nudgify, product_name: str, product_url: str, image_url: str, nudge_text: str):
        # Import the requests library here to avoid naming conflicts
        import requests

        # Construct the API endpoint for creating a nudge
        api_endpoint = f"https://api.nudgify.com/v1/sites/{nudgify_resource['site_id']}/nudges"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {nudgify_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the nudge
        data = {
            "type": "purchase",
            "content": {
                "product_name": product_name,
                "product_url": product_url,
                "image_url": image_url,
                "nudge_text": nudge_text
            }
        }

        # Make the POST request to create the nudge
        response = requests.post(api_endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created nudge details
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # Example usage (do not include this in the script):
    # result = main(nudgify_resource={'api_key': 'your_api_key', 'site_id': 'your_site_id'}, product_name='Example Product', product_url='https://example.com/product', image_url='https://example.com/product.jpg', nudge_text='Just purchased!')
  id: |-
    synthetic_create-purchase-nudge
  instructions: |-
    Creates a purchase nudge in nudgify
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nudgify
  resource_type_def: |-
    class nudgify(TypedDict):
        api_key: str
        site_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BingX as BingXClient } from "npm:bingx-api";

    type Bingx = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(bingxResource: Bingx) {
        const bingxClient = new BingXClient(bingxResource.apiKey, bingxResource.apiSecret);
        const balance = await bingxClient.getBalance();
        return balance;
    }
  good: |-
    // Import any libraries you need here
    import { Bingx } from "npm:@bingx/bingx-api"; // Assuming there's an npm package for Bingx API

    type BingxResource = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for Bingx API authentication
    }

    export async function main(bingxResource: BingxResource) {
        // Initialize the Bingx API client with the provided credentials
        const bingxClient = new Bingx(bingxResource.apiKey, bingxResource.secretKey);

        // Fetch the Perpetual Swap Account Asset Information
        const assetInfo = await bingxClient.getPerpetualSwapAccountAssetInfo();

        // Return the result
        return assetInfo;
    }
  id: |-
    synthetic_account-get-balance
  instructions: |-
    Get Perpetual Swap Account Asset Information. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:base-64";

    type Mailerlite = {
        apiKey: string;
        groupId: string;
    }

    export async function main(mailerliteResource: Mailerlite, email: string, name?: string) {
        const url = `https://api.mailerlite.com/api/v2/groups/${mailerliteResource.groupId}/subscribers`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Basic ${encode(mailerliteResource.apiKey)}`
        };
        const body = JSON.stringify({
            email: email,
            name: name
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error adding subscriber: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    import { encode } from "npm:base-64";

    type Mailerlite = {
        apiKey: string;
    }

    export async function main(mailerliteResource: Mailerlite, groupId: string, subscriberEmail: string, name?: string) {
        const url = `https://api.mailerlite.com/api/v2/groups/${groupId}/subscribers`;
        const authHeader = `Basic ${encode(mailerliteResource.apiKey + ":")}`;
        const body = {
            email: subscriberEmail,
            name: name,
            type: 'active'
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`Error subscribing to MailerLite group: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_subscribe-to-group
  instructions: |-
    Add a subscriber to a group in mailerlite
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailerlite
  resource_type_def: |-
    type Mailerlite = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { S3Client, PutObjectCommand } from "npm:@aws-sdk/client-s3";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string; // Optional for temporary credentials
        region: string;
        bucketName: string;
    }

    export async function main(awsResource: Aws, destinationPrefix: string, fileContent: Buffer, fileName: string) {
        const s3 = new S3Client({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
                sessionToken: awsResource.sessionToken,
            },
            region: awsResource.region,
        });

        const key = `${destinationPrefix}${fileName}`;
        const putObjectParams = {
            Bucket: awsResource.bucketName,
            Key: key,
            Body: fileContent,
        };

        const command = new PutObjectCommand(putObjectParams);
        const response = await s3.send(command);

        return response;
    }
  good: |-
    import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";

    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }

    export async function main(awsResource: Aws, bucketName: string, filePath: string, destinationKey: string) {
        const s3 = new S3Client({
            credentials: {
                accessKeyId: awsResource.accessKeyId,
                secretAccessKey: awsResource.secretAccessKey,
                sessionToken: awsResource.sessionToken,
            },
            region: awsResource.region,
        });

        const fileContent = await Deno.readFile(filePath);

        const putObjectParams = {
            Bucket: bucketName,
            Key: destinationKey,
            Body: fileContent,
        };

        const command = new PutObjectCommand(putObjectParams);
        const response = await s3.send(command);

        return response;
    }
  id: |-
    synthetic_s3-upload-file-tmp
  instructions: |-
    This is the destination S3 prefix. Files or folders would both get uploaded to the prefix. in aws
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Aws
  resource_type_def: |-
    type Aws = {
        accessKeyId: string;
        secretAccessKey: string;
        sessionToken?: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import boto3
    from botocore.client import Config

    # Define the resource type for the digitalocean_spaces integration
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str

    def main(digitalocean_spaces_resource: digitalocean_spaces, file_path: str, bucket_name: str, object_name: str):
        # Initialize a session using DigitalOcean Spaces credentials
        session = boto3.session.Session()
        client = session.client('s3',
                                region_name=digitalocean_spaces_resource['region_name'],
                                endpoint_url=digitalocean_spaces_resource['endpoint_url'],
                                aws_access_key_id=digitalocean_spaces_resource['access_key_id'],
                                aws_secret_access_key=digitalocean_spaces_resource['secret_access_key'],
                                config=Config(signature_version='s3v4'))

        # Upload the file to the specified bucket
        with open(file_path, 'rb') as data:
            client.upload_fileobj(data, bucket_name, object_name)

        # Return a confirmation message
        return f"File {file_path} has been uploaded to {bucket_name}/{object_name} on DigitalOcean Spaces."
  good: |-
    from typing import TypedDict
    import boto3
    from botocore.client import Config

    # Define the resource type for the digitalocean_spaces integration
    class digitalocean_spaces(TypedDict):
        spaces_key: str
        spaces_secret: str
        region_name: str
        endpoint_url: str
        bucket_name: str

    def main(digitalocean_spaces_resource: digitalocean_spaces, file_path: str, destination_path: str) -> dict:
        # Initialize a session using DigitalOcean Spaces credentials
        session = boto3.session.Session()
        client = session.client('s3',
                                region_name=digitalocean_spaces_resource['region_name'],
                                endpoint_url=digitalocean_spaces_resource['endpoint_url'],
                                aws_access_key_id=digitalocean_spaces_resource['spaces_key'],
                                aws_secret_access_key=digitalocean_spaces_resource['spaces_secret'],
                                config=Config(signature_version='s3v4'))

        # Upload the file to the specified bucket
        with open(file_path, 'rb') as file:
            client.upload_fileobj(file, digitalocean_spaces_resource['bucket_name'], destination_path)

        # Return the result
        return {
            'message': 'File uploaded successfully',
            'file_path': file_path,
            'destination_path': destination_path,
            'bucket_name': digitalocean_spaces_resource['bucket_name']
        }
  id: |-
    synthetic_upload-file-tmp
  instructions: |-
    Accepts a file path starting from /tmp, then uploads as a file to DigitalOcean Spaces. in digitalocean spaces
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    digitalocean_spaces
  resource_type_def: |-
    class digitalocean_spaces(TypedDict):
        access_key_id: str
        secret_access_key: str
        region_name: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Filter = {
        // No specific properties needed for a generic filter operation
    }

    export async function main(filterResource: Filter, condition: boolean): Promise<void> {
        if (condition) {
            console.log("Condition met, ending execution.");
            return;
        }

        // If the condition is not met, the function will continue its execution
        // Additional logic would go here
    }
  good: |-
    type Filter = {
        // No specific properties needed for a generic filter integration
    }

    export async function main(filterResource: Filter, condition: boolean): Promise<void> {
        if (condition) {
            throw new Error('Condition met, workflow execution ended.');
        }
        // If the condition is not met, the function will end silently allowing the workflow to continue
    }
  id: |-
    synthetic_end-based-on-condition
  instructions: |-
    End workflow execution if a condition is met in filter
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Filter
  resource_type_def: |-
    type Filter = {
        // No specific properties needed for a generic filter operation
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to meistertask API

    class meistertask(TypedDict):
        api_token: str

    def main(meistertask_resource: meistertask, attachment_id: str) -> dict:
        base_url = "https://www.meistertask.com/api"
        headers = {
            "Authorization": f"Bearer {meistertask_resource['api_token']}"
        }
        response = requests.get(f"{base_url}/attachments/{attachment_id}", headers=headers)
        response.raise_for_status()  # This will raise an error if the request fails
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the meistertask integration
    class meistertask(TypedDict):
        api_key: str  # API key for authentication

    def main(meistertask_resource: meistertask, task_id: str, attachment_id: str) -> Any:
        # Base URL for MeisterTask API
        base_url = "https://www.meistertask.com/api"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {meistertask_resource['api_key']}"
        }

        # Endpoint to get the attachment
        attachment_url = f"{base_url}/tasks/{task_id}/attachments/{attachment_id}"

        # Make the request to get the attachment
        response = requests.get(attachment_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the attachment data
            return response.json()
        else:
            # Handle errors (e.g., attachment not found, access denied)
            response.raise_for_status()
  id: |-
    synthetic_get-attachment
  instructions: |-
    Retrieves information about an attachment in meistertask
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    meistertask
  resource_type_def: |-
    class meistertask(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(linkedin_resource: linkedin, account_id: str, start_timestamp: int, end_timestamp: int) -> Dict[str, Any]:
        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Define the URL for querying analytics
        url = f"https://api.linkedin.com/v2/organizationPageStatistics?q=organization&organization={account_id}&timeIntervals.timeGranularityType=DAY&timeIntervals.timeRange=(start:{start_timestamp},end:{end_timestamp})"

        # Make the API request
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response data
            data = response.json()
            return data
        else:
            # Handle errors (you could also raise an exception here)
            return {'error': response.text, 'status_code': response.status_code}

    # Note: The function is not called here, it's just defined and ready to be exported.
  good: |-
    from typing import TypedDict, Optional
    import datetime
    import linkedin_api  # Assuming this is the library for LinkedIn API

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the LinkedIn resource and additional parameters
    def main(
        linkedin_resource: linkedin,
        account_id: str,
        start_year: int,
        end_year: Optional[int] = None
    ):
        # If end_year is not provided, use the current year
        if end_year is None:
            end_year = datetime.datetime.now().year

        # Initialize the LinkedIn API client with the access token
        client = linkedin_api.Client(access_token=linkedin_resource['access_token'])

        # Define the date range for the analytics query
        start_date = datetime.date(start_year, 1, 1)
        end_date = datetime.date(end_year, 12, 31)

        # Perform the analytics query for the specified account and date range
        analytics = client.get_analytics(account_id, start_date, end_date)

        # Return the analytics data
        return analytics
  id: |-
    synthetic_analytics-finder-account-sample
  instructions: |-
    Sample query using analytics finder that gets analytics for a particular account for date range starting in a given year in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to the Kanban Tool API

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        domain: str
        board_id: int

    # Define the main function that updates a task in Kanban Tool
    def main(
        kanban_tool_resource: kanban_tool,
        task_id: int,
        task_data: dict[str, Any]
    ) -> dict:
        # Construct the API endpoint for updating a task
        endpoint = f"https://{kanban_tool_resource['domain']}.kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}.json"

        # Prepare the headers and payload for the request
        headers = {
            'X-KanbanToolToken': kanban_tool_resource['api_key'],
            'Content-Type': 'application/json'
        }
        payload = {
            'task': task_data
        }

        # Send the request to update the task
        response = requests.put(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated task data
        else:
            raise Exception(f"Failed to update task: {response.status_code} {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the kanban_tool integration
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str

    # Define the main function for updating a task in the kanban_tool
    def main(kanban_tool_resource: kanban_tool, task_id: str, task_updates: dict[str, Any]):
        # Import the requests library here to avoid naming conflicts
        import requests

        # Construct the API endpoint for updating a task
        api_endpoint = f"https://kanbantool.com/api/v1/boards/{kanban_tool_resource['board_id']}/tasks/{task_id}"

        # Prepare the headers for the API request
        headers = {
            "X-KanbanToolToken": kanban_tool_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Make the API request to update the task
        response = requests.put(api_endpoint, headers=headers, json=task_updates)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the updated task data
            return response.json()
        else:
            # Handle errors (e.g., task not found, invalid updates)
            response.raise_for_status()

    # Example usage:
    # result = main(kanban_tool_resource={'api_key': 'your_api_key', 'board_id': 'your_board_id'}, task_id='your_task_id', task_updates={'name': 'Updated Task Name', 'description': 'Updated description'})
    # print(result)
  id: |-
    synthetic_update-task
  instructions: |-
    Updates a task with the given parameters in kanban tool
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kanban_tool
  resource_type_def: |-
    class kanban_tool(TypedDict):
        api_key: str
        board_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type JudgeMe = {
        apiKey: string;
        privateToken: string;
        shopDomain: string;
    }

    export async function main(judgeMeResource: JudgeMe, productId: string, message: string, email: string, rating: number) {
        const { apiKey, privateToken, shopDomain } = judgeMeResource;
        const body = {
            shop_domain: shopDomain,
            product_id: productId,
            message: message,
            email: email,
            rating: rating
        };

        const requestOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${privateToken}`
            },
            body: JSON.stringify(body)
        };

        const response = await fetch(`https://${shopDomain}/judge_me_endpoint`, requestOptions);
        const result = await response.json();

        return result;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type JudgeMe = {
        apiKey: string;
        token: string;
        shopDomain: string;
    }

    export async function main(judgeMeResource: JudgeMe, reviewId: number, privateReplyMessage: string) {
        const authHeader = `Basic ${encode(`${judgeMeResource.apiKey}:${judgeMeResource.token}`)}`;
        const replyUrl = `https://${judgeMeResource.shopDomain}/judge_me/reviews/${reviewId}/private_reply`;

        const response = await fetch(replyUrl, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ private_reply: { body: privateReplyMessage } }),
        });

        if (!response.ok) {
            throw new Error(`Failed to send private reply: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_private-reply
  instructions: |-
    Create a private reply for a review, on behalf of the shop. Private replies are not shown on the widgets, but can be emailed to the reviewers in judge me
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    JudgeMe
  resource_type_def: |-
    type JudgeMe = {
        apiKey: string;
        privateToken: string;
        shopDomain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    class data_stores(TypedDict):
        api_key: str

    def main(data_stores_resource: data_stores, store_url: str, key_to_check: str) -> bool:
        store = connect_to_data_store(data_stores_resource['api_key'], store_url)
        key_exists = check_key_existence(store, key_to_check)

        return key_exists

    def connect_to_data_store(api_key: str, store_url: str) -> Any:
        return "data_store_connection"

    def check_key_existence(store: Any, key: str) -> bool:
        return True
  good: |-
    from typing import TypedDict, Any

    class data_stores(TypedDict):
        api_key: str
        endpoint_url: str

    def main(data_stores_resource: data_stores, key_name: str, default_value: Any):
        # Assuming there is a library to interact with the data store
        from data_stores_lib import get_key, create_key

        # Check if the key exists
        value = get_key(data_stores_resource['api_key'], data_stores_resource['endpoint_url'], key_name)

        # If the key does not exist, create it with the default value
        if value is None:
            create_key(data_stores_resource['api_key'], data_stores_resource['endpoint_url'], key_name, default_value)
            return f"Key '{key_name}' created with default value."

        return f"Key '{key_name}' already exists."
  id: |-
    synthetic_has-key-or-create
  instructions: |-
    Check if a key exists in your or create one if it doesn't exist. in data stores
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    data_stores
  resource_type_def: |-
    class data_stores(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import openai as openai_client  # Renamed to avoid conflict with the resource type

    class openai(TypedDict):
        api_key: str

    def main(openai_config: openai, texts: List[str]) -> List[dict]:
        openai_client.api_key = openai_config['api_key']

        embeddings = []
        for text in texts:
            response = openai_client.Embedding.create(input=text)
            embeddings.append(response)

        return embeddings
  good: |-
    from typing import TypedDict
    import openai as openai_client

    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, input_text: str) -> dict:
        openai_client.api_key = openai_resource['api_key']

        response = openai_client.Embedding.create(
            input=input_text,
            engine="text-similarity-babbage-001"
        )

        return response
  id: |-
    synthetic_create-embeddings
  instructions: |-
    Get a vector representation of a given input that can be easily consumed by machine learning models and algorithms in openai
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming that requests might be used for API calls

    # Define the resource type for the 'goody' integration
    class goody(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    # Define the main function with the resource type and any additional parameters
    def main(goody_resource: goody, batch_id: str) -> List[Any]:
        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {goody_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the URL for the API endpoint
        url = f"{goody_resource['base_url']}/orders/batch/{batch_id}"

        # Make the API request to retrieve orders for the specified batch
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of orders
            return response.json()
        else:
            # Handle errors (for simplicity, just returning an empty list here)
            return []
  good: |-
    from typing import TypedDict, List, Any

    # Define the resource type for the 'goody' integration
    class goody(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function that retrieves orders for an order batch in Goody
    def main(goody_resource: goody, batch_id: str) -> List[Any]:
        # Import the necessary library for HTTP requests
        import requests

        # Define the endpoint for retrieving orders for a batch
        orders_endpoint = f"https://api.goody.com/order_batches/{batch_id}/orders"

        # Set up the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {goody_resource['api_key']}",
            "X-Secret": goody_resource['api_secret']
        }

        # Make the HTTP GET request to retrieve the orders
        response = requests.get(orders_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of orders
            return response.json()
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # The complete script is ready to be used as is, with the user providing the 'goody_resource' and 'batch_id'.
  id: |-
    synthetic_retrieve-orders-for-order-batch
  instructions: |-
    Retrieves orders for an order batch in Goody in goody
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    goody
  resource_type_def: |-
    class goody(TypedDict):
        api_key: str
        api_secret: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to ByBit API

    # Define the resource type for the 'bybit' integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The API endpoint, e.g., "https://api.bybit.com"

    # Define the main function with the resource type and any additional parameters
    def main(bybit_resource: bybit, symbol: str, order_id: str) -> dict:
        # Construct the request to cancel the stop order
        url = f"{bybit_resource['endpoint']}/v2/private/stop-order/cancel"
        params = {
            "api_key": bybit_resource['api_key'],
            "symbol": symbol,
            "stop_order_id": order_id,
            # Additional parameters like timestamp and signature will be required
            # for a real request. These should be generated as per ByBit's API
            # documentation. The example assumes these values are calculated
            # and added to the request.
        }

        # Send the request to cancel the stop order
        response = requests.post(url, params=params)

        # Return the response as a dictionary
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the bybit API

    # Define the resource type for the bybit integration
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The API endpoint, e.g., "https://api.bybit.com"

    # Define the main function for cancelling a conditional order in bybit
    def main(bybit_resource: bybit, symbol: str, order_id: str) -> dict:
        # Construct the request to cancel the conditional order
        url = f"{bybit_resource['endpoint']}/v2/private/stop-order/cancel"
        params = {
            "api_key": bybit_resource['api_key'],
            "symbol": symbol,
            "stop_order_id": order_id,
            # Additional parameters like timestamp and signature will be required
            # for a real request. These are typically generated using the API secret
            # and the rest of the parameters. The user should implement this part.
        }

        # Send the request to cancel the conditional order
        response = requests.post(url, params=params)

        # Return the response as a dictionary
        return response.json()
  id: |-
    synthetic_linear-stop-order-cancel
  instructions: |-
    Cancel Conditional Order. in bybit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bybit
  resource_type_def: |-
    class bybit(TypedDict):
        api_key: str
        api_secret: str
        endpoint: str  # The API endpoint, e.g., "https://api.bybit.com"
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import meraki as meraki_sdk  # Renamed the imported module to avoid conflict

    # Define the resource type for the cisco_meraki integration
    class cisco_meraki(TypedDict):
        api_key: str
        base_url: str  # Assuming the base URL is needed for the API calls

    # Define the main function with the cisco_meraki resource and any other necessary parameters
    def main(meraki_resource: cisco_meraki, network_id: str):
        # Configure the Meraki dashboard API with the provided API key and base URL
        dashboard = meraki_sdk.DashboardAPI(
            api_key=meraki_resource['api_key'],
            base_url=meraki_resource['base_url'],
            output_log=False  # Assuming we don't want to output logs in this script
        )

        # Fetch the network details using the provided network ID
        network = dashboard.networks.getNetwork(network_id)

        # Return the network details
        return network
  good: |-
    from typing import TypedDict
    import meraki  # Assuming meraki is the SDK for Cisco Meraki

    # Define the resource type for the cisco_meraki integration
    class cisco_meraki(TypedDict):
        api_key: str

    # Define the main function with the resource type and any additional parameters
    def main(cisco_meraki_resource: cisco_meraki, network_id: str):
        # Configure the Meraki dashboard API with the provided API key
        dashboard = meraki.DashboardAPI(api_key=cisco_meraki_resource['api_key'])

        # Get the network details using the provided network ID
        network = dashboard.networks.getNetwork(network_id)

        # Return the network details
        return network
  id: |-
    synthetic_get-network
  instructions: |-
    Gets a network. in cisco meraki
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cisco_meraki
  resource_type_def: |-
    class cisco_meraki(TypedDict):
        api_key: str
        base_url: str  # Assuming the base URL is needed for the API calls
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the aero_workflow integration
    class aero_workflow(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for creating a company in Aero Workflow
    def main(aero_workflow_resource: aero_workflow, company_name: str, company_email: str, additional_info: dict):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a company
        endpoint = f"{aero_workflow_resource['base_url']}/api/v1/companies"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Bearer {aero_workflow_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'name': company_name,
            'email': company_email,
            **additional_info  # Include any additional company-specific information
        }

        # Make the API request to create the company
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check the response and return the result
        if response.status_code == 201:
            return response.json()  # Return the created company information
        else:
            raise Exception(f"Error creating company: {response.text}")

    # Note: The function is not called here, it is just defined and ready to be used.
  good: |-
    from typing import TypedDict

    # Define the resource type for the aero_workflow integration
    class aero_workflow(TypedDict):
        api_key: str

    # Define the main function for creating a company in the Aero Workflow platform
    def main(aero_workflow_resource: aero_workflow, base_url: str, company_name: str, company_email: str, additional_info: dict):
        # Import the requests library here to avoid potential naming conflicts
        import requests

        # Construct the headers with the API key
        headers = {
            'Authorization': f"Bearer {aero_workflow_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the payload with the company details
        payload = {
            'name': company_name,
            'email': company_email,
            'additional_info': additional_info
        }

        # Make the POST request to create a new company
        response = requests.post(
            f"{base_url}/companies",
            headers=headers,
            json=payload
        )

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created company details
        else:
            response.raise_for_status()  # Raise an error if the request failed

    # The main function is not called here, as per the instructions
  id: |-
    synthetic_create-company
  instructions: |-
    Creates a company in aero workflow
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aero_workflow
  resource_type_def: |-
    class aero_workflow(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import chartmogul as cm

    class chartmogul(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_resource: chartmogul, start_date: str, end_date: str) -> float:
        config = cm.Config(
            account_token=chartmogul_resource['account_token'],
            secret_key=chartmogul_resource['secret_key']
        )

        metrics = cm.Metrics.arpa(
            config,
            start_date=start_date,
            end_date=end_date
        )

        return metrics['arpa']
  good: |-
    from typing import TypedDict
    import chartmogul

    class chartmogul_resource(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_resource: chartmogul_resource, start_date: str, end_date: str) -> float:
        config = chartmogul.Config(
            account_token=chartmogul_resource['account_token'],
            secret_key=chartmogul_resource['secret_key']
        )

        metrics = chartmogul.Metrics.arpa(
            config,
            start_date=start_date,
            end_date=end_date
        )

        return metrics['arpa']
  id: |-
    synthetic_retrieve-arpa
  instructions: |-
    Retrieves the Average Revenue Per Account (ARPA), for the specified time period in chartmogul
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    chartmogul
  resource_type_def: |-
    class chartmogul(TypedDict):
        account_token: str
        secret_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { DateTime } from "npm:luxon";

    type CalCom = {
        apiKey: string;
        calendarId: string;
    }

    export async function main(calComResource: CalCom, bookingDate: string, bookingTime: string, attendeeEmail: string, attendeeName: string) {
        // Construct the booking datetime in ISO format
        const bookingDateTime = DateTime.fromISO(`${bookingDate}T${bookingTime}`).toISO();

        // Prepare the request payload
        const payload = {
            calendar_id: calComResource.calendarId,
            start_time: bookingDateTime,
            invitee_email: attendeeEmail,
            invitee_full_name: attendeeName
        };

        // Make the API call to create the booking
        const response = await fetch('https://api.cal.com/v1/bookings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${calComResource.apiKey}`
            },
            body: JSON.stringify(payload)
        });

        // Parse the response
        const result = await response.json();

        // Always return the result
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { CalComBooking } from "npm:@calcom/client"; // Assuming @calcom/client is the npm package for CalCom

    type CalCom = {
        apiKey: string,
        calendarId: string
    }

    export async function main(calComResource: CalCom, bookingDetails: { startTime: Date, endTime: Date, inviteeEmail: string, inviteeName: string, inviteeTimeZone: string }) {
        // Create a new instance of the CalComBooking client
        const calComClient = new CalComBooking(calComResource.apiKey);

        // Create a new booking using the client
        const booking = await calComClient.createBooking({
            calendarId: calComResource.calendarId,
            startTime: bookingDetails.startTime,
            endTime: bookingDetails.endTime,
            inviteeEmail: bookingDetails.inviteeEmail,
            inviteeName: bookingDetails.inviteeName,
            inviteeTimeZone: bookingDetails.inviteeTimeZone
        });

        // Return the result
        return booking;
    }
  id: |-
    synthetic_create-booking
  instructions: |-
    Create a new booking in cal com
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CalCom
  resource_type_def: |-
    type CalCom = {
        apiKey: string;
        calendarId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { FeedbinClient } from "npm:@types/feedbin"; // Assuming there's a type definition for Feedbin client

    type Feedbin = {
        username: string;
        password: string;
    }

    export async function main(feedbinResource: Feedbin) {
        const feedbinClient = new FeedbinClient(feedbinResource.username, feedbinResource.password);
        const subscriptions = await feedbinClient.getSubscriptions();
        return subscriptions;
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Feedbin = {
        username: string;
        password: string;
    }

    export async function main(feedbinResource: Feedbin) {
        const authHeader = `Basic ${encode(`${feedbinResource.username}:${feedbinResource.password}`)}`;
        const response = await fetch('https://api.feedbin.com/v2/subscriptions.json', {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching subscriptions: ${response.status} ${response.statusText}`);
        }

        const subscriptions = await response.json();
        return subscriptions;
    }
  id: |-
    synthetic_get-subscriptions
  instructions: |-
    Return all subscriptions. in feedbin
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Feedbin
  resource_type_def: |-
    type Feedbin = {
        username: string;
        password: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP requests

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, campaign_id: str) -> dict:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }
        response = requests.delete(f"{base_url}/campaigns/{campaign_id}", headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    # Define the resource type for the Mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # Mailchimp API endpoints are prefixed with a server prefix

    def main(mailchimp_resource: mailchimp, campaign_id: str) -> dict:
        """
        Deletes a campaign in Mailchimp.

        :param mailchimp_resource: A dictionary containing the Mailchimp API key and server prefix.
        :param campaign_id: The unique id for the campaign to delete.
        :return: A dictionary with the result of the deletion operation.
        """
        # Construct the API endpoint for deleting a campaign
        endpoint = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0/campaigns/{campaign_id}"

        # Set up the headers for authorization
        headers = {
            'Authorization': f'Bearer {mailchimp_resource["api_key"]}'
        }

        # Make the DELETE request to the Mailchimp API
        response = requests.delete(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 204:
            return {'status': 'success', 'message': 'Campaign deleted successfully.'}
        else:
            # Return the error if the deletion was not successful
            return {'status': 'error', 'message': response.json()}
  id: |-
    synthetic_delete-campaign
  instructions: |-
    Delete a specific campaign in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str  # Mailchimp API endpoints are prefixed with a server prefix
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        baseUrl: string;
        username: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueKey: string, attachments: File[], comment?: string) {
        const url = `${jiraResource.baseUrl}/rest/api/3/issue/${issueKey}/attachments`;
        const headers = {
            'X-Atlassian-Token': 'no-check',
            'Authorization': `Basic ${Buffer.from(`${jiraResource.username}:${jiraResource.apiToken}`).toString('base64')}`
        };

        const formData = new FormData();
        attachments.forEach(attachment => {
            formData.append('file', attachment);
        });

        if (comment) {
            formData.append('comment', comment);
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Failed to add attachments to issue ${issueKey}: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { FormData } from "npm:@deno/form-data";

    type Jira = {
        baseUrl: string;
        username: string;
        apiToken: string;
        issueKey: string; // Assuming issueKey is a common property for Jira integration
    }

    export async function main(jiraResource: Jira, attachments: File[], comment?: string) {
        const url = `${jiraResource.baseUrl}/rest/api/3/issue/${jiraResource.issueKey}/attachments`;

        const formData = new FormData();
        attachments.forEach(attachment => {
            formData.append('file', attachment);
        });

        if (comment) {
            formData.append('comment', comment);
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${btoa(`${jiraResource.username}:${jiraResource.apiToken}`)}`,
                'X-Atlassian-Token': 'no-check',
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Failed to add attachments to the issue: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-multiple-attachments-to-issue
  instructions: |-
    Adds multiple attachments to an issue, in jira
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jira
  resource_type_def: |-
    type Jira = {
        baseUrl: string;
        username: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { CoinbasePro } from "npm:@coinbase-pro-node";

    type Coinbase = {
        apiKey: string;
        apiSecret: string;
        passphrase: string;
        useSandbox: boolean; // true for sandbox mode, false for production
    }

    export async function main(coinbaseResource: Coinbase, product_id: string, price: string, size: string) {
        const client = new CoinbasePro({
            apiKey: coinbaseResource.apiKey,
            apiSecret: coinbaseResource.apiSecret,
            passphrase: coinbaseResource.passphrase,
            useSandbox: coinbaseResource.useSandbox,
        });

        const order = {
            type: 'limit',
            side: 'buy',
            product_id: product_id,
            price: price,
            size: size,
        };

        try {
            const result = await client.rest.order.placeOrder(order);
            return result;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { CoinbasePro as CoinbaseProClient } from "npm:@coinbase/coinbase-pro-node";

    type Coinbase = {
        apiKey: string;
        apiSecret: string;
        passphrase: string;
        useSandbox: boolean;
    }

    export async function main(coinbaseResource: Coinbase, product_id: string, price: string, size: string) {
        const client = new CoinbaseProClient({
            apiKey: coinbaseResource.apiKey,
            apiSecret: coinbaseResource.apiSecret,
            passphrase: coinbaseResource.passphrase,
            useSandbox: coinbaseResource.useSandbox,
        });

        const order = {
            type: 'limit',
            side: 'buy',
            product_id: product_id,
            price: price,
            size: size,
        };

        try {
            const result = await client.rest.order.placeOrder(order);
            return result;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_place-buy-order
  instructions: |-
    Places a buy order in coinbase
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coinbase
  resource_type_def: |-
    type Coinbase = {
        apiKey: string;
        apiSecret: string;
        passphrase: string;
        useSandbox: boolean;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, List
    import gspread  # Assuming gspread is used for Google Sheets API

    # Renaming gspread's method if it conflicts with the integration name
    from gspread.models import Spreadsheet as GSpreadSpreadsheet

    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict

    def main(google_sheets_resource: google_sheets, spreadsheet_id: str, range_name: str) -> List[List[Any]]:
        gc = gspread.service_account_from_dict(google_sheets_resource['service_account_info'])
        spreadsheet: GSpreadSpreadsheet = gc.open_by_key(spreadsheet_id)
        sheet = spreadsheet.worksheet(range_name.split('!')[0])
        values = sheet.get(range_name)

        return values
  good: |-
    from typing import TypedDict, List, Any
    import gspread  # Assuming gspread library is used for Google Sheets API

    # Rename the imported method if it conflicts with the resource type name
    from gspread.models import Spreadsheet as GSpreadSpreadsheet

    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict

    def main(google_sheets_resource: google_sheets, spreadsheet_id: str, range_name: str) -> List[List[Any]]:
        gc = gspread.service_account_from_dict(google_sheets_resource['service_account_info'])
        sh: GSpreadSpreadsheet = gc.open_by_key(spreadsheet_id)
        worksheet = sh.worksheet(range_name.split('!')[0])
        values_list = worksheet.get_all_values()
        return values_list
  id: |-
    synthetic_get-values
  instructions: |-
    Get all values from a sheet. in google sheets
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_sheets
  resource_type_def: |-
    class google_sheets(TypedDict):
        api_key: str
        service_account_info: dict
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ClockworkRecruiting as ClockworkRecruitingClient } from "npm:clockwork-recruiting";

    type ClockworkRecruiting = {
        apiKey: string,
        baseUrl: string
    }

    export async function main(clockworkRecruitingResource: ClockworkRecruiting, personId: number, address: string) {
        const clockworkClient = new ClockworkRecruitingClient({
            apiKey: clockworkRecruitingResource.apiKey,
            baseUrl: clockworkRecruitingResource.baseUrl
        });

        const endpoint = `${clockworkRecruitingResource.baseUrl}/people/${personId}/addresses`;

        const requestBody = {
            address: address
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${clockworkRecruitingResource.apiKey}`
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`Failed to add address to person with ID ${personId}: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:querystring";

    type ClockworkRecruiting = {
        apiKey: string;
        firmId: number;
    }

    export async function main(clockworkRecruitingResource: ClockworkRecruiting, personId: number, address: string, city: string, state: string, postalCode: string, country: string, addressType: string) {
        const baseUrl = `https://api.clockworkrecruiting.com/${clockworkRecruitingResource.firmId}/people/${personId}/addresses`;
        const headers = {
            'Authorization': `Bearer ${clockworkRecruitingResource.apiKey}`,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            address: {
                address: address,
                city: city,
                state: state,
                postalCode: postalCode,
                country: country,
                addressType: addressType
            }
        });

        const response = await fetch(baseUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-person-address
  instructions: |-
    Create an address to a specific person in clockwork recruiting
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    ClockworkRecruiting
  resource_type_def: |-
    type ClockworkRecruiting = {
        apiKey: string,
        baseUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Buffer } from "npm:buffer";

    type MicrosoftOnedrive = {
        accessToken: string;
    }

    export async function main(microsoftOnedriveResource: MicrosoftOnedrive, fileId: string) {
        const downloadUrl = `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`;

        const response = await fetch(downloadUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${microsoftOnedriveResource.accessToken}`
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to download file: ${response.statusText}`);
        }

        const data = await response.arrayBuffer();
        return Buffer.from(data);
    }
  good: |-
    import { Buffer } from "npm:buffer";

    type MicrosoftOnedrive = {
        accessToken: string;
    }

    export async function main(onedriveResource: MicrosoftOnedrive, fileId: string, destinationPath: string) {
        const downloadUrl = `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`;
        const response = await fetch(downloadUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${onedriveResource.accessToken}`
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to download file: ${response.statusText}`);
        }

        const data = await response.arrayBuffer();
        const buffer = Buffer.from(data);
        await Deno.writeFile(destinationPath, buffer);

        return { success: true, message: `File downloaded to ${destinationPath}` };
    }
  id: |-
    synthetic_download-file
  instructions: |-
    Download a file stored in OneDrive in microsoft onedrive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftOnedrive
  resource_type_def: |-
    type MicrosoftOnedrive = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import aftership as aftership_pkg  # Renamed the imported package

    class aftership(TypedDict):
        api_key: str

    def main(aftership_resource: aftership, tracking_number: str, carrier: str, title: str, order_id: str, order_id_path: str, custom_fields: Dict[str, Any]):
        aftership_api = aftership_pkg.APIv4(aftership_resource['api_key'])
        tracking_data = {
            'tracking_number': tracking_number,
            'carrier': carrier,
            'title': title,
            'order_id': order_id,
            'order_id_path': order_id_path,
            'custom_fields': custom_fields,
        }
        result = aftership_api.trackings.post(tracking_data)
        return result
  good: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the aftership integration
    class aftership(TypedDict):
        api_key: str

    def main(aftership_resource: aftership, tracking_number: str, carrier: str, title: str, order_id: str, order_id_path: str, custom_fields: Dict[str, Any]):
        # Prepare the headers for the HTTP request
        headers = {
            'Content-Type': 'application/json',
            'aftership-api-key': aftership_resource['api_key']
        }

        # Prepare the data for the tracking update
        data = {
            'tracking': {
                'title': title,
                'order_id': order_id,
                'order_id_path': order_id_path,
                'custom_fields': custom_fields
            }
        }

        # Prepare the URL for the tracking update
        url = f'https://api.aftership.com/v4/trackings/{carrier}/{tracking_number}'

        # Make the HTTP request to update the tracking
        response = requests.put(url, json=data, headers=headers)

        # Return the response from the API
        return response.json()

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_update-tracking
  instructions: |-
    Updates an existing tracking in aftership
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    aftership
  resource_type_def: |-
    class aftership(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, driveId: string, updateFields: { name?: string, themeId?: string }) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        const response = await drive.drives.update({
            driveId: driveId,
            requestBody: updateFields,
        });

        return response.data;
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, driveId: string, updateFields: { name?: string, themeId?: string }) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        const result = await drive.drives.update({
            driveId: driveId,
            requestBody: updateFields,
            fields: 'id, name, themeId'
        });

        return result.data;
    }
  id: |-
    synthetic_update-shared-drive
  instructions: |-
    Update an existing shared drive for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ScreenshotOptions } from "npm:puppeteer-core";

    type Browserless = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: Browserless, url: string, options?: ScreenshotOptions) {
        const browserlessApiUrl = `${browserlessResource.endpoint}/screenshot?token=${browserlessResource.apiKey}&url=${encodeURIComponent(url)}`;

        const requestOptions: RequestInit = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(options)
        };

        const response = await fetch(browserlessApiUrl, requestOptions);
        if (!response.ok) {
            throw new Error(`Error taking screenshot: ${response.statusText}`);
        }

        const buffer = await response.arrayBuffer();
        return Buffer.from(buffer);
    }
  good: |-
    import { ScreenshotOptions } from "npm:@browserless/types";

    type Browserless = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: Browserless, url: string, options?: ScreenshotOptions) {
        const { apiKey, endpoint } = browserlessResource;
        const screenshotEndpoint = `${endpoint}/screenshot?token=${apiKey}`;
        const body = JSON.stringify({ url, options });

        const response = await fetch(screenshotEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: body
        });

        if (!response.ok) {
            throw new Error(`Failed to take screenshot: ${response.statusText}`);
        }

        return await response.blob();
    }
  id: |-
    synthetic_take-screenshot
  instructions: |-
    Take a screenshot of a page in browserless
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Browserless
  resource_type_def: |-
    type Browserless = {
        apiKey: string,
        endpoint: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailgun API

    # Define the resource type for the mailgun integration
    class mailgun(TypedDict):
        api_key: str
        domain: str

    def main(mailgun_resource: mailgun, recipient_email: str) -> dict:
        # Mailgun API URL for suppressing an email
        suppress_email_url = f"https://api.mailgun.net/v3/{mailgun_resource['domain']}/bounces"

        # Prepare the data for the POST request to suppress the email
        data = {
            'address': recipient_email,
        }

        # Make the POST request to suppress the email
        response = requests.post(
            suppress_email_url,
            auth=("api", mailgun_resource['api_key']),
            data=data
        )

        # Return the response as a dictionary
        return response.json()
  good: |-
    from typing import TypedDict
    import requests

    class mailgun(TypedDict):
        api_key: str
        domain: str

    def main(mailgun_resource: mailgun, email_address: str, suppression_type: str = 'bounces') -> dict:
        api_base_url = f"https://api.mailgun.net/v3/{mailgun_resource['domain']}/"
        suppression_url = f"{api_base_url}{suppression_type}"
        auth = ("api", mailgun_resource['api_key'])
        data = {"address": email_address}

        response = requests.post(suppression_url, auth=auth, data=data)
        return response.json()
  id: |-
    synthetic_suppress-email
  instructions: |-
    Add email to the Mailgun suppression list in mailgun
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailgun
  resource_type_def: |-
    class mailgun(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the dbt integration
    class dbt(TypedDict):
        api_token: str
        account_id: str
        project_id: str
        environment_id: str

    # Import requests but rename it to avoid conflicts with any potential 'requests' property in the dbt resource
    import requests as http_requests

    def main(dbt_resource: dbt, additional_headers: Dict[str, str] = None) -> Dict[str, Any]:
        # Construct the headers for the HTTP request
        headers = {
            'Authorization': f"Token {dbt_resource['api_token']}",
            'Content-Type': 'application/json'
        }

        # If there are additional headers provided, update the headers dictionary
        if additional_headers:
            headers.update(additional_headers)

        # Construct the URL for the dbt environment information endpoint
        url = f"https://cloud.getdbt.com/api/v2/accounts/{dbt_resource['account_id']}/projects/{dbt_resource['project_id']}/environments/{dbt_resource['environment_id']}/"

        # Make the HTTP GET request to retrieve the environment information
        response = http_requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    from typing import TypedDict

    # Define the resource type for the dbt integration
    class dbt(TypedDict):
        api_token: str
        account_id: str
        project_id: str

    def main(dbt_resource: dbt, environment_name: str, environment_id: str) -> dict:
        # Import the requests library, renaming it if it conflicts with any parameter
        import requests as req

        # Construct the API endpoint for getting environment details
        endpoint = f"https://cloud.getdbt.com/api/v2/accounts/{dbt_resource['account_id']}/projects/{dbt_resource['project_id']}/environments/{environment_id}/"

        # Set up the headers with the API token
        headers = {
            "Authorization": f"Token {dbt_resource['api_token']}",
            "Content-Type": "application/json"
        }

        # Make the GET request to the dbt Cloud API
        response = req.get(endpoint, headers=headers)

        # Check if the response is successful
        if response.status_code == 200:
            # Parse the JSON response
            environment_data = response.json()

            # Filter the environment by name if provided
            if environment_name:
                environment_data = next((env for env in environment_data.get('data', []) if env.get('name') == environment_name), None)

            # Return the environment data
            return environment_data
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()
  id: |-
    synthetic_get-environment
  instructions: |-
    Retrieve information about an environment in dbt
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dbt
  resource_type_def: |-
    class dbt(TypedDict):
        api_token: str
        account_id: str
        project_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the esputnik integration
    class esputnik(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for updating a contact in esputnik
    def main(esputnik_resource: esputnik, contact_id: int, updated_contact_info: Dict[str, Any]) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a contact
        update_contact_endpoint = f"{esputnik_resource['base_url']}/v1/contact/{contact_id}"

        # Prepare the headers for the request
        headers = {
            'Authorization': f"Bearer {esputnik_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Make the request to update the contact
        response = requests.post(update_contact_endpoint, json=updated_contact_info, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the response as a JSON object
        else:
            # Handle the error case
            return {
                'error': response.text,
                'status_code': response.status_code
            }

    # The script ends here, with the main function defined and ready to be used.
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to eSputnik API

    class esputnik(TypedDict):
        username: str
        password: str
        base_url: str

    def main(esputnik_resource: esputnik, contact_id: int, email: Optional[str] = None,
             first_name: Optional[str] = None, last_name: Optional[str] = None,
             phone_number: Optional[str] = None):
        # Construct the API endpoint for updating a contact
        update_contact_url = f"{esputnik_resource['base_url']}/v1/contact/{contact_id}"

        # Prepare the data to be updated
        contact_data = {
            "channels": [],
            "fields": []
        }

        if email:
            contact_data["channels"].append({"type": "email", "value": email})
        if phone_number:
            contact_data["channels"].append({"type": "sms", "value": phone_number})
        if first_name:
            contact_data["fields"].append({"id": "firstName", "value": first_name})
        if last_name:
            contact_data["fields"].append({"id": "lastName", "value": last_name})

        # Make the request to update the contact
        response = requests.post(
            update_contact_url,
            json=contact_data,
            auth=(esputnik_resource['username'], esputnik_resource['password'])
        )

        # Check for successful update
        if response.status_code == 200:
            return {"success": True, "message": "Contact updated successfully."}
        else:
            return {"success": False, "message": "Failed to update contact.", "error": response.text}
  id: |-
    synthetic_update-contact
  instructions: |-
    Update an existing contact in eSputnik in esputnik
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    esputnik
  resource_type_def: |-
    class esputnik(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import mysql.connector
    from mysql.connector import connection

    class mysql(TypedDict):
        host: str
        user: str
        password: str
        database: str

    def main(mysql_resource: mysql, table_name: str, lookup_column: str, lookup_value: Any):
        cnx = mysql.connector.connect(
            host=mysql_resource['host'],
            user=mysql_resource['user'],
            password=mysql_resource['password'],
            database=mysql_resource['database']
        )
        cursor = cnx.cursor(dictionary=True)

        query = f"SELECT * FROM {table_name} WHERE {lookup_column} = %s"
        cursor.execute(query, (lookup_value,))

        result = cursor.fetchone()
        cursor.close()
        cnx.close()

        return result
  good: |-
    from typing import TypedDict
    import mysql.connector  # Assuming mysql.connector is used for MySQL integration
    from mysql.connector import connect as mysql_connect  # Renaming in case of conflict

    class mysql(TypedDict):
        host: str
        user: str
        password: str

    def main(mysql_resource: mysql, database: str, table_name: str, search_column: str, search_value: str):
        connection = mysql_connect(
            host=mysql_resource['host'],
            user=mysql_resource['user'],
            password=mysql_resource['password'],
            database=database
        )
        cursor = connection.cursor(dictionary=True)

        query = f"SELECT * FROM {table_name} WHERE {search_column} = %s"
        cursor.execute(query, (search_value,))

        result = cursor.fetchone()
        cursor.close()
        connection.close()

        return result
  id: |-
    synthetic_find-row
  instructions: |-
    Finds a row in a table via a lookup column in mysql
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mysql
  resource_type_def: |-
    class mysql(TypedDict):
        host: str
        user: str
        password: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Drip = {
        accountId: string;
        apiToken: string;
    }

    export async function main(dripResource: Drip, workflowId: string) {
        const authHeader = `Basic ${encode(`${dripResource.apiToken}:`)}`;
        const url = `https://api.getdrip.com/v2/${dripResource.accountId}/workflows/${workflowId}/activations`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/vnd.api+json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Drip = {
        accountId: string;
        apiToken: string;
    }

    export async function main(dripResource: Drip, workflowId: string, email: string) {
        const authHeader = `Basic ${encode(`${dripResource.apiToken}:`)}`;
        const url = `https://api.getdrip.com/v2/${dripResource.accountId}/subscribers/${email}/workflow_triggers/${workflowId}/activations`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/vnd.api+json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_activate-workflow
  instructions: |-
    Activate a workflow in drip
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Drip
  resource_type_def: |-
    type Drip = {
        accountId: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed for HTTP calls to the Amilia API

    # Define the resource type for the 'amilia' integration
    class amilia(TypedDict):
        api_key: str
        base_url: str

    def main(amilia_resource: amilia, additional_param: str) -> List[Any]:
        # Construct the headers with the API key
        headers = {
            'X-API-KEY': amilia_resource['api_key']
        }

        # Construct the URL for listing accounts
        url = f"{amilia_resource['base_url']}/api/v3/accounts?{additional_param}"

        # Make the HTTP GET request to the Amilia API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON response if successful
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API calls

    class amilia(TypedDict):
        api_key: str
        organization_id: str

    def main(amilia_resource: amilia, additional_param: str) -> List[dict]:
        base_url = "https://api.amilia.com"
        headers = {
            "Authorization": f"Bearer {amilia_resource['api_key']}"
        }
        endpoint = f"/api/v3/organizations/{amilia_resource['organization_id']}/accounts"
        response = requests.get(base_url + endpoint, headers=headers)
        response.raise_for_status()  # This will raise an error if the request fails
        accounts = response.json()

        # Process accounts if needed, based on additional_param or other logic
        # For example, filter accounts, enrich data, etc.

        return accounts

    # The main function is now defined and can be exported and used with the required parameters.
  id: |-
    synthetic_list-accounts
  instructions: |-
    List all (client) accounts in an organization in amilia
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    amilia
  resource_type_def: |-
    class amilia(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to the Hyros API

    # Define the resource type for the 'hyros' integration
    class hyros(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function for creating a new lead in Hyros
    def main(hyros_resource: hyros, lead_data: dict, lead_type: str = 'default'):
        headers = {
            'Authorization': f"Bearer {hyros_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'type': lead_type,
            'data': lead_data
        }
        response = requests.post(f"{hyros_resource['endpoint_url']}/new-lead", json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'hyros' integration
    class hyros(TypedDict):
        api_key: str
        account_id: str

    # Define the main function for creating a lead in Hyros
    def main(hyros_resource: hyros, lead_name: str, lead_email: str, lead_phone: str = '', custom_fields: dict = None):
        import requests  # Import here to avoid conflicts with parameter names

        # Endpoint for creating a lead in Hyros
        create_lead_endpoint = f"https://api.hyros.com/v1/accounts/{hyros_resource['account_id']}/leads"

        # Prepare the data for the new lead
        lead_data = {
            'name': lead_name,
            'email': lead_email,
            'phone': lead_phone,
            'custom_fields': custom_fields if custom_fields else {}
        }

        # Set up the headers with the API key for authentication
        headers = {
            'Authorization': f"Bearer {hyros_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Make the request to create the lead
        response = requests.post(create_lead_endpoint, json=lead_data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the response data as JSON
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # The main function is now ready to be used with the required 'hyros' resource and parameters for creating a lead.
  id: |-
    synthetic_create-lead
  instructions: |-
    Create a new lead in hyros
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    hyros
  resource_type_def: |-
    class hyros(TypedDict):
        api_key: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here

    type DataStores = {
        apiKey: string;
        storeId: string;
    }

    export async function main(dataStoresResource: DataStores) {
        const url = `https://api.datastores.com/stores/${dataStoresResource.storeId}/keys`;
        const headers = {
            'Authorization': `Bearer ${dataStoresResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Error fetching keys: ${response.status} ${response.statusText}`);
        }

        const keys = await response.json();
        return keys;
    }
  good: |-
    // Import any libraries you need here
    // Assuming 'DataStores' is the name of the integration and also the name of a method we need to import,
    // we will rename the imported method to avoid conflict.

    type DataStores = {
        apiKey: string;
        // Add other properties needed for authentication/configuration
    }

    export async function main(dataStoresResource: DataStores) {
        // Assuming there's an API endpoint to list all keys in the data stores
        const url = `https://api.datastores.com/v1/keys`;
        const headers = {
            'Authorization': `Bearer ${dataStoresResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(url, { headers: headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data; // Assuming the API returns a JSON object with the keys
        } catch (error) {
            console.error('Error listing keys in data stores:', error);
            throw error;
        }
    }
  id: |-
    synthetic_list-keys
  instructions: |-
    List all keys in your. in data stores
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DataStores
  resource_type_def: |-
    type DataStores = {
        apiKey: string;
        storeId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to send HTTP requests

    class microsoft_teams(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
        token: str  # Assuming the OAuth2 token is already provided

    def main(microsoft_teams_resource: microsoft_teams, channel_id: str, message: str) -> dict:
        headers = {
            'Authorization': f'Bearer {microsoft_teams_resource["token"]}',
            'Content-Type': 'application/json'
        }
        url = f'https://graph.microsoft.com/v1.0/teams/{channel_id}/messages'
        payload = {
            'body': {
                'content': message
            }
        }
        response = requests.post(url, headers=headers, json=payload)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the microsoft_teams integration
    class microsoft_teams(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str

    # Define the main function to send a message to a Microsoft Teams channel
    def main(microsoft_teams_resource: microsoft_teams, access_token: str, channel_id: str, message_content: str):
        # Construct the HTTP request headers with the provided access token
        headers = {
            'Authorization': f'Bearer {access_token}',
            'Content-Type': 'application/json'
        }

        # Construct the message payload
        message_payload = {
            'body': {
                'content': message_content
            }
        }

        # Construct the URL for sending a message to the specified channel
        url = f'https://graph.microsoft.com/v1.0/teams/{microsoft_teams_resource["tenant_id"]}/channels/{channel_id}/messages'

        # Send the POST request to the Microsoft Teams API
        response = requests.post(url, headers=headers, json=message_payload)

        # Check if the request was successful
        if response.status_code == 201:
            return {'status': 'success', 'data': response.json()}
        else:
            return {'status': 'error', 'message': response.text}

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_send-channel-message
  instructions: |-
    Send a message to a team&#39;s channel in microsoft teams
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_teams
  resource_type_def: |-
    class microsoft_teams(TypedDict):
        tenant_id: str
        client_id: str
        client_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'missive' integration
    class missive(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a draft in Missive
    def main(missive_resource: missive, to_recipients: list[str], subject: str, body: str, cc_recipients: list[str] = [], bcc_recipients: list[str] = []):
        # Import the necessary library for HTTP requests
        import requests

        # Define the endpoint for creating a draft in Missive
        create_draft_endpoint = "https://missiveapp.com/api/drafts"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {missive_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload for the draft creation
        payload = {
            "to": to_recipients,
            "subject": subject,
            "body": body,
            "cc": cc_recipients,
            "bcc": bcc_recipients
        }

        # Make the HTTP POST request to create the draft
        response = requests.post(create_draft_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the response JSON if the draft was created successfully
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    from typing import TypedDict

    # Define the resource type for the missive integration
    class missive(TypedDict):
        api_key: str

    # Define the main function for creating a new draft in Missive
    def main(missive_resource: missive, subject: str, body: str, to_recipients: list[str], cc_recipients: list[str] = [], bcc_recipients: list[str] = []):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a new draft
        url = "https://missiveapp.com/api/drafts"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {missive_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the draft details
        payload = {
            "subject": subject,
            "body": body,
            "to": to_recipients,
            "cc": cc_recipients,
            "bcc": bcc_recipients
        }

        # Make the POST request to create a new draft
        response = requests.post(url, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the JSON response if the draft was created successfully
        else:
            response.raise_for_status()  # Raise an exception if there was an error

    # The main function is now defined and can be used with the required parameters
  id: |-
    synthetic_create-draft
  instructions: |-
    Create a new draft in missive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    missive
  resource_type_def: |-
    class missive(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function with the LinkedIn resource and additional parameters
    def main(linkedin_resource: linkedin, member_ids: List[str]) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Define the base URL for the LinkedIn API
        linkedin_api_url = "https://api.linkedin.com/v2/people/(id:{})"

        # Prepare the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {linkedin_resource['access_token']}"
        }

        # Initialize a list to hold the member profiles
        member_profiles = []

        # Loop through the member IDs and fetch their profiles
        for member_id in member_ids:
            # Make the API request to get the member profile
            response = requests.get(linkedin_api_url.format(member_id), headers=headers)

            # Check if the request was successful
            if response.status_code == 200:
                # Add the member profile to the list
                member_profiles.append(response.json())
            else:
                # Handle errors (e.g., member not found, access denied)
                member_profiles.append({"error": response.json()})

        # Return the list of member profiles
        return member_profiles
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function to get multiple member profiles
    def main(linkedin_resource: linkedin, member_ids: List[str]) -> List[dict]:
        import requests  # Import requests or any other HTTP library if needed

        # Base URL for LinkedIn API
        base_url = "https://api.linkedin.com/v2/people/(id:{})"

        # Prepare the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {linkedin_resource['access_token']}"
        }

        # List to hold the profiles
        profiles = []

        # Loop through the member IDs and fetch their profiles
        for member_id in member_ids:
            # Construct the URL for the current member
            url = base_url.format(member_id)

            # Make the HTTP GET request to LinkedIn API
            response = requests.get(url, headers=headers)

            # Check if the request was successful
            if response.status_code == 200:
                # Add the profile to the list
                profiles.append(response.json())
            else:
                # Handle errors (e.g., member not found, access denied)
                profiles.append({"error": response.json(), "member_id": member_id})

        # Return the list of profiles
        return profiles
  id: |-
    synthetic_get-multiple-member-profiles
  instructions: |-
    Gets multiple member profiles at once in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Klaviyo = {
        apiKey: string;
    }

    export async function main(klaviyoResource: Klaviyo, listName: string) {
        const url = `https://a.klaviyo.com/api/v2/lists`;
        const body = JSON.stringify({
            list_name: listName
        });
        const headers = {
            'Content-Type': 'application/json',
            'api-key': klaviyoResource.apiKey
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { KlaviyoClient } from "npm:@klaviyo/client";

    type Klaviyo = {
        apiKey: string;
    }

    export async function main(klaviyoResource: Klaviyo, listName: string) {
        const klaviyo = new KlaviyoClient({ apiKey: klaviyoResource.apiKey });

        const response = await klaviyo.lists.createList({ list_name: listName });

        return response;
    }
  id: |-
    synthetic_create-new-list
  instructions: |-
    Creates a new list in an account in klaviyo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Klaviyo
  resource_type_def: |-
    type Klaviyo = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createClient } from "npm:@netlify/js-client";

    type Netlify = {
        accessToken: string;
        siteId: string;
    }

    export async function main(netlifyResource: Netlify, directory: string) {
        const netlify = createClient({
            accessToken: netlifyResource.accessToken,
        });

        const files = await netlify.listSiteFiles({
            site_id: netlifyResource.siteId,
        });

        const directoryFiles = files.filter(file => file.path.startsWith(directory));

        return directoryFiles;
    }
  good: |-
    import { NetlifyAPI } from "npm:@netlify/js-client";

    type Netlify = {
        accessToken: string;
        siteId: string;
    }

    export async function main(netlifyResource: Netlify) {
        const client = new NetlifyAPI(netlifyResource.accessToken);
        const siteDeploys = await client.listSiteDeploys({ site_id: netlifyResource.siteId });
        const currentDeploy = siteDeploys[0]; // Assuming the first deploy is the current one

        if (!currentDeploy) {
            throw new Error('No deploys found for the specified site.');
        }

        const files = await client.listSiteFiles({ site_id: netlifyResource.siteId, deploy_id: currentDeploy.id });

        return files.map(file => ({
            path: file.path,
            sha: file.sha,
            mimeType: file.mime_type,
            size: file.size
        }));
    }
  id: |-
    synthetic_list-files
  instructions: |-
    Returns a list of all the files in the current deploy in netlify
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Netlify
  resource_type_def: |-
    type Netlify = {
        accessToken: string;
        siteId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Dropbox } from "npm:dropbox";

    type Dropbox = {
        accessToken: string;
    }

    export async function main(dropboxResource: Dropbox, fromPath: string, toPath: string) {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        try {
            const response = await dbx.filesMoveV2({
                from_path: fromPath,
                to_path: toPath,
            });
            return response;
        } catch (error) {
            console.error('Error moving file/folder:', error);
            throw error;
        }
    }
  good: |-
    import { Dropbox } from "npm:dropbox";

    type DropboxResource = {
        accessToken: string;
    }

    export async function main(dropboxResource: DropboxResource, fromPath: string, toPath: string) {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        try {
            const response = await dbx.filesMoveV2({
                from_path: fromPath,
                to_path: toPath,
            });
            return response;
        } catch (error) {
            console.error('Error moving file or folder in Dropbox:', error);
            throw error;
        }
    }
  id: |-
    synthetic_move-file-folder
  instructions: |-
    Moves a file or folder to a different location in the user's Dropbox in dropbox
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dropbox
  resource_type_def: |-
    type Dropbox = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional

    # Define the resource type for the 'megaventory' integration
    class megaventory(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function for inserting or updating a product in Megaventory
    def main(megaventory_resource: megaventory, product_sku: str, product_description: str, product_details: Optional[dict] = None):
        import requests  # Import requests or any other library if needed

        # Prepare the data for the API request
        data = {
            'APIKEY': megaventory_resource['api_key'],
            'mvProduct': {
                'ProductSKU': product_sku,
                'ProductDescription': product_description
            },
            'mvRecordAction': 'InsertOrUpdate'
        }

        # If there are additional product details, include them
        if product_details:
            data['mvProduct'].update(product_details)

        # Make the API request to insert or update the product
        response = requests.post(megaventory_resource['endpoint_url'], json=data)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to the Megaventory API

    # Define the resource type for the megaventory integration
    class megaventory(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the product data type for the Megaventory product
    class ProductData(TypedDict):
        ProductSKU: str
        ProductDescription: str
        ProductSellingPrice: float
        ProductPurchasePrice: float
        ProductCategory: str

    def main(megaventory_resource: megaventory, product_data: ProductData, product_id: Optional[int] = None):
        headers = {
            'Content-Type': 'application/json',
            'APIKEY': megaventory_resource['api_key']
        }

        # Prepare the data payload for the API request
        data = {
            'APIKEY': megaventory_resource['api_key'],
            'mvProduct': product_data,
            'mvRecordAction': 'InsertOrUpdate'
        }

        # If a product ID is provided, include it for an update action
        if product_id is not None:
            data['mvProduct']['ProductID'] = product_id

        # Make the API request to insert or update the product
        response = requests.post(megaventory_resource['endpoint_url'], json=data, headers=headers)

        # Return the response from the API
        return response.json()

    # Example usage (do not include this in the script):
    # result = main(
    #     megaventory_resource={
    #         'api_key': 'YOUR_API_KEY',
    #         'endpoint_url': 'https://api.megaventory.com/v2017a/Product/ProductUpdate'
    #     },
    #     product_data={
    #         'ProductSKU': '12345',
    #         'ProductDescription': 'Example Product',
    #         'ProductSellingPrice': 99.99,
    #         'ProductPurchasePrice': 59.99,
    #         'ProductCategory': 'Electronics'
    #     },
    #     product_id=123  # Optional, only if updating an existing product
    # )
  id: |-
    synthetic_insert-or-update-product
  instructions: |-
    Insert or update a product in the database. in megaventory
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    megaventory
  resource_type_def: |-
    class megaventory(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Freshdesk = {
        apiKey: string;
        domain: string;
    }

    export async function main(freshdeskResource: Freshdesk, companyName: string, description?: string, domains?: string[], note?: string) {
        const authHeader = `Basic ${encode(`${freshdeskResource.apiKey}:X`)}`;
        const url = `https://${freshdeskResource.domain}.freshdesk.com/api/v2/companies`;

        const companyData = {
            name: companyName,
            description: description,
            domains: domains,
            note: note
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(companyData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { Client } from "npm:@freshdesk/api";

    type Freshdesk = {
        apiKey: string;
        domain: string;
    }

    export async function main(freshdeskResource: Freshdesk, companyName: string, description?: string, domains?: string[], note?: string) {
        const client = new Client(freshdeskResource.apiKey, freshdeskResource.domain);

        const companyData = {
            name: companyName,
            description: description,
            domains: domains,
            note: note
        };

        try {
            const response = await client.companies.create(companyData);
            return response;
        } catch (error) {
            console.error('Error creating company in Freshdesk:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-company
  instructions: |-
    Create a company in freshdesk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Freshdesk
  resource_type_def: |-
    type Freshdesk = {
        apiKey: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AdRoll as AdRollClient } from 'npm:@adroll/adroll-api';

    type Adroll = {
        apiKey: string;
        advertiserId: string;
    }

    export async function main(adrollResource: Adroll, audienceId: string, emailsToReplace: string[]) {
        const adroll = new AdRollClient({ apiKey: adrollResource.apiKey });

        const endpoint = `https://services.adroll.com/audience/v1/${adrollResource.advertiserId}/audiences/${audienceId}/replace`;

        const payload = {
            emails: emailsToReplace
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${adrollResource.apiKey}`
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            throw new Error(`Failed to replace emails in audience: ${response.statusText}`);
        }

        const result = await response.json();

        return result;
    }
  good: |-
    import { AdRoll } from 'npm:@adroll/adroll-api';

    type AdrollResource = {
        apiKey: string;
        advertiserId: string;
    }

    export async function main(adrollResource: AdrollResource, audienceId: string, emailList: string[]) {
        const adroll = new AdRoll({ apiKey: adrollResource.apiKey });

        const response = await adroll.audience.replaceEmailList({
            advertiserId: adrollResource.advertiserId,
            audienceId: audienceId,
            emails: emailList
        });

        return response;
    }
  id: |-
    synthetic_replace-emails-from-crm-audience
  instructions: |-
    Replace the email list from a CRM audience in AdRoll in adroll
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Adroll
  resource_type_def: |-
    type Adroll = {
        apiKey: string;
        advertiserId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the instagram_business integration
    class instagram_business(TypedDict):
        access_token: str
        page_id: str

    def main(instagram_business_resource: instagram_business, media_id: str) -> Dict[str, Any]:
        # Construct the endpoint URL for media insights
        url = f"https://graph.facebook.com/v14.0/{media_id}/insights"

        # Define the parameters for the request
        params = {
            'access_token': instagram_business_resource['access_token'],
            'metric': 'engagement,impressions,reach,saved,video_views'  # Example metrics
        }

        # Make the API call to get media insights
        response = requests.get(url, params=params)

        # Check if the response is successful
        if response.status_code == 200:
            # Return the JSON data from the response
            return response.json()
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Note: The function is not called here, it is just defined and ready to be exported.
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP calls to the Instagram API

    # Define the resource type for the instagram_business integration
    class instagram_business(TypedDict):
        access_token: str
        page_id: str

    # Define the main function with the resource type and additional parameters
    def main(instagram_business_resource: instagram_business, media_object_id: str) -> Dict[str, Any]:
        # Construct the URL for the Instagram Graph API endpoint
        url = f"https://graph.facebook.com/v14.0/{media_object_id}/insights"

        # Define the parameters for the API request
        params = {
            'access_token': instagram_business_resource['access_token'],
            'metric': 'engagement,impressions,reach,saved,video_views',  # Metrics to retrieve
        }

        # Make the GET request to the Instagram Graph API
        response = requests.get(url, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the insights data as a dictionary
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # Note: The function is not called here, it is only defined and exported.
  id: |-
    synthetic_get-media-insights
  instructions: |-
    Get insights data on a media object in instagram business
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    instagram_business
  resource_type_def: |-
    class instagram_business(TypedDict):
        access_token: str
        page_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { format } from "npm:date-fns-tz";

    type HelperFunctions = {
        timezone: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, date: Date) {
        // Format the date to the specified timezone
        const formattedDate = format(date, "yyyy-MM-dd'T'HH:mm:ssXXX", { timeZone: helperFunctionsResource.timezone });

        // Return the formatted date
        return formattedDate;
    }
  good: |-
    // Import necessary libraries
    import { zonedTimeToUtc, utcToZonedTime, format } from "npm:date-fns-tz";

    type HelperFunctions = {
        timezone: string;
    }

    export async function main(helperFunctionsResource: HelperFunctions, isoTimestamp: string, targetTimezone: string): Promise<string> {
        // Convert the ISO 8601 timestamp to the target timezone
        const zonedDate = utcToZonedTime(isoTimestamp, targetTimezone);
        // Format the date to ISO 8601 in the target timezone
        const formattedDate = format(zonedDate, "yyyy-MM-dd'T'HH:mm:ssXXX", { timeZone: targetTimezone });
        // Return the converted timestamp
        return formattedDate;
    }
  id: |-
    synthetic_get-time-in-specific-timezone
  instructions: |-
    Given an ISO 8601 timestamp, and a timezone, convert the time to the target timezone. in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        timezone: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import chartmogul as cm

    class chartmogul(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_config: chartmogul, start_date: str, end_date: str, interval: str = 'month'):
        config = cm.Config(
            account_token=chartmogul_config['account_token'],
            secret_key=chartmogul_config['secret_key']
        )

        churn_rates = cm.Metrics.mrr_churn_rate(
            config,
            start_date=start_date,
            end_date=end_date,
            interval=interval
        ).get()

        return churn_rates
  good: |-
    from typing import TypedDict
    import chartmogul

    class chartmogul_resource(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_resource: chartmogul_resource, start_date: str, end_date: str) -> float:
        config = chartmogul.Config(
            account_token=chartmogul_resource['account_token'],
            secret_key=chartmogul_resource['secret_key']
        )

        metrics = chartmogul.Metrics.mrr_churn_rate(
            config,
            start_date=start_date,
            end_date=end_date
        )

        net_mrr_churn_rate = metrics.entries[0].net_mrr_churn_rate if metrics.entries else None

        return net_mrr_churn_rate
  id: |-
    synthetic_retrieve-mrr-churn-reate
  instructions: |-
    Retrieves the Net MRR Churn Rate, for the specified time period in chartmogul
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    chartmogul
  resource_type_def: |-
    class chartmogul(TypedDict):
        account_token: str
        secret_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type Alpaca = {
        apiKey: string;
        apiSecret: string;
        baseUrl: string;
    }

    export async function main(alpacaResource: Alpaca, orderId: string) {
        const url = `${alpacaResource.baseUrl}/v2/orders/${orderId}`;
        const headers = {
            'APCA-API-KEY-ID': alpacaResource.apiKey,
            'APCA-API-SECRET-KEY': alpacaResource.apiSecret,
            'Content-Type': 'application/json'
        };

        try {
            const response = await fetch(url, {
                method: 'DELETE',
                headers: headers
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to cancel order: ${error.message}`);
            }

            return await response.json();
        } catch (error) {
            throw new Error(`Error cancelling order: ${error.message}`);
        }
    }
  good: |-
    import { AlpacaClient as AlpacaApiClient } from "npm:@alpacahq/alpaca-trade-api";

    type Alpaca = {
        apiKeyId: string;
        secretKey: string;
        paper: boolean;
    }

    export async function main(alpacaResource: Alpaca, orderId: string) {
        const alpaca = new AlpacaApiClient({
            credentials: {
                keyId: alpacaResource.apiKeyId,
                secretKey: alpacaResource.secretKey,
                paper: alpacaResource.paper,
            },
        });

        const result = await alpaca.cancelOrder({ orderId });

        return result;
    }
  id: |-
    synthetic_cancel-order
  instructions: |-
    Attempts to cancel an open order. If the order is no longer cancelable (example: status=`filled`), the server will reject the request, in alpaca
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Alpaca
  resource_type_def: |-
    type Alpaca = {
        apiKeyId: string;
        secretKey: string;
        paper: boolean;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Esputnik = {
        username: string;
        password: string;
        endpoint: string;
    }

    export async function main(
        esputnikResource: Esputnik,
        eventType: string,
        eventKey: string,
        eventData: Record<string, any>
    ) {
        const credentials = `${esputnikResource.username}:${esputnikResource.password}`;
        const encodedCredentials = encode(credentials);
        const url = `${esputnikResource.endpoint}/v1/event`;

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                eventType: eventType,
                key: eventKey,
                data: eventData
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Esputnik = {
        username: string;
        password: string;
    }

    export async function main(esputnikResource: Esputnik, eventType: string, eventData: Record<string, any>) {
        const url = 'https://esputnik.com/api/v1/event';
        const credentials = `${esputnikResource.username}:${esputnikResource.password}`;
        const encodedCredentials = encode(credentials);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${encodedCredentials}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                eventType: eventType,
                key: eventData.key,
                parameters: eventData.parameters
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_send-event
  instructions: |-
    Send an event in eSputnik in esputnik
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Esputnik
  resource_type_def: |-
    type Esputnik = {
        username: string;
        password: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Coda as CodaAPI } from "npm:@codahq/packs-sdk";

    type Coda = {
        apiToken: string;
    }

    export async function main(codaResource: Coda, sourceDocId: string, destinationDocId: string, sourceTableIdOrName: string, destinationTableIdOrName: string) {
        const codaApi = new CodaAPI(codaResource.apiToken);

        // Fetch rows from the source table
        const rowsToCopy = await codaApi.listRows(sourceDocId, sourceTableIdOrName, { useColumnNames: true });

        // Prepare rows for insertion by removing id and browserLink
        const rowsForInsertion = rowsToCopy.items.map(row => {
            const { id, browserLink, ...rest } = row.values;
            return rest;
        });

        // Insert rows into the destination table
        const result = await codaApi.insertRows(destinationDocId, destinationTableIdOrName, rowsForInsertion, { useColumnNames: true });

        return result;
    }
  good: |-
    import { Coda } from "npm:@codahq/packs-sdk";

    type CodaResource = {
        apiToken: string;
    }

    export async function main(codaResource: CodaResource, docId: string, destinationFolderId: string, newDocName?: string) {
        const coda = new Coda(codaResource.apiToken);
        const copyEndpoint = `https://coda.io/apis/v1/docs/${docId}/copy`;

        const body = {
            destinationFolderId: destinationFolderId,
            name: newDocName,
        };

        const response = await fetch(copyEndpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${codaResource.apiToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });

        if (!response.ok) {
            throw new Error(`Failed to copy document: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_copy-doc
  instructions: |-
    Creates a copy of the specified doc in coda
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coda
  resource_type_def: |-
    type Coda = {
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string,
        clientEmail: string,
        privateKey: string,
    }

    export async function main(dialogflowResource: GoogleDialogflow, displayName: string, kind: string, autoExpansionMode: string) {
        const client = new SessionsClient({
            credentials: {
                client_email: dialogflowResource.clientEmail,
                private_key: dialogflowResource.privateKey,
            },
            projectId: dialogflowResource.projectId,
        });

        const formattedParent = client.projectAgentPath(dialogflowResource.projectId);
        const entityType = {
            displayName,
            kind,
            autoExpansionMode,
        };

        const request = {
            parent: formattedParent,
            entityType: entityType,
        };

        const [response] = await client.entityTypesClient.createEntityType(request);
        return response;
    }
  good: |-
    import { SessionsClient as DialogflowSessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }

    export async function main(
        googleDialogflowResource: GoogleDialogflow,
        displayName: string,
        kind: 'KIND_MAP' | 'KIND_LIST',
        autoExpansionMode: 'AUTO_EXPANSION_MODE_DEFAULT' | 'AUTO_EXPANSION_MODE_UNSPECIFIED'
    ) {
        const dialogflowClient = new DialogflowSessionsClient({
            credentials: {
                client_email: googleDialogflowResource.clientEmail,
                private_key: googleDialogflowResource.privateKey,
            },
            projectId: googleDialogflowResource.projectId,
        });

        const formattedParent = dialogflowClient.projectAgentPath(googleDialogflowResource.projectId);

        const entityType = {
            displayName,
            kind,
            autoExpansionMode,
        };

        const request = {
            parent: formattedParent,
            entityType,
        };

        const [response] = await dialogflowClient.entityTypesClient.createEntityType(request);
        return response;
    }
  id: |-
    synthetic_create-entity-type
  instructions: |-
    Creates an Entity Type, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        clientEmail: string;
        privateKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { InvoiceUpdate } from "npm:@holded/invoiceupdate";

    type Holded = {
        apiKey: string;
        // Add other necessary properties for Holded authentication/configuration
    }

    export async function main(holdedResource: Holded, invoiceId: string, updateData: InvoiceUpdate) {
        const holdedApiUrl = `https://api.holded.com/api/invoicing/v1/invoices/${invoiceId}`;

        const response = await fetch(holdedApiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${holdedResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { InvoiceUpdate } from "npm:@holded/invoicing";

    type Holded = {
        apiKey: string;
    }

    export async function main(holdedResource: Holded, invoiceId: string, updateData: InvoiceUpdate) {
        const holdedApiUrl = `https://api.holded.com/api/invoicing/v1/invoices/${invoiceId}`;

        const response = await fetch(holdedApiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${holdedResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-invoice
  instructions: |-
    Modify an existing invoice in Holded. in holded
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Holded
  resource_type_def: |-
    type Holded = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Miestro as MiestroClient } from 'npm:miestro-api-client';

    type Miestro = {
        apiKey: string;
    }

    export async function main(miestroResource: Miestro, userId: string, courseId: string) {
        const miestroClient = new MiestroClient(miestroResource.apiKey);
        const result = await miestroClient.unrollUserFromCourse(userId, courseId);
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Miestro = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(miestroResource: Miestro, userEmail: string, courseId: string) {
        const authHeader = `Basic ${encode(`${miestroResource.apiKey}:${miestroResource.apiSecret}`)}`;
        const response = await fetch(`https://api.miestro.com/v1/unroll_user`, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                user_email: userEmail,
                course_id: courseId,
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_unroll-user-to-course
  instructions: |-
    Unrolls user to a course in miestro
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Miestro
  resource_type_def: |-
    type Miestro = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'dayschedule' integration
    class dayschedule(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for adding a new event to the DaySchedule
    def main(dayschedule_resource: dayschedule, event_title: str, event_start: str, event_end: str, event_description: str = "") -> Any:
        # Assuming there's a library 'dayschedule_api' that we use to interact with the DaySchedule service
        from dayschedule_api import create_event as create_dayschedule_event

        # Create the event using the provided credentials and event details
        result = create_dayschedule_event(
            api_key=dayschedule_resource['api_key'],
            api_secret=dayschedule_resource['api_secret'],
            title=event_title,
            start=event_start,
            end=event_end,
            description=event_description
        )

        # Return the result of the event creation
        return result
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the 'dayschedule' integration
    class dayschedule(TypedDict):
        api_key: str
        api_secret: str

    def main(dayschedule_resource: dayschedule, event_title: str, event_description: str, start_time: str, end_time: str, attendees: list[str]) -> Any:
        # Construct the headers for authentication
        headers = {
            'Authorization': f"Bearer {dayschedule_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the payload for the new event
        payload = {
            'title': event_title,
            'description': event_description,
            'start_time': start_time,
            'end_time': end_time,
            'attendees': attendees
        }

        # Make a POST request to the dayschedule API to create an event
        response = requests.post('https://api.dayschedule.com/v1/events', headers=headers, json=payload)

        # Return the response from the API
        return response.json()
  id: |-
    synthetic_create-event
  instructions: |-
    Add a new event to the DaySchedule in dayschedule
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dayschedule
  resource_type_def: |-
    class dayschedule(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Blogger = {
        apiKey: string;
        blogId: string;
        accessToken: string;
    }

    export async function main(bloggerResource: Blogger, postId: string) {
        const url = `https://www.googleapis.com/blogger/v3/blogs/${bloggerResource.blogId}/posts/${postId}/revert?key=${bloggerResource.apiKey}`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${bloggerResource.accessToken}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { OAuth2Client } from "npm:google-auth-library";

    type Blogger = {
        apiKey: string;
        accessToken: string;
        blogId: string;
    }

    export async function main(bloggerResource: Blogger, postId: string) {
        const { apiKey, accessToken, blogId } = bloggerResource;

        const oauth2Client = new OAuth2Client();
        oauth2Client.setCredentials({
            access_token: accessToken,
        });

        const url = `https://www.googleapis.com/blogger/v3/blogs/${blogId}/posts/${postId}/revert?key=${apiKey}`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_revert-post
  instructions: |-
    Revert a published or scheduled post to draft state. in blogger
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Blogger
  resource_type_def: |-
    type Blogger = {
        apiKey: string;
        accessToken: string;
        blogId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the microsoft_excel integration
    class microsoft_excel(TypedDict):
        client_id: str
        client_secret: str
        tenant_id: str
        access_token: str  # Assuming OAuth2 credentials are included

    # Define the main function to add rows to a specific table in Microsoft Excel
    def main(microsoft_excel_resource: microsoft_excel, table_id: str, rows_to_add: List[List[str]]):
        # Import the required library for Microsoft Excel API interaction
        from microsoftgraph.client import Client

        # Initialize the Microsoft Graph client with the provided OAuth2 credentials
        client = Client(microsoft_excel_resource['client_id'], microsoft_excel_resource['client_secret'],
                        microsoft_excel_resource['tenant_id'], microsoft_excel_resource['access_token'])

        # Define the endpoint for appending rows to the table
        append_rows_endpoint = f'https://graph.microsoft.com/v1.0/me/drive/items/{table_id}/workbook/tables/{table_id}/rows/add'

        # Prepare the data payload for the API request
        data_payload = {
            "values": rows_to_add
        }

        # Make the API request to append rows to the table
        response = client.api(append_rows_endpoint).post(json=data_payload)

        # Return the API response
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import openpyxl  # Assuming openpyxl is used for Excel operations

    # Define the resource type for the microsoft_excel integration
    class microsoft_excel(TypedDict):
        file_path: str
        access_token: str  # Assuming OAuth2 is used and the token is provided

    def main(excel_resource: microsoft_excel, sheet_name: str, row_data: list[Any], row_index: int = None) -> None:
        # Load the workbook and select the specified sheet
        workbook = openpyxl.load_workbook(excel_resource['file_path'])
        worksheet = workbook[sheet_name]

        # Insert the row data at the specified index or append if no index is provided
        if row_index is not None:
            worksheet.insert_rows(row_index)
            for col_index, value in enumerate(row_data, start=1):
                worksheet.cell(row=row_index, column=col_index, value=value)
        else:
            worksheet.append(row_data)

        # Save the workbook
        workbook.save(excel_resource['file_path'])

    # The main function is not called, as per the instructions.
  id: |-
    synthetic_add-a-worksheet-tablerow
  instructions: |-
    Adds rows to the end of specific table in microsoft excel
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    microsoft_excel
  resource_type_def: |-
    class microsoft_excel(TypedDict):
        file_path: str
        access_token: str  # Assuming OAuth2 is used and the token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the Gong integration
    class gong(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for listing calls
    def main(gong_resource: gong, start_date: str, end_date: str) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for listing calls
        endpoint = f"{gong_resource['base_url']}/calls/list"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {gong_resource['api_key']}"
        }

        # Set up the parameters for the date range
        params = {
            "start_date": start_date,
            "end_date": end_date
        }

        # Make the request to the Gong API
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of calls
            return response.json()['calls']
        else:
            # Handle errors (you could raise an exception or return an error message)
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  good: |-
    from typing import TypedDict, List, Any
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the 'gong' integration
    class gong(TypedDict):
        api_key: str
        base_url: str

    def main(gong_resource: gong, start_date: str, end_date: str) -> List[Any]:
        """
        Fetches a list of calls from Gong within a specified date range.

        :param gong_resource: A dictionary containing the 'api_key' and 'base_url' for Gong API.
        :param start_date: The start date for filtering calls in ISO 8601 format (YYYY-MM-DD).
        :param end_date: The end date for filtering calls in ISO 8601 format (YYYY-MM-DD).
        :return: A list of calls.
        """
        headers = {
            'Authorization': f'Bearer {gong_resource["api_key"]}'
        }
        params = {
            'from': start_date,
            'to': end_date
        }
        response = requests.get(f'{gong_resource["base_url"]}/api/v2/calls', headers=headers, params=params)
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        return response.json()

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_list-calls
  instructions: |-
    List calls in gong
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gong
  resource_type_def: |-
    class gong(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the nethunt_crm integration
    class nethunt_crm(TypedDict):
        api_key: str
        api_url: str

    # Define the main function for creating a comment in NetHunt CRM
    def main(nethunt_crm_resource: nethunt_crm, record_id: str, comment_text: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a comment
        endpoint = f"{nethunt_crm_resource['api_url']}/records/{record_id}/comments"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {nethunt_crm_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload with the comment text
        data = {
            "text": comment_text
        }

        # Make the POST request to create the comment
        response = requests.post(endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created comment as a JSON object
        else:
            # If the request failed, raise an exception with the error message
            response.raise_for_status()

    # The main function is now defined and ready to be used with the specified parameters
  good: |-
    from typing import TypedDict, Any
    import nethunt as nh_module  # Assuming 'nethunt' is the module name and it conflicts with the resource type name

    class nethunt_crm(TypedDict):
        api_key: str
        workspace_id: str

    def main(nethunt_resource: nethunt_crm, record_id: str, comment_text: str) -> Any:
        nh_client = nh_module.Client(api_key=nethunt_resource['api_key'], workspace_id=nethunt_resource['workspace_id'])
        comment = nh_client.create_record_comment(record_id=record_id, text=comment_text)
        return comment
  id: |-
    synthetic_create-comment
  instructions: |-
    Create a new record comment in nethunt crm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nethunt_crm
  resource_type_def: |-
    class nethunt_crm(TypedDict):
        api_key: str
        api_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Ifttt = {
        apiKey: string
    }

    export async function main(iftttResource: Ifttt, eventName: string, jsonData: Record<string, unknown>) {
        const url = `https://maker.ifttt.com/trigger/${eventName}/with/key/${iftttResource.apiKey}`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${encode(iftttResource.apiKey)}`
            },
            body: JSON.stringify(jsonData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    type Ifttt = {
        apiKey: string;
        eventName: string;
    }

    export async function main(iftttResource: Ifttt, jsonPayload: Record<string, unknown>) {
        const iftttUrl = `https://maker.ifttt.com/trigger/${iftttResource.eventName}/with/key/${iftttResource.apiKey}`;
        const response = await fetch(iftttUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(jsonPayload),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_trigger-event-with-json
  instructions: |-
    Trigger Event with an arbitrary JSON payload in ifttt
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Ifttt
  resource_type_def: |-
    type Ifttt = {
        apiKey: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing the necessary library to make HTTP requests
    import { fetch } from "npm:@deno/fetch";

    type HtmlCssToImage = {
        userId: string;
        apiKey: string;
    }

    export async function main(htmlCssToImageResource: HtmlCssToImage, html: string, css: string, outputFormat: 'jpg' | 'png' = 'png') {
        const endpoint = 'https://hcti.io/v1/image';
        const auth = `Basic ${btoa(`${htmlCssToImageResource.userId}:${htmlCssToImageResource.apiKey}`)}`;

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': auth,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                html: html,
                css: css,
                output: outputFormat,
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    import { createApi } from "npm:@htmlcsstoimage/sdk";

    type HtmlCssToImage = {
        userId: string;
        apiKey: string;
    }

    export async function main(htmlCssToImageResource: HtmlCssToImage, imageUrl: string, width: number = 800, height: number = 600) {
        const hcti = createApi({
            userId: htmlCssToImageResource.userId,
            apiKey: htmlCssToImageResource.apiKey,
        });

        const data = {
            html: `<div style="width:100%;height:100%;background:url('${imageUrl}') no-repeat center center;background-size:cover;"></div>`,
            css: "",
            google_fonts: "",
            width: width,
            height: height,
        };

        try {
            const image = await hcti.createImage(data);
            return image.url;
        } catch (error) {
            console.error('Error creating image:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-image-from-url
  instructions: |-
    Create Image From URL. in html css to image
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HtmlCssToImage
  resource_type_def: |-
    type HtmlCssToImage = {
        userId: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bingx as BingxClient } from "npm:@bingx/sdk"; // Rename the imported Bingx to avoid conflict

    type Bingx = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for BingX authentication
    }

    export async function main(bingxConfig: Bingx, symbol: string) {
        // Initialize the BingX client with the provided credentials
        const bingxClient = new BingxClient({
            apiKey: bingxConfig.apiKey,
            apiSecret: bingxConfig.apiSecret,
        });

        // Fetch market trades for the specified symbol
        const marketTrades = await bingxClient.getMarketTrades(symbol);

        // Return the result
        return marketTrades;
    }
  good: |-
    // Import any libraries you need here
    import { Bingx } from 'npm:@types/bingx'; // Assuming there's a type definition for Bingx in npm

    type BingxResource = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for Bingx authentication/configuration
    }

    export async function main(bingxResource: BingxResource, tradingPair: string) {
        // Assuming there's a Bingx client library that we can use to interact with the Bingx API
        const bingxClient = new Bingx(bingxResource.apiKey, bingxResource.apiSecret);

        // Fetch the latest trade of the specified trading pair
        const latestTrade = await bingxClient.getLatestTrade(tradingPair);

        // Return the result
        return latestTrade;
    }
  id: |-
    synthetic_market-get-market-trades
  instructions: |-
    The latest Trade of a Trading Pair. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        apiSecret: string;
        // Add any other properties needed for BingX authentication
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { stringify } from "npm:qs";

    type Discourse = {
        apiKey: string;
        apiUsername: string;
        discourseUrl: string;
    }

    export async function main(discourseResource: Discourse, title: string, content: string, categoryId: number) {
        const { apiKey, apiUsername, discourseUrl } = discourseResource;
        const url = `${discourseUrl}/posts.json`;

        const body = stringify({
            title,
            raw: content,
            category: categoryId,
            api_key: apiKey,
            api_username: apiUsername
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/encoding/base64";

    type Discourse = {
        apiKey: string;
        apiUsername: string;
        discourseUrl: string;
    }

    export async function main(discourseResource: Discourse, title: string, content: string, categoryId: number) {
        const url = `${discourseResource.discourseUrl}/posts.json`;
        const body = new URLSearchParams({
            'title': title,
            'raw': content,
            'category': categoryId.toString(),
            'api_key': discourseResource.apiKey,
            'api_username': discourseResource.apiUsername
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': `Basic ${encode(`${discourseResource.apiUsername}:${discourseResource.apiKey}`)}`
            },
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-post
  instructions: |-
    Creates a post in discourse
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Discourse
  resource_type_def: |-
    type Discourse = {
        apiKey: string;
        apiUsername: string;
        discourseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Mastodon } from "npm:mastodon-api";

    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodonResource: Mastodon, maxItems: number = 20) {
        const M = new Mastodon({
            access_token: mastodonResource.accessToken,
            timeout_ms: 60 * 1000,  // 60sec
            api_url: mastodonResource.apiUrl + '/api/v1/'
        });

        try {
            const response = await M.get('timelines/home', { limit: maxItems });
            return response.data;
        } catch (error) {
            console.error('Error fetching Mastodon timeline:', error);
            throw error;
        }
    }
  good: |-
    import { Mastodon } from "npm:mastodon-api";

    type MastodonResource = {
        accessToken: string,
        apiUrl: string
    }

    export async function main(mastodonResource: MastodonResource, listId: string) {
        const mastodonClient = new Mastodon({
            access_token: mastodonResource.accessToken,
            api_url: mastodonResource.apiUrl
        });

        const response = await mastodonClient.get(`timelines/list/${listId}`);
        return response.data;
    }
  id: |-
    synthetic_view-list-timeline
  instructions: |-
    View statuses in the given list timeline in mastodon
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mastodon
  resource_type_def: |-
    type Mastodon = {
        accessToken: string,
        apiUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'noticeable' integration
    class noticeable(TypedDict):
        api_key: str  # API key for authentication with the Noticeable platform

    # Main function to create an email subscription in Noticeable
    def main(noticeable_resource: noticeable, email: str, project_id: str, locale: str = 'en'):
        import requests  # Import requests or any other library if needed

        # Noticeable API endpoint to create a subscription
        api_endpoint = f"https://api.noticeable.io/v1/projects/{project_id}/subscriptions"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {noticeable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Data payload for the subscription
        data = {
            "email": email,
            "locale": locale
        }

        # Make the API request to create the subscription
        response = requests.post(api_endpoint, json=data, headers=headers)

        # Check for successful response and return accordingly
        if response.status_code == 200:
            return {"success": True, "message": "Subscription created successfully."}
        else:
            return {"success": False, "message": "Failed to create subscription.", "error": response.text}

    # Note: The function does not call itself, it's ready to be exported and used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'noticeable' integration
    class noticeable(TypedDict):
        api_key: str
        project_id: str

    # Define the main function for creating an email subscription
    def main(noticeable_resource: noticeable, email: str, label: str = None) -> dict:
        import requests  # Import requests or any other necessary library here

        # Construct the API endpoint for creating a subscription
        endpoint = f"https://api.noticeable.io/v1/projects/{noticeable_resource['project_id']}/subscriptions"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {noticeable_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the email and optional label
        payload = {
            "email": email,
            "label": label
        }

        # Make the POST request to create the subscription
        response = requests.post(endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return {"success": True, "message": "Subscription created successfully."}
        else:
            return {"success": False, "message": "Failed to create subscription.", "error": response.json()}

    # Note: The function does not call itself, it's meant to be exported and used elsewhere.
  id: |-
    synthetic_create-email-subscription
  instructions: |-
    Creates an email subscription, in noticeable
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    noticeable
  resource_type_def: |-
    class noticeable(TypedDict):
        api_key: str
        project_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { Coinmarketcal as CoinmarketcalClient } from 'npm:coinmarketcal-api-client';

    type Coinmarketcal = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(coinmarketcalResource: Coinmarketcal) {
        // Initialize the Coinmarketcal client with the provided credentials
        const client = new CoinmarketcalClient(coinmarketcalResource.apiKey, coinmarketcalResource.apiSecret);

        // Fetch the list of coins from Coinmarketcal
        const coinsList = await client.getCoins();

        // Return the result
        return coinsList;
    }
  good: |-
    // Importing necessary libraries
    import { Coinmarketcal } from 'npm:coinmarketcal-api-client';

    type CoinmarketcalResource = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(coinmarketcalResource: CoinmarketcalResource) {
        // Initialize the CoinMarketCal client with the provided credentials
        const client = new Coinmarketcal(coinmarketcalResource.apiKey, coinmarketcalResource.apiSecret);

        // Fetch the list of all available coins from CoinMarketCal
        const coinsList = await client.getCoins();

        // Return the result
        return coinsList;
    }
  id: |-
    synthetic_list-coins
  instructions: |-
    Obtain a list of all available coins in CoinMarketCal in coinmarketcal
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Coinmarketcal
  resource_type_def: |-
    type Coinmarketcal = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:airtable";

    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }

    export async function main(
        airtableResource: AirtableOauth,
        tableName: string,
        records: Array<{ [key: string]: any }>
    ) {
        const base = new Base({ apiKey: airtableResource.apiKey })(airtableResource.baseId);
        const table = base(tableName);

        try {
            const createdRecords = await table.create(records);
            return createdRecords;
        } catch (error) {
            console.error('Error creating records in Airtable:', error);
            throw error;
        }
    }
  good: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableOauth = {
        apiKey: string,
        baseId: string,
        tableName: string
    }

    export async function main(airtableResource: AirtableOauth, recordsToCreate: Array<{ [fieldName: string]: any }>) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(airtableResource.tableName);

        try {
            const createdRecords = await table.createRecordsAsync(recordsToCreate);
            return createdRecords;
        } catch (error) {
            console.error("Error creating records in Airtable:", error);
            throw error;
        }
    }
  id: |-
    synthetic_create-multiple-records
  instructions: |-
    Create one or more records in a table by passing an array of objects containing field names and values as key/value pairs. in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string,
        baseId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the beanstalkapp integration
    class beanstalkapp(TypedDict):
        api_url: str
        access_token: str

    def main(beanstalkapp_resource: beanstalkapp, repository_id: int, changeset_id: str):
        # Assuming that the 'requests' library is used to make HTTP requests to the Beanstalk API
        import requests

        # Construct the URL for the code review endpoint
        code_review_url = f"{beanstalkapp_resource['api_url']}/repositories/{repository_id}/changesets/{changeset_id}/reviews.json"

        # Set up the headers with the access token for authentication
        headers = {
            'Authorization': f"Bearer {beanstalkapp_resource['access_token']}",
            'Content-Type': 'application/json'
        }

        # Make the request to the Beanstalk API to create a code review
        response = requests.post(code_review_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the JSON response if the code review was created successfully
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  good: |-
    import requests
    from typing import TypedDict, Optional

    class beanstalkapp(TypedDict):
        api_token: str
        account_name: str
        repository_id: str

    def main(beanstalkapp_resource: beanstalkapp, changeset: str, reviewer_username: str, title: Optional[str] = None):
        base_url = f"https://{beanstalkapp_resource['account_name']}.beanstalkapp.com/api/"
        headers = {
            "Authorization": f"Bearer {beanstalkapp_resource['api_token']}",
            "Content-Type": "application/json"
        }
        data = {
            "changeset": changeset,
            "reviewer_username": reviewer_username
        }
        if title:
            data["title"] = title

        response = requests.post(
            f"{base_url}repositories/{beanstalkapp_resource['repository_id']}/code_reviews.json",
            headers=headers,
            json=data
        )

        if response.status_code == 201:
            return response.json()
        else:
            raise Exception(f"Error creating code review: {response.status_code} {response.text}")
  id: |-
    synthetic_create-code-review
  instructions: "Creates a new code review. This action is essentially the same as\
    \ clicking the \u201CRequest review\u201D button in the app. in beanstalkapp"
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    beanstalkapp
  resource_type_def: |-
    class beanstalkapp(TypedDict):
        api_url: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        accessToken: string;
    }

    export async function main(
        githubResource: Github,
        owner: string,
        repo: string,
        path: string,
        content: string,
        message: string,
        branch: string = 'main',
        sha?: string
    ) {
        const octokit = new Octokit({ auth: githubResource.accessToken });

        const params = {
            owner,
            repo,
            path,
            message,
            content: Buffer.from(content).toString('base64'),
            branch,
        };

        if (sha) {
            params['sha'] = sha;
        }

        try {
            const response = await octokit.repos.createOrUpdateFileContents(params);
            return response.data;
        } catch (error) {
            throw new Error(`Failed to create or update file: ${error.message}`);
        }
    }
  good: |-
    import { Octokit } from "npm:@octokit/rest";

    type Github = {
        token: string;
        owner: string;
        repo: string;
    }

    export async function main(githubResource: Github, filePath: string, fileContent: string, commitMessage: string, branch: string = 'main') {
        const octokit = new Octokit({ auth: githubResource.token });

        // Retrieve the SHA of the file to be updated or create a new one
        let sha: string | undefined;
        try {
            const response = await octokit.rest.repos.getContent({
                owner: githubResource.owner,
                repo: githubResource.repo,
                path: filePath,
                ref: branch
            });
            sha = (response.data as any).sha;
        } catch (error) {
            if (error.status !== 404) {
                throw error;
            }
            // If the file does not exist, it will be created
        }

        // Create or update the file
        const result = await octokit.rest.repos.createOrUpdateFileContents({
            owner: githubResource.owner,
            repo: githubResource.repo,
            path: filePath,
            message: commitMessage,
            content: Buffer.from(fileContent).toString('base64'),
            sha: sha,
            branch: branch
        });

        return result;
    }
  id: |-
    synthetic_create-or-update-file-contents
  instructions: |-
    Create or update a file in a repository. This will replace an existing file in github
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the LinkedIn integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    # Define the main function for getting the current member profile
    def main(linkedin_resource: linkedin):
        import requests  # Import requests or any other library if needed

        # Define the API endpoint for LinkedIn to get the current member's profile
        url = "https://api.linkedin.com/v2/me"

        # Set up the headers with the OAuth2 access token
        headers = {
            "Authorization": f"Bearer {linkedin_resource['access_token']}"
        }

        # Make the HTTP GET request to LinkedIn API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response to JSON and return the profile data
            return response.json()
        else:
            # Handle errors (e.g., by raising an exception or returning an error message)
            response.raise_for_status()

    # The script ends here, with no call to the main function as per the instructions.
  good: |-
    from typing import TypedDict, Dict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the linkedin integration
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token

    def main(linkedin_resource: linkedin, fields: str = 'id,firstName,lastName'):
        """
        Fetches the profile of the current authenticated member in LinkedIn.

        :param linkedin_resource: A dictionary containing the LinkedIn credentials.
        :param fields: A comma-separated list of fields to be retrieved for the profile.
        :return: A dictionary containing the LinkedIn profile information.
        """
        headers = {
            'Authorization': f"Bearer {linkedin_resource['access_token']}",
            'Cache-Control': 'no-cache',
            'X-Restli-Protocol-Version': '2.0.0'  # Required for LinkedIn API calls
        }
        url = f"https://api.linkedin.com/v2/me?projection=({fields})"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()

    # The main function is not called, as per the instructions.
  id: |-
    synthetic_get-current-member-profile
  instructions: |-
    Gets the profile of the current authenticated member in linkedin
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        access_token: str  # OAuth2 Access Token
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { generate } from "npm:@cohere/ai";

    type CoherePlatform = {
        apiKey: string;
    }

    export async function main(coherePlatformResource: CoherePlatform, textToSummarize: string) {
        const cohereResponse = await generate({
            model: 'large',
            prompt: `Summarize the following text in English:\n\n${textToSummarize}\n\nSummary:`,
            max_tokens: 50,
            temperature: 0.5,
            k: 0,
            p: 1,
            frequency_penalty: 0,
            presence_penalty: 0,
            stop_sequences: ["\n"],
            return_likelihoods: 'NONE'
        }, {
            headers: {
                'Authorization': `Bearer ${coherePlatformResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        return cohereResponse.text;
    }
  good: |-
    import { summarize as cohereSummarize } from "npm:@cohere-ai/cohere";

    type CoherePlatform = {
        apiKey: string;
    }

    export async function main(cohereResource: CoherePlatform, textToSummarize: string, maxLength: number) {
        const cohereApiKey = cohereResource.apiKey;
        const response = await cohereSummarize({
            apiKey: cohereApiKey,
            text: textToSummarize,
            maxLength: maxLength,
        });

        return response;
    }
  id: |-
    synthetic_summarize-text
  instructions: |-
    This action generates a summary in English for the given text in cohere platform
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CoherePlatform
  resource_type_def: |-
    type CoherePlatform = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        languageCode: string; // e.g., 'en-US'
    }

    export async function main(dialogflowResource: GoogleDialogflow, sessionId: string, query: string) {
        // Initialize the Dialogflow client with credentials
        const sessionClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail,
            },
            projectId: dialogflowResource.projectId,
        });

        // Define the session path
        const sessionPath = sessionClient.projectAgentSessionPath(dialogflowResource.projectId, sessionId);

        // The text query request.
        const request = {
            session: sessionPath,
            queryInput: {
                text: {
                    text: query,
                    languageCode: dialogflowResource.languageCode,
                },
            },
        };

        // Send request and log result
        const responses = await sessionClient.detectIntent(request);
        const result = responses[0].queryResult;

        // Return the query result
        return result;
    }
  good: |-
    // Importing necessary libraries
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(dialogflowResource: GoogleDialogflow, sessionId: string, query: string, languageCode: string = 'en-US') {
        // Initialize the Dialogflow client with credentials
        const sessionClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail,
            },
            projectId: dialogflowResource.projectId,
        });

        // Define the session path
        const sessionPath = sessionClient.projectAgentSessionPath(dialogflowResource.projectId, sessionId);

        // The text query request.
        const request = {
            session: sessionPath,
            queryInput: {
                text: {
                    text: query,
                    languageCode: languageCode,
                },
            },
        };

        // Send request and log result
        const responses = await sessionClient.detectIntent(request);
        const result = responses[0].queryResult;

        // Return the query result
        return result;
    }
  id: |-
    synthetic_get-context
  instructions: |-
    Get a context, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
        environment?: string;
    }

    export async function main(dialogflowResource: GoogleDialogflow, entityTypeName: string, languageCode: string = 'en') {
        const dialogflowClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail,
            },
            projectId: dialogflowResource.projectId,
        });

        const formattedParent = dialogflowClient.entityTypePath(dialogflowResource.projectId, '-', entityTypeName);

        const request = {
            name: formattedParent,
            languageCode: languageCode,
        };

        const [response] = await dialogflowClient.getEntityType(request);
        return response;
    }
  good: |-
    import { SessionsClient } from "npm:@google-cloud/dialogflow";

    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
    }

    export async function main(dialogflowResource: GoogleDialogflow, sessionId: string, entityTypeName: string) {
        const dialogflowClient = new SessionsClient({
            credentials: {
                private_key: dialogflowResource.privateKey,
                client_email: dialogflowResource.clientEmail,
            },
            projectId: dialogflowResource.projectId,
        });

        const sessionPath = dialogflowClient.projectAgentSessionPath(dialogflowResource.projectId, sessionId);
        const entityTypePath = `${sessionPath}/entityTypes/${entityTypeName}`;

        try {
            const response = await dialogflowClient.getEntityType({ name: entityTypePath });
            return response;
        } catch (error) {
            console.error(`Failed to get entity type: ${error}`);
            throw error;
        }
    }
  id: |-
    synthetic_get-entity-type
  instructions: |-
    Retrieves an Entity Type, and in google dialogflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDialogflow
  resource_type_def: |-
    type GoogleDialogflow = {
        projectId: string;
        privateKey: string;
        clientEmail: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type DockCerts = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(dockCertsResource: DockCerts) {
        const credentials = {
            apiKey: dockCertsResource.apiKey,
            apiSecret: dockCertsResource.apiSecret
        };

        // Assuming the API endpoint to list credentials is as follows
        const endpoint = 'https://api.dockcerts.com/credentials';

        const response = await fetch(endpoint, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${credentials.apiKey}:${credentials.apiSecret}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    type DockCerts = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(dockCertsResource: DockCerts) {
        const credentialsListUrl = 'https://api.dock.io/v1/certificates';

        const response = await fetch(credentialsListUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${dockCertsResource.apiKey}:${dockCertsResource.apiSecret}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_list-credentials
  instructions: |-
    List existing credentials in dock certs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DockCerts
  resource_type_def: |-
    type DockCerts = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import cohere  # Assuming 'cohere' is the library for the 'cohere_platform' integration

    class cohere_platform(TypedDict):
        api_key: str

    def main(cohere_resource: cohere_platform, text_to_summarize: str) -> str:
        co = cohere.Client(cohere_resource['api_key'])
        summary = co.generate(prompt=f"Summarize the following text: {text_to_summarize}",
                              model='large',
                              max_tokens=60,
                              temperature=0.5).text
        return summary
  good: |-
    from typing import TypedDict
    import cohere  # Assuming cohere is the library for the cohere platform

    class cohere_platform(TypedDict):
        api_key: str

    def main(cohere_resource: cohere_platform, text_to_summarize: str) -> str:
        co = cohere.Client(cohere_resource['api_key'])
        response = co.generate(
            model='large',
            prompt=f"Summarize the following text in English:\n\n{text_to_summarize}",
            max_tokens=50,
            temperature=0.5
        )
        return response.generations[0].text
  id: |-
    synthetic_summarize-text
  instructions: |-
    This action generates a summary in English for the given text in cohere platform
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cohere_platform
  resource_type_def: |-
    class cohere_platform(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Demio = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(demioResource: Demio, eventId: number, registrantId: number) {
        const authHeader = `Basic ${encode(`${demioResource.apiKey}:${demioResource.apiSecret}`)}`;

        const response = await fetch(`https://my.demio.com/api/v1/event/${eventId}/registrant/${registrantId}/join-link`, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching join link: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        return data.join_link;
    }
  good: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Demio = {
        apiKey: string,
        apiSecret: string
    }

    export async function main(demioResource: Demio, webinarId: number, registrantName: string, registrantEmail: string) {
        // Construct the API endpoint for creating a join link
        const endpoint = `https://my.demio.com/api/v1/webinar/${webinarId}/registrant`;

        // Encode the API credentials
        const credentials = encode(`${demioResource.apiKey}:${demioResource.apiSecret}`);

        // Set up the request headers
        const headers = new Headers({
            'Authorization': `Basic ${credentials}`,
            'Content-Type': 'application/json'
        });

        // Set up the request body with the registrant's details
        const body = JSON.stringify({
            name: registrantName,
            email: registrantEmail
        });

        // Make the POST request to create a join link
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: body
        });

        // Parse the response
        const result = await response.json();

        // Check if the request was successful
        if (!response.ok) {
            throw new Error(`Error creating join link: ${result.error}`);
        }

        // Return the join link
        return result.join_link;
    }
  id: |-
    synthetic_create-join-link
  instructions: |-
    Create Join Link in demio
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Demio
  resource_type_def: |-
    type Demio = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Livestorm as LivestormPlugin } from "npm:@livestorm/plugin";

    type Livestorm = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(livestorm: Livestorm, email: string, firstName: string, lastName: string, webinarId: string) {
        const { apiKey, apiSecret } = livestorm;

        // Set up the authorization header for the API request
        const headers = new Headers({
            'Authorization': `Basic ${btoa(`${apiKey}:${apiSecret}`)}`,
            'Content-Type': 'application/json'
        });

        // Define the API endpoint for registering a participant
        const registerEndpoint = `https://api.livestorm.co/v1/webinars/${webinarId}/registrations`;

        // Prepare the registration data
        const registrationData = {
            email,
            first_name: firstName,
            last_name: lastName
        };

        // Make the API request to register the participant
        const response = await fetch(registerEndpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(registrationData)
        });

        // Check if the registration was successful
        if (!response.ok) {
            throw new Error(`Failed to register participant: ${response.status} ${response.statusText}`);
        }

        // Return the registration confirmation
        return await response.json();
    }
  good: |-
    // Import necessary libraries
    import { encode } from "npm:base-64";

    type Livestorm = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(livestormResource: Livestorm, sessionId: string, participantEmail: string, participantFirstName: string, participantLastName: string, isTeamMember: boolean) {
        // Construct the basic auth header
        const basicAuth = `Basic ${encode(`${livestormResource.apiKey}:${livestormResource.apiSecret}`)}`;

        // Define the API endpoint for registering a participant
        const endpoint = `https://api.livestorm.co/v1/sessions/${sessionId}/registrations`;

        // Construct the participant data
        const participantData = {
            email: participantEmail,
            first_name: participantFirstName,
            last_name: participantLastName,
            role: isTeamMember ? 'team_member' : 'registrant'
        };

        // Make the API request to register the participant
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': basicAuth,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(participantData)
        });

        // Check for successful response
        if (!response.ok) {
            throw new Error(`Error registering participant: ${response.status} ${response.statusText}`);
        }

        // Return the result
        return await response.json();
    }
  id: |-
    synthetic_register-someone-for-session
  instructions: |-
    Register a new participant for a session (either an external registrant or internal team member) in livestorm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Livestorm
  resource_type_def: |-
    type Livestorm = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { v4 as uuidv4 } from "npm:uuid";

    type Centralstationcrm = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(centralstationcrmResource: Centralstationcrm, personDetails: { firstName: string, lastName: string, email: string, company?: string, jobTitle?: string }) {
        const { apiKey, apiUrl } = centralstationcrmResource;
        const { firstName, lastName, email, company, jobTitle } = personDetails;

        const url = `${apiUrl}/people`;
        const body = {
            person: {
                first_name: firstName,
                last_name: lastName,
                email: email,
                company: company,
                job_title: jobTitle,
                // Add any additional fields here
            }
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CentralStationCRM-API-Token': apiKey,
            },
            body: JSON.stringify(body),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:@std/encoding/base64";

    type Centralstationcrm = {
        apiKey: string;
        accountId: string;
    }

    export async function main(centralstationcrmResource: Centralstationcrm, personDetails: { firstName: string, lastName: string, email?: string, phone?: string }) {
        const apiUrl = `https://${centralstationcrmResource.accountId}.centralstationcrm.net/people.json`;
        const authHeader = `Basic ${encode(`${centralstationcrmResource.apiKey}:x`)}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                person: {
                    first_name: personDetails.firstName,
                    last_name: personDetails.lastName,
                    contact_data: {
                        email_addresses: personDetails.email ? [{ address: personDetails.email }] : [],
                        phone_numbers: personDetails.phone ? [{ number: personDetails.phone }] : []
                    }
                }
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-person
  instructions: |-
    Creates a new person in CentralStationCRM in centralstationcrm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Centralstationcrm
  resource_type_def: |-
    type Centralstationcrm = {
        apiKey: string;
        apiUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOutlook = {
        clientId: string;
        tenantId: string;
        clientSecret: string;
        accessToken: string;
    }

    export async function main(microsoftOutlookResource: MicrosoftOutlook) {
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsoftOutlookResource.accessToken); // Assuming the accessToken is always up-to-date
            }
        });

        try {
            const contacts = await client.api('/me/contacts').get();
            return contacts;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type MicrosoftOutlook = {
        accessToken: string;
    }

    export async function main(outlookResource: MicrosoftOutlook) {
        const client = Client.init({
            authProvider: (done) => {
                done(null, outlookResource.accessToken); // Here we are providing the access token to the authProvider
            }
        });

        try {
            // Get the list of contacts from the user's mailbox
            const contacts = await client.api('/me/contacts').get();

            // Return the list of contacts
            return contacts;
        } catch (error) {
            // Handle any errors that occur during the API call
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_list-contacts
  instructions: |-
    Get a contact collection from the default contacts folder, in microsoft outlook
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MicrosoftOutlook
  resource_type_def: |-
    type MicrosoftOutlook = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests library is used for HTTP requests

    class ahrefs(TypedDict):
        access_token: str
        target: str

    def main(ahrefs_resource: ahrefs, url: str, limit: int = 100) -> List[Dict]:
        headers = {
            'Authorization': f"Bearer {ahrefs_resource['access_token']}",
            'Content-Type': 'application/json'
        }
        params = {
            'target': ahrefs_resource['target'],
            'limit': limit,
            'output': 'json',
            'from': 'backlinks',
            'select': 'url_from,title,anchor'
        }
        response = requests.get(f"https://apiv2.ahrefs.com?target={url}", headers=headers, params=params)
        backlinks_data = response.json()

        return backlinks_data.get('refpages', [])

    # Example usage:
    # backlinks = main(ahrefs_resource={'access_token': 'your_access_token', 'target': 'your_target_domain'}, url='https://example.com')
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the ahrefs integration
    class ahrefs(TypedDict):
        access_token: str
        account_id: str

    # Define the main function for getting backlinks from ahrefs
    def main(ahrefs_resource: ahrefs, target_url: str, limit: int = 100) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Define the endpoint and parameters for the ahrefs API call
        endpoint = "https://apiv2.ahrefs.com"
        params = {
            "from": "backlinks",
            "target": target_url,
            "limit": limit,
            "token": ahrefs_resource['access_token'],
            "output": "json"
        }

        # Make the API call to ahrefs
        response = requests.get(endpoint, params=params)
        response.raise_for_status()  # Raise an exception for HTTP errors

        # Parse the response to JSON
        backlinks_data = response.json()

        # Extract the backlinks information
        backlinks = backlinks_data.get('backlinks', [])

        # Return the list of backlinks
        return backlinks

    # Note: The function does not call itself, it's ready to be exported and used with the required parameters.
  id: |-
    synthetic_get-backlinks
  instructions: |-
    Get the backlinks for a domain or URL with details for the referring pages (e.g., anchor and page title). in ahrefs
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ahrefs
  resource_type_def: |-
    class ahrefs(TypedDict):
        access_token: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Gmail } from "npm:@googleapis/gmail";

    type GmailCustomOauth = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string,
        redirectUri: string,
        scope: string,
        tokenType: string,
        expiryDate: number
    }

    export async function main(gmailCustomOauthResource: GmailCustomOauth, userEmail: string, searchQuery: string) {
        const gmail = new Gmail({ version: 'v1', auth: gmailCustomOauthResource.accessToken });

        const response = await gmail.users.messages.list({
            userId: userEmail,
            q: searchQuery
        });

        return response.data;
    }
  good: |-
    // Import necessary libraries
    import { Gmail as GmailAPI } from "npm:@googleapis/gmail";

    type GmailCustomOauth = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string,
        redirectUri: string
    }

    export async function main(gmailResource: GmailCustomOauth, userEmail: string, query: string) {
        const gmail = new GmailAPI({ version: 'v1' });
        gmail.auth.setCredentials({
            access_token: gmailResource.accessToken,
            refresh_token: gmailResource.refreshToken,
            client_id: gmailResource.clientId,
            client_secret: gmailResource.clientSecret,
            redirect_uri: gmailResource.redirectUri
        });

        const response = await gmail.users.messages.list({
            userId: userEmail,
            q: query
        });

        return response.data;
    }
  id: |-
    synthetic_find-email
  instructions: |-
    Find an email using Google's Search Engine in gmail custom oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GmailCustomOauth
  resource_type_def: |-
    type GmailCustomOauth = {
        accessToken: string,
        refreshToken: string,
        clientId: string,
        clientSecret: string,
        redirectUri: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the google_chat integration
    class google_chat(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the Google Chat API client library, renaming if necessary
    try:
        from google_chat import spaces as google_chat_spaces
    except ImportError:
        google_chat_spaces = None

    # If the import name conflicts, import the library with a different name
    if google_chat_spaces is None:
        from some_other_google_chat_library import spaces as google_chat_spaces

    def main(google_chat_resource: google_chat) -> List[str]:
        """
        Lists the spaces the bot is a part of in Google Chat.

        :param google_chat_resource: A dictionary containing the 'access_token' for Google Chat API.
        :return: A list of space names.
        """
        # Set up the API client with the provided access token
        # This is a placeholder for the actual API client setup, which would vary based on the library used
        api_client = google_chat_spaces.GoogleChatSpacesClient(access_token=google_chat_resource['access_token'])

        # Fetch the list of spaces
        spaces = api_client.list_spaces()

        # Extract the names of the spaces
        space_names = [space.name for space in spaces]

        return space_names

    # Note: The actual implementation details inside the main function will vary based on the specific
    # Google Chat API client library used. The above code assumes a hypothetical client library and methods.
  good: |-
    from typing import TypedDict, List, Any
    import google_auth_library  # Hypothetical import, replace with actual required library

    # Assuming google_auth_library has a method that conflicts with the integration name
    from google_auth_library import some_method as renamed_some_method

    class google_chat(TypedDict):
        access_token: str
        refresh_token: str
        token_uri: str
        client_id: str
        client_secret: str
        scopes: List[str]

    def main(google_chat_resource: google_chat, max_results: int = 100) -> Any:
        # Assuming there's a library method to set up credentials and list spaces
        credentials = google_auth_library.credentials_from_dict(google_chat_resource)
        service = google_auth_library.build('chat', 'v1', credentials=credentials)

        # Call the Chat API to list spaces
        results = service.spaces().list(pageSize=max_results).execute()
        spaces = results.get('spaces', [])

        # Return the list of spaces
        return spaces
  id: |-
    synthetic_list-spaces
  instructions: |-
    Lists spaces the caller is a member of. Group chats and DMs aren't listed until the first message is sent in google chat
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_chat
  resource_type_def: |-
    class google_chat(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make API calls to Eventbrite

    class eventbrite(TypedDict):
        api_key: str
        token: str

    def main(eventbrite_resource: eventbrite, event_id: str) -> dict:
        headers = {
            'Authorization': f'Bearer {eventbrite_resource["token"]}',
            'Content-Type': 'application/json'
        }
        url = f'https://www.eventbriteapi.com/v3/events/{event_id}/'

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an error if the request fails

        event_summary = response.json()
        return event_summary
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the 'eventbrite' integration
    class eventbrite(TypedDict):
        api_key: str
        organizer_id: str

    def main(eventbrite_resource: eventbrite, event_id: str) -> Dict[str, Any]:
        # Base URL for Eventbrite API
        base_url = "https://www.eventbriteapi.com/v3"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {eventbrite_resource['api_key']}"
        }

        # Endpoint for getting event summary
        event_summary_url = f"{base_url}/events/{event_id}/"

        # Make the API request
        response = requests.get(event_summary_url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the event summary data
            return response.json()
        else:
            # Return an error message if the call was unsuccessful
            return {"error": "Failed to retrieve event summary", "status_code": response.status_code}

    # The main function is not called, as per the instructions.
  id: |-
    synthetic_get-event-summary
  instructions: |-
    Get event summary for a specified event in eventbrite
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    eventbrite
  resource_type_def: |-
    class eventbrite(TypedDict):
        api_key: str
        organizer_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Basecamp } from "npm:@basecamp/basecamp"; // Assuming there's a Basecamp package for npm

    type Basecamp = {
        accessToken: string,
        accountId: string
    }

    export async function main(basecampResource: Basecamp, projectId: number, content: string) {
        const basecamp = new Basecamp({
            accessToken: basecampResource.accessToken,
            accountId: basecampResource.accountId
        });

        const result = await basecamp.createComment({
            projectId: projectId,
            content: content
        });

        return result;
    }
  good: |-
    import { Base64 } from "npm:js-base64";

    type Basecamp = {
        accessToken: string;
        accountId: string;
        projectId: string;
        bucketId: string;
    }

    export async function main(basecampResource: Basecamp, recordingId: string, commentText: string) {
        const url = `https://3.basecampapi.com/${basecampResource.accountId}/buckets/${basecampResource.bucketId}/recordings/${recordingId}/comments.json`;
        const authHeader = `Bearer ${basecampResource.accessToken}`;
        const body = JSON.stringify({ content: commentText });

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
                'User-Agent': 'MyApp (yourname@example.com)'
            },
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-comment
  instructions: |-
    Publishes a comment to the select recording in basecamp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Basecamp
  resource_type_def: |-
    type Basecamp = {
        accessToken: string,
        accountId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { writeFile } from "npm:fs/promises";
    import { join } from "npm:path";
    import { tmpdir } from "npm:os";
    import { Dropbox } from "npm:dropbox";

    type DropboxResource = {
        accessToken: string;
    }

    export async function main(dropboxResource: DropboxResource, filePath: string) {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        const response = await dbx.filesDownload({ path: filePath });

        if ('fileBinary' in response.result) {
            const tempDir = tmpdir();
            const tempFilePath = join(tempDir, response.result.name);
            await writeFile(tempFilePath, response.result.fileBinary);
            return { path: tempFilePath };
        } else {
            throw new Error('File download failed.');
        }
    }
  good: |-
    import { Dropbox as DropboxClient, files } from "npm:dropbox";

    type Dropbox = {
        accessToken: string;
    }

    export async function main(dropbox: Dropbox, filePath: string, destinationPath: string = '/tmp/') {
        const dbx = new DropboxClient({ accessToken: dropbox.accessToken });

        try {
            const response = await dbx.filesDownload({ path: filePath });
            const fileBlob = response.result.fileBlob;
            const fileName = response.result.name;
            const dest = destinationPath + fileName;
            await Deno.writeFile(dest, new Uint8Array(await fileBlob.arrayBuffer()));
            return { success: true, message: `File downloaded to ${dest}` };
        } catch (error) {
            return { success: false, message: error.message };
        }
    }
  id: |-
    synthetic_download-file-to-tmp
  instructions: |-
    Download a specific file to the temporary directory. in dropbox
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dropbox
  resource_type_def: |-
    type Dropbox = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, member_email: str) -> dict:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        endpoint = f"/lists/{{list_id}}/members/{member_email.lower().encode('utf-8').hex()}"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        response = requests.delete(f"{base_url}{endpoint}", headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, list_id: str, member_email: str) -> dict:
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        members_endpoint = f"{base_url}/lists/{list_id}/members/{member_email.lower().encode('utf-8').hex()}"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        response = requests.delete(members_endpoint, headers=headers)
        return response.json()
  id: |-
    synthetic_delete-list-member
  instructions: |-
    Permanently deletes a member in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { difference as lodashDifference } from "npm:lodash";

    type DataStores = {
        apiKey: string;
        storeId: string;
    }

    export async function main(dataStoresResource: DataStores, localData: any[], remoteDataEndpoint: string) {
        // Fetch the remote data
        const response = await fetch(remoteDataEndpoint, {
            headers: {
                'Authorization': `Bearer ${dataStoresResource.apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const remoteData = await response.json();

        // Calculate the difference
        const differenceData = lodashDifference(localData, remoteData);

        // Return the result
        return differenceData;
    }
  good: |-
    type DataStoresResource = {
        storeAEndpoint: string;
        storeAAuthToken: string;
        storeBEndpoint: string;
        storeBAuthToken: string;
    }

    export async function main(dataStoresResource: DataStoresResource, additionalParam?: string) {
        const headersA = {
            'Authorization': `Bearer ${dataStoresResource.storeAAuthToken}`,
            'Content-Type': 'application/json'
        };

        const headersB = {
            'Authorization': `Bearer ${dataStoresResource.storeBAuthToken}`,
            'Content-Type': 'application/json'
        };

        const storeAFetch = fetch(dataStoresResource.storeAEndpoint, { headers: headersA });
        const storeBFetch = fetch(dataStoresResource.storeBEndpoint, { headers: headersB });

        const [storeAResponse, storeBResponse] = await Promise.all([storeAFetch, storeBFetch]);
        const storeAData = await storeAResponse.json();
        const storeBData = await storeBResponse.json();

        const storeAKeys = new Set(Object.keys(storeAData));
        const storeBKeys = new Set(Object.keys(storeBData));

        const difference = {};

        storeAKeys.forEach((key) => {
            if (!storeBKeys.has(key)) {
                difference[key] = storeAData[key];
            }
        });

        storeBKeys.forEach((key) => {
            if (!storeAKeys.has(key)) {
                difference[key] = storeBData[key];
            }
        });

        return difference;
    }
  id: |-
    synthetic_get-difference
  instructions: |-
    Get the difference between two data stores. Result contains key/value pairs where the key exists in one data store, but not the other. in data stores
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DataStores
  resource_type_def: |-
    type DataStores = {
        apiKey: string;
        storeId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the clockwork_recruiting integration
    class clockwork_recruiting(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for adding a phone number to a contact in Clockwork Recruiting
    def main(clockwork_resource: clockwork_recruiting, contact_id: int, phone_number: str, phone_type: str):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a contact
        endpoint = f"{clockwork_resource['base_url']}/contacts/{contact_id}/phones"

        # Prepare the data to be sent in the API request
        data = {
            "phone": {
                "number": phone_number,
                "phoneType": phone_type
            }
        }

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {clockwork_resource['api_key']}"
        }

        # Make the API request to add the phone number to the contact
        response = requests.post(endpoint, json=data, headers=headers)

        # Return the API response
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the clockwork_recruiting integration
    class clockwork_recruiting(TypedDict):
        api_key: str
        base_url: str

    def main(clockwork_resource: clockwork_recruiting, person_id: str, phone_number: str, phone_type: str = 'mobile'):
        """
        Adds a phone number to a specific person in Clockwork Recruiting.

        :param clockwork_resource: A dictionary containing the API key and base URL for the Clockwork Recruiting API.
        :param person_id: The ID of the person to whom the phone number will be added.
        :param phone_number: The phone number to add.
        :param phone_type: The type of the phone number (e.g., 'mobile', 'work', 'home'). Defaults to 'mobile'.
        :return: The response from the Clockwork Recruiting API.
        """
        headers = {
            'Authorization': f"Bearer {clockwork_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"{clockwork_resource['base_url']}/people/{person_id}/phone_numbers"
        payload = {
            'phone_number': {
                'number': phone_number,
                'phone_type': phone_type
            }
        }
        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_add-person-phone-number
  instructions: |-
    Add a phone number to a specific person in clockwork recruiting
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clockwork_recruiting
  resource_type_def: |-
    class clockwork_recruiting(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to CloudTables API

    # Define the resource type for the cloudtables integration
    class cloudtables(TypedDict):
        api_key: str
        table_id: str

    def main(cloudtables_resource: cloudtables, row_id: str, data: Dict[str, Any]):
        """
        Update a row in a CloudTable data set.

        :param cloudtables_resource: A dictionary containing the API key and table ID for CloudTables.
        :param row_id: The ID of the row to update.
        :param data: A dictionary of the data to update in the row.
        :return: The response from the CloudTables API.
        """
        # Construct the URL for the CloudTables API
        url = f"https://api.cloudtables.com/v1/tables/{cloudtables_resource['table_id']}/rows/{row_id}"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {cloudtables_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the HTTP request to update the row
        response = requests.patch(url, headers=headers, json=data)

        # Return the response from the API
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the cloudtables integration
    class cloudtables(TypedDict):
        api_key: str
        base_id: str

    # Define the main function for updating a row in a CloudTables table
    def main(cloudtables_resource: cloudtables, table_name: str, row_id: str, updated_data: Dict[str, Any]) -> Dict[str, Any]:
        import requests  # Import here to avoid conflicts with the resource type name

        # Construct the API endpoint for updating a row
        endpoint = f"https://api.cloudtables.com/v1/{cloudtables_resource['base_id']}/{table_name}/{row_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {cloudtables_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to update the row with the provided data
        response = requests.patch(endpoint, json=updated_data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated row data
        else:
            # If the request failed, raise an exception with the error message
            response.raise_for_status()

    # The main function is now defined and can be used to update a row in a CloudTables table
  id: |-
    synthetic_update-row
  instructions: |-
    Update a row in a CloudTable data set in cloudtables
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudtables
  resource_type_def: |-
    class cloudtables(TypedDict):
        api_key: str
        base_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    from helper_functions import html_to_markdown as convert_html_to_markdown

    class helper_functions(TypedDict):
        pass

    def main(api_key: str, html_content: str) -> str:
        markdown_content = convert_html_to_markdown(api_key, html_content)
        return markdown_content
  good: |-
    from typing import TypedDict, Any

    # Assuming 'turndown' is a function from a library named 'helper_functions'
    # and we need to rename it due to conflict with the resource type name.
    from helper_functions import turndown as turndown_function

    class helper_functions(TypedDict):
        api_key: str
        api_secret: str

    def main(helper_functions_resource: helper_functions, markdown_text: str) -> str:
        # Use the renamed 'turndown_function' with the provided markdown text
        html_content = turndown_function(markdown_text, helper_functions_resource['api_key'], helper_functions_resource['api_secret'])

        return html_content
  id: |-
    synthetic_html-to-markdown
  instructions: |-
    Convert via turndown in helper functions
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    helper_functions
  resource_type_def: |-
    class helper_functions(TypedDict):
        pass
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'expofp' integration
    class expofp(TypedDict):
        api_key: str

    # Define the main function for updating an exhibitor on the expofp platform
    def main(expofp_resource: expofp, exhibitor_id: str, exhibitor_name: str, booth_number: str, description: str):
        # Assuming there is a library 'expofp_api' that provides methods to interact with the expofp platform
        from expofp_api import update_exhibitor as update_exhibitor_api

        # Use the provided 'expofp_resource' to authenticate and update the exhibitor details
        result = update_exhibitor_api(
            api_key=expofp_resource['api_key'],
            exhibitor_id=exhibitor_id,
            name=exhibitor_name,
            booth=booth_number,
            description=description
        )

        # Return the result of the update operation
        return result
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the expofp integration
    class expofp(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for updating an exhibitor in expofp
    def main(expofp_resource: expofp, exhibitor_id: int, exhibitor_data: dict) -> Any:
        headers = {
            'Authorization': f"Bearer {expofp_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        url = f"{expofp_resource['base_url']}/exhibitors/{exhibitor_id}"

        response = requests.put(url, headers=headers, json=exhibitor_data)

        return response.json()
  id: |-
    synthetic_update-exhibitor
  instructions: |-
    Updates an exhibitor in expofp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    expofp
  resource_type_def: |-
    class expofp(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { BloomGrowth as BloomGrowthClient } from "npm:@bloomgrowth/sdk"; // Renamed the imported method to avoid conflict

    type BloomGrowth = {
        apiKey: string;
        projectId: string;
    }

    export async function main(bloomGrowthResource: BloomGrowth, issueTitle: string, issueDescription: string, issueLabels: string[]) {
        // Initialize the BloomGrowth client with the provided API key and project ID
        const bloomGrowthClient = new BloomGrowthClient(bloomGrowthResource.apiKey, bloomGrowthResource.projectId);

        // Create the issue in the BloomGrowth project
        const issue = await bloomGrowthClient.createIssue({
            title: issueTitle,
            description: issueDescription,
            labels: issueLabels,
        });

        // Return the created issue
        return issue;
    }
  good: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type BloomGrowth = {
        apiKey: string;
        apiUrl: string;
    }

    export async function main(bloomGrowthResource: BloomGrowth, title: string, description: string, startTime: string, durationMinutes: number) {
        const meetingId = uuidv4();
        const response = await fetch(`${bloomGrowthResource.apiUrl}/meetings`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${bloomGrowthResource.apiKey}`
            },
            body: JSON.stringify({
                id: meetingId,
                title: title,
                description: description,
                start_time: startTime,
                duration_minutes: durationMinutes
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-issue
  instructions: |-
    Create a new meeting issue in bloom growth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    BloomGrowth
  resource_type_def: |-
    type BloomGrowth = {
        apiKey: string;
        projectId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the 'amara' integration
    class amara(TypedDict):
        api_key: str
        team: str

    # Define the main function with the resource type and any additional parameters
    def main(amara_resource: amara, video_id: str, language_code: str = 'en') -> Optional[str]:
        # Construct the API endpoint for fetching subtitles
        url = f"https://amara.org/api/videos/{video_id}/languages/{language_code}/subtitles/"

        # Set up the headers with the API key
        headers = {
            "X-api-key": amara_resource['api_key'],
            "X-api-username": amara_resource['team']
        }

        # Make the HTTP GET request to fetch subtitles
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the subtitles text if successful
            return response.text
        else:
            # Return None if the request failed
            return None
  good: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed to fetch data from Amara API

    class amara(TypedDict):
        api_key: str
        team: Optional[str]

    def main(amara_resource: amara, video_id: str, language_code: str = 'en') -> dict:
        base_url = "https://amara.org/api/videos/"
        headers = {
            "X-api-key": amara_resource['api_key'],
            "X-api-username": amara_resource.get('team', '')
        }
        url = f"{base_url}{video_id}/languages/{language_code}/subtitles/"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code

        subtitles_data = response.json()
        return subtitles_data
  id: |-
    synthetic_fetch-subtitles-data
  instructions: |-
    Fetch subtitles data in amara
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    amara
  resource_type_def: |-
    class amara(TypedDict):
        api_key: str
        team: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import dropbox  # Assuming dropbox is the library used for Dropbox integration

    # Rename the imported dropbox module if it conflicts with the resource type name
    import dropbox as dropbox_sdk

    class dropbox(TypedDict):
        access_token: str

    def main(dropbox_resource: dropbox, file_path: str, content: str) -> str:
        dbx = dropbox_sdk.Dropbox(dropbox_resource['access_token'])
        dbx.files_upload(content.encode(), file_path)
        return f"File {file_path} created successfully in Dropbox."

    # Example usage:
    # result = main(dropbox_resource={'access_token': 'YOUR_ACCESS_TOKEN'}, file_path='/path/to/newfile.txt', content='Your plain text content here.')
    # print(result)
  good: |-
    from typing import TypedDict
    import dropbox as dbx_sdk  # Rename the imported module to avoid conflict

    # Define the resource type for the Dropbox integration
    class dropbox(TypedDict):
        access_token: str  # Access token is required for Dropbox API authentication

    def main(dropbox: dropbox, file_name: str, file_content: str) -> str:
        # Initialize a Dropbox client using the access token provided in the resource
        dbx = dbx_sdk.Dropbox(dropbox['access_token'])

        # Create and upload the file to Dropbox
        dbx.files_upload(file_content.encode(), '/' + file_name)

        # Return a success message with the file name
        return f"File '{file_name}' created and uploaded to Dropbox successfully."
  id: |-
    synthetic_create-a-text-file
  instructions: |-
    Creates a brand new text file from plain text content you specify in dropbox
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dropbox
  resource_type_def: |-
    class dropbox(TypedDict):
        access_token: str  # Access token is required for Dropbox API authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { stringify } from "npm:querystring";

    type Gitlab = {
        apiToken: string;
        gitlabUrl: string;
    }

    export async function main(gitlabResource: Gitlab, repositoryId: string, searchQuery: string) {
        const endpoint = `${gitlabResource.gitlabUrl}/api/v4/projects/${encodeURIComponent(repositoryId)}/search?scope=issues&search=${encodeURIComponent(searchQuery)}`;
        const headers = {
            'Authorization': `Bearer ${gitlabResource.apiToken}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(endpoint, { headers });
        if (!response.ok) {
            throw new Error(`Failed to search issues: ${response.status} ${response.statusText}`);
        }

        const issues = await response.json();
        return issues;
    }
  good: |-
    import { GitLab as GitLabApi } from "@gitbeaker/node";

    type Gitlab = {
        host: string;
        token: string;
    }

    export async function main(gitlabResource: Gitlab, projectId: number, search: string) {
        const api = new GitLabApi({
            host: gitlabResource.host,
            token: gitlabResource.token,
        });

        const issues = await api.Issues.all({
            projectId,
            search,
        });

        return issues;
    }
  id: |-
    synthetic_search-issues
  instructions: |-
    Search for issues in a repository with a query in gitlab
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
        host: string;
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    # Define the main function for the ClickUp integration
    def main(clickup_resource: clickup, team_id: str) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Base URL for ClickUp API
        base_url = "https://api.clickup.com/api/v2"

        # Headers to authenticate with the ClickUp API
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Endpoint to get team views
        endpoint = f"/team/{team_id}/view"

        # Make the API call
        response = requests.get(base_url + endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of views
            return response.json()['views']
        else:
            # Handle errors (you could also raise an exception here)
            return {"error": response.json().get("err", "Unknown error")}
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed to make HTTP calls to the ClickUp API

    class clickup(TypedDict):
        api_key: str
        team_id: str

    def main(clickup_resource: clickup) -> List[dict]:
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }
        team_id = clickup_resource['team_id']
        url = f"https://api.clickup.com/api/v2/team/{team_id}/view"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json().get('views', [])
  id: |-
    synthetic_get-team-views
  instructions: |-
    Get all views of a team. See the docs in **Views / Get Team Views** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import dropbox as dbx_module

    class dropbox(TypedDict):
        access_token: str

    def main(dropbox_config: dropbox, file_path: str, content: str, mode: str = 'add'):
        dbx = dbx_module.Dropbox(dropbox_config['access_token'])

        if mode == 'add':
            dbx.files_upload(content.encode(), file_path, mode=dbx_module.files.WriteMode.add)
        elif mode == 'overwrite':
            dbx.files_upload(content.encode(), file_path, mode=dbx_module.files.WriteMode.overwrite)
        else:
            raise ValueError("Invalid mode. Use 'add' for creating or appending to a file, or 'overwrite' to overwrite an existing file.")

        return f"File '{file_path}' updated successfully."
  good: |-
    from typing import TypedDict
    import dropbox

    class dropbox_resource(TypedDict):
        access_token: str

    def main(dropbox_resource: dropbox_resource, file_path: str, new_line: str) -> str:
        dbx = dropbox.Dropbox(dropbox_resource['access_token'])

        try:
            # Check if the file exists
            _, res = dbx.files_download(file_path)
            content = res.content.decode('utf-8') + '\n' + new_line
        except dropbox.exceptions.ApiError as e:
            if isinstance(e.error, dropbox.files.DownloadError) and e.error.is_path() and e.error.get_path().is_not_found():
                # File does not exist, so we start with the new line
                content = new_line
            else:
                # Other errors are raised
                raise

        # Upload the new content
        dbx.files_upload(content.encode('utf-8'), file_path, mode=dropbox.files.WriteMode.overwrite)

        return f"Line added to {file_path}"
  id: |-
    synthetic_create-or-append-to-a-text-file
  instructions: |-
    Adds a new line to an existing text file, or creates a file if it doesn't exist in dropbox
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    dropbox
  resource_type_def: |-
    class dropbox(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Noticeable } from "npm:@noticeable/node";

    type Noticeable = {
        projectId: string;
        apiKey: string;
    }

    export async function main(noticeableResource: Noticeable, emailAddress: string, isSubscribed: boolean) {
        const noticeable = new Noticeable({
            projectId: noticeableResource.projectId,
            apiKey: noticeableResource.apiKey
        });

        const subscriptionStatus = isSubscribed ? 'subscribed' : 'unsubscribed';

        try {
            const response = await noticeable.subscriptions.update(emailAddress, {
                status: subscriptionStatus
            });

            return response;
        } catch (error) {
            console.error('Failed to update email subscription:', error);
            throw error;
        }
    }
  good: |-
    import { NoticeableProject, NoticeableSubscription } from "npm:@noticeable/node";

    type Noticeable = {
        apiKey: string,
        projectId: string
    }

    export async function main(noticeableResource: Noticeable, emailAddress: string, subscriptionId: string, isSubscribed: boolean) {
        const noticeableProject = new NoticeableProject(noticeableResource.apiKey, noticeableResource.projectId);
        const subscription: NoticeableSubscription = {
            id: subscriptionId,
            email: emailAddress,
            isSubscribed: isSubscribed
        };

        try {
            const result = await noticeableProject.updateSubscription(subscription);
            return result;
        } catch (error) {
            console.error("Failed to update the subscription:", error);
            throw error;
        }
    }
  id: |-
    synthetic_update-email-subscription
  instructions: |-
    Updates an email subscription, in noticeable
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Noticeable
  resource_type_def: |-
    type Noticeable = {
        projectId: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Bingx } from "npm:@types/bingx"; // Assuming there's a type definition for Bingx in npm

    type BingxResource = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for authentication/configuration
    }

    export async function main(bingxResource: BingxResource, orderId: string) {
        // Assuming there's a Bingx client library that handles the API requests
        const bingxClient = new Bingx(bingxResource.apiKey, bingxResource.secretKey);

        // Query the order details using the Bingx client
        const orderDetails = await bingxClient.getOrderDetails(orderId);

        // Always return the result
        return orderDetails;
    }
  good: |-
    // Import any libraries you need here
    import { hmac as generateHmac } from "npm:crypto";

    type Bingx = {
        apiKey: string;
        secretKey: string;
        passphrase: string;
    }

    export async function main(bingxResource: Bingx, orderId: string) {
        const apiBase = 'https://api.bingx.com/v1';
        const endpoint = `/order/query?orderId=${orderId}`;
        const timestamp = Date.now().toString();
        const method = 'GET';
        const preHash = timestamp + method + endpoint;
        const signature = generateHmac('sha256', bingxResource.secretKey, preHash, 'utf8', 'hex');

        const headers = {
            'Content-Type': 'application/json',
            'ACCESS-KEY': bingxResource.apiKey,
            'ACCESS-SIGN': signature,
            'ACCESS-TIMESTAMP': timestamp,
            'ACCESS-PASSPHRASE': bingxResource.passphrase,
        };

        const response = await fetch(`${apiBase}${endpoint}`, {
            method: method,
            headers: headers,
        });

        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_trade-query-order
  instructions: |-
    Query Order Details. in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
        passphrase: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { sendMessage as sendLoopMessage } from "npm:@loopmessage/sdk";

    type Loopmessage = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(loopmessageResource: Loopmessage, recipientNumber: string, messageText: string) {
        const client = sendLoopMessage(loopmessageResource.apiKey, loopmessageResource.apiSecret);

        const result = await client.send({
            to: recipientNumber,
            body: messageText
        });

        return result;
    }
  good: |-
    type Loopmessage = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(loopmessageResource: Loopmessage, recipientNumber: string, messageText: string) {
        const url = 'https://api.loopmessage.com/v1/send';
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${loopmessageResource.apiKey}:${loopmessageResource.apiSecret}`
        };
        const body = JSON.stringify({
            to: recipientNumber,
            message: messageText
        });

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: body
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            console.error('Error sending message:', error);
            throw error;
        }
    }
  id: |-
    synthetic_send-text-message
  instructions: |-
    Action to send a text in iMessage to an individual recipient in loopmessage
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Loopmessage
  resource_type_def: |-
    type Loopmessage = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { google } from "npm:googleapis";

    type GoogleDirectory = {
        clientEmail: string;
        privateKey: string;
        adminEmail: string;
    }

    export async function main(googleDirectoryResource: GoogleDirectory, customer: string = 'my_customer') {
        const { clientEmail, privateKey, adminEmail } = googleDirectoryResource;
        const scopes = ['https://www.googleapis.com/auth/admin.directory.user.readonly'];

        const jwtClient = new google.auth.JWT(
            clientEmail,
            undefined,
            privateKey,
            scopes,
            adminEmail
        );

        await jwtClient.authorize();

        const directory = google.admin('directory_v1', { auth: jwtClient });
        const res = await directory.users.list({
            customer,
            maxResults: 100, // You can parameterize this if needed
            orderBy: 'email',
        });

        return res.data;
    }
  good: |-
    import { google } from "npm:googleapis";

    type GoogleDirectory = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        accessToken: string;
        refreshToken: string;
        domain: string;
    }

    export async function main(googleDirectoryResource: GoogleDirectory, maxResults: number = 100, orderBy: string = 'email') {
        const { clientId, clientSecret, redirectUri, accessToken, refreshToken, domain } = googleDirectoryResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ access_token: accessToken, refresh_token: refreshToken });

        const admin = google.admin({ version: 'directory_v1', auth: oauth2Client });

        const response = await admin.users.list({
            customer: 'my_customer',
            maxResults: maxResults,
            orderBy: orderBy,
            domain: domain
        });

        return response.data.users || [];
    }
  id: |-
    synthetic_list-users
  instructions: |-
    Retrieves a list of directory users in google directory
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDirectory
  resource_type_def: |-
    type GoogleDirectory = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        accessToken: string;
        refreshToken: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'mercury' integration
    class mercury(TypedDict):
        api_key: str
        account_id: str

    def main(mercury_resource: mercury, additional_param: str) -> dict:
        # Assuming 'requests' is needed for HTTP requests
        import requests as http_requests

        # Construct the headers with the API key for authentication
        headers = {
            'Authorization': f'Bearer {mercury_resource["api_key"]}',
            'Content-Type': 'application/json'
        }

        # Construct the URL for getting account information
        url = f'https://api.mercury.com/v1/accounts/{mercury_resource["account_id"]}'

        # Make the HTTP GET request to the Mercury API
        response = http_requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the account information as a dictionary
            return response.json()
        else:
            # Handle errors (for simplicity, just returning the error code)
            return {'error': response.status_code, 'message': response.text}

    # The 'main' function is now defined and can be used with the 'mercury' resource type and an additional parameter.
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the mercury integration
    class mercury(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for retrieving account information
    def main(mercury_resource: mercury, account_id: str) -> Any:
        import requests  # Import requests or any other library if needed

        # Base URL for the mercury API
        base_url = "https://api.mercury.com/v1"

        # Endpoint for retrieving account information
        account_info_endpoint = f"{base_url}/accounts/{account_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {mercury_resource['api_key']}"
        }

        # Make the request to the mercury API
        response = requests.get(account_info_endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the account information as JSON
            return response.json()
        else:
            # Handle errors (e.g., account not found, authentication error)
            response.raise_for_status()

    # The script ends here, with no calls to the main function as per the instructions.
  id: |-
    synthetic_get-account-info
  instructions: |-
    Retrieve information about a specific account in mercury
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mercury
  resource_type_def: |-
    class mercury(TypedDict):
        api_key: str
        account_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Instapaper = {
        consumerKey: string;
        consumerSecret: string;
        accessToken: string;
        accessTokenSecret: string;
    }

    export async function main(instapaperResource: Instapaper, urlToAdd: string) {
        const apiUrl = 'https://www.instapaper.com/api/add';
        const params = new URLSearchParams({
            url: urlToAdd,
            consumer_key: instapaperResource.consumerKey,
            consumer_secret: instapaperResource.consumerSecret,
            access_token: instapaperResource.accessToken,
            access_token_secret: instapaperResource.accessTokenSecret
        });

        const response = await fetch(apiUrl, {
            method: 'POST',
            body: params,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        });

        if (!response.ok) {
            throw new Error(`Error adding URL to Instapaper: ${response.statusText}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { encode } from "npm:base-64";

    type Instapaper = {
        username: string;
        password: string;
    }

    export async function main(instapaperResource: Instapaper, url: string, title?: string, selection?: string) {
        const endpoint = 'https://www.instapaper.com/api/add';
        const headers = new Headers({
            'Authorization': 'Basic ' + encode(`${instapaperResource.username}:${instapaperResource.password}`),
            'Content-Type': 'application/x-www-form-urlencoded'
        });

        const body = new URLSearchParams({
            'url': url,
            'title': title || '',
            'selection': selection || ''
        });

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error adding URL to Instapaper: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-url
  instructions: |-
    Adding URLs to an Instapaper account in instapaper
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Instapaper
  resource_type_def: |-
    type Instapaper = {
        consumerKey: string;
        consumerSecret: string;
        accessToken: string;
        accessTokenSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, companyName: string, companyDomain: string, companyDescription?: string) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });

        const companyProperties = {
            name: companyName,
            domain: companyDomain,
            description: companyDescription
        };

        try {
            const createdCompany = await hubspotClient.crm.companies.basicApi.create({
                properties: companyProperties
            });
            return createdCompany;
        } catch (error) {
            console.error('Error creating company in HubSpot:', error);
            throw error;
        }
    }
  good: |-
    import { Client } from "npm:@hubspot/api-client";

    type Hubspot = {
        apiKey: string;
    }

    export async function main(hubspotResource: Hubspot, companyName: string, companyDomain: string, description?: string) {
        const hubspotClient = new Client({ apiKey: hubspotResource.apiKey });

        const companyProperties = {
            name: companyName,
            domain: companyDomain,
            description: description || '',
        };

        try {
            const createdCompany = await hubspotClient.crm.companies.basicApi.create({
                properties: companyProperties
            });
            return createdCompany;
        } catch (error) {
            console.error('Error creating company in HubSpot:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-company
  instructions: |-
    Create a company in Hubspot in hubspot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the ghost_org_admin_api integration
    class ghost_org_admin_api(TypedDict):
        api_key: str
        admin_url: str

    # Define the main function for updating a member in Ghost's Admin API
    def main(ghost_org_admin_api_resource: ghost_org_admin_api, member_id: str, updated_data: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the headers with the API key
        headers = {
            'Authorization': f"Ghost {ghost_org_admin_api_resource['api_key']}"
        }

        # Construct the URL for the member update endpoint
        update_url = f"{ghost_org_admin_api_resource['admin_url']}/members/{member_id}/"

        # Make the request to update the member
        response = requests.put(update_url, json=updated_data, headers=headers)

        # Return the response from the API call
        return response.json()

    # The complete script is ready to be exported and used with the specified parameters
  good: |-
    from typing import TypedDict

    # Define the resource type for the ghost_org_admin_api integration
    class ghost_org_admin_api(TypedDict):
        api_key: str
        admin_api_url: str

    # Import requests but rename it to avoid conflicts with any integration resource names
    import requests as req

    def main(ghost_org_admin_api_resource: ghost_org_admin_api, member_id: str, updated_data: dict):
        # Construct the headers with the API key
        headers = {
            'Authorization': f"Ghost {ghost_org_admin_api_resource['api_key']}"
        }

        # Construct the URL for updating the member
        update_url = f"{ghost_org_admin_api_resource['admin_api_url']}/members/{member_id}/"

        # Make the request to update the member
        response = req.put(update_url, json=updated_data, headers=headers)

        # Return the response from the API call
        return response.json()
  id: |-
    synthetic_update-member
  instructions: |-
    Update a member in Ghost in ghost org admin api
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ghost_org_admin_api
  resource_type_def: |-
    class ghost_org_admin_api(TypedDict):
        api_key: str
        admin_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class mailgun(TypedDict):
        api_key: str
        domain: str

    def main(mailgun_resource: mailgun, recipient: str, subject: str, text: str, html: str = None):
        request_url = f"https://api.mailgun.net/v3/{mailgun_resource['domain']}/messages"
        request_data = {
            "from": f"Mailgun Sandbox <postmaster@{mailgun_resource['domain']}>",
            "to": recipient,
            "subject": subject,
            "text": text,
        }
        if html:
            request_data["html"] = html

        response = requests.post(
            request_url,
            auth=("api", mailgun_resource["api_key"]),
            data=request_data
        )

        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to send an email via Mailgun API

    class mailgun(TypedDict):
        api_key: str
        domain: str

    def main(mailgun_resource: mailgun, recipient: str, subject: str, text: str, html: str = None):
        mailgun_api_url = f"https://api.mailgun.net/v3/{mailgun_resource['domain']}/messages"
        auth = ("api", mailgun_resource['api_key'])
        data = {
            "from": f"Mailgun Sandbox <postmaster@{mailgun_resource['domain']}>",
            "to": recipient,
            "subject": subject,
            "text": text,
        }
        if html:
            data["html"] = html

        response = requests.post(mailgun_api_url, auth=auth, data=data)
        return response
  id: |-
    synthetic_send-email
  instructions: |-
    Send email with Mailgun in mailgun
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailgun
  resource_type_def: |-
    class mailgun(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import asana as asana_client

    class asana(TypedDict):
        access_token: str

    def main(asana_resource: asana, task_gid: str, comment_text: str) -> dict:
        client = asana_client.Client.access_token(asana_resource['access_token'])
        result = client.tasks.add_comment(task_gid, {'text': comment_text})
        return result
  good: |-
    from typing import TypedDict
    import asana

    class asana(TypedDict):
        access_token: str

    def main(asana_resource: asana, task_id: str, comment: str) -> dict:
        client = asana.Client.access_token(asana_resource['access_token'])
        result = client.tasks.add_comment(task_id, {'text': comment})
        return result
  id: |-
    synthetic_create-task-comment
  instructions: |-
    Adds a comment to a task in asana
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    asana
  resource_type_def: |-
    class asana(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the 'jp_funda' integration
    class jp_funda(TypedDict):
        api_key: str
        base_url: str

    # Define the main function with the resource type and additional parameters
    def main(jp_funda_resource: jp_funda, edinet_code: str) -> Any:
        # Construct the URL for the API call
        url = f"{jp_funda_resource['base_url']}/api/some_endpoint"

        # Set up the headers with the API key
        headers = {
            'Authorization': f"Bearer {jp_funda_resource['api_key']}"
        }

        # Make the API call to get data by EDINET code
        response = requests.get(url, headers=headers, params={'edinet_code': edinet_code})

        # Check if the request was successful
        if response.status_code == 200:
            # Return the JSON data if successful
            return response.json()
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {'error': 'Failed to retrieve data', 'status_code': response.status_code}
  good: |-
    from typing import TypedDict, List, Dict
    import requests  # Assuming requests is needed for API interaction

    class jp_funda(TypedDict):
        api_key: str
        base_url: str

    def main(jp_funda_resource: jp_funda, company_code: str, years: int = 3) -> Dict[str, List[Dict]]:
        headers = {
            'Authorization': f"Bearer {jp_funda_resource['api_key']}"
        }
        recent_report_url = f"{jp_funda_resource['base_url']}/securities_report/recent/{company_code}"
        annual_report_url = f"{jp_funda_resource['base_url']}/securities_report/annual/{company_code}"

        recent_report_response = requests.get(recent_report_url, headers=headers)
        annual_report_responses = [
            requests.get(f"{annual_report_url}?year={year}", headers=headers)
            for year in range(years)
        ]

        if recent_report_response.status_code != 200:
            raise Exception(f"Failed to fetch recent report: {recent_report_response.text}")

        recent_report_data = recent_report_response.json()

        annual_reports_data = []
        for response in annual_report_responses:
            if response.status_code == 200:
                annual_reports_data.append(response.json())
            else:
                raise Exception(f"Failed to fetch annual report for a year: {response.text}")

        return {
            'recent_report': recent_report_data,
            'annual_reports': annual_reports_data
        }
  id: |-
    synthetic_get-data-by-edinet-code
  instructions: |-
    Returns the most recent and annual securities report data for the past few years in jp funda
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jp_funda
  resource_type_def: |-
    class jp_funda(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any

    # Define the resource type for the intuiface integration
    class intuiface(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function for sending a message
    def main(intuiface_resource: intuiface, message: str, recipient_id: str) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the headers with the API key
        headers = {
            'Authorization': f"Bearer {intuiface_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Construct the payload with the message and recipient
        payload = {
            'recipient_id': recipient_id,
            'message': message
        }

        # Send the message using the endpoint URL
        response = requests.post(intuiface_resource['endpoint_url'], json=payload, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to send messages to Intuiface Player

    class intuiface(TypedDict):
        api_key: str
        experience_id: str
        player_id: str

    def main(intuiface_resource: intuiface, message: str, target_asset_id: str):
        base_url = "https://api.intuiface.com/v1"
        headers = {
            "API-Key": intuiface_resource['api_key'],
            "Content-Type": "application/json"
        }
        payload = {
            "experienceId": intuiface_resource['experience_id'],
            "playerId": intuiface_resource['player_id'],
            "message": message,
            "targetAssetId": target_asset_id
        }

        response = requests.post(f"{base_url}/players/{intuiface_resource['player_id']}/messages", headers=headers, json=payload)
        return response.json()
  id: |-
    synthetic_send-message
  instructions: |-
    Send messages to any connected Intuiface Player running an experience that embeds the. in intuiface
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    intuiface
  resource_type_def: |-
    class intuiface(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import nethunt as nh_module  # Assuming 'nethunt' is the library for nethunt_crm integration

    # Renaming the imported method if it conflicts with the resource type name
    if hasattr(nh_module, 'nethunt_crm'):
        nh_crm_method = nh_module.nethunt_crm
    else:
        nh_crm_method = None

    class nethunt_crm(TypedDict):
        api_key: str
        workspace_id: str

    def main(nethunt_crm_resource: nethunt_crm, record_id: str) -> Any:
        # Assuming there is a method in the nethunt library to retrieve a record by ID
        client = nh_module.Client(api_key=nethunt_crm_resource['api_key'])
        record = client.get_record(nethunt_crm_resource['workspace_id'], record_id)
        return record
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API interaction

    # Define the resource type for the nethunt_crm integration
    class nethunt_crm(TypedDict):
        api_key: str
        base_url: str

    def main(nethunt_crm_resource: nethunt_crm, record_id: str) -> Dict[str, Any]:
        headers = {
            'Authorization': f"Bearer {nethunt_crm_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        response = requests.get(
            f"{nethunt_crm_resource['base_url']}/records/{record_id}",
            headers=headers
        )

        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return response.json()
  id: |-
    synthetic_get-record
  instructions: |-
    Retrieve a record by its ID in nethunt crm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nethunt_crm
  resource_type_def: |-
    class nethunt_crm(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
        tableName: string;
    }

    export async function main(airtableResource: AirtableOauth, fieldName: string, fieldType: string) {
        const base = new Base({ apiKey: airtableResource.apiKey });

        const table = base.getTable(airtableResource.tableName);
        const createFieldResult = await table.createFieldAsync(fieldName, fieldType);

        return createFieldResult;
    }
  good: |-
    import { Base } from "npm:@airtable/blocks/models";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, fieldName: string, fieldType: string, options?: object) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(tableName);

        const result = await table.createFieldAsync(fieldName, fieldType, options);

        return result;
    }
  id: |-
    synthetic_create-field
  instructions: |-
    Create a new field in a table in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to Agile CRM

    class agile_crm(TypedDict):
        domain: str
        email: str
        api_key: str

    def main(agile_crm_resource: agile_crm, first_name: str, last_name: str, email: str, tags: list[str] = []):
        url = f"https://{agile_crm_resource['domain']}.agilecrm.com/dev/api/contacts"
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {agile_crm_resource['api_key']}"
        }
        payload = {
            "properties": [
                {"type": "SYSTEM", "name": "first_name", "value": first_name},
                {"type": "SYSTEM", "name": "last_name", "value": last_name},
                {"type": "SYSTEM", "name": "email", "subtype": "work", "value": email}
            ],
            "tags": tags
        }
        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for API calls

    # Define the resource type for the 'agile_crm' integration
    class agile_crm(TypedDict):
        domain: str
        api_key: str

    # Define the main function for creating a contact in Agile CRM
    def main(agile_crm_resource: agile_crm, contact_data: Dict[str, Any]):
        # Construct the API endpoint for creating a contact
        endpoint = f"https://{agile_crm_resource['domain']}.agilecrm.com/dev/api/contacts"

        # Set up the headers with the necessary authentication
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {agile_crm_resource['api_key']}"
        }

        # Make the API request to create the contact
        response = requests.post(endpoint, json=contact_data, headers=headers)

        # Check for a successful response and return the result
        if response.status_code == 200 or response.status_code == 201:
            return response.json()  # Return the created contact information
        else:
            response.raise_for_status()  # Raise an exception for any failed requests
  id: |-
    synthetic_create-contact
  instructions: |-
    Create a new contact in Agile CRM in agile crm
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    agile_crm
  resource_type_def: |-
    class agile_crm(TypedDict):
        domain: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Deepgram as DeepgramSDK } from "npm:@deepgram/sdk";

    type Deepgram = {
        apiKey: string;
    }

    export async function main(deepgramResource: Deepgram) {
        const deepgram = new DeepgramSDK(deepgramResource.apiKey);
        try {
            const balanceResponse = await deepgram.usage.getBalance();
            return balanceResponse;
        } catch (error) {
            console.error('Error fetching balance:', error);
            throw error;
        }
    }
  good: |-
    import { Deepgram } from "npm:@deepgram/sdk";

    type DeepgramResource = {
        apiKey: string;
    }

    export async function main(deepgramResource: DeepgramResource, balanceId: string) {
        const deepgram = new Deepgram(deepgramResource.apiKey);
        const balanceDetails = await deepgram.usage.getBalance(balanceId);
        return balanceDetails;
    }
  id: |-
    synthetic_get-balance
  instructions: |-
    Retrieves details about the specified balance in deepgram
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Deepgram
  resource_type_def: |-
    type Deepgram = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to Mailchimp API

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(mailchimp_resource: mailchimp, campaign_name: str, from_email: str, subject_line: str, reply_to: str, list_id: str, template_id: int, folder_id: Optional[str] = None):
        base_url = f"https://{mailchimp_resource['server_prefix']}.api.mailchimp.com/3.0"
        headers = {
            "Authorization": f"Bearer {mailchimp_resource['api_key']}"
        }

        campaign_data = {
            "type": "regular",
            "recipients": {
                "list_id": list_id
            },
            "settings": {
                "subject_line": subject_line,
                "reply_to": reply_to,
                "from_name": campaign_name,
                "template_id": template_id
            }
        }

        if folder_id:
            campaign_data["settings"]["folder_id"] = folder_id

        response = requests.post(f"{base_url}/campaigns", json=campaign_data, headers=headers)

        if response.status_code == 200 or response.status_code == 201:
            return response.json()
        else:
            raise Exception(f"Error creating campaign: {response.text}")
  good: |-
    from typing import TypedDict

    # Define the resource type for the mailchimp integration
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    # Import the Mailchimp Marketing library and rename the conflicting method if necessary
    import mailchimp_marketing as MailchimpMarketing
    from mailchimp_marketing.api_client import ApiClientError

    # Define the main function with the necessary parameters for creating a campaign draft
    def main(mailchimp_resource: mailchimp, list_id: str, campaign_type: str, subject_line: str, reply_to: str, from_name: str, title: str):
        # Initialize the Mailchimp client with the provided resource credentials
        client = MailchimpMarketing.Client()
        client.set_config({
            "api_key": mailchimp_resource['api_key'],
            "server": mailchimp_resource['server_prefix']
        })

        # Create the campaign draft with the provided parameters
        try:
            campaign_content = {
                "type": campaign_type,
                "recipients": {
                    "list_id": list_id
                },
                "settings": {
                    "subject_line": subject_line,
                    "reply_to": reply_to,
                    "from_name": from_name,
                    "title": title
                }
            }
            response = client.campaigns.create(campaign_content)
            return response
        except ApiClientError as error:
            return {'status': 'error', 'message': str(error)}

    # Note: The function is not called here, it is only defined and ready to be used with the appropriate parameters.
  id: |-
    synthetic_create-campaign
  instructions: |-
    Creates a new campaign draft in mailchimp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import discord as discord_client  # Renamed to avoid conflict with the TypedDict

    class discord(TypedDict):
        token: str
        channel_id: str

    def main(discord_resource: discord, message: str) -> None:
        client = discord_client.Client()

        async def send_message():
            await client.wait_until_ready()
            channel = client.get_channel(int(discord_resource['channel_id']))
            await channel.send(message)

        client.loop.create_task(send_message())
        client.run(discord_resource['token'])
  good: |-
    from typing import TypedDict
    import requests

    class discord(TypedDict):
        token: str
        channel_id: str

    def main(discord_resource: discord, message: str) -> dict:
        url = f"https://discord.com/api/v9/channels/{discord_resource['channel_id']}/messages"
        headers = {
            "Authorization": f"Bot {discord_resource['token']}",
            "Content-Type": "application/json"
        }
        payload = {
            "content": message
        }
        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_send-message
  instructions: |-
    Send a simple message to a Discord channel in discord
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    discord
  resource_type_def: |-
    class discord(TypedDict):
        token: str
        channel_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Bot } from "npm:discordeno";

    type DiscordBot = {
        token: string;
    }

    export async function main(discordBotResource: DiscordBot, channelId: string, botId: string) {
        const bot = new Bot({
            token: discordBotResource.token,
            botId: botId,
            intents: [], // Specify the necessary intents for your bot
        });

        const invites = await bot.helpers.getChannelInvites(channelId);

        return invites;
    }
  good: |-
    import { Client, GuildChannel, Invite } from "npm:discord.js";

    type DiscordBot = {
        token: string;
    }

    export async function main(discordBotResource: DiscordBot, channelId: string): Promise<Invite[]> {
        const client = new Client();

        await client.login(discordBotResource.token);

        const channel = await client.channels.fetch(channelId);
        if (!(channel instanceof GuildChannel)) {
            throw new Error('The provided channel ID does not belong to a guild channel.');
        }

        const invites = await channel.fetchInvites();
        await client.destroy(); // Clean up the client after use

        return invites.map(invite => ({
            code: invite.code,
            uses: invite.uses,
            maxUses: invite.maxUses,
            maxAge: invite.maxAge,
            temporary: invite.temporary,
            createdAt: invite.createdAt,
            inviter: invite.inviter ? {
                id: invite.inviter.id,
                username: invite.inviter.username,
                discriminator: invite.inviter.discriminator,
                avatar: invite.inviter.avatar,
                bot: invite.inviter.bot,
            } : null,
            channel: {
                id: invite.channel.id,
                name: invite.channel.name,
                type: invite.channel.type,
            },
            guild: invite.guild ? {
                id: invite.guild.id,
                name: invite.guild.name,
                splash: invite.guild.splash,
                banner: invite.guild.banner,
                description: invite.guild.description,
            } : null,
        }));
    }
  id: |-
    synthetic_list-channel-invites
  instructions: |-
    Return a list of invitees for the channel. Only usable for guild channels. in discord bot
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DiscordBot
  resource_type_def: |-
    type DiscordBot = {
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { hmac as createHmac } from "npm:crypto";

    type Bingx = {
        apiKey: string;
        secretKey: string;
    }

    export async function main(bingxResource: Bingx, symbol: string, side: 'BUY' | 'SELL', type: 'LIMIT' | 'MARKET', quantity: number, price?: number) {
        const requestBody = {
            symbol: symbol,
            side: side,
            type: type,
            quantity: quantity,
            ...(price && { price: price }),
        };

        const timestamp = Date.now();
        const query = `timestamp=${timestamp}&` + new URLSearchParams(requestBody).toString();
        const signature = createHmac('sha256', bingxResource.secretKey, query, 'utf8', 'hex');

        const headers = {
            'X-BINGX-APIKEY': bingxResource.apiKey,
            'Content-Type': 'application/x-www-form-urlencoded',
        };

        const apiUrl = `https://api.bingx.com/v1/order?${query}&signature=${signature}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: new URLSearchParams(requestBody).toString(),
        });

        const result = await response.json();
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { hmac } from "npm:crypto";

    type Bingx = {
        apiKey: string;
        secretKey: string;
        // Add any other properties needed for the Bingx integration
    }

    export async function main(bingxResource: Bingx, symbol: string, side: 'buy' | 'sell', type: 'market' | 'limit', size: number, price?: number) {
        // Ensure that the price is provided for limit orders
        if (type === 'limit' && price === undefined) {
            throw new Error('Price must be provided for limit orders');
        }

        // Construct the request body based on the order type
        const body = {
            symbol: symbol,
            side: side,
            type: type,
            size: size,
            ...(type === 'limit' && { price: price }), // Include price only for limit orders
        };

        // Generate the signature for the request
        const timestamp = Date.now();
        const queryString = `apiKey=${bingxResource.apiKey}&timestamp=${timestamp}`;
        const signature = hmac('sha256', bingxResource.secretKey, queryString).digest('hex');

        // Construct the headers for the request
        const headers = {
            'Content-Type': 'application/json',
            'X-BINGX-APIKEY': bingxResource.apiKey,
            'X-BINGX-SIGNATURE': signature,
            'X-BINGX-TIMESTAMP': timestamp.toString(),
        };

        // Make the request to place a new order
        const response = await fetch('https://api.bingx.com/v1/order', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body),
        });

        // Parse the response and return the result
        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_trade-new-order
  instructions: |-
    Place a New Order in bingx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bingx
  resource_type_def: |-
    type Bingx = {
        apiKey: string;
        secretKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the kingsumo integration
    class kingsumo(TypedDict):
        api_key: str
        contest_id: str

    # Define the main function for listing contestants
    def main(kingsumo_resource: kingsumo, page: int = 1, per_page: int = 10) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for listing contestants
        endpoint = f"https://api.kingsumo.com/v1/contests/{kingsumo_resource['contest_id']}/contestants"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {kingsumo_resource['api_key']}"
        }

        # Set up the parameters for pagination
        params = {
            "page": page,
            "per_page": per_page
        }

        # Make the request to the KingSumo API
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of contestants
            return response.json()['contestants']
        else:
            # Handle errors (e.g., by raising an exception or returning an empty list)
            response.raise_for_status()

    # The script ends here, with no calls to the main function, as per the instructions.
  good: |-
    from typing import TypedDict, List

    # Define the resource type for the kingsumo integration
    class kingsumo(TypedDict):
        api_key: str
        giveaway_id: str

    # Define the main function for listing contestants of a specified giveaway
    def main(kingsumo_resource: kingsumo, page: int = 1, per_page: int = 100) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for listing contestants
        endpoint = f"https://api.kingsumo.com/v1/giveaways/{kingsumo_resource['giveaway_id']}/contestants"

        # Set up the headers with the API key
        headers = {
            "Authorization": f"Bearer {kingsumo_resource['api_key']}"
        }

        # Set up the parameters for pagination
        params = {
            "page": page,
            "per_page": per_page
        }

        # Make the request to the KingSumo API
        response = requests.get(endpoint, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the list of contestants
            return response.json()['contestants']
        else:
            # Handle errors (you could raise an exception or return an error message)
            response.raise_for_status()

    # The script ends here, and the main function can be called with the required parameters
  id: |-
    synthetic_list-contestants
  instructions: |-
    List contestants for specified giveaway in kingsumo
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kingsumo
  resource_type_def: |-
    class kingsumo(TypedDict):
        api_key: str
        contest_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict
    import requests  # Assuming requests is needed for HTTP requests to Etsy API

    # Define the resource type for the Etsy integration
    class etsy(TypedDict):
        api_key: str
        api_secret: str
        oauth_token: str
        oauth_token_secret: str

    # Define the main function for updating a listing property on Etsy
    def main(etsy_resource: etsy, listing_id: int, property_name: str, property_value: Any) -> Dict[str, Any]:
        # Endpoint for updating a listing on Etsy
        update_url = f"https://openapi.etsy.com/v2/listings/{listing_id}"

        # Prepare the headers for OAuth authentication
        headers = {
            "Authorization": f"Bearer {etsy_resource['oauth_token']}",
            "x-api-key": etsy_resource['api_key']
        }

        # Prepare the payload with the property to update
        payload = {
            property_name: property_value
        }

        # Make the request to update the listing
        response = requests.put(update_url, headers=headers, data=payload)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the JSON response if successful
        else:
            return {
                "error": response.text,
                "status_code": response.status_code
            }  # Return an error message and status code if not successful

    # The script ends here, with no call to the main function, as per the instructions.
  good: |-
    from typing import TypedDict, List, Dict

    # Assuming 'requests' is needed for HTTP requests to the Etsy API
    import requests as http_requests

    class etsy(TypedDict):
        api_key: str
        api_secret: str
        access_token: str
        access_token_secret: str

    # Define a type for the offerings to be updated or populated
    class Offering(TypedDict):
        value: str
        value_id: int
        scale_id: int

    def main(etsy_resource: etsy, listing_id: int, offerings: List[Offering]):
        # Endpoint for updating or populating properties list for a listing on Etsy
        url = f"https://openapi.etsy.com/v2/listings/{listing_id}/inventory"

        # Prepare the headers with OAuth credentials
        headers = {
            "x-api-key": etsy_resource['api_key'],
            "Authorization": f"Bearer {etsy_resource['access_token']}"
        }

        # Prepare the payload with the offerings data
        payload = {
            'products': [
                {
                    'property_values': [
                        {
                            'property_id': offering['scale_id'],
                            'value': offering['value'],
                            'value_id': offering['value_id']
                        }
                        for offering in offerings
                    ]
                }
            ]
        }

        # Make the request to Etsy API to update the listing
        response = http_requests.put(url, headers=headers, json=payload)

        # Return the response from the Etsy API
        return response.json()

    # Note: The function is not called here, it is just defined and exported.
  id: |-
    synthetic_update-listing-property
  instructions: |-
    Updates or populates the properties list defining product offerings for a listing. Each offering requires both a `value` and a `value_id` that are valid for a `scale_id` assigned to the listing or that you assign to the listing with this request in etsy
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    etsy
  resource_type_def: |-
    class etsy(TypedDict):
        api_key: str
        api_secret: str
        oauth_token: str
        oauth_token_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed to send the event to Customer.io

    class customer_io(TypedDict):
        site_id: str
        api_key: str

    def main(customer_io_resource: customer_io, customer_id: str, event_name: str, event_data: dict[str, Any]):
        base_url = "https://track.customer.io/api/v1"
        headers = {
            "Authorization": f"Basic {customer_io_resource['api_key']}",
            "Content-Type": "application/json"
        }

        event_url = f"{base_url}/customers/{customer_id}/events"
        payload = {
            "name": event_name,
            "data": event_data
        }

        response = requests.post(event_url, json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the customer_io integration
    class customer_io(TypedDict):
        site_id: str
        api_key: str

    # Define the main function for sending an event to customer.io
    def main(customer_io_resource: customer_io, customer_id: str, event_name: str, event_data: dict[str, Any]):
        from customerio import CustomerIO as CustomerIOClient  # Rename the imported CustomerIO class

        # Instantiate the CustomerIO object with credentials from the resource
        cio = CustomerIOClient(customer_io_resource['site_id'], customer_io_resource['api_key'])

        # Send the event to customer.io
        cio.track(customer_id, event_name, event_data)

        # Return a success message
        return f"Event '{event_name}' for customer '{customer_id}' sent successfully."
  id: |-
    synthetic_send-event-to
  instructions: |-
    Sends an event to Customer.io in customer io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    customer_io
  resource_type_def: |-
    class customer_io(TypedDict):
        site_id: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GistClient } from "npm:@sendgrid/client"; // Assuming GistClient is the relevant npm package for Gist API

    type Gist = {
        apiKey: string;
    }

    export async function main(gistResource: Gist, contactId: string | null, contactData: { email: string; name?: string; customFields?: Record<string, any>; }, upsert: boolean = false) {
        GistClient.setApiKey(gistResource.apiKey);

        let result;
        if (contactId && !upsert) {
            // Update an existing contact
            result = await GistClient.request({
                method: 'PATCH',
                url: `/contacts/${contactId}`,
                body: contactData
            });
        } else {
            // Create a new contact or upsert
            const method = upsert ? 'PUT' : 'POST';
            const endpoint = upsert && contactId ? `/contacts/${contactId}` : '/contacts';
            result = await GistClient.request({
                method: method,
                url: endpoint,
                body: contactData
            });
        }

        return result;
    }
  good: |-
    import { GistClient } from "npm:@gistrun/gist-client";

    type Gist = {
        apiKey: string;
    }

    export async function main(gistResource: Gist, contactId: string | null, email: string, firstName: string, lastName: string, phone?: string, customFields?: Record<string, any>) {
        const client = new GistClient(gistResource.apiKey);

        const contactData = {
            email,
            first_name: firstName,
            last_name: lastName,
            phone,
            custom_attributes: customFields
        };

        let result;
        if (contactId) {
            // Update an existing contact
            result = await client.contacts.update(contactId, contactData);
        } else {
            // Create a new contact
            result = await client.contacts.create(contactData);
        }

        return result;
    }
  id: |-
    synthetic_create-or-update-contact
  instructions: |-
    Create or update a contact in Gist in gist
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Gist
  resource_type_def: |-
    type Gist = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { AeroWorkflow as AeroWorkflowClient } from "npm:aero-workflow"; // Renamed the imported AeroWorkflow to AeroWorkflowClient

    type AeroWorkflow = {
        apiKey: string,
        endpointUrl: string
    }

    export async function main(aeroWorkflowResource: AeroWorkflow, recipientEmail: string, emailSubject: string, emailBody: string) {
        // Initialize the AeroWorkflow client with the provided API key and endpoint URL
        const aeroClient = new AeroWorkflowClient(aeroWorkflowResource.apiKey, aeroWorkflowResource.endpointUrl);

        // Construct the email object
        const email = {
            to: recipientEmail,
            subject: emailSubject,
            body: emailBody
        };

        // Send the email using the AeroWorkflow client
        const result = await aeroClient.sendEmail(email);

        // Return the result of the email sending operation
        return result;
    }
  good: |-
    import { AeroWorkflow } from "npm:aero-workflow-sdk";

    type AeroWorkflowResource = {
        apiKey: string;
        accountId: string;
    }

    export async function main(aeroWorkflowResource: AeroWorkflowResource, emailSubject: string, emailBody: string, recipientEmail: string) {
        const aero = new AeroWorkflow(aeroWorkflowResource.apiKey, aeroWorkflowResource.accountId);

        const email = {
            subject: emailSubject,
            body: emailBody,
            to: recipientEmail
        };

        const result = await aero.createEmail(email);
        return result;
    }
  id: |-
    synthetic_create-email-aero
  instructions: |-
    Creates an email aero in aero workflow
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AeroWorkflow
  resource_type_def: |-
    type AeroWorkflow = {
        apiKey: string,
        endpointUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        toAddresses: string[],
        fromAddress: string,
        subject: string,
        htmlBodyTemplate: string,
        textBodyTemplate: string,
        templateData: { [key: string]: string }
    ) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        // Replace template tags in the body templates
        const htmlBody = htmlBodyTemplate.replace(/\{\{(\w+)\}\}/g, (_, key) => templateData[key] || '');
        const textBody = textBodyTemplate.replace(/\{\{(\w+)\}\}/g, (_, key) => templateData[key] || '');

        const params = {
            Destination: {
                ToAddresses: toAddresses,
            },
            Message: {
                Body: {
                    Html: {
                        Charset: "UTF-8",
                        Data: htmlBody,
                    },
                    Text: {
                        Charset: "UTF-8",
                        Data: textBody,
                    },
                },
                Subject: {
                    Charset: 'UTF-8',
                    Data: subject,
                },
            },
            Source: fromAddress,
        };

        try {
            const response = await ses.sendEmail(params);
            return response;
        } catch (error) {
            console.error("Error sending email via Amazon SES", error);
            throw error;
        }
    }
  good: |-
    import { SES } from "npm:@aws-sdk/client-ses";

    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }

    export async function main(
        amazonSesResource: AmazonSes,
        toAddresses: string[],
        fromAddress: string,
        templateName: string,
        templateData: string // JSON string of the replacement variables in the template
    ) {
        const ses = new SES({
            credentials: {
                accessKeyId: amazonSesResource.accessKeyId,
                secretAccessKey: amazonSesResource.secretAccessKey,
            },
            region: amazonSesResource.region,
        });

        const params = {
            Destination: {
                ToAddresses: toAddresses,
            },
            Source: fromAddress,
            Template: templateName,
            TemplateData: templateData,
        };

        try {
            const response = await ses.sendTemplatedEmail(params);
            return response;
        } catch (error) {
            console.error("Error sending templated email:", error);
            throw error;
        }
    }
  id: |-
    synthetic_send-templated-email
  instructions: |-
    Send an email replacing the template tags with values using Amazon SES in amazon ses
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AmazonSes
  resource_type_def: |-
    type AmazonSes = {
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { encode } from "npm:@std/base64";

    type Buildkite = {
        apiKey: string;
    }

    export async function main(buildkiteResource: Buildkite) {
        const apiUrl = 'https://api.buildkite.com/v2/user';
        const headers = new Headers({
            'Authorization': `Bearer ${encode(buildkiteResource.apiKey)}`
        });

        try {
            const response = await fetch(apiUrl, { headers });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const userDetails = await response.json();
            return userDetails;
        } catch (error) {
            console.error('Error fetching user details:', error);
            throw error;
        }
    }
  good: |-
    import { Buildkite } from "npm:@buildkite/client";

    type Buildkite = {
        accessToken: string;
    }

    export async function main(buildkiteResource: Buildkite) {
        const buildkite = new Buildkite({ accessToken: buildkiteResource.accessToken });
        const user = await buildkite.user().get();
        return user;
    }
  id: |-
    synthetic_get-user
  instructions: |-
    Returns basic details about the user account that sent the request in buildkite
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Buildkite
  resource_type_def: |-
    type Buildkite = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Kingsumo = {
        apiKey: string;
        giveawayId: string;
    }

    export async function main(kingsumoResource: Kingsumo) {
        const response = await fetch(`https://api.kingsumo.com/v1/giveaways/${kingsumoResource.giveawayId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${kingsumoResource.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  good: |-
    // Import any libraries you need here
    import { Kingsumo } from 'npm:kingsumo-api';

    type Kingsumo = {
        apiKey: string;
        // Add other properties needed for Kingsumo integration
    }

    export async function main(kingsumoResource: Kingsumo, giveawayId: string) {
        // Initialize the Kingsumo client with the provided apiKey
        const kingsumoClient = new Kingsumo(kingsumoResource.apiKey);

        // Fetch the specified giveaway using the Kingsumo client
        const giveaway = await kingsumoClient.getGiveaway(giveawayId);

        // Return the giveaway details
        return giveaway;
    }
  id: |-
    synthetic_get-giveaway
  instructions: |-
    Gets specified giveaway in kingsumo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Kingsumo
  resource_type_def: |-
    type Kingsumo = {
        apiKey: string;
        giveawayId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ensureDir } from "npm:fs-extra";

    type HelperFunctions = {
        // Include only authentication/configuration properties relevant to any script
    }

    export async function main(fileUrl: string, fileName: string) {
        const targetDir = '/tmp';
        await ensureDir(targetDir);
        const response = await fetch(fileUrl);
        if (!response.ok) {
            throw new Error(`Failed to download file: ${response.statusText}`);
        }
        const fileData = await response.arrayBuffer();
        const filePath = `${targetDir}/${fileName}`;
        await Deno.writeFile(filePath, new Uint8Array(fileData));
        return filePath;
    }
  good: |-
    // Import any libraries you need here
    import { ensureDir } from "npm:fs-extra";

    type HelperFunctions = {
        downloadDirectory: string; // Directory where files will be downloaded
    }

    export async function main(helperFunctionsResource: HelperFunctions, fileUrl: string, fileName: string) {
        // Ensure the download directory exists
        await ensureDir(helperFunctionsResource.downloadDirectory);

        // Download the file
        const response = await fetch(fileUrl);
        if (!response.ok) {
            throw new Error(`Failed to download file: ${response.statusText}`);
        }
        const fileData = await response.blob();

        // Save the file to the specified directory
        const filePath = `${helperFunctionsResource.downloadDirectory}/${fileName}`;
        const fileStream = Deno.createWriteStream(filePath);
        const writableStream = new WritableStream({
            write(chunk) {
                fileStream.write(chunk);
            },
            close() {
                fileStream.close();
            }
        });

        const reader = fileData.stream().getReader();
        const pump = () => reader.read().then(({ done, value }) => {
            if (done) {
                writableStream.close();
                return;
            }
            writableStream.write(value);
            pump();
        });

        await pump();

        // Return the path to the downloaded file
        return filePath;
    }
  id: |-
    synthetic_download-file-to-tmp
  instructions: |-
    Downloads a file to in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        // Include only authentication/configuration properties relevant to any script
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed to make HTTP calls to Bitbucket's API

    class bitbucket(TypedDict):
        api_url: str
        access_token: str

    def main(bitbucket_resource: bitbucket, repository_full_name: str, issue_id: int) -> Any:
        headers = {
            'Authorization': f'Bearer {bitbucket_resource["access_token"]}',
            'Content-Type': 'application/json'
        }
        url = f'{bitbucket_resource["api_url"]}/repositories/{repository_full_name}/issues/{issue_id}'
        response = requests.get(url, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls to Bitbucket API

    class bitbucket(TypedDict):
        access_token: str

    def main(bitbucket_resource: bitbucket, api_url: str, repository_full_name: str, issue_id: int) -> Any:
        headers = {
            'Authorization': f'Bearer {bitbucket_resource["access_token"]}',
            'Content-Type': 'application/json'
        }
        url = f'{api_url}/repositories/{repository_full_name}/issues/{issue_id}'
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes
        return response.json()
  id: |-
    synthetic_get-issue
  instructions: |-
    Get a issue in bitbucket
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitbucket
  resource_type_def: |-
    class bitbucket(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Awork = {
        apiKey: string;
        workspaceId: string;
    }

    export async function main(aworkResource: Awork, projectName: string, projectDescription?: string) {
        const url = `https://api.awork.io/api/v1/workspaces/${aworkResource.workspaceId}/projects`;
        const body = {
            name: projectName,
            description: projectDescription,
            id: uuidv4() // Generate a unique identifier for the project
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${aworkResource.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { Awork as AworkSDK } from "npm:@awork/sdk";

    type Awork = {
        apiKey: string;
    }

    export async function main(aworkResource: Awork, workspaceId: string, projectName: string, projectDescription: string = '') {
        const awork = new AworkSDK({ apiKey: aworkResource.apiKey });

        const projectData = {
            name: projectName,
            description: projectDescription
        };

        try {
            const response = await awork.projects.create(workspaceId, projectData);
            return response;
        } catch (error) {
            console.error('Error creating project in Awork:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-project
  instructions: |-
    Creates a project in awork
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Awork
  resource_type_def: |-
    type Awork = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the kite_suite integration
    class kite_suite(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function to send a message using kite_suite integration
    def main(kite_suite_resource: kite_suite, message: str, recipient_id: str) -> bool:
        # Assuming there is a library to interact with kite_suite
        from kite_suite_api import KiteSuiteClient as KiteClient

        # Initialize the kite_suite client with the provided credentials
        kite_client = KiteClient(api_key=kite_suite_resource['api_key'], api_secret=kite_suite_resource['api_secret'])

        # Send the message to the specified recipient
        result = kite_client.send_message(recipient_id=recipient_id, message=message)

        # Return the result of the send_message operation
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the kite_suite integration
    class kite_suite(TypedDict):
        api_key: str
        api_secret: str
        base_url: str

    # Define the main function for sending a message using Kite Suite
    def main(kite_suite_resource: kite_suite, recipient_id: str, message: str, is_group: bool = False):
        import requests  # Import requests or any other library if needed

        # Construct the endpoint URL
        endpoint = f"{kite_suite_resource['base_url']}/sendMessage"

        # Prepare the headers and payload for the API request
        headers = {
            'Authorization': f"Bearer {kite_suite_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'recipient_id': recipient_id,
            'message': message,
            'is_group': is_group
        }

        # Send the message using a POST request
        response = requests.post(endpoint, headers=headers, json=payload)

        # Check for successful response and return the result
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to send message: {response.text}")

    # The main function is now defined and can be used with the required parameters.
  id: |-
    synthetic_send-message
  instructions: |-
    Sends a message to a user or project group using Kite Suite in kite suite
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    kite_suite
  resource_type_def: |-
    class kite_suite(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'firmao' integration
    class firmao(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a task in the 'firmao' integration
    def main(firmao_resource: firmao, task_name: str, task_description: str, assignee_id: int, due_date: str):
        # Assuming there is a library to interact with the 'firmao' API
        import firmao_api_client as client

        # Initialize the 'firmao' API client with the provided credentials
        firmao_client = client.Client(api_key=firmao_resource['api_key'], api_secret=firmao_resource['api_secret'])

        # Create the task using the 'firmao' API client
        task = firmao_client.create_task(
            name=task_name,
            description=task_description,
            assignee_id=assignee_id,
            due_date=due_date
        )

        # Return the result of the task creation
        return task
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'firmao' integration
    class firmao(TypedDict):
        api_key: str
        user_id: str

    # Define the main function for creating a new task in firmao
    def main(firmao_resource: firmao, task_name: str, task_description: str, assignee_id: int, due_date: str):
        # Assuming 'requests' library is needed for HTTP requests
        import requests

        # Define the endpoint for creating a new task in firmao
        create_task_endpoint = "https://api.firmao.net/task"

        # Prepare the headers and payload for the request
        headers = {
            "Authorization": f"Bearer {firmao_resource['api_key']}",
            "Content-Type": "application/json"
        }
        payload = {
            "name": task_name,
            "description": task_description,
            "assigned_to": assignee_id,
            "due_date": due_date,
            "created_by": firmao_resource['user_id']
        }

        # Make the request to create a new task
        response = requests.post(create_task_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created task information
        else:
            raise Exception(f"Failed to create task: {response.status_code} - {response.text}")

    # Example usage:
    # result = main(firmao_resource={'api_key': 'your_api_key', 'user_id': 'your_user_id'},
    #               task_name='New Integration Task',
    #               task_description='Create a new task in firmao for demonstration purposes.',
    #               assignee_id=12345,
    #               due_date='2023-12-31')
    # print(result)
  id: |-
    synthetic_create-task
  instructions: |-
    Create a new task for the organization in firmao
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    firmao
  resource_type_def: |-
    class firmao(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the 'gong' integration
    class gong(TypedDict):
        api_key: str
        base_url: str

    # Define the main function to retrieve transcripts of calls
    def main(gong_resource: gong, call_ids: List[str]) -> List[dict]:
        import requests  # Import requests or any other library if needed

        # Define the headers for authentication
        headers = {
            'Authorization': f'Bearer {gong_resource["api_key"]}'
        }

        # Initialize a list to store the transcripts
        transcripts = []

        # Loop through each call ID to retrieve its transcript
        for call_id in call_ids:
            # Construct the URL for the API endpoint
            url = f'{gong_resource["base_url"]}/calls/{call_id}/transcript'

            # Make the API request
            response = requests.get(url, headers=headers)

            # Check if the request was successful
            if response.status_code == 200:
                # Append the transcript to the transcripts list
                transcripts.append(response.json())
            else:
                # Handle errors (e.g., log them, throw an exception, etc.)
                # For simplicity, we'll just print an error message
                print(f'Failed to retrieve transcript for call ID {call_id}: {response.status_code}')

        # Return the list of transcripts
        return transcripts
  good: |-
    from typing import TypedDict, List, Optional
    import requests  # Assuming requests is needed to interact with the Gong API

    # Define the resource type for the Gong integration
    class gong(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for retrieving call transcripts from Gong
    def main(gong_resource: gong, call_ids: List[str], start_date: Optional[str] = None, end_date: Optional[str] = None) -> List[dict]:
        headers = {
            'Authorization': f'Bearer {gong_resource["api_key"]}'
        }

        transcripts = []
        for call_id in call_ids:
            response = requests.get(
                f'{gong_resource["base_url"]}/calls/{call_id}/transcript',
                headers=headers,
                params={
                    'start_date': start_date,
                    'end_date': end_date
                }
            )
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
            transcripts.append(response.json())

        return transcripts

    # Note: The function does not call itself, it's meant to be called with the appropriate parameters.
  id: |-
    synthetic_retrieve-transcripts-of-calls
  instructions: |-
    Retrieve transcripts of calls in gong
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gong
  resource_type_def: |-
    class gong(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    from google.oauth2.credentials import Credentials
    import googleapiclient.discovery

    class google_drive(TypedDict):
        pass

    def main(credentials: Credentials, drive_id: str, new_name: str):
        service = googleapiclient.discovery.build('drive', 'v3', credentials=credentials)

        drive_metadata = {'name': new_name}
        updated_drive = service.drives().update(driveId=drive_id, body=drive_metadata).execute()

        return updated_drive
  good: |-
    from typing import TypedDict, Optional
    import googleapiclient.discovery

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, drive_id: str, new_name: Optional[str] = None, new_theme_id: Optional[str] = None):
        service = googleapiclient.discovery.build('drive', 'v3', developerKey=google_drive_resource['api_key'])
        drive_metadata = {}
        if new_name:
            drive_metadata['name'] = new_name
        if new_theme_id:
            drive_metadata['themeId'] = new_theme_id

        request = service.drives().update(driveId=drive_id, body=drive_metadata, fields='id, name, themeId')
        response = request.execute()

        return response
  id: |-
    synthetic_update-shared-drive
  instructions: |-
    Update an existing shared drive for more information in google drive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_drive
  resource_type_def: |-
    class google_drive(TypedDict):
        pass
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Dropbox } from "npm:dropbox";

    type Dropbox = {
        accessToken: string;
    }

    export async function main(dropboxResource: Dropbox, path: string): Promise<any> {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        try {
            const response = await dbx.filesDeleteV2({ path });
            return response;
        } catch (error) {
            console.error('Error deleting file/folder:', error);
            throw error;
        }
    }
  good: |-
    import { Dropbox } from "npm:dropbox";

    type DropboxResource = {
        accessToken: string;
    }

    export async function main(dropboxResource: DropboxResource, path: string): Promise<any> {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        try {
            const response = await dbx.filesDeleteV2({ path });
            return response;
        } catch (error) {
            console.error('Error deleting file/folder:', error);
            throw error;
        }
    }
  id: |-
    synthetic_delete-file-folder
  instructions: |-
    Permanently removes a file/folder from the server in dropbox
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dropbox
  resource_type_def: |-
    type Dropbox = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Jumpseller = {
        storeUrl: string;
        adminEmail: string;
        authToken: string;
    }

    export async function main(jumpsellerResource: Jumpseller, productName: string, productPrice: number, productStock: number, productDescription: string, productCategory: string, productImages: string[]) {
        const url = `${jumpsellerResource.storeUrl}/api/v1/products.json`;
        const authHeader = `Basic ${encode(`${jumpsellerResource.adminEmail}:${jumpsellerResource.authToken}`)}`;

        const productData = {
            product: {
                name: productName,
                price: productPrice,
                stock: productStock,
                description: productDescription,
                category: productCategory,
                images: productImages.map((image) => ({ src: image }))
            }
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader
            },
            body: JSON.stringify(productData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    import { JumpsellerClient as JumpsellerApiClient } from "npm:jumpseller-api";

    type Jumpseller = {
        accessToken: string;
        storeId: string;
    }

    export async function main(jumpsellerResource: Jumpseller, productName: string, productPrice: number, productStock: number, productDescription: string, productCategory: string, productImages: string[]) {
        const client = new JumpsellerApiClient({
            accessToken: jumpsellerResource.accessToken,
            storeId: jumpsellerResource.storeId,
        });

        const productData = {
            name: productName,
            price: productPrice,
            stock: productStock,
            description: productDescription,
            category: productCategory,
            images: productImages.map(url => ({ src: url })),
        };

        const result = await client.createProduct(productData);

        return result;
    }
  id: |-
    synthetic_create-product
  instructions: |-
    Create a new product in Jumpseller in jumpseller
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jumpseller
  resource_type_def: |-
    type Jumpseller = {
        accessToken: string;
        storeId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { OAuth2Client } from "npm:google-auth-library";

    type GoogleTasks = {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
        accessToken: string;
        scope: string;
        tokenType: string;
        expiryDate: number;
    }

    export async function main(
        googleTasksResource: GoogleTasks,
        taskListId: string,
        title: string,
        notes?: string,
        due?: string
    ) {
        // Initialize OAuth2 Client
        const oauth2Client = new OAuth2Client(
            googleTasksResource.clientId,
            googleTasksResource.clientSecret
        );

        // Set credentials for the OAuth2 client
        oauth2Client.setCredentials({
            refresh_token: googleTasksResource.refreshToken,
            access_token: googleTasksResource.accessToken,
            scope: googleTasksResource.scope,
            token_type: googleTasksResource.tokenType,
            expiry_date: googleTasksResource.expiryDate
        });

        // Define the API endpoint to create a new task
        const endpoint = `https://tasks.googleapis.com/tasks/v1/lists/${taskListId}/tasks`;

        // Construct the task object
        const task = {
            title: title,
            notes: notes,
            due: due
        };

        // Make an authenticated request to create a new task
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${oauth2Client.credentials.access_token}`,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(task)
        });

        // Parse the response as JSON
        const result = await response.json();

        // Return the result
        return result;
    }
  good: |-
    import { tasks_v1, google } from "npm:googleapis";

    type GoogleTasks = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(
        googleTasksResource: GoogleTasks,
        taskListId: string,
        title: string,
        notes?: string,
        due?: string
    ) {
        const tasksApi = google.tasks({ version: 'v1', auth: googleTasksResource.apiKey });
        const authClient = google.auth.fromAPIKey(googleTasksResource.apiKey);
        authClient.setCredentials({ access_token: googleTasksResource.accessToken });

        const task = {
            title: title,
            notes: notes,
            due: due
        };

        const result = await tasksApi.tasks.insert({
            tasklist: taskListId,
            requestBody: task,
            auth: authClient
        });

        return result.data;
    }
  id: |-
    synthetic_create-task
  instructions: |-
    Creates a new task and adds it to the authenticated user's task lists in google tasks
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleTasks
  resource_type_def: |-
    type GoogleTasks = {
        apiKey: string;
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'libraria' integration
    class libraria(TypedDict):
        api_key: str
        endpoint_url: str

    # Define the main function for adding a document to the 'libraria' integration
    def main(libraria_resource: libraria, document_title: str, document_content: str, document_category: str):
        # Assuming there's a library to interact with the 'libraria' API
        import libraria_client as lc

        # Create a new document with the given parameters
        document = {
            'title': document_title,
            'content': document_content,
            'category': document_category
        }

        # Use the 'libraria' resource to authenticate and interact with the API
        client = lc.Client(api_key=libraria_resource['api_key'], endpoint_url=libraria_resource['endpoint_url'])
        result = client.add_document(document)

        # Return the result of the API call
        return result
  good: |-
    from typing import TypedDict

    # Define the resource type for the 'libraria' integration
    class libraria(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for adding a document to 'libraria'
    def main(libraria_resource: libraria, document_title: str, document_content: str, author_name: str, category: str):
        # Import the requests library here to avoid potential naming conflicts
        import requests

        # Construct the URL for the 'add document' endpoint
        add_document_url = f"{libraria_resource['base_url']}/add-document"

        # Prepare the headers and payload for the request
        headers = {
            'Authorization': f"Bearer {libraria_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'title': document_title,
            'content': document_content,
            'author': author_name,
            'category': category
        }

        # Make the POST request to add the document
        response = requests.post(add_document_url, json=payload, headers=headers)

        # Check if the request was successful and return the result
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to add document: {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  id: |-
    synthetic_add-document
  instructions: |-
    Add a document in libraria
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    libraria
  resource_type_def: |-
    class libraria(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the requests library, which is commonly used for HTTP requests
    import requests as http_requests

    def main(facebook_groups_resource: facebook_groups, group_id: str, post_id: str) -> List[dict]:
        # Construct the URL for the Facebook Graph API to get reactions on a group post
        url = f"https://graph.facebook.com/v14.0/{group_id}_{post_id}/reactions"

        # Prepare the headers with the access token
        headers = {
            'Authorization': f"Bearer {facebook_groups_resource['access_token']}"
        }

        # Make the HTTP GET request to the Facebook Graph API
        response = http_requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the list of reactions
            return response.json().get('data', [])
        else:
            # If the request failed, raise an exception with the error message
            response.raise_for_status()

    # Note: The function does not call itself, it's meant to be called with the appropriate parameters.
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the facebook_groups integration
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str

    def main(facebook_groups_resource: facebook_groups, post_id: str) -> List[dict]:
        # Construct the URL for the Facebook Graph API to list reactions
        url = f"https://graph.facebook.com/v14.0/{facebook_groups_resource['group_id']}/{post_id}/reactions"

        # Prepare the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {facebook_groups_resource['access_token']}"
        }

        # Make the GET request to the Facebook Graph API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Parse the response JSON and return the list of reactions
            return response.json().get('data', [])
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Note: The function is not called here, it's just defined and ready to be exported.
  id: |-
    synthetic_list-reactions
  instructions: |-
    Retrieves a list of reactions on a group post in facebook groups
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    facebook_groups
  resource_type_def: |-
    class facebook_groups(TypedDict):
        access_token: str
        group_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming that requests might be used for a proxy GET request

    # Define the resource type for the 'nango' integration
    class nango(TypedDict):
        api_key: str
        base_url: str

    def main(nango_resource: nango, endpoint: str, query_params: dict[str, Any] = None) -> requests.Response:
        # Construct the full URL for the GET request
        url = f"{nango_resource['base_url']}{endpoint}"

        # Prepare the headers with the API key
        headers = {
            'Authorization': f"Bearer {nango_resource['api_key']}"
        }

        # Make the GET request
        response = requests.get(url, headers=headers, params=query_params)

        # Return the response object
        return response
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is the library used for HTTP requests

    # Define the resource type for the 'nango' integration
    class nango(TypedDict):
        api_key: str
        proxy_url: str

    # Define the main function with the nango resource and additional parameters for the POST request
    def main(nango_resource: nango, url: str, data: dict, headers: dict = None):
        # Prepare the proxy dictionary for the requests library
        proxies = {
            "http": nango_resource['proxy_url'],
            "https": nango_resource['proxy_url'],
        }

        # Include the API key in the headers
        if headers is None:
            headers = {}
        headers['Authorization'] = f"Bearer {nango_resource['api_key']}"

        # Make the POST request using the proxy
        response = requests.post(url, data=data, headers=headers, proxies=proxies)

        # Return the response
        return response.json()
  id: |-
    synthetic_proxy-get
  instructions: |-
    Make a post request with the Proxy in nango
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nango
  resource_type_def: |-
    class nango(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to asknicely API

    class asknicely(TypedDict):
        api_key: str
        domain: str

    def main(asknicely_resource: asknicely, contact_email: str, contact_name: str, additional_fields: dict = None):
        base_url = f"https://{asknicely_resource['domain']}.asknice.ly/api/v1"
        headers = {
            "X-Api-Key": asknicely_resource['api_key'],
            "Content-Type": "application/json"
        }
        contact_data = {
            "email": contact_email,
            "name": contact_name
        }
        if additional_fields:
            contact_data.update(additional_fields)

        response = requests.post(f"{base_url}/contacts", headers=headers, json=contact_data)
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'asknicely' integration
    class asknicely(TypedDict):
        api_key: str
        domain: str

    # Define the main function for adding a contact to asknicely
    def main(asknicely_resource: asknicely, contact_email: str, contact_name: str, additional_fields: dict[str, Any] = {}):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for adding a contact
        api_endpoint = f"https://{asknicely_resource['domain']}.asknice.ly/api/v1/contacts"

        # Prepare the headers for the request
        headers = {
            "X-Api-Key": asknicely_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the request
        data = {
            "email": contact_email,
            "name": contact_name,
            **additional_fields  # Include any additional fields provided
        }

        # Make the request to add the contact
        response = requests.post(api_endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the JSON response if successful
        else:
            response.raise_for_status()  # Raise an exception if the request failed

    # The main function is now defined and can be used to add a contact to asknicely
  id: |-
    synthetic_add-contact
  instructions: |-
    Add a new contact in asknicely
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    asknicely
  resource_type_def: |-
    class asknicely(TypedDict):
        api_key: str
        domain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Dealmachine = {
        apiKey: string;
    }

    export async function main(dealmachineResource: Dealmachine, noteContent: string, dealId: number) {
        const url = `https://api.dealmachine.com/api/v1/deals/${dealId}/notes`;
        const headers = {
            "Authorization": `Basic ${encode(dealmachineResource.apiKey)}`,
            "Content-Type": "application/json"
        };
        const body = JSON.stringify({
            note: noteContent
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { DealmachineClient } from "npm:dealmachine-sdk"; // Assuming there's an npm package for Dealmachine

    type Dealmachine = {
        apiKey: string;
        // Add other properties needed for Dealmachine authentication/configuration
    }

    export async function main(dealmachineResource: Dealmachine, leadId: string, noteContent: string) {
        // Initialize the Dealmachine client with the provided API key
        const client = new DealmachineClient(dealmachineResource.apiKey);

        // Create a note for the lead in Dealmachine
        const result = await client.createNoteForLead(leadId, noteContent);

        // Return the result
        return result;
    }
  id: |-
    synthetic_create-note
  instructions: |-
    Create a note for the lead in dealmachine
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dealmachine
  resource_type_def: |-
    type Dealmachine = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the basecamp integration
    class basecamp(TypedDict):
        access_token: str

    def main(basecamp_resource: basecamp, project_id: str, message: str, subject: str) -> Any:
        # Base URL for Basecamp API
        base_url = "https://3.basecampapi.com"

        # Headers for authentication and content type
        headers = {
            "Authorization": f"Bearer {basecamp_resource['access_token']}",
            "Content-Type": "application/json",
        }

        # Endpoint for creating a message in a specific project
        endpoint = f"/{project_id}/buckets/{project_id}/messages.json"

        # Data payload for the message
        data = {
            "subject": subject,
            "content": message
        }

        # Make the POST request to create a message
        response = requests.post(f"{base_url}{endpoint}", headers=headers, json=data)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict
    import basecampy3  # Assuming basecampy3 is the library used for Basecamp API

    class basecamp(TypedDict):
        access_token: str
        project_id: int
        board_id: int

    def main(basecamp_resource: basecamp, message_title: str, message_content: str):
        bc3 = basecampy3.Basecamp3(access_token=basecamp_resource['access_token'])
        project = bc3.projects.get(basecamp_resource['project_id'])
        message_board = project.message_board
        new_message = message_board.post(message_title, message_content)

        return new_message
  id: |-
    synthetic_create-message
  instructions: |-
    Publishes a message in the project and message board selected in basecamp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    basecamp
  resource_type_def: |-
    class basecamp(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class cloudflare_api_key(TypedDict):
        email: str
        api_key: str

    def main(cloudflare_resource: cloudflare_api_key, mode: str, configuration: str, notes: str):
        url = "https://api.cloudflare.com/client/v4/accounts/{account_id}/rules"
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json"
        }
        data = {
            "mode": mode,
            "configuration": {
                "target": "ip",
                "value": configuration
            },
            "notes": notes
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()
  good: |-
    from typing import TypedDict

    # Define the resource type for the Cloudflare API key integration
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str

    # Define the main function for creating an IP access rule
    def main(cloudflare_resource: cloudflare_api_key, zone_id: str, mode: str, ip: str, note: str):
        import requests  # Import requests or any other library if needed

        # Construct the headers for authentication
        headers = {
            "X-Auth-Email": cloudflare_resource['email'],
            "X-Auth-Key": cloudflare_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Construct the URL for the Cloudflare API endpoint
        url = f"https://api.cloudflare.com/client/v4/zones/{zone_id}/firewall/access_rules/rules"

        # Construct the payload with the parameters provided
        payload = {
            "mode": mode,
            "configuration": {
                "target": "ip",
                "value": ip
            },
            "notes": note
        }

        # Make the POST request to create the IP access rule
        response = requests.post(url, headers=headers, json=payload)

        # Return the result of the API call
        return response.json()
  id: |-
    synthetic_create-ip-access-rule
  instructions: |-
    Creates a new IP Access Rule for an account. The rule will apply to all zones in the account in cloudflare api key
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    cloudflare_api_key
  resource_type_def: |-
    class cloudflare_api_key(TypedDict):
        api_key: str
        email: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { request } from "npm:@octokit/request";

    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueKey: string) {
        const { host, email, apiToken } = jiraResource;
        const auth = Buffer.from(`${email}:${apiToken}`).toString('base64');
        const url = `${host}/rest/api/3/issue/${issueKey}`;

        const response = await request('GET /', {
            headers: {
                Authorization: `Basic ${auth}`,
                Accept: 'application/json'
            },
            baseUrl: url
        });

        return response.data;
    }
  good: |-
    import { encode } from "npm:@std/encoding/base64";

    type Jira = {
        baseUrl: string;
        username: string;
        apiToken: string;
    }

    export async function main(jiraResource: Jira, issueKey: string) {
        const authHeader = `Basic ${encode(`${jiraResource.username}:${jiraResource.apiToken}`)}`;
        const issueUrl = `${jiraResource.baseUrl}/rest/api/2/issue/${issueKey}`;

        const response = await fetch(issueUrl, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching issue details: ${response.status} ${response.statusText}`);
        }

        const issueDetails = await response.json();
        return issueDetails;
    }
  id: |-
    synthetic_get-issue
  instructions: |-
    Gets the details for an issue in jira
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Jira
  resource_type_def: |-
    type Jira = {
        host: string;
        email: string;
        apiToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import clearbit as clearbit_api  # Renamed the clearbit module to avoid conflict

    class clearbit(TypedDict):
        api_key: str

    def main(clearbit_resource: clearbit, company_name: str) -> Optional[str]:
        clearbit_api.key = clearbit_resource['api_key']

        # Perform a lookup to find the company domain by its name
        response = clearbit_api.Enrichment.find(domain=None, email=None, company=company_name, stream=False)

        # Extract the domain if the company is found
        if response and 'domain' in response['company']:
            return response['company']['domain']
        else:
            return None
  good: |-
    from typing import TypedDict, Tuple
    import clearbit as clearbit_lib

    class clearbit(TypedDict):
        api_key: str

    def main(clearbit_resource: clearbit, company_name: str) -> Tuple[str, str]:
        clearbit_lib.key = clearbit_resource['api_key']
        company_info = clearbit_lib.Company.find(domain=None, name=company_name)

        if company_info:
            domain = company_info['domain']
            logo = company_info['logo']
            return domain, logo
        else:
            return "Not found", "Not found"
  id: |-
    synthetic_company-name-to-domain
  instructions: |-
    The Company Name to Domain action lets you convert the exact name of a company to a website domain, and a logo. in clearbit
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clearbit
  resource_type_def: |-
    class clearbit(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the google_drive integration
    class google_drive(TypedDict):
        access_token: str  # Assuming OAuth2 access token is provided

    # Import the Google Drive API client library, renaming it if it conflicts with the resource type name
    from googleapiclient.discovery import build as build_google_drive_client

    def main(google_drive_resource: google_drive, file_or_folder_id: str) -> dict:
        # Initialize the Google Drive API client
        service = build_google_drive_client('drive', 'v3', credentials=google_drive_resource)

        # Use the Google Drive API to delete the specified file or folder
        result = service.files().delete(fileId=file_or_folder_id).execute()

        # Return the result of the deletion operation
        return result
  good: |-
    from typing import TypedDict
    import googleapiclient.discovery

    class google_drive(TypedDict):
        api_key: str
        access_token: str

    def main(google_drive_resource: google_drive, file_id: str) -> dict:
        service = googleapiclient.discovery.build('drive', 'v3', developerKey=google_drive_resource['api_key'])
        service.files().delete(fileId=file_id).execute()
        return {"status": "success", "fileId": file_id}
  id: |-
    synthetic_delete-file
  instructions: |-
    The file or folder to delete in google drive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_drive
  resource_type_def: |-
    class google_drive(TypedDict):
        api_key: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is used for HTTP calls

    # Define the resource type for the insightly integration
    class insightly(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for creating a new contact in insightly
    def main(insightly_resource: insightly, first_name: str, last_name: str, email: str, phone: str) -> Any:
        # Construct the headers for authentication
        headers = {
            'Authorization': f'Basic {insightly_resource["api_key"]}',
            'Content-Type': 'application/json'
        }

        # Construct the payload with the contact details
        payload = {
            'FIRST_NAME': first_name,
            'LAST_NAME': last_name,
            'CONTACTINFOS': [
                {
                    'TYPE': 'EMAIL',
                    'LABEL': 'Work',
                    'DETAIL': email
                },
                {
                    'TYPE': 'PHONE',
                    'LABEL': 'Work',
                    'DETAIL': phone
                }
            ]
        }

        # Make the POST request to create a new contact
        response = requests.post(f'{insightly_resource["base_url"]}/v3.1/Contacts', json=payload, headers=headers)

        # Return the response from the API call
        return response.json()
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'insightly' integration
    class insightly(TypedDict):
        api_key: str

    # Define the main function for creating a contact in Insightly
    def main(insightly_resource: insightly, first_name: str, last_name: str, email: str, phone: str = None, address: str = None) -> Any:
        import requests  # Import requests or any other library if needed

        # Insightly API endpoint for creating a contact
        url = "https://api.insight.ly/v3.1/Contacts"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {insightly_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload with the contact details
        data = {
            "FIRST_NAME": first_name,
            "LAST_NAME": last_name,
            "EMAIL_ADDRESS": email,
        }

        # Add optional fields if provided
        if phone:
            data["PHONE"] = phone
        if address:
            data["ADDRESS_MAIL_STREET"] = address

        # Make the POST request to create the contact
        response = requests.post(url, headers=headers, json=data)

        # Return the response from the API call
        return response.json()
  id: |-
    synthetic_create-contact
  instructions: |-
    Creates a new contact in insightly
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    insightly
  resource_type_def: |-
    class insightly(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
    }

    export async function main(
        microsoft365PeopleResource: Microsoft365People,
        resource: string,
        contactId: string,
        updateFields: { [key: string]: any }
    ) {
        // Initialize Microsoft Graph client
        const client = Client.init({
            authProvider: async (done) => {
                // Implement authentication logic here
                // For example, you might need to fetch an access token using the provided credentials
                // and then call the done callback with the token like this:
                // done(null, accessToken);
            }
        });

        // Update the contact
        const result = await client.api(`/me/contacts/${contactId}`)
            .header("Content-Type", "application/json")
            .update(updateFields);

        return result;
    }
  good: |-
    import { Client } from "npm:@microsoft/microsoft-graph-client";

    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        accessToken: string; // Assuming the OAuth2 flow has been completed and we have an access token
    }

    export async function main(
        microsoft365PeopleResource: Microsoft365People,
        contactId: string,
        updateFields: { [key: string]: any }
    ) {
        // Initialize the Microsoft Graph client with the provided credentials
        const client = Client.init({
            authProvider: (done) => {
                done(null, microsoft365PeopleResource.accessToken); // First parameter takes an error if there is one
            }
        });

        // Update the contact with the given ID and fields
        const result = await client.api(`/me/contacts/${contactId}`)
            .header("Content-Type", "application/json")
            .update(updateFields);

        return result;
    }
  id: |-
    synthetic_update-contact
  instructions: |-
    Updates an existing contact in Microsoft 365 People in microsoft 365 people
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Microsoft365People
  resource_type_def: |-
    type Microsoft365People = {
        tenantId: string;
        clientId: string;
        clientSecret: string;
        authEndpoint: string;
        tokenEndpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:@std/encoding/base64";

    type Mailgun = {
        apiKey: string;
        domain: string;
    }

    export async function main(mailgunResource: Mailgun, listAddress: string, memberAddress: string) {
        const authHeader = `Basic ${encode(`api:${mailgunResource.apiKey}`)}`;
        const url = `https://api.mailgun.net/v3/lists/${encodeURIComponent(listAddress)}/members/${encodeURIComponent(memberAddress)}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
            },
        });

        if (!response.ok) {
            throw new Error(`Error fetching mailing list member: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();
        return result;
    }
  good: |-
    import { Client as MailgunClient } from "npm:@mailgun/mailgun.js";

    type Mailgun = {
        apiKey: string;
        domain: string;
    }

    export async function main(mailgunResource: Mailgun, mailingListAddress: string, memberEmailAddress: string) {
        const mailgunClient = new MailgunClient({ username: 'api', key: mailgunResource.apiKey });

        try {
            const member = await mailgunClient.lists.members.get(mailgunResource.domain, mailingListAddress, memberEmailAddress);
            return member;
        } catch (error) {
            console.error(error);
            throw error;
        }
    }
  id: |-
    synthetic_retrieve-mailinglist-member
  instructions: |-
    Retrieve a mailing list member by address in mailgun
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailgun
  resource_type_def: |-
    type Mailgun = {
        apiKey: string;
        domain: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Jira API

    # Define the resource type for the Jira integration
    class jira(TypedDict):
        base_url: str
        email: str
        api_token: str

    def main(jira_resource: jira, project_key: str) -> bool:
        # Construct the API endpoint for deleting a project
        api_endpoint = f"{jira_resource['base_url']}/rest/api/3/project/{project_key}"

        # Set up the authentication headers
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": f"Basic {jira_resource['api_token']}"
        }

        # Make the request to delete the project
        response = requests.delete(api_endpoint, headers=headers)

        # Check if the deletion was successful
        if response.status_code == 204:
            return True  # Project was successfully deleted
        else:
            response.raise_for_status()  # Raise an HTTPError if the deletion failed

    # The main function is not called, as per the instructions.
  good: |-
    from typing import TypedDict
    import base64
    import requests as req

    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str

    def main(jira_resource: jira, project_key: str) -> bool:
        api_endpoint = f"{jira_resource['base_url']}/rest/api/3/project/{project_key}"

        # Encode the credentials for Basic Authentication
        credentials = base64.b64encode(f"{jira_resource['username']}:{jira_resource['api_token']}".encode('utf-8')).decode('utf-8')

        headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': f'Basic {credentials}'
        }

        response = req.delete(api_endpoint, headers=headers)

        if response.status_code == 204:
            return True
        else:
            response.raise_for_status()
            return False
  id: |-
    synthetic_delete-project
  instructions: |-
    Deletes a project, in jira
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    jira
  resource_type_def: |-
    class jira(TypedDict):
        base_url: str
        username: str
        api_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { hmacSha256 } from "npm:@noble/hashes/sha256";
    import { bytesToHex } from "npm:@noble/hashes/utils";

    type Clevertap = {
        accountId: string;
        passcode: string;
        regionValue: string;
    }

    export async function main(
        clevertapResource: Clevertap,
        identity: string,
        name?: string,
        email?: string,
        phone?: string,
        profileData?: Record<string, any>
    ) {
        const baseUrl = `https://${clevertapResource.regionValue}.api.clevertap.com/1/upload`;
        const ts = Math.floor(Date.now() / 1000);
        const X_CleverTap_Account_Id = clevertapResource.accountId;
        const X_CleverTap_Passcode = clevertapResource.passcode;
        const body = {
            "d": [
                {
                    "objectId": identity,
                    "type": "profile",
                    "profileData": {
                        "Name": name,
                        "Email": email,
                        "Phone": phone,
                        ...profileData
                    },
                    "ts": ts
                }
            ]
        };

        const X_CleverTap_TS = ts.toString();
        const signString = `${X_CleverTap_Account_Id}:${X_CleverTap_Passcode}:${X_CleverTap_TS}`;
        const X_CleverTap_Signature = bytesToHex(hmacSha256(signString, clevertapResource.passcode));

        const response = await fetch(baseUrl, {
            method: 'POST',
            headers: {
                'X-CleverTap-Account-Id': X_CleverTap_Account_Id,
                'X-CleverTap-Passcode': X_CleverTap_Passcode,
                'X-CleverTap-TS': X_CleverTap_TS,
                'X-CleverTap-Signature': X_CleverTap_Signature,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { CleverTap as CleverTapClient } from "npm:clevertap";

    type Clevertap = {
        accountId: string;
        passcode: string;
        regionValue: string;
    }

    export async function main(
        clevertapResource: Clevertap,
        identity: string,
        name: string,
        email: string,
        phone?: string,
        profileData?: Record<string, any>
    ) {
        const clevertapClient = new CleverTapClient(clevertapResource.accountId, clevertapResource.passcode, clevertapResource.regionValue);

        const profileUpdate = {
            "d": [{
                "objectId": identity,
                "type": "profile",
                "profileData": {
                    "Name": name,
                    "Email": email,
                    ...profileData
                },
                "ts": 1
            }]
        };

        if (phone) {
            profileUpdate.d[0].profileData['Phone'] = phone;
        }

        try {
            const response = await clevertapClient.uploadEvents(profileUpdate);
            return response;
        } catch (error) {
            console.error('Error updating CleverTap user profile:', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-or-update-user
  instructions: |-
    Create or update an user in clevertap
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clevertap
  resource_type_def: |-
    type Clevertap = {
        accountId: string;
        passcode: string;
        regionValue: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { KanbanToolClient } from "npm:kanban-tool-api";

    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
    }

    export async function main(kanbanResource: KanbanTool, taskName: string) {
        const client = new KanbanToolClient(kanbanResource.apiKey, kanbanResource.domain);
        const board = await client.getBoard(kanbanResource.boardId);
        const tasks = await board.getTasks();
        const foundTask = tasks.find(task => task.name === taskName);

        return foundTask;
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:querystring";

    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
    }

    export async function main(kanbanToolResource: KanbanTool, taskName: string, swimlaneName?: string, stageName?: string) {
        const baseUrl = `https://${kanbanToolResource.domain}.kanbantool.com/api/v1`;
        const authParams = `?api_token=${kanbanToolResource.apiKey}`;
        const boardId = kanbanToolResource.boardId;
        const tasksUrl = `${baseUrl}/boards/${boardId}/tasks${authParams}`;

        try {
            const response = await fetch(tasksUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const tasks = await response.json();

            const filteredTasks = tasks.filter((task: any) => {
                const matchesTaskName = task.name === taskName;
                const matchesSwimlaneName = swimlaneName ? task.swimlane.name === swimlaneName : true;
                const matchesStageName = stageName ? task.stage.name === stageName : true;
                return matchesTaskName && matchesSwimlaneName && matchesStageName;
            });

            return filteredTasks;
        } catch (error) {
            console.error("Failed to fetch tasks:", error);
            throw error;
        }
    }
  id: |-
    synthetic_find-task
  instructions: |-
    Finds task with given parameters in kanban tool
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    KanbanTool
  resource_type_def: |-
    type KanbanTool = {
        apiKey: string;
        domain: string;
        boardId: number;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
        authToken: string;
    }

    export async function main(notionResource: Notion, sourcePageId: string, parentPageId: string, pageTitle: string) {
        const notion = new Client({ auth: notionResource.authToken });

        // Retrieve the block children of the source page
        const response = await notion.blocks.children.list({
            block_id: sourcePageId,
        });

        // Create a new page under the specified parent page with the given title
        const newPage = await notion.pages.create({
            parent: { page_id: parentPageId },
            properties: {
                title: {
                    title: [
                        {
                            text: {
                                content: pageTitle,
                            },
                        },
                    ],
                },
            },
            children: response.results,
        });

        return newPage;
    }
  good: |-
    import { Client as NotionClient } from "@notionhq/client";

    type Notion = {
        authToken: string;
    }

    export async function main(notionResource: Notion, pageId: string, parentPageId?: string) {
        const notion = new NotionClient({ auth: notionResource.authToken });

        const response = await notion.pages.retrieve({ page_id: pageId });
        if (!response || !response.id) {
            throw new Error('Failed to retrieve the page from Notion.');
        }

        const duplicatePage = {
            parent: {
                page_id: parentPageId || response.parent.page_id
            },
            properties: response.properties,
            children: response.children
        };

        const duplicatedPageResponse = await notion.pages.create(duplicatePage);

        return duplicatedPageResponse;
    }
  id: |-
    synthetic_duplicate-page
  instructions: |-
    Creates a new page copied from an existing page block in notion
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
        authToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { KiteClient } from "npm:kitesuite-sdk";

    type KiteSuite = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(kiteSuiteResource: KiteSuite, taskId: string, taskStatus: string, taskDetails: string) {
        const kiteClient = new KiteClient({
            apiKey: kiteSuiteResource.apiKey,
            apiSecret: kiteSuiteResource.apiSecret,
        });

        const result = await kiteClient.updateTask(taskId, {
            status: taskStatus,
            details: taskDetails,
        });

        return result;
    }
  good: |-
    import { KiteClient } from "npm:kite-suite";

    type KiteSuite = {
        apiKey: string;
        projectId: string;
    }

    export async function main(kiteSuiteResource: KiteSuite, taskId: string, updatedTaskDetails: { title?: string, description?: string, status?: string }) {
        const kite = new KiteClient(kiteSuiteResource.apiKey);

        const updatedTask = await kite.updateTask(kiteSuiteResource.projectId, taskId, updatedTaskDetails);

        return updatedTask;
    }
  id: |-
    synthetic_update-task
  instructions: |-
    Update an existing task in a project. in kite suite
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    KiteSuite
  resource_type_def: |-
    type KiteSuite = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests

    class imgbb(TypedDict):
        api_key: str

    def main(imgbb_resource: imgbb, image_path: str, name: str = None, expiration: int = None):
        with open(image_path, 'rb') as image_file:
            files = {
                'image': image_file,
            }
            data = {
                'key': imgbb_resource['api_key'],
            }
            if name:
                data['name'] = name
            if expiration:
                data['expiration'] = expiration

            response = requests.post('https://api.imgbb.com/1/upload', files=files, data=data)
            return response.json()
  good: |-
    from typing import TypedDict
    import requests

    class imgbb(TypedDict):
        api_key: str

    def main(imgbb_resource: imgbb, image_path: str, name: str = None, expiration: int = None):
        with open(image_path, 'rb') as image_file:
            files = {
                'image': image_file,
            }
            data = {
                'key': imgbb_resource['api_key'],
            }
            if name:
                data['name'] = name
            if expiration:
                data['expiration'] = expiration

            response = requests.post('https://api.imgbb.com/1/upload', files=files, data=data)
            return response.json()
  id: |-
    synthetic_upload-picture
  instructions: |-
    Upload a picture to imgbb in imgbb
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    imgbb
  resource_type_def: |-
    class imgbb(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, path: string): Promise<string | null> {
        const { apiKey, accessToken } = googleDriveResource;
        const drive = google.drive({ version: 'v3', auth: apiKey });
        drive.auth.setCredentials({ access_token: accessToken });

        const folders = path.split('/').filter(p => p.length > 0);
        let currentFolderId = 'root';

        for (const folderName of folders) {
            const response = await drive.files.list({
                q: `mimeType='application/vnd.google-apps.folder' and name='${folderName}' and '${currentFolderId}' in parents and trashed=false`,
                fields: 'files(id, name)',
                spaces: 'drive',
            });

            const folder = response.data.files?.find(f => f.name === folderName);
            if (folder && folder.id) {
                currentFolderId = folder.id;
            } else {
                return null; // Folder not found
            }
        }

        return currentFolderId;
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        accessToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, path: string): Promise<string | null> {
        const drive = google.drive({ version: 'v3' });
        drive.credentials = { access_token: googleDriveResource.accessToken };

        const folders = path.split('/').filter(p => p.length > 0);
        let currentFolderId = 'root';

        for (const folderName of folders) {
            const response = await drive.files.list({
                q: `mimeType='application/vnd.google-apps.folder' and name='${folderName}' and '${currentFolderId}' in parents and trashed=false`,
                fields: 'files(id, name)',
                spaces: 'drive',
            });

            const folder = response.data.files?.find(f => f.name === folderName);
            if (folder) {
                currentFolderId = folder.id!;
            } else {
                return null; // Folder not found
            }
        }

        return currentFolderId;
    }
  id: |-
    synthetic_get-folder-id-for-path
  instructions: |-
    Retrieve a folderId for a path for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import asana

    class asana(TypedDict):
        access_token: str
        workspace_id: str

    def main(asana_resource: asana, project_id: str, task_name: str) -> Optional[dict]:
        client = asana.Client.access_token(asana_resource['access_token'])
        tasks = client.tasks.find_by_project(project_id, {"opt_fields": "name"})

        for task in tasks:
            if task['name'] == task_name:
                return task

        return None
  good: |-
    from typing import TypedDict, List
    import asana as asana_client

    class asana(TypedDict):
        access_token: str

    def main(asana_resource: asana, project_id: str, task_name: str) -> List[dict]:
        client = asana_client.Client.access_token(asana_resource['access_token'])
        tasks = client.tasks.find_by_project(project_id, {"opt_fields": "name"})
        matching_tasks = [task for task in tasks if task['name'] == task_name]
        return matching_tasks
  id: |-
    synthetic_search-tasks
  instructions: |-
    Searches for a Task by name within a Project in asana
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    asana
  resource_type_def: |-
    class asana(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Dropbox } from "npm:dropbox";

    type DropboxResource = {
        accessToken: string;
    }

    export async function main(dropboxResource: DropboxResource, filePath: string, newLine: string) {
        const dbx = new Dropbox({ accessToken: dropboxResource.accessToken });
        let fileContent = '';

        try {
            // Try to download the existing file
            const downloadResponse = await dbx.filesDownload({ path: filePath });
            const blob = (downloadResponse.result as any).fileBlob;
            fileContent = await blob.text();
        } catch (error) {
            if (error.status !== 409) { // 409 is a not_found error, other errors should be thrown
                throw error;
            }
            // If the file does not exist, we'll create it with the new line
        }

        // Append the new line to the existing content or start with the new line
        fileContent += (fileContent ? '\n' : '') + newLine;

        // Convert the updated content to a Blob
        const updatedBlob = new Blob([fileContent], { type: 'text/plain' });

        // Upload the updated file content
        await dbx.filesUpload({
            path: filePath,
            contents: updatedBlob,
            mode: { ".tag": "overwrite" }
        });

        return { success: true, message: `Line added to ${filePath}` };
    }
  good: |-
    import { Dropbox as DropboxClient, files } from "npm:dropbox";

    type Dropbox = {
        accessToken: string;
    }

    export async function main(dropbox: Dropbox, filePath: string, content: string, mode: 'add' | 'overwrite' = 'add') {
        const dbx = new DropboxClient({ accessToken: dropbox.accessToken });

        let writeMode: files.WriteMode;
        if (mode === 'add') {
            writeMode = { '.tag': 'append' };
        } else {
            writeMode = { '.tag': 'overwrite' };
        }

        try {
            const response = await dbx.filesUpload({
                path: filePath,
                contents: content,
                mode: writeMode,
                autorename: true,
            });
            return response;
        } catch (error) {
            console.error('Error uploading file: ', error);
            throw error;
        }
    }
  id: |-
    synthetic_create-or-append-to-a-text-file
  instructions: |-
    Adds a new line to an existing text file, or creates a file if it doesn't exist in dropbox
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dropbox
  resource_type_def: |-
    type Dropbox = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'devrev' integration
    class devrev(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a ticket in the 'devrev' integration
    def main(devrev_resource: devrev, title: str, description: str, priority: str, tags: list[str]):
        # Import the necessary library for HTTP requests
        import requests

        # Define the API endpoint for creating a ticket
        create_ticket_endpoint = "https://api.devrev.ai/ticket"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {devrev_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the ticket
        data = {
            "title": title,
            "description": description,
            "priority": priority,
            "tags": tags
        }

        # Make the HTTP POST request to create the ticket
        response = requests.post(create_ticket_endpoint, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 201:
            # Return the created ticket information
            return response.json()
        else:
            # Return an error message if the request failed
            raise Exception(f"Failed to create ticket: {response.status_code} - {response.text}")

    # Note: The function is not called here, as per the instructions.
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the 'devrev' integration
    class devrev(TypedDict):
        api_key: str
        api_secret: str

    # Define the main function for creating a new ticket in DevRev
    def main(devrev_resource: devrev, title: str, description: str, priority: str, tags: list[str], assignee_id: str = None) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a new ticket
        url = "https://api.devrev.ai/tickets"

        # Prepare the headers with the API credentials
        headers = {
            "Authorization": f"Bearer {devrev_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the payload with the ticket details
        payload = {
            "title": title,
            "description": description,
            "priority": priority,
            "tags": tags
        }

        # If an assignee ID is provided, include it in the payload
        if assignee_id:
            payload["assignee_id"] = assignee_id

        # Make the POST request to create the ticket
        response = requests.post(url, json=payload, headers=headers)

        # Check for a successful response and return the result
        if response.status_code == 201:
            return response.json()  # Return the created ticket information
        else:
            raise Exception(f"Failed to create ticket: {response.text}")

    # The main function is now defined and ready to be used with the 'devrev' integration.
  id: |-
    synthetic_create-ticket
  instructions: |-
    Creates a new ticket in DevRev in devrev
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    devrev
  resource_type_def: |-
    class devrev(TypedDict):
        api_key: str
        api_secret: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import chartmogul

    class chartmogul_resource(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_res: chartmogul_resource, start_date: str, end_date: str) -> dict:
        config = chartmogul.Config(**chartmogul_res)
        metrics = chartmogul.Metrics.all(
            config,
            start_date=start_date,
            end_date=end_date,
            interval='month',
            metrics='arr'
        )
        return metrics.to_dict()
  good: |-
    from typing import TypedDict
    import chartmogul as cm

    class chartmogul(TypedDict):
        account_token: str
        secret_key: str

    def main(chartmogul_config: chartmogul, start_date: str, end_date: str) -> float:
        config = cm.Config(
            account_token=chartmogul_config['account_token'],
            secret_key=chartmogul_config['secret_key']
        )

        metrics = cm.Metrics.arr(
            config,
            start_date=start_date,
            end_date=end_date
        )

        return metrics['entries'][0]['arr'] if metrics['entries'] else 0.0
  id: |-
    synthetic_retrieve-arr
  instructions: |-
    Retrieves the Annualized Run Rate (ARR), for the specified time period in chartmogul
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    chartmogul
  resource_type_def: |-
    class chartmogul(TypedDict):
        account_token: str
        secret_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Optional
    import requests  # Assuming requests is needed for HTTP requests to the MailerLite API

    class mailerlite(TypedDict):
        api_key: str

    def main(mailerlite_resource: mailerlite, subscriber_email: str, group_id: int, name: Optional[str] = None):
        headers = {
            'Content-Type': 'application/json',
            'X-MailerLite-ApiKey': mailerlite_resource['api_key']
        }
        url = f"https://api.mailerlite.com/api/v2/groups/{group_id}/subscribers"
        payload = {
            'email': subscriber_email,
            'name': name
        }

        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests to MailerLite API

    class mailerlite(TypedDict):
        api_key: str

    def main(mailerlite_resource: mailerlite, group_id: str, subscriber_email: str, name: str = None, fields: dict = None) -> Any:
        headers = {
            'Content-Type': 'application/json',
            'X-MailerLite-ApiKey': mailerlite_resource['api_key']
        }
        url = f'https://api.mailerlite.com/api/v2/groups/{group_id}/subscribers'
        payload = {
            'email': subscriber_email,
            'name': name,
            'fields': fields
        }
        response = requests.post(url, json=payload, headers=headers)
        return response.json()
  id: |-
    synthetic_subscribe-to-group
  instructions: |-
    Add a subscriber to a group in mailerlite
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mailerlite
  resource_type_def: |-
    class mailerlite(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { FlodeskSegment } from "npm:@flodesk/node-sdk";

    type Flodesk = {
        apiKey: string;
    }

    export async function main(flodeskResource: Flodesk, subscriberEmail: string, segmentIds: string[]) {
        // Initialize the Flodesk client with the API key
        const flodeskClient = new FlodeskSegment(flodeskResource.apiKey);

        // Add the subscriber to the specified segments
        const results = await Promise.all(segmentIds.map(segmentId =>
            flodeskClient.addSubscriberToSegment(segmentId, subscriberEmail)
        ));

        // Return the results of the segment additions
        return results;
    }
  good: |-
    // Import necessary libraries
    import { Flodesk as FlodeskClient } from 'npm:flodesk'; // Rename the imported method to avoid conflict

    // Define the resource type for the Flodesk integration
    type Flodesk = {
        apiKey: string;
    }

    // Define the function to add a subscriber to segments
    export async function main(flodesk: Flodesk, subscriberEmail: string, segmentIds: string[]) {
        // Initialize the Flodesk client with the API key
        const flodeskClient = new FlodeskClient(flodesk.apiKey);

        // Add the subscriber to the specified segments
        const result = await flodeskClient.addSubscriberToSegments(subscriberEmail, segmentIds);

        // Return the result
        return result;
    }
  id: |-
    synthetic_add-subscriber-to-segments
  instructions: |-
    Add a subscriber to one or more segments in Flodesk in flodesk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Flodesk
  resource_type_def: |-
    type Flodesk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Client } from "npm:@dbt-labs/dbt-rpc";

    type Dbt = {
        host: string;
        port: number;
        rpcToken: string;
    }

    export async function main(dbtResource: Dbt) {
        // Create a new dbt client instance with the provided resource credentials
        const dbtClient = new Client({
            endpoint: `http://${dbtResource.host}:${dbtResource.port}`,
            token: dbtResource.rpcToken
        });

        // Fetch the environment information from the dbt server
        const environmentInfo = await dbtClient.getEnvironment();

        // Return the environment information
        return environmentInfo;
    }
  good: |-
    import { Client } from "npm:@dbt-labs/dbt-cloud";

    type Dbt = {
        accountId: number;
        apiKey: string;
    }

    export async function main(dbtResource: Dbt, environmentId: number) {
        const client = new Client({
            accountId: dbtResource.accountId,
            apiKey: dbtResource.apiKey,
        });

        const environment = await client.getEnvironment(environmentId);

        return environment;
    }
  id: |-
    synthetic_get-environment
  instructions: |-
    Retrieve information about an environment in dbt
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Dbt
  resource_type_def: |-
    type Dbt = {
        host: string;
        port: number;
        rpcToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { BoothDetails } from "npm:@expofp/api"; // Assuming @expofp/api is the npm package for the expofp integration

    type Expofp = {
        apiKey: string;
        eventSlug: string;
    }

    export async function main(expofpResource: Expofp, boothId: string): Promise<BoothDetails> {
        // Assuming there is a function getBoothDetails in the @expofp/api package that fetches booth details
        const boothDetails = await getBoothDetails(expofpResource.apiKey, expofpResource.eventSlug, boothId);

        // Always return the result
        return boothDetails;
    }
  good: |-
    import { Booth as ExpofpBooth } from "npm:@expofp/api"; // Renamed imported Booth to ExpofpBooth to avoid conflict

    type Expofp = {
        apiKey: string;
        eventID: string;
    }

    export async function main(expofpResource: Expofp, boothId: string): Promise<ExpofpBooth> {
        const url = `https://api.expofp.com/${expofpResource.eventID}/booths/${boothId}`;

        const headers = {
            'Authorization': `Bearer ${expofpResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        const response = await fetch(url, {
            method: 'GET',
            headers: headers
        });

        if (!response.ok) {
            throw new Error(`Error fetching booth: ${response.status} ${response.statusText}`);
        }

        const booth: ExpofpBooth = await response.json();

        return booth;
    }
  id: |-
    synthetic_get-booth
  instructions: |-
    Get details of a booth in expofp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Expofp
  resource_type_def: |-
    type Expofp = {
        apiKey: string;
        eventID: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { InstagramBusiness as InstagramBusinessAPI } from "npm:@types/instagram-private-api";

    type InstagramBusiness = {
        accessToken: string;
        pageId: string;
    }

    export async function main(instagramBusiness: InstagramBusiness, photoUrl: string, message: string) {
        const { accessToken, pageId } = instagramBusiness;

        const endpoint = `https://graph.facebook.com/v14.0/${pageId}/media`;

        const payload = {
            image_url: photoUrl,
            caption: message,
            access_token: accessToken,
        };

        const response = await fetch(endpoint, {
            method: 'POST',
            body: JSON.stringify(payload),
            headers: {
                'Content-Type': 'application/json',
            },
        });

        const result = await response.json();

        return result;
    }
  good: |-
    // Import necessary libraries
    import { InstagramBusiness } from 'npm:@types/instagram-private-api'; // Assuming this is the correct npm package

    type InstagramBusinessResource = {
        accessToken: string;
        clientId: string;
        clientSecret: string;
    }

    export async function main(instagramBusinessResource: InstagramBusinessResource, mediaId: string, commentText: string) {
        // Initialize the Instagram Business API client
        const ig = new InstagramBusiness({
            accessToken: instagramBusinessResource.accessToken,
            clientId: instagramBusinessResource.clientId,
            clientSecret: instagramBusinessResource.clientSecret,
        });

        // Create a comment on the specified media object
        const result = await ig.media.comment({
            mediaId: mediaId,
            text: commentText,
        });

        // Return the result of the comment creation
        return result;
    }
  id: |-
    synthetic_create-comment
  instructions: |-
    Creates a comment on a media object in instagram business
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    InstagramBusiness
  resource_type_def: |-
    type InstagramBusiness = {
        accessToken: string;
        pageId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { AutomationContact } from "npm:@activecampaign/api";
    import { Client } from "npm:@activecampaign/client";

    type ActivecampaignResource = {
        apiUrl: string;
        apiKey: string;
    };

    export async function main(
        activecampaignResource: ActivecampaignResource,
        contactId: number,
        automationId: number
    ) {
        const client = new Client(activecampaignResource.apiUrl, activecampaignResource.apiKey);
        const automationContact = new AutomationContact(client);

        const result = await automationContact.create({
            contact: contactId,
            automation: automationId
        });

        return result;
    }
  good: |-
    import { ActiveCampaign as ActiveCampaignAPI } from "npm:@activecampaign/api";

    type Activecampaign = {
        apiUrl: string;
        apiKey: string;
    }

    export async function main(activecampaignResource: Activecampaign, contactEmail: string, automationId: number) {
        const ac = new ActiveCampaignAPI(activecampaignResource.apiUrl, activecampaignResource.apiKey);

        // Retrieve contact by email to get the contact ID
        const contactResponse = await ac.contacts.list({ email: contactEmail });
        const contact = contactResponse.contacts[0];
        if (!contact) {
            throw new Error(`Contact with email ${contactEmail} not found.`);
        }

        // Add contact to automation
        const automationResponse = await ac.automations.addContact(automationId, contact.id);

        return automationResponse;
    }
  id: |-
    synthetic_add-contact-to-automation
  instructions: |-
    Adds an existing contact to an existing automation. See the docs. in activecampaign
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Activecampaign
  resource_type_def: |-
    type Activecampaign = {
        apiUrl: string;
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the basecamp integration
    class basecamp(TypedDict):
        access_token: str
        base_url: str

    # Define the main function for creating a todo in a selected project and message board in basecamp
    def main(basecamp_resource: basecamp, project_id: int, message_board_id: int, content: str) -> Any:
        headers = {
            'Authorization': f'Bearer {basecamp_resource["access_token"]}',
            'Content-Type': 'application/json'
        }
        url = f'{basecamp_resource["base_url"]}/buckets/{project_id}/message_boards/{message_board_id}/messages.json'
        data = {
            'content': content
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()

    # The script ends here, and the main function is ready to be used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the basecamp integration
    class basecamp(TypedDict):
        access_token: str

    # Define the main function for creating a todo item in Basecamp
    def main(basecamp_resource: basecamp, project_id: str, content: str, todo_list_id: str) -> dict:
        import requests  # Import requests or any other library if needed

        # Basecamp API endpoint to create a todo item
        url = f"https://3.basecampapi.com/{project_id}/buckets/{todo_list_id}/todos.json"

        # Headers for authentication and content type
        headers = {
            "Authorization": f"Bearer {basecamp_resource['access_token']}",
            "Content-Type": "application/json",
        }

        # Data payload for the new todo item
        data = {
            "content": content
        }

        # Make the POST request to create a new todo item
        response = requests.post(url, headers=headers, json=data)

        # Check for successful creation
        if response.status_code == 201:
            return response.json()  # Return the created todo item as a dictionary
        else:
            raise Exception(f"Error creating todo item: {response.text}")

    # Example usage:
    # result = main(basecamp_resource={'access_token': 'your_access_token'}, project_id='your_project_id', content='Buy milk', todo_list_id='your_todo_list_id')
    # print(result)
  id: |-
    synthetic_create-todo-item
  instructions: |-
    Creates a todo in the project and message board selected in basecamp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    basecamp
  resource_type_def: |-
    class basecamp(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { v4 as uuidv4 } from "npm:uuid";

    type Fibery = {
        apiToken: string;
        workspaceApiUrl: string;
    }

    export async function main(
        fiberyResource: Fibery,
        entityType: string,
        entityData: Record<string, any>,
        entityId?: string
    ) {
        const apiUrl = `${fiberyResource.workspaceApiUrl}/api/commands`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Token ${fiberyResource.apiToken}`
        };

        let body;
        if (entityId) {
            // Update existing entity
            body = JSON.stringify({
                command: 'fibery.entity/update',
                args: {
                    type: entityType,
                    entity: {
                        ...entityData,
                        'fibery/id': entityId
                    }
                }
            });
        } else {
            // Create new entity
            body = JSON.stringify({
                command: 'fibery.entity/create',
                args: {
                    type: entityType,
                    entity: {
                        ...entityData,
                        'fibery/id': uuidv4() // Generate a UUID for the new entity
                    }
                }
            });
        }

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Error ${response.status}: ${await response.text()}`);
        }

        return await response.json();
    }
  good: |-
    // Importing necessary libraries
    import { Fibery as FiberyClient } from "npm:@fibery/unofficial";

    type Fibery = {
        apiToken: string;
        workspace: string;
    }

    export async function main(
        fiberyResource: Fibery,
        entityTypeName: string,
        entityId: string | null,
        fields: Record<string, any>
    ) {
        const fibery = new FiberyClient({
            token: fiberyResource.apiToken,
            host: `${fiberyResource.workspace}.fibery.io`
        });

        let result;

        if (entityId) {
            // Update an existing entity
            result = await fibery.entity.update(entityTypeName, entityId, fields);
        } else {
            // Create a new entity
            result = await fibery.entity.create(entityTypeName, fields);
        }

        return result;
    }
  id: |-
    synthetic_create-entity-or-update
  instructions: |-
    Creates a new entity or updates if it exists in fibery
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Fibery
  resource_type_def: |-
    type Fibery = {
        apiToken: string;
        workspace: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { CuratedClient } from "npm:@curated/api";

    type Curated = {
        apiKey: string;
    }

    export async function main(curatedResource: Curated, collectionId: number, title: string, url: string, description?: string) {
        const client = new CuratedClient({ apiKey: curatedResource.apiKey });

        const linkData = {
            collection_id: collectionId,
            title: title,
            url: url,
            description: description
        };

        const result = await client.links.create(linkData);

        return result;
    }
  good: |-
    // Import any libraries you need here
    import { Client } from "npm:@curatedhq/client";

    type Curated = {
        apiKey: string;
    }

    export async function main(curatedResource: Curated, collectionId: string, title: string, url: string, description?: string) {
        const client = new Client({ apiKey: curatedResource.apiKey });

        const linkData = {
            collection_id: collectionId,
            title: title,
            url: url,
            description: description
        };

        const result = await client.links.create(linkData);

        return result;
    }
  id: |-
    synthetic_create-link
  instructions: |-
    Creates a link in curated
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Curated
  resource_type_def: |-
    type Curated = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Base } from "npm:@airtable/blocks/models";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }

    export async function main(airtableResource: AirtableOauth, tableName: string, recordId: string) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(tableName);
        const record = await table.selectRecordAsync(recordId);

        return record;
    }
  good: |-
    import { Base } from "npm:@airtable/blocks";

    type AirtableOauth = {
        apiKey: string;
        baseId: string;
        tableName: string;
    }

    export async function main(airtableResource: AirtableOauth, recordId: string) {
        const base = new Base(airtableResource.apiKey, airtableResource.baseId);
        const table = base.getTable(airtableResource.tableName);
        const record = await table.selectRecordByIdAsync(recordId);

        return record;
    }
  id: |-
    synthetic_get-record
  instructions: |-
    Get a record from a table by record ID. in airtable oauth
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AirtableOauth
  resource_type_def: |-
    type AirtableOauth = {
        apiKey: string;
        baseId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Mailchimp } from "npm:@mailchimp/mailchimp_marketing";

    type MailchimpResource = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: MailchimpResource, campaignId: string) {
        Mailchimp.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        try {
            const response = await Mailchimp.campaigns.remove(campaignId);
            return response;
        } catch (error) {
            // Handle error appropriately, possibly re-throw or return a specific error message
            throw error;
        }
    }
  good: |-
    import { Mailchimp as MailchimpAPI } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimp: Mailchimp, campaignId: string) {
        MailchimpAPI.setConfig({
            apiKey: mailchimp.apiKey,
            server: mailchimp.serverPrefix,
        });

        try {
            const response = await MailchimpAPI.campaigns.remove(campaignId);
            return response;
        } catch (error) {
            throw error;
        }
    }
  id: |-
    synthetic_delete-campaign
  instructions: |-
    Delete a specific campaign in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the coinbase integration
    class coinbase(TypedDict):
        api_key: str
        api_secret: str
        access_token: str
        refresh_token: str

    # Define the main function for withdrawing funds from coinbase
    def main(coinbase_resource: coinbase, currency: str, amount: float, payment_method_id: str) -> dict:
        # Assuming the existence of a Coinbase client library
        from coinbase.wallet.client import Client as CoinbaseClient

        # Create a client instance with the provided credentials
        client = CoinbaseClient(
            coinbase_resource['api_key'],
            coinbase_resource['api_secret'],
            access_token=coinbase_resource['access_token'],
            refresh_token=coinbase_resource['refresh_token']
        )

        # Perform the withdrawal operation
        withdrawal = client.withdraw(
            currency=currency,
            amount=str(amount),
            payment_method=payment_method_id
        )

        # Return the result of the withdrawal operation
        return withdrawal
  good: |-
    from typing import TypedDict

    # Define the resource type for the coinbase integration
    class coinbase(TypedDict):
        api_key: str
        api_secret: str
        access_token: str
        refresh_token: str

    # Define the main function for withdrawing funds
    def main(coinbase_resource: coinbase, amount: float, currency: str, payment_method_id: str) -> dict:
        # Import the necessary library for the coinbase API
        from coinbase.wallet.client import Client as CoinbaseClient

        # Create a client instance with the provided credentials
        client = CoinbaseClient(coinbase_resource['api_key'], coinbase_resource['api_secret'],
                                access_token=coinbase_resource['access_token'],
                                refresh_token=coinbase_resource['refresh_token'])

        # Perform the withdrawal
        withdrawal = client.withdraw(amount=amount,
                                     currency=currency,
                                     payment_method=payment_method_id)

        # Return the result of the withdrawal
        return withdrawal
  id: |-
    synthetic_withdraw-funds
  instructions: |-
    Withdraw funds in coinbase
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    coinbase
  resource_type_def: |-
    class coinbase(TypedDict):
        api_key: str
        api_secret: str
        access_token: str
        refresh_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { BlobServiceClient } from "@azure/storage-blob";

    type AzureOpenaiService = {
        // Add relevant authentication/configuration properties for Azure OpenAI Service
    }

    export async function main(azureOpenaiService: AzureOpenaiService, storageAccountName: string, storageAccountKey: string, containerName: string, imageName: string, imageContent: Buffer) {
        const blobServiceClient = BlobServiceClient.fromConnectionString(
            `DefaultEndpointsProtocol=https;AccountName=${storageAccountName};AccountKey=${storageAccountKey};EndpointSuffix=core.windows.net`
        );

        const containerClient = blobServiceClient.getContainerClient(containerName);
        const blockBlobClient = containerClient.getBlockBlobClient(imageName);

        const uploadBlobResponse = await blockBlobClient.upload(imageContent, imageContent.length);
        return {
            success: uploadBlobResponse.requestId !== undefined,
            message: uploadBlobResponse.requestId ? `Image uploaded successfully. Request ID: ${uploadBlobResponse.requestId}` : 'Failed to upload image.',
            url: blockBlobClient.url
        };
    }
  good: |-
    import { BlobServiceClient } from "npm:@azure/storage-blob";

    type AzureOpenaiService = {
        azureStorageConnectionString: string,
        containerName: string,
        openaiApiKey: string
    }

    export async function main(azureOpenaiService: AzureOpenaiService, prompt: string): Promise<string> {
        const blobServiceClient = BlobServiceClient.fromConnectionString(azureOpenaiService.azureStorageConnectionString);
        const containerClient = blobServiceClient.getContainerClient(azureOpenaiService.containerName);
        const blobName = `image-${Date.now()}.png`;
        const blockBlobClient = containerClient.getBlockBlobClient(blobName);

        // Assuming the OpenAI API provides an endpoint to generate images from prompts
        const openaiResponse = await fetch('https://api.openai.com/v1/images/generate', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${azureOpenaiService.openaiApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ prompt: prompt })
        });

        if (!openaiResponse.ok) {
            throw new Error(`OpenAI API error: ${openaiResponse.statusText}`);
        }

        const imageBuffer = await openaiResponse.arrayBuffer();
        await blockBlobClient.uploadData(Buffer.from(imageBuffer), {
            blobHTTPHeaders: { blobContentType: "image/png" }
        });

        const imageUrl = blockBlobClient.url;
        return imageUrl;
    }
  id: |-
    synthetic_create-image
  instructions: |-
    Creates an image given a prompt, and returns a URL to the image in azure openai service
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AzureOpenaiService
  resource_type_def: |-
    type AzureOpenaiService = {
        // Add relevant authentication/configuration properties for Azure OpenAI Service
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MondayClient } from "npm:@mondaydotcom/monday-sdk-js";

    type Monday = {
        apiKey: string;
    }

    export async function main(mondayResource: Monday, boardId: number, columnId: string): Promise<any[]> {
        const mondayClient = new MondayClient();
        mondayClient.setToken(mondayResource.apiKey);

        const query = `query ($boardId: Int!, $columnId: String!) {
            boards(ids: $boardId) {
                columns(ids: $columnId) {
                    values {
                        value
                    }
                }
            }
        }`;

        const variables = {
            boardId,
            columnId
        };

        try {
            const response = await mondayClient.api(query, { variables });
            const columnValues = response.data.boards[0].columns[0].values.map((valueObj: { value: string }) => valueObj.value);
            return columnValues;
        } catch (error) {
            console.error("Error fetching column values from Monday.com: ", error);
            throw error;
        }
    }
  good: |-
    import { MondayClient } from "npm:@mondaydotcom/monday-sdk-js";

    type Monday = {
        apiKey: string;
    }

    export async function main(mondayResource: Monday, boardId: number, itemId: number, columnIds: string[]) {
        const mondayClient = new MondayClient();
        mondayClient.setToken(mondayResource.apiKey);

        const query = `query ($boardId: Int!, $itemId: Int!, $columnIds: [String!]!) {
            items (ids: [$itemId]) {
                column_values (ids: $columnIds) {
                    id
                    text
                }
            }
        }`;

        const variables = {
            boardId: boardId,
            itemId: itemId,
            columnIds: columnIds
        };

        try {
            const response = await mondayClient.api(query, { variables });
            const columnValues = response.data.items[0].column_values;
            return columnValues.map((column: { id: string; text: string }) => ({
                id: column.id,
                value: column.text
            }));
        } catch (error) {
            console.error("Error fetching column values from Monday.com: ", error);
            throw error;
        }
    }
  id: |-
    synthetic_get-column-values
  instructions: |-
    Return values of a specific column or columns for a board item in monday
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Monday
  resource_type_def: |-
    type Monday = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Cardly } from 'npm:cardly-sdk'; // Assuming 'cardly-sdk' is the npm package for Cardly

    type CardlyResource = {
        apiKey: string,
        apiSecret: string
    }

    export async function main(cardlyResource: CardlyResource, recipientName: string, recipientAddress: string, message: string, cardDesignId: string) {
        // Initialize the Cardly service with the provided credentials
        const cardly = new Cardly(cardlyResource.apiKey, cardlyResource.apiSecret);

        // Create the card with the provided details
        const card = {
            to_name: recipientName,
            to_address: recipientAddress,
            message: message,
            design_id: cardDesignId
        };

        // Send the card using the Cardly service
        const result = await cardly.sendCard(card);

        // Return the result of the card sending operation
        return result;
    }
  good: |-
    type Cardly = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(cardlyResource: Cardly, recipientName: string, recipientAddress: string, message: string, cardDesignId: string) {
        const cardlyApiUrl = 'https://api.cardly.net/v1/cards';

        const cardData = {
            recipient: {
                name: recipientName,
                address: recipientAddress,
            },
            message: message,
            designId: cardDesignId,
        };

        const response = await fetch(cardlyApiUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${cardlyResource.apiKey}:${cardlyResource.apiSecret}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(cardData),
        });

        if (!response.ok) {
            throw new Error(`Failed to send card: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_send-card
  instructions: |-
    Send a card in Cardly in cardly
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Cardly
  resource_type_def: |-
    type Cardly = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { launch as launchBrowser } from "npm:puppeteer-core";
    import { getOptions } from "npm:@browserless/aws-lambda-chrome";

    type Browserless = {
        apiKey: string,
        endpointUrl: string
    }

    export async function main(browserlessResource: Browserless, urlToScrape: string) {
        // Set up Puppeteer options to connect to browserless service
        const browserlessOptions = {
            browserWSEndpoint: `${browserlessResource.endpointUrl}?token=${browserlessResource.apiKey}`,
            ...await getOptions()
        };

        // Launch the browser using the browserless service
        const browser = await launchBrowser(browserlessOptions);
        const page = await browser.newPage();

        // Navigate to the URL to scrape
        await page.goto(urlToScrape, { waitUntil: 'networkidle2' });

        // Scrape the content of the page
        const content = await page.content();

        // Close the browser
        await browser.close();

        // Return the scraped content
        return content;
    }
  good: |-
    // Importing necessary libraries
    import { Browserless } from 'npm:@browserless/node';

    type BrowserlessResource = {
        apiKey: string,
        endpoint: string
    }

    export async function main(browserlessResource: BrowserlessResource, urlToScrape: string) {
        // Initialize the Browserless client
        const browserless = new Browserless(browserlessResource.apiKey, { endpoint: browserlessResource.endpoint });

        // Use the browserless client to scrape content from the page
        const pageContent = await browserless.evaluate(async ({ page, context }) => {
            const { url } = context;
            await page.goto(url);
            return await page.content();
        }, { context: { url: urlToScrape } });

        // Return the scraped content
        return pageContent;
    }
  id: |-
    synthetic_scrape-url
  instructions: |-
    Scrape content from a page. in browserless
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Browserless
  resource_type_def: |-
    type Browserless = {
        apiKey: string,
        endpointUrl: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, orderType: string, side: string, quantity: number, price?: number, timeInForce?: string) {
        const { apiKey, apiSecret, endpoint } = bybitResource;

        const params = {
            api_key: apiKey,
            symbol: symbol,
            side: side,
            type: orderType,
            qty: quantity.toString(),
            time_in_force: timeInForce || 'GoodTillCancel',
            timestamp: Date.now().toString(),
        };

        if (price) {
            params['price'] = price.toString();
        }

        const paramString = Object.entries(params)
            .map(([key, val]) => `${key}=${val}`)
            .join('&');

        const signature = createHmac('sha256', apiSecret)
            .update(paramString)
            .digest('hex');

        const response = await fetch(`${endpoint}/v2/private/order/create`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `${paramString}&sign=${signature}`,
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { createHmac } from "npm:crypto";

    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }

    export async function main(bybitResource: Bybit, symbol: string, orderType: string, side: string, quantity: number, price?: number, timeInForce?: string) {
        const timestamp = new Date().getTime();
        const params = {
            api_key: bybitResource.apiKey,
            symbol: symbol,
            side: side,
            order_type: orderType,
            qty: quantity.toString(),
            price: price?.toString(),
            time_in_force: timeInForce,
            timestamp: timestamp.toString(),
        };

        // Remove undefined or null parameters
        Object.keys(params).forEach(key => params[key] == null && delete params[key]);

        // Create the signature
        const signature = createHmac('sha256', bybitResource.apiSecret)
            .update(new URLSearchParams(params).toString())
            .digest('hex');

        // Add the signature to the parameters
        params['sign'] = signature;

        // Make the request to Bybit API
        const response = await fetch(`${bybitResource.endpoint}/v2/private/order/create`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams(params).toString(),
        });

        // Parse the response
        const result = await response.json();

        // Always return the result
        return result;
    }
  id: |-
    synthetic_linear-order-create
  instructions: |-
    Place active order. in bybit
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Bybit
  resource_type_def: |-
    type Bybit = {
        apiKey: string;
        apiSecret: string;
        endpoint: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { ClickUp as ClickUpAPI } from "npm:clickup-api";

    type Clickup = {
        apiKey: string;
    }

    export async function main(clickupResource: Clickup, folderId: string, newName: string) {
        const clickup = new ClickUpAPI(clickupResource.apiKey);

        const response = await clickup.Folders.update_folder(folderId, { name: newName });

        return response;
    }
  good: |-
    import { fetch } from "npm:@deno/fetch";

    type Clickup = {
        accessToken: string;
    }

    export async function main(clickupResource: Clickup, folderId: string, name?: string, color?: string) {
        const url = `https://api.clickup.com/api/v2/folder/${folderId}`;
        const headers = {
            "Authorization": clickupResource.accessToken,
            "Content-Type": "application/json"
        };
        const body = JSON.stringify({
            ...(name && { name }),
            ...(color && { color })
        });

        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`Failed to update folder: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_update-folder
  instructions: |-
    Update a folder. See the docs in **Folders / Update Folder** section. in clickup
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clickup
  resource_type_def: |-
    type Clickup = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests library is used for HTTP requests

    class ipinfo_io(TypedDict):
        access_token: str

    def main(ipinfo_io_resource: ipinfo_io, ip_address: str):
        base_url = "http://ipinfo.io/"
        headers = {
            "Authorization": f"Bearer {ipinfo_io_resource['access_token']}"
        }
        response = requests.get(f"{base_url}{ip_address}", headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for the IP lookup

    class ipinfo_io(TypedDict):
        access_token: str

    def main(ipinfo_io_resource: ipinfo_io, ip_address: str) -> dict:
        base_url = "http://ipinfo.io/"
        headers = {
            "Authorization": f"Bearer {ipinfo_io_resource['access_token']}"
        }
        response = requests.get(f"{base_url}{ip_address}", headers=headers)
        return response.json()
  id: |-
    synthetic_lookup-ip
  instructions: |-
    Lookup an IP in ipinfo io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    ipinfo_io
  resource_type_def: |-
    class ipinfo_io(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import necessary libraries
    import { MiroCustomApp } from 'npm:@mirohq/websdk-types'; // Assuming this is the correct npm package for Miro types

    // Define the resource type for the MiroCustomApp integration
    type MiroCustomAppResource = {
        accessToken: string; // OAuth2 access token
        boardId: string;     // ID of the Miro board
    };

    export async function main(miroResource: MiroCustomAppResource, itemId: string): Promise<boolean> {
        // Construct the API endpoint to delete an item from the Miro board
        const endpoint = `https://api.miro.com/v1/boards/${miroResource.boardId}/items/${itemId}`;

        // Set up the request headers
        const headers = {
            'Authorization': `Bearer ${miroResource.accessToken}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };

        // Make the DELETE request to the Miro API
        const response = await fetch(endpoint, {
            method: 'DELETE',
            headers: headers
        });

        // Check if the deletion was successful
        if (response.ok) {
            return true; // Item was successfully deleted
        } else {
            // Handle any errors
            const errorData = await response.json();
            console.error('Failed to delete item:', errorData);
            return false; // Deletion failed
        }
    }
  good: |-
    import { MiroCustomApp } from "npm:@mirohq/websdk-types";

    type MiroCustomApp = {
        accessToken: string;
        boardId: string;
    }

    export async function main(miroResource: MiroCustomApp, itemId: string) {
        const endpoint = `https://api.miro.com/v1/boards/${miroResource.boardId}/items/${itemId}`;

        const headers = {
            'Authorization': `Bearer ${miroResource.accessToken}`,
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        };

        const response = await fetch(endpoint, {
            method: 'DELETE',
            headers: headers
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to delete item: ${error}`);
        }

        return `Item with ID ${itemId} was successfully deleted from the board.`;
    }
  id: |-
    synthetic_delete-item
  instructions: |-
    Deletes an item from a Miro board. in miro custom app
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    MiroCustomApp
  resource_type_def: |-
    type MiroCustomApp = {
        accessToken: string;
        boardId: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import googleapiclient.discovery
    from google.oauth2.credentials import Credentials

    # Define the resource type for the google_drive integration
    class google_drive(TypedDict):
        token: str
        refresh_token: str
        token_uri: str
        client_id: str
        client_secret: str
        scopes: list

    # Define the main function for the google_drive integration
    def main(google_drive_resource: google_drive, file_url: str = None, file_path: str = None, folder_id: str = None):
        # Create credentials object from the google_drive_resource
        credentials = Credentials(
            token=google_drive_resource['token'],
            refresh_token=google_drive_resource['refresh_token'],
            token_uri=google_drive_resource['token_uri'],
            client_id=google_drive_resource['client_id'],
            client_secret=google_drive_resource['client_secret'],
            scopes=google_drive_resource['scopes']
        )

        # Build the Google Drive service
        service = googleapiclient.discovery.build('drive', 'v3', credentials=credentials)

        # Prepare the file metadata
        file_metadata = {'name': 'New File'}
        if folder_id:
            file_metadata['parents'] = [folder_id]

        # Create the file on Google Drive
        if file_url:
            # If a URL is provided, use it to fetch the file's content
            file_metadata['name'] = file_url.split('/')[-1]  # Extract the file name from the URL
            media = googleapiclient.http.MediaIoBaseDownload(io.BytesIO(requests.get(file_url).content))
        elif file_path:
            # If a local file path is provided, read the file content
            file_metadata['name'] = os.path.basename(file_path)  # Extract the file name from the file path
            media = googleapiclient.http.MediaFileUpload(file_path)

        # Upload the file
        file = service.files().create(body=file_metadata, media_body=media, fields='id').execute()

        # Return the file ID of the newly created file
        return file.get('id')
  good: |-
    from typing import TypedDict
    import googleapiclient.discovery
    import googleapiclient.http
    import io

    class google_drive(TypedDict):
        access_token: str

    def main(google_drive_resource: google_drive, file_name: str, file_content: str, mime_type: str = 'text/plain'):
        credentials = googleapiclient.credentials.Credentials(google_drive_resource['access_token'])
        service = googleapiclient.discovery.build('drive', 'v3', credentials=credentials)

        file_metadata = {
            'name': file_name,
            'mimeType': mime_type
        }
        media = googleapiclient.http.MediaIoBaseUpload(io.StringIO(file_content), mimetype=mime_type)
        file = service.files().create(body=file_metadata, media_body=media, fields='id').execute()

        return file
  id: |-
    synthetic_create-file
  instructions: |-
    Create a new file from a URL or /tmp/filepath for more information in google drive
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    google_drive
  resource_type_def: |-
    class google_drive(TypedDict):
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, sourceFileId: string, destinationFolderId: string) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;

        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        const copiedFile = await drive.files.copy({
            fileId: sourceFileId,
            requestBody: {
                parents: [destinationFolderId]
            }
        });

        return copiedFile.data;
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string, newTitle: string) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        try {
            const copiedFile = await drive.files.copy({
                fileId: fileId,
                requestBody: {
                    name: newTitle
                }
            });

            return copiedFile.data;
        } catch (error) {
            console.error('The API returned an error: ' + error);
            throw error;
        }
    }
  id: |-
    synthetic_copy-file
  instructions: |-
    Create a copy of the specified file for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make HTTP calls to Clickup API

    class clickup(TypedDict):
        api_key: str

    def main(clickup_resource: clickup, view_id: str) -> dict:
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }
        url = f"https://api.clickup.com/api/v2/view/{view_id}"

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error responses

        return response.json()
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls

    # Define the resource type for the ClickUp integration
    class clickup(TypedDict):
        api_key: str

    def main(clickup_resource: clickup, view_id: str) -> Any:
        # Set up the headers for authentication
        headers = {
            "Authorization": clickup_resource['api_key'],
            "Content-Type": "application/json"
        }

        # Define the endpoint URL for getting a view
        url = f"https://api.clickup.com/api/v2/view/{view_id}"

        # Make the HTTP GET request to the ClickUp API
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the view details
            return response.json()
        else:
            # Handle errors (e.g., view not found, authentication error)
            return {
                "error": response.status_code,
                "message": response.text
            }
  id: |-
    synthetic_get-view
  instructions: |-
    Get a view. See the docs in **Views / Get View** section. in clickup
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    clickup
  resource_type_def: |-
    class clickup(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type Http = {
        baseUrl: string;
    }

    export async function main(httpResource: Http, endpoint: string, queryParams?: Record<string, string>) {
        const url = new URL(endpoint, httpResource.baseUrl);
        if (queryParams) {
            for (const [key, value] of Object.entries(queryParams)) {
                url.searchParams.append(key, value);
            }
        }

        const response = await fetch(url.toString());
        const result = await response.json();
        return result;
    }
  good: |-
    type Http = {
        basicAuthUsername?: string;
        basicAuthPassword?: string;
    }

    export async function main(httpResource: Http, url: string, queryParams?: Record<string, string>, headers?: Record<string, string>) {
        // Construct the query string from queryParams if provided
        const queryString = queryParams ? '?' + new URLSearchParams(queryParams) : '';
        const requestUrl = url + queryString;

        // Set up headers, including Basic Auth if credentials are provided
        const requestHeaders = new Headers(headers);
        if (httpResource.basicAuthUsername && httpResource.basicAuthPassword) {
            const auth = btoa(`${httpResource.basicAuthUsername}:${httpResource.basicAuthPassword}`);
            requestHeaders.set('Authorization', `Basic ${auth}`);
        }

        // Perform the HTTP GET request
        const response = await fetch(requestUrl, {
            method: 'GET',
            headers: requestHeaders,
        });

        // Parse the response and return it
        const result = await response.json();
        return result;
    }
  id: |-
    synthetic_get-request
  instructions: |-
    Send an HTTP GET request to any URL. Optionally configure query string parameters, headers and basic auth. in http
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Http
  resource_type_def: |-
    type Http = {
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@supabase/supabase-js";

    type NeonApiKeys = {
        apiKey: string;
        projectUrl: string;
    }

    export async function main(neonApiKeys: NeonApiKeys, databaseName: string) {
        const supabase = new Client(neonApiKeys.projectUrl, neonApiKeys.apiKey);

        const { data, error } = await supabase.rpc('create_database', { name: databaseName });

        if (error) {
            throw error;
        }

        return data;
    }
  good: |-
    type NeonApiKeys = {
        apiKey: string;
        apiSecret: string;
    }

    export async function main(neonApiKeys: NeonApiKeys, databaseName: string) {
        const response = await fetch('https://api.neon.com/databases', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${neonApiKeys.apiKey}:${neonApiKeys.apiSecret}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name: databaseName }),
        });

        if (!response.ok) {
            throw new Error(`Failed to create database: ${response.statusText}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-database
  instructions: |-
    Creates a database in the project in neon api keys
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    NeonApiKeys
  resource_type_def: |-
    type NeonApiKeys = {
        apiKey: string;
        apiSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Clerk as ClerkSDK } from "npm:@clerk/clerk-sdk-node";

    type Clerk = {
        apiKey: string;
    }

    export async function main(clerkResource: Clerk, userId: string) {
        const clerk = new ClerkSDK({ apiKey: clerkResource.apiKey });

        try {
            const user = await clerk.users.getUser(userId);
            return user;
        } catch (error) {
            throw error;
        }
    }
  good: |-
    import { Clerk, UserResource } from "npm:@clerk/clerk-sdk-node";

    type ClerkResource = {
        apiKey: string;
    }

    export async function main(clerkResource: ClerkResource, userId: string): Promise<UserResource | null> {
        const clerk = new Clerk(clerkResource.apiKey);

        try {
            const user = await clerk.users.getUser(userId);
            return user;
        } catch (error) {
            console.error("Failed to retrieve user details:", error);
            return null;
        }
    }
  id: |-
    synthetic_get-user
  instructions: |-
    Retrieve the details of a specific user in clerk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Clerk
  resource_type_def: |-
    type Clerk = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the gigasheet integration
    class gigasheet(TypedDict):
        api_key: str  # API key for authenticating with the Gigasheet API

    # Define the main function for exporting a dataset from Gigasheet
    def main(gigasheet_resource: gigasheet, dataset_id: str, file_format: str = 'csv') -> str:
        # Import the necessary library for making HTTP requests
        import requests

        # Gigasheet API endpoint for exporting a dataset
        export_url = f"https://api.gigasheet.com/v1/datasets/{dataset_id}/export"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {gigasheet_resource['api_key']}",
            "Accept": "application/json"
        }

        # Prepare the parameters for the export request
        params = {
            "format": file_format
        }

        # Make the request to export the dataset
        response = requests.get(export_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the URL to the exported file
            return response.json().get('export_url', '')
        else:
            # Handle errors (for simplicity, just return the error message)
            return f"Error: {response.text}"

    # Note: The function does not call itself, it's meant to be called with the appropriate parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the Gigasheet integration
    class gigasheet(TypedDict):
        api_key: str  # API key for authenticating with the Gigasheet API

    # Main function to be exported for the Gigasheet integration
    def main(gigasheet_resource: gigasheet, file_id: str, export_format: str = 'csv') -> bytes:
        import requests  # Import here to avoid potential naming conflicts

        # Construct the URL for the Gigasheet export API endpoint
        export_url = f"https://api.gigasheet.com/v1/files/{file_id}/export"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {gigasheet_resource['api_key']}",
            "Accept": "application/octet-stream",  # To receive the file content in bytes
        }

        # Set up the parameters for the export request
        params = {
            "format": export_format,  # Format of the export, e.g., 'csv', 'xlsx'
        }

        # Make the request to the Gigasheet API to export the file
        response = requests.get(export_url, headers=headers, params=params)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the content of the file in bytes
            return response.content
        else:
            # Handle errors (e.g., file not found, access denied, etc.)
            response.raise_for_status()

    # Note: The function does not call itself, it's meant to be used by importing and calling with appropriate parameters.
  id: |-
    synthetic_create-export
  instructions: |-
    Creates an export for a gigasheet dataset in gigasheet
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gigasheet
  resource_type_def: |-
    class gigasheet(TypedDict):
        api_key: str  # API key for authenticating with the Gigasheet API
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { CohereClient } from "npm:@cohere-ai/cohere";

    type CoherePlatform = {
        apiKey: string;
    }

    export async function main(cohereResource: CoherePlatform, textToClassify: string, modelName: string) {
        const cohere = new CohereClient(cohereResource.apiKey);

        const response = await cohere.classify({
            model: modelName,
            inputs: [textToClassify]
        });

        return response.body;
    }
  good: |-
    // Import the necessary library for Cohere API
    import cohere from 'npm:cohere-ai';

    type CoherePlatform = {
        apiKey: string;
    }

    export async function main(cohereResource: CoherePlatform, prompt: string, examples: any[], maxTokens: number, temperature: number) {
        // Initialize the Cohere client with the provided API key
        cohere.init(cohereResource.apiKey);

        // Call the Cohere API to generate a completion based on the given examples
        const response = await cohere.generate({
            model: 'large',
            prompt: prompt,
            max_tokens: maxTokens,
            temperature: temperature,
            examples_context: examples.map(example => example.context).join('\n'),
            examples: examples.map(example => ({text: example.text, label: example.label}))
        });

        // Return the result from the Cohere API
        return response.body;
    }
  id: |-
    synthetic_choose-best-completion
  instructions: |-
    This action chooses the best completion conditioned on a given examples in cohere platform
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    CoherePlatform
  resource_type_def: |-
    type CoherePlatform = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import codaio as coda_client  # Renamed the imported codaio to avoid conflict

    class coda(TypedDict):
        api_token: str
        doc_id: str

    def main(coda_resource: coda, table_id_or_name: str) -> List[str]:
        client = coda_client.Coda(coda_resource['api_token'])
        doc = client.get_doc(coda_resource['doc_id'])
        table = doc.get_table(table_id_or_name)
        columns = table.list_columns()

        column_names = [column['name'] for column in columns]
        return column_names
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed to interact with Coda API

    class coda(TypedDict):
        api_token: str
        doc_id: str

    def main(coda_resource: coda, table_id_or_name: str) -> List[str]:
        headers = {
            'Authorization': f'Bearer {coda_resource["api_token"]}',
            'Content-Type': 'application/json'
        }
        url = f'https://coda.io/apis/v1/docs/{coda_resource["doc_id"]}/tables/{table_id_or_name}/columns'

        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an exception for HTTP error codes

        columns_data = response.json()
        column_names = [column['name'] for column in columns_data['items']]

        return column_names
  id: |-
    synthetic_list-columns
  instructions: |-
    Lists columns in a table in coda
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    coda
  resource_type_def: |-
    class coda(TypedDict):
        api_token: str
        doc_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP calls to the Badger Maps API

    # Define the resource type for the badger_maps integration
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the check-in creation in Badger Maps
    def main(badger_maps_resource: badger_maps, customer_id: int, check_in_time: str, latitude: float, longitude: float, notes: str = "") -> Any:
        # Construct the API endpoint for creating a check-in
        url = "https://api.badgermapping.com/v1/checkins"

        # Prepare the headers for authentication
        headers = {
            "Authorization": f"Bearer {badger_maps_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the check-in
        data = {
            "customer_id": customer_id,
            "check_in_time": check_in_time,
            "latitude": latitude,
            "longitude": longitude,
            "notes": notes
        }

        # Make the HTTP POST request to create the check-in
        response = requests.post(url, headers=headers, json=data)

        # Return the response from the API call
        return response.json()

    # The script ends here, with the main function defined and ready to be used with the required parameters.
  good: |-
    from typing import TypedDict

    # Define the resource type for the badger_maps integration
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for the Check-In creation script
    def main(badger_maps_resource: badger_maps, customer_id: int, check_in_time: str, latitude: float, longitude: float, notes: str = ""):
        # Import the requests library here to avoid naming conflicts
        import requests

        # Construct the URL for the Check-In endpoint
        check_in_url = "https://api.badgermaps.com/v1/checkin"

        # Prepare the headers with the API key
        headers = {
            "Authorization": f"Bearer {badger_maps_resource['api_key']}"
        }

        # Prepare the data payload for the Check-In
        data = {
            "customer_id": customer_id,
            "check_in_time": check_in_time,
            "latitude": latitude,
            "longitude": longitude,
            "notes": notes
        }

        # Make the POST request to create a Check-In
        response = requests.post(check_in_url, headers=headers, json=data)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the response JSON if successful
            return response.json()
        else:
            # Raise an exception if the request failed
            response.raise_for_status()
  id: |-
    synthetic_create-check-in
  instructions: |-
    Creates a check-in. in badger maps
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    badger_maps
  resource_type_def: |-
    class badger_maps(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the nocrm_io integration
    class nocrm_io(TypedDict):
        api_key: str  # API key for authentication

    # Define the main function for creating a lead in noCRM.io
    def main(nocrm_io_resource: nocrm_io, lead_name: str, lead_status: str, lead_source: str, lead_description: str = ""):
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for creating a lead
        api_endpoint = "https://api.nocrm.io/v1/leads"

        # Prepare the headers for the API request
        headers = {
            "Authorization": f"Token {nocrm_io_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Prepare the data for the new lead
        data = {
            "name": lead_name,
            "status": lead_status,
            "source": lead_source,
            "description": lead_description
        }

        # Make the API request to create the lead
        response = requests.post(api_endpoint, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created lead information
        else:
            raise Exception(f"Error creating lead: {response.status_code} - {response.text}")

    # Note: The function is not called here, it is only defined and ready to be exported.
  good: |-
    from typing import TypedDict, Any
    import requests  # Assuming requests is needed for HTTP requests

    # Define the resource type for the nocrm_io integration
    class nocrm_io(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for creating a new lead in nocrm_io
    def main(nocrm_io_resource: nocrm_io, lead_name: str, lead_email: str, lead_phone: str = '', lead_status: str = 'new', custom_fields: dict[str, Any] = {}):
        # Construct the API endpoint
        api_endpoint = f"https://{nocrm_io_resource['subdomain']}.nocrm.io/api/v1/leads"

        # Prepare the headers and payload for the request
        headers = {
            'Authorization': f"Token {nocrm_io_resource['api_key']}",
            'Content-Type': 'application/json'
        }
        payload = {
            'lead': {
                'name': lead_name,
                'email': lead_email,
                'phone': lead_phone,
                'status': lead_status,
                'custom_fields': custom_fields
            }
        }

        # Make the request to create a new lead
        response = requests.post(api_endpoint, json=payload, headers=headers)

        # Check if the request was successful
        if response.status_code == 201:
            return response.json()  # Return the created lead information
        else:
            raise Exception(f"Error creating lead: {response.status_code} - {response.text}")

    # Example usage (do not include this in the script):
    # result = main(nocrm_io_resource={'api_key': 'your_api_key', 'subdomain': 'your_subdomain'}, lead_name='John Doe', lead_email='john.doe@example.com')
    # print(result)
  id: |-
    synthetic_create-lead
  instructions: |-
    Creates a new lead in nocrm io
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    nocrm_io
  resource_type_def: |-
    class nocrm_io(TypedDict):
        api_key: str  # API key for authentication
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OpenAIApi as OpenAIApiClient } from "npm:openai";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, fileId: string) {
        const openai = new OpenAIApiClient({
            apiKey: openaiResource.apiKey,
        });

        const response = await openai.files.retrieve(fileId);
        return response.data;
    }
  good: |-
    import { OpenAIApi } from "npm:openai";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, fileId: string) {
        const openai = new OpenAIApi({
            apiKey: openaiResource.apiKey,
        });

        try {
            const response = await openai.files.retrieve(fileId);
            return response.data;
        } catch (error) {
            // Handle the error according to your platform's best practices
            throw error;
        }
    }
  id: |-
    synthetic_retrieve-file
  instructions: |-
    Retrieves a specific file from OpenAI in openai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { HttpClient } from "npm:@angular/common/http";

    type Mailchimp = {
        apiKey: string,
        serverPrefix: string // Mailchimp API endpoints are prefixed with the server - e.g., 'us1', 'us2', etc.
    }

    export async function main(mailchimpResource: Mailchimp, listId: string): Promise<any> {
        // Construct the authorization header
        const headers = {
            'Authorization': `Bearer ${mailchimpResource.apiKey}`,
            'Content-Type': 'application/json'
        };

        // Construct the URL for the Mailchimp API request
        const url = `https://${mailchimpResource.serverPrefix}.api.mailchimp.com/3.0/lists/${listId}`;

        // Create an instance of HttpClient
        const httpClient = new HttpClient();

        try {
            // Make the DELETE request to the Mailchimp API to delete the list
            const response = await httpClient.delete(url, { headers: headers });
            return response;
        } catch (error) {
            // Handle any errors that occur during the API request
            console.error('Error deleting the Mailchimp list:', error);
            throw error;
        }
    }
  good: |-
    import { Lists as MailchimpLists } from "npm:@mailchimp/mailchimp_marketing";

    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }

    export async function main(mailchimpResource: Mailchimp, listId: string) {
        // Configure Mailchimp
        MailchimpLists.setConfig({
            apiKey: mailchimpResource.apiKey,
            server: mailchimpResource.serverPrefix,
        });

        // Delete the list
        const response = await MailchimpLists.removeList(listId);

        // Return the result
        return response;
    }
  id: |-
    synthetic_delete-list
  instructions: |-
    Deletes an existing list in mailchimp
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
        apiKey: string;
        serverPrefix: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the Mastodon integration
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    def main(mastodon_resource: mastodon, status_id: int) -> bool:
        import requests

        # Endpoint to remove a status from bookmarks
        endpoint = f"{mastodon_resource['api_base_url'].rstrip('/')}/api/v1/bookmarks/{status_id}/unbookmark"

        # Headers for authentication
        headers = {
            'Authorization': f'Bearer {mastodon_resource["access_token"]}'
        }

        # Make the request to unbookmark the status
        response = requests.post(endpoint, headers=headers)

        # Return True if the status was successfully unbookmarked, False otherwise
        return response.status_code == 200

    # Example usage:
    # result = main(mastodon_resource={'access_token': 'YOUR_ACCESS_TOKEN', 'api_base_url': 'https://mastodon.example'}, status_id=123456)
    # print(result)
  good: |-
    from typing import TypedDict

    # Define the resource type for the Mastodon integration
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str

    # Define the main function for the Mastodon integration script
    def main(mastodon_resource: mastodon, status_id: int) -> bool:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for undoing a bookmark
        endpoint = f"{mastodon_resource['api_base_url'].rstrip('/')}/api/v1/statuses/{status_id}/unbookmark"

        # Set up the headers with the OAuth2 access token
        headers = {
            'Authorization': f"Bearer {mastodon_resource['access_token']}"
        }

        # Make the request to undo the bookmark
        response = requests.post(endpoint, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return True
        else:
            # Handle error (you could expand on this with specific error messages)
            return False

    # The script ends here, with the main function defined and ready to be used.
  id: |-
    synthetic_unbookmark-status
  instructions: |-
    Remove a status from your private bookmarks in mastodon
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    mastodon
  resource_type_def: |-
    class mastodon(TypedDict):
        access_token: str
        api_base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Etsy as EtsyType } from "npm:@types/etsy";

    type Etsy = {
        apiKey: string;
        shopId: string;
        oauthToken: string;
        oauthTokenSecret: string;
    }

    export async function main(etsyResource: Etsy, listingId: string, propertyToUpdate: string, newValue: any) {
        const etsyApiEndpoint = `https://openapi.etsy.com/v2/shops/${etsyResource.shopId}/listings/${listingId}`;
        const updateBody = {
            [propertyToUpdate]: newValue
        };

        const response = await fetch(etsyApiEndpoint, {
            method: 'PUT',
            headers: {
                'x-api-key': etsyResource.apiKey,
                'Authorization': `OAuth oauth_consumer_key="${etsyResource.apiKey}", oauth_token="${etsyResource.oauthToken}", oauth_signature_method="HMAC-SHA1", oauth_timestamp="${Math.floor(Date.now() / 1000)}", oauth_nonce="${Math.random().toString(36).substring(2, 15)}", oauth_version="1.0", oauth_signature="${etsyResource.oauthTokenSecret}"`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { stringify } from "npm:querystring";

    type Etsy = {
        apiKey: string;
        apiSecret: string;
        token: string;
        tokenSecret: string;
    }

    export async function main(etsyResource: Etsy, listingId: number, offerings: { value: string, value_id: number }[], scaleId: number) {
        const url = `https://openapi.etsy.com/v2/listings/${listingId}/inventory`;

        // Prepare the data for the request
        const data = {
            products: offerings.map(offering => ({
                property_values: [
                    {
                        property_id: scaleId,
                        value: offering.value,
                        value_id: offering.value_id
                    }
                ]
            })),
            price_on_property: [scaleId],
            quantity_on_property: [scaleId],
            sku_on_property: [scaleId]
        };

        // Prepare the headers for OAuth 1.0a authentication
        const headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        headers.append('Authorization', `OAuth oauth_consumer_key="${etsyResource.apiKey}", oauth_token="${etsyResource.token}", oauth_signature_method="HMAC-SHA1", oauth_timestamp="${Math.floor(Date.now() / 1000)}", oauth_nonce="${Math.random().toString(36).substring(2, 15)}", oauth_version="1.0", oauth_signature="${etsyResource.apiSecret}&${etsyResource.tokenSecret}"`);

        // Make the request to Etsy API
        const response = await fetch(url, {
            method: 'PUT',
            headers: headers,
            body: stringify(data)
        });

        // Parse the response
        const result = await response.json();

        // Always return the result
        return result;
    }
  id: |-
    synthetic_update-listing-property
  instructions: |-
    Updates or populates the properties list defining product offerings for a listing. Each offering requires both a `value` and a `value_id` that are valid for a `scale_id` assigned to the listing or that you assign to the listing with this request in etsy
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Etsy
  resource_type_def: |-
    type Etsy = {
        apiKey: string;
        shopId: string;
        oauthToken: string;
        oauthTokenSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List

    # Define the resource type for the lemlist integration
    class lemlist(TypedDict):
        api_key: str

    # Define the main function for the lemlist integration
    def main(lemlist_resource: lemlist, campaign_id: str, lead_emails: List[str]):
        import requests  # Import requests or any other library if needed

        # Base URL for lemlist API
        base_url = "https://api.lemlist.com/api"

        # Headers for authentication
        headers = {
            "Authorization": f"Bearer {lemlist_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Iterate over each email and mark them as interested
        for email in lead_emails:
            # Endpoint to mark a lead as interested
            url = f"{base_url}/campaigns/{campaign_id}/leads/{email}/interested"

            # Make the POST request to mark the lead as interested
            response = requests.post(url, headers=headers)

            # Check if the request was successful
            if response.status_code != 200:
                # If not successful, print the error and continue with the next email
                print(f"Failed to mark {email} as interested: {response.text}")
                continue

            # If successful, print a confirmation message
            print(f"Marked {email} as interested successfully.")

        # Return a message indicating the operation is complete
        return "Operation completed for all leads."
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to lemlist API

    class lemlist(TypedDict):
        api_key: str
        base_url: str

    def main(lemlist_resource: lemlist, lead_email: str, interested: bool) -> List[str]:
        headers = {
            'Authorization': f"Bearer {lemlist_resource['api_key']}",
            'Content-Type': 'application/json'
        }

        # Assuming there's an endpoint to list all campaigns
        campaigns_url = f"{lemlist_resource['base_url']}/campaigns"
        response = requests.get(campaigns_url, headers=headers)
        response.raise_for_status()
        campaigns = response.json()

        # Assuming there's an endpoint to mark a lead as interested in a campaign
        update_status_url_template = f"{lemlist_resource['base_url']}/campaigns/{{campaign_id}}/leads/{{lead_email}}/interested"

        updated_campaigns = []
        for campaign in campaigns:
            campaign_id = campaign['id']
            update_status_url = update_status_url_template.format(campaign_id=campaign_id, lead_email=lead_email)

            status_data = {'interested': interested}
            response = requests.post(update_status_url, headers=headers, json=status_data)

            if response.status_code == 200:
                updated_campaigns.append(campaign_id)
            else:
                # Handle error appropriately, e.g., log it, raise an exception, etc.
                print(f"Failed to update lead status for campaign {campaign_id}: {response.text}")

        return updated_campaigns
  id: |-
    synthetic_mark-lead-from-all-campaigns-as-interested
  instructions: |-
    This action marks a specific lead as interested using its email in all campaigns in lemlist
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    lemlist
  resource_type_def: |-
    class lemlist(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    type HelperFunctions = {
        // Add properties needed for authentication/configuration that are relevant to any script related to this integration
    }

    export async function main(helperFunctionsResource: HelperFunctions, daysAgo: number, timezone: string): Promise<string> {
        // Calculate the date n days ago based on the timezone provided in the parameter
        const currentDate = new Date();
        currentDate.setHours(currentDate.getHours() - daysAgo * 24); // Subtract n days worth of hours

        // Convert the date to an ISO string with respect to the timezone
        const isoString = currentDate.toISOString();

        return isoString;
    }
  good: |-
    type HelperFunctions = {
        // No specific properties needed for this integration as it's a utility function
    }

    export async function main(helperFunctionsResource: HelperFunctions, daysAgo: number): Promise<string> {
        const currentDate = new Date();
        currentDate.setUTCDate(currentDate.getUTCDate() - daysAgo);
        return currentDate.toISOString();
    }
  id: |-
    synthetic_get-iso-string-n-days-ago
  instructions: |-
    Returns an ISO string (UTC TZ) N days ago in helper functions
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    HelperFunctions
  resource_type_def: |-
    type HelperFunctions = {
        // Add properties needed for authentication/configuration that are relevant to any script related to this integration
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for HTTP requests to ActiveCampaign API

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(activecampaign_resource: activecampaign, contact_id: int) -> List[str]:
        headers = {
            'Api-Token': activecampaign_resource['api_key']
        }
        response = requests.get(
            f"{activecampaign_resource['api_url']}/api/3/contacts/{contact_id}/contactTags",
            headers=headers
        )
        response.raise_for_status()  # This will raise an exception for HTTP error responses
        contact_tags_data = response.json()
        tags = [tag['tag'] for tag in contact_tags_data.get('contactTags', [])]
        return tags
  good: |-
    from typing import TypedDict, List
    import requests  # Assuming requests is needed for API interaction

    class activecampaign(TypedDict):
        api_url: str
        api_key: str

    def main(ac_resource: activecampaign, contact_email: str) -> List[str]:
        api_endpoint = f"{ac_resource['api_url']}/api/3/contacts"
        headers = {
            "Api-Token": ac_resource['api_key'],
            "Content-Type": "application/json"
        }
        params = {
            "email": contact_email
        }
        response = requests.get(api_endpoint, headers=headers, params=params)
        response.raise_for_status()
        contact_data = response.json()
        contact_tags = []
        if 'contacts' in contact_data and contact_data['contacts']:
            contact_id = contact_data['contacts'][0]['id']
            tags_endpoint = f"{ac_resource['api_url']}/api/3/contacts/{contact_id}/contactTags"
            tags_response = requests.get(tags_endpoint, headers=headers)
            tags_response.raise_for_status()
            tags_data = tags_response.json()
            if 'contactTags' in tags_data:
                for contact_tag in tags_data['contactTags']:
                    contact_tags.append(contact_tag['tag'])
        return contact_tags
  id: |-
    synthetic_get-tags-for-contact
  instructions: |-
    Get Contact Tags. in activecampaign
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    activecampaign
  resource_type_def: |-
    class activecampaign(TypedDict):
        api_url: str
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { MongoClient } from "npm:mongodb";

    type Mongodb = {
        uri: string,
        dbName: string
    }

    export async function main(mongodbResource: Mongodb, collectionName: string, documentId: string) {
        const client = new MongoClient(mongodbResource.uri);
        try {
            await client.connect();
            const database = client.db(mongodbResource.dbName);
            const collection = database.collection(collectionName);
            const query = { _id: documentId };
            const document = await collection.findOne(query);
            return document;
        } finally {
            await client.close();
        }
    }
  good: |-
    import { MongoClient } from "npm:mongodb";

    type Mongodb = {
        uri: string,
        dbName: string,
        collectionName: string
    }

    export async function main(mongodbResource: Mongodb, documentId: string) {
        const client = new MongoClient(mongodbResource.uri);
        try {
            await client.connect();
            const database = client.db(mongodbResource.dbName);
            const collection = database.collection(mongodbResource.collectionName);
            const document = await collection.findOne({ _id: documentId });
            return document;
        } finally {
            await client.close();
        }
    }
  id: |-
    synthetic_find-document-by-id
  instructions: |-
    Retrieves a single document by ID in mongodb
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Mongodb
  resource_type_def: |-
    type Mongodb = {
        uri: string,
        dbName: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Client } from "npm:@asana/client";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, projectName: string, taskName: string) {
        const client = Client.create().useAccessToken(asanaResource.accessToken);

        // Retrieve all projects
        const projects = await client.projects.findAll();
        const project = projects.find(p => p.name === projectName);

        if (!project) {
            throw new Error(`Project with name ${projectName} not found.`);
        }

        // Retrieve all tasks in the project
        const tasks = await client.tasks.findByProject(project.gid);
        const task = tasks.find(t => t.name === taskName);

        if (!task) {
            throw new Error(`Task with name ${taskName} not found in project ${projectName}.`);
        }

        return task;
    }
  good: |-
    // Importing necessary libraries
    import { Client } from "npm:@asana/client";

    type Asana = {
        accessToken: string;
    }

    export async function main(asanaResource: Asana, projectGid: string, taskName: string) {
        // Initialize Asana client with the provided access token
        const client = Client.create().useAccessToken(asanaResource.accessToken);

        // Search for tasks within the specified project with the given task name
        const searchResult = await client.tasks.searchInWorkspaceForName(taskName, {
            project: projectGid,
        });

        // Return the search results
        return searchResult;
    }
  id: |-
    synthetic_search-tasks
  instructions: |-
    Searches for a Task by name within a Project in asana
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asana
  resource_type_def: |-
    type Asana = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        apiKey: string;
        accessToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string, sourceFolderId: string, targetFolderId: string) {
        const drive = google.drive({ version: 'v3', auth: googleDriveResource.apiKey });
        drive.auth.setCredentials({ access_token: googleDriveResource.accessToken });

        // Retrieve the existing parents to remove
        const file = await drive.files.get({
            fileId: fileId,
            fields: 'parents'
        });
        const previousParents = file.data.parents?.join(',');

        // Move the file to the new folder
        const result = await drive.files.update({
            fileId: fileId,
            addParents: targetFolderId,
            removeParents: previousParents,
            fields: 'id, parents'
        });

        return result.data;
    }
  good: |-
    import { drive_v3, google } from "npm:googleapis";

    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }

    export async function main(googleDriveResource: GoogleDrive, fileId: string, folderId: string) {
        const { clientId, clientSecret, redirectUri, refreshToken } = googleDriveResource;
        const oauth2Client = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2Client.setCredentials({ refresh_token: refreshToken });

        const drive = google.drive({ version: 'v3', auth: oauth2Client });

        try {
            // Retrieve the existing parents to remove
            const file = await drive.files.get({
                fileId: fileId,
                fields: 'parents'
            });
            const previousParents = file.data.parents?.join(',');

            // Move the file to the new folder
            const result = await drive.files.update({
                fileId: fileId,
                addParents: folderId,
                removeParents: previousParents,
                fields: 'id, parents'
            });

            return result.data;
        } catch (error) {
            throw new Error(`Failed to move file: ${error.message}`);
        }
    }
  id: |-
    synthetic_move-file
  instructions: |-
    Move a file from one folder to another for more information in google drive
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GoogleDrive
  resource_type_def: |-
    type GoogleDrive = {
        clientId: string;
        clientSecret: string;
        redirectUri: string;
        refreshToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type Asknicely = {
        apiKey: string,
        domain: string
    }

    export async function main(asknicelyResource: Asknicely, contactEmail: string, contactFirstName?: string, contactLastName?: string) {
        const url = `https://${asknicelyResource.domain}.asknice.ly/api/v1/contacts`;

        const headers = {
            "Authorization": `Basic ${encode(asknicelyResource.apiKey + ":")}`,
            "Content-Type": "application/json"
        };

        const body = JSON.stringify({
            email: contactEmail,
            first_name: contactFirstName,
            last_name: contactLastName
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type Asknicely = {
        apiKey: string,
        domain: string
    }

    export async function main(asknicelyResource: Asknicely, contactEmail: string, contactFirstName?: string, contactLastName?: string) {
        const url = `https://${asknicelyResource.domain}.asknice.ly/api/v1/contacts`;

        const headers = {
            'Authorization': `Basic ${encode(asknicelyResource.apiKey + ':')}`,
            'Content-Type': 'application/json'
        };

        const body = JSON.stringify({
            email: contactEmail,
            first_name: contactFirstName,
            last_name: contactLastName
        });

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_add-contact
  instructions: |-
    Add a new contact in asknicely
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Asknicely
  resource_type_def: |-
    type Asknicely = {
        apiKey: string,
        domain: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP requests to the Bitbucket API

    class bitbucket(TypedDict):
        api_base_url: str
        workspace: str
        repo_slug: str
        auth_token: str

    def main(bitbucket_resource: bitbucket, issue_id: int, comment_id: int, new_comment_body: str):
        headers = {
            "Authorization": f"Bearer {bitbucket_resource['auth_token']}",
            "Content-Type": "application/json"
        }
        url = f"{bitbucket_resource['api_base_url']}/repositories/{bitbucket_resource['workspace']}/{bitbucket_resource['repo_slug']}/issues/{issue_id}/comments/{comment_id}"
        payload = {
            "content": {
                "raw": new_comment_body
            }
        }
        response = requests.put(url, json=payload, headers=headers)
        return response.json()
  good: |-
    from typing import TypedDict
    import requests

    # Define the resource type for the Bitbucket integration
    class bitbucket(TypedDict):
        api_base_url: str
        access_token: str

    # Define the main function for updating an issue comment on Bitbucket
    def main(bitbucket_resource: bitbucket, workspace: str, repo_slug: str, issue_id: int, comment_id: int, new_content: str):
        # Construct the URL for the Bitbucket API endpoint to update an issue comment
        url = f"{bitbucket_resource['api_base_url']}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}/"

        # Prepare the headers for the HTTP request
        headers = {
            "Authorization": f"Bearer {bitbucket_resource['access_token']}",
            "Content-Type": "application/json"
        }

        # Prepare the data payload for the HTTP request
        data = {
            "content": {
                "raw": new_content
            }
        }

        # Make the HTTP request to update the issue comment
        response = requests.put(url, json=data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated comment data
        else:
            response.raise_for_status()  # Raise an exception if the request failed
  id: |-
    synthetic_update-issue-comment
  instructions: |-
    Updates a existent issue comment in bitbucket
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    bitbucket
  resource_type_def: |-
    class bitbucket(TypedDict):
        api_base_url: str
        access_token: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { fetch } from "npm:@deno/fetch";

    type DataPoliceUk = {
        baseUrl: string;
    }

    export async function main(
        dataPoliceUkResource: DataPoliceUk,
        latitude: number,
        longitude: number,
        dateFrom: string,
        dateTo: string
    ) {
        const url = `${dataPoliceUkResource.baseUrl}/crimes-at-location?lat=${latitude}&lng=${longitude}&date=${dateFrom},${dateTo}`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    }
  good: |-
    // Importing necessary libraries
    import { stringify } from "npm:query-string";

    type DataPoliceUk = {
        apiKey: string; // Assuming API key is needed, adjust according to actual requirements
    }

    export async function main(
        dataPoliceUkResource: DataPoliceUk,
        date: string, // Format YYYY-MM
        location: { latitude: number, longitude: number },
        category: string = 'all-crime' // default category if not specified
    ) {
        const queryParams = stringify({
            date: date,
            lat: location.latitude,
            lng: location.longitude,
            category: category
        });

        const response = await fetch(`https://data.police.uk/api/crimes-at-location?${queryParams}`, {
            headers: {
                'Authorization': `Bearer ${dataPoliceUkResource.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    }
  id: |-
    synthetic_retrieve-crime-data
  instructions: |-
    Obtain crime data for a specific location and date range in data police uk
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    DataPoliceUk
  resource_type_def: |-
    type DataPoliceUk = {
        apiKey: string; // Assuming API key is needed, adjust according to actual requirements
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the Memberstack integration
    class memberstack(TypedDict):
        api_key: str
        subdomain: str

    # Define the main function for updating a member in Memberstack
    def main(memberstack_resource: memberstack, member_id: str, update_data: dict) -> dict:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a member
        api_endpoint = f"https://{memberstack_resource['subdomain']}.memberstack.com/api/members/{member_id}"

        # Set up the headers with the API key
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {memberstack_resource['api_key']}"
        }

        # Make the request to update the member
        response = requests.patch(api_endpoint, json=update_data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated member data
        else:
            # Handle errors (you could raise an exception or return an error message)
            return {"error": response.text, "status_code": response.status_code}
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the Memberstack integration
    class memberstack(TypedDict):
        api_key: str
        subdomain: str

    # Define the function to update a member in Memberstack
    def main(memberstack_resource: memberstack, member_id: str, update_data: Dict[str, Any]) -> Dict[str, Any]:
        import requests  # Import requests or any other library if needed

        # Construct the API endpoint for updating a member
        url = f"https://{memberstack_resource['subdomain']}.memberstack.com/api/members/{member_id}"

        # Set up the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {memberstack_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to update the member
        response = requests.patch(url, json=update_data, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            return response.json()  # Return the updated member data
        else:
            # Handle error cases appropriately
            return {
                "error": "Failed to update member",
                "status_code": response.status_code,
                "message": response.text
            }

    # Note: The function is not called here, it is just defined and ready to be used.
  id: |-
    synthetic_update-member
  instructions: |-
    Updates a member in memberstack
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    memberstack
  resource_type_def: |-
    class memberstack(TypedDict):
        api_key: str
        subdomain: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:base-64";

    type AcelleMail = {
        apiUrl: string;
        token: string;
    }

    export async function main(acelleMailResource: AcelleMail, customerEmail: string, planId: string) {
        const url = `${acelleMailResource.apiUrl}/subscribers?api_token=${acelleMailResource.token}`;
        const body = {
            EMAIL: customerEmail,
            PLAN_ID: planId
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${encode(`${acelleMailResource.token}:`)}`,
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  good: |-
    // Import any libraries you need here
    import { encode } from "npm:base-64";

    type AcelleMail = {
        apiUrl: string;
        token: string;
    }

    export async function main(acelleMailResource: AcelleMail, customerEmail: string, planId: string) {
        const url = `${acelleMailResource.apiUrl}/api/v1/subscriptions`; // Endpoint for creating a subscription
        const authHeader = `Basic ${encode(`${acelleMailResource.token}:`)}`; // Basic Auth header

        const body = {
            contact: {
                email: customerEmail
            },
            plan_id: planId
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': authHeader,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json(); // Return the result of the subscription
    }
  id: |-
    synthetic_subscribe-customer-to-plan
  instructions: |-
    Subscribe customer to a plan in acelle mail
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AcelleMail
  resource_type_def: |-
    type AcelleMail = {
        apiUrl: string;
        token: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { Contact, Note } from "npm:@agilecrm/client"; // Assuming @agilecrm/client is the npm package for Agile CRM

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, contactId: string, noteContent: string) {
        // Initialize the Agile CRM client with the provided credentials
        const agileCrmClient = new Contact({
            apiKey: agileCrmResource.apiKey,
            domain: agileCrmResource.domain,
            email: agileCrmResource.email
        });

        // Create a new note object
        const note = new Note({
            subject: "Note",
            description: noteContent
        });

        // Add the note to the contact
        const result = await agileCrmClient.addNote(contactId, note);

        // Return the result of the operation
        return result;
    }
  good: |-
    import { AgileCrmClient as AgileCrmApiClient } from "npm:agilecrm";

    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }

    export async function main(agileCrmResource: AgileCrm, contactId: string, noteContent: string) {
        const agileCrmClient = new AgileCrmApiClient({
            apiKey: agileCrmResource.apiKey,
            domain: agileCrmResource.domain,
            email: agileCrmResource.email
        });

        const result = await agileCrmClient.contacts.addNote(contactId, {
            subject: "Note",
            description: noteContent
        });

        return result;
    }
  id: |-
    synthetic_create-contact-note
  instructions: |-
    Adds a note to a contact in agile crm
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    AgileCrm
  resource_type_def: |-
    type AgileCrm = {
        apiKey: string;
        domain: string;
        email: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict

    # Define the resource type for the 'expofp' integration
    class expofp(TypedDict):
        api_key: str
        event_id: str

    # Define the main function for updating a booth
    def main(expofp_resource: expofp, booth_id: str, booth_name: str, booth_description: str):
        # Assuming there's a library to interact with expofp API
        import expofp_api_client as client

        # Create an instance of the expofp API client
        expofp_client = client.ExpofpClient(api_key=expofp_resource['api_key'])

        # Update the booth with the provided details
        result = expofp_client.update_booth(
            event_id=expofp_resource['event_id'],
            booth_id=booth_id,
            name=booth_name,
            description=booth_description
        )

        # Return the result of the update operation
        return result
  good: |-
    from typing import TypedDict, Any

    # Define the resource type for the expofp integration
    class expofp(TypedDict):
        api_key: str
        base_url: str

    # Define the main function for updating a booth in expofp
    def main(expofp_resource: expofp, booth_id: int, booth_details: dict) -> Any:
        import requests  # Import requests or any other library if needed

        # Construct the URL for updating the booth
        update_url = f"{expofp_resource['base_url']}/booths/{booth_id}"

        # Prepare the headers with the API key for authentication
        headers = {
            "Authorization": f"Bearer {expofp_resource['api_key']}",
            "Content-Type": "application/json"
        }

        # Make the request to update the booth with the provided details
        response = requests.put(update_url, json=booth_details, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the updated booth information
            return response.json()
        else:
            # Return an error message if the update failed
            return {"error": response.text, "status_code": response.status_code}
  id: |-
    synthetic_update-booth
  instructions: |-
    Updates a booth in expofp
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    expofp
  resource_type_def: |-
    class expofp(TypedDict):
        api_key: str
        event_id: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Importing necessary libraries
    import { AmaraApi } from "npm:@amara/api"; // Assuming there's an npm package for Amara API

    // Define the resource type for the Amara integration
    type Amara = {
        apiKey: string;
    }

    // Define the parameters for adding new subtitles
    type NewSubtitleParams = {
        videoId: string;
        languageCode: string;
        subtitleContent: string;
        format: string; // e.g., 'srt', 'vtt'
    }

    export async function main(amaraResource: Amara, { videoId, languageCode, subtitleContent, format }: NewSubtitleParams) {
        // Initialize the Amara API client with the provided API key
        const amaraApi = new AmaraApi(amaraResource.apiKey);

        // Call the Amara API to add new subtitles
        const response = await amaraApi.addSubtitles(videoId, languageCode, subtitleContent, format);

        // Return the result of the API call
        return response;
    }
  good: |-
    import { AmaraCredentials } from "npm:@types/amara"; // Assuming there's a type definition for Amara credentials

    type Amara = {
        apiKey: string;
        username: string;
    }

    export async function main(amaraResource: Amara, videoId: string, languageCode: string, subtitles: string, subFormat: string) {
        const apiUrl = `https://amara.org/api/videos/${videoId}/languages/${languageCode}/subtitles/`;

        const headers = {
            'X-api-key': amaraResource.apiKey,
            'X-api-username': amaraResource.username,
            'Content-Type': 'application/json'
        };
        const body = JSON.stringify({
            subtitles: subtitles,
            sub_format: subFormat
        });

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();

        return result;
    }
  id: |-
    synthetic_add-new-subtitles
  instructions: |-
    Add new subtitles in amara
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Amara
  resource_type_def: |-
    type Amara = {
        apiKey: string;
        username: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, List, Dict
    import facebook  # Assuming 'facebook' is the library used for Facebook Pages API

    # Define the resource type for the 'facebook_pages' integration
    class facebook_pages(TypedDict):
        access_token: str  # OAuth2 Access Token for the Facebook Page

    # Define the main function for listing posts from a Facebook Page
    def main(facebook_pages_resource: facebook_pages, page_id: str) -> List[Dict]:
        graph = facebook.GraphAPI(access_token=facebook_pages_resource['access_token'])
        posts = graph.get_connections(id=page_id, connection_name='posts')

        # Extract the data from the response
        post_list = posts['data']

        return post_list

    # The script ends here, and the 'main' function can be exported and used as required.
  good: |-
    from typing import TypedDict, List, Dict
    import facebook  # Assuming 'facebook' is the library used for Facebook integration

    class facebook_pages(TypedDict):
        access_token: str
        page_id: str

    def main(facebook_pages_resource: facebook_pages, limit: int = 10) -> List[Dict]:
        graph = facebook.GraphAPI(access_token=facebook_pages_resource['access_token'])
        posts = graph.get_connections(id=facebook_pages_resource['page_id'], connection_name='posts', limit=limit)
        return posts['data']
  id: |-
    synthetic_list-posts
  instructions: |-
    Retrieves a list of posts on a Facebook Page in facebook pages
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    facebook_pages
  resource_type_def: |-
    class facebook_pages(TypedDict):
        access_token: str  # OAuth2 Access Token for the Facebook Page
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you might need here
    import { Adalo as AdaloAPI } from "npm:@adalo/api"; // Rename the imported method to avoid conflict

    type Adalo = {
        apiKey: string,
        appId: string
    }

    export async function main(adaloResource: Adalo, tableName: string, filters?: Record<string, any>) {
        // Initialize the Adalo API client with the provided apiKey
        const adalo = new AdaloAPI(adaloResource.apiKey);

        // Fetch records from the specified table in the Adalo app
        // If filters are provided, apply them to the query
        const records = await adalo.getRecords(adaloResource.appId, tableName, filters);

        // Return the fetched records
        return records;
    }
  good: |-
    import { fetch } from "npm:@adalo/fetch";

    type Adalo = {
        apiKey: string,
        appId: string,
        collectionId: string
    }

    export async function main(adaloResource: Adalo) {
        const url = `https://api.adalo.com/apps/${adaloResource.appId}/collections/${adaloResource.collectionId}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${adaloResource.apiKey}`
            }
        });

        if (!response.ok) {
            throw new Error(`Error fetching records: ${response.statusText}`);
        }

        const records = await response.json();
        return records;
    }
  id: |-
    synthetic_get-records
  instructions: |-
    Get all records from a collection in adalo
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Adalo
  resource_type_def: |-
    type Adalo = {
        apiKey: string,
        appId: string
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { OpenAI as OpenAIClient } from "npm:openai";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, audioUrl: string) {
        const openai = new OpenAIClient(openaiResource.apiKey);

        const response = await openai.createTranscription({
            source: audioUrl,
            format: "mp3",
            language: "en"
        });

        return response;
    }
  good: |-
    import { OpenAIAPI } from "npm:@openai/client";

    type Openai = {
        apiKey: string;
    }

    export async function main(openaiResource: Openai, audioUrl: string, inputLanguage: string) {
        const openai = new OpenAIAPI({
            apiKey: openaiResource.apiKey,
        });

        const response = await openai.createTranscription({
            audio_url: audioUrl,
            input_language: inputLanguage,
        });

        return response;
    }
  id: |-
    synthetic_create-transcription
  instructions: |-
    Transcribes audio into the input language. in openai
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { GhostAdminAPI } from "npm:@tryghost/admin-api";

    type GhostOrgAdminApi = {
        apiUrl: string;
        adminApiKey: string;
    }

    export async function main(
        ghostResource: GhostOrgAdminApi,
        memberId: string,
        memberData: {
            name?: string;
            email?: string;
            note?: string;
            subscribed?: boolean;
            labels?: string[];
        }
    ) {
        const api = new GhostAdminAPI({
            url: ghostResource.apiUrl,
            key: ghostResource.adminApiKey,
            version: "v3"
        });

        try {
            const updatedMember = await api.members.edit({
                id: memberId,
                ...memberData
            });
            return updatedMember;
        } catch (error) {
            console.error('Error updating member:', error);
            throw error;
        }
    }
  good: |-
    import { GhostAdminAPI } from "npm:@tryghost/admin-api";

    type GhostOrgAdminApi = {
        url: string;
        adminApiKey: string;
        version: string;
    }

    export async function main(
        ghostResource: GhostOrgAdminApi,
        memberId: string,
        memberData: {
            name?: string;
            email?: string;
            note?: string;
            subscribed?: boolean;
            labels?: string[];
        }
    ) {
        const api = new GhostAdminAPI({
            url: ghostResource.url,
            key: ghostResource.adminApiKey,
            version: ghostResource.version
        });

        try {
            const updatedMember = await api.members.edit({ id: memberId, ...memberData });
            return updatedMember;
        } catch (error) {
            console.error('Error updating member:', error);
            throw error;
        }
    }
  id: |-
    synthetic_update-member
  instructions: |-
    Update a member in Ghost in ghost org admin api
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    GhostOrgAdminApi
  resource_type_def: |-
    type GhostOrgAdminApi = {
        apiUrl: string;
        adminApiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { RestClient } from "npm:typed-rest-client/RestClient";

    type Cleverreach = {
        clientId: string;
        clientSecret: string;
        accessToken: string;
        refreshToken: string;
        baseUrl: string;
    }

    export async function main(
        cleverreachResource: Cleverreach,
        groupId: number,
        email: string,
        attributes?: Record<string, any>,
        globalAttributes?: Record<string, any>
    ) {
        const restClient = new RestClient('cleverreach', cleverreachResource.baseUrl);

        const subscriber = {
            email: email,
            attributes: attributes || {},
            global_attributes: globalAttributes || {}
        };

        const response = await restClient.create<any>(
            `/groups.json/${groupId}/receivers`,
            subscriber,
            {
                additionalHeaders: {
                    'Authorization': `Bearer ${cleverreachResource.accessToken}`
                }
            }
        );

        return response.result;
    }
  good: |-
    import { RestClient } from "npm:typed-rest-client/RestClient";

    type Cleverreach = {
        accessToken: string,
        clientId: string,
        clientSecret: string,
        baseUrl: string
    }

    export async function main(cleverreachResource: Cleverreach, newSubscriberEmail: string, groupId: number) {
        const restClient = new RestClient('cleverreach_client', cleverreachResource.baseUrl);

        const response = await restClient.create(`/groups.json/${groupId}/receivers`, {
            email: newSubscriberEmail,
            activated: new Date().toISOString(),
            registered: new Date().toISOString()
        }, {
            additionalHeaders: {
                'Authorization': `Bearer ${cleverreachResource.accessToken}`
            }
        });

        return response.result;
    }
  id: |-
    synthetic_create-subscriber
  instructions: |-
    The email address of the new subscriber in cleverreach
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Cleverreach
  resource_type_def: |-
    type Cleverreach = {
        clientId: string;
        clientSecret: string;
        accessToken: string;
        refreshToken: string;
        baseUrl: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed for HTTP calls

    class gryd(TypedDict):
        api_key: str
        endpoint_url: str

    def main(gryd_resource: gryd, vehicle_registration: str) -> dict:
        headers = {
            'Authorization': f"Bearer {gryd_resource['api_key']}"
        }
        response = requests.get(
            f"{gryd_resource['endpoint_url']}/vehicles/{vehicle_registration}/ulez",
            headers=headers
        )
        response.raise_for_status()  # This will raise an exception for HTTP errors
        return response.json()
  good: |-
    from typing import TypedDict
    import requests  # Assuming requests is needed to make API calls

    class gryd(TypedDict):
        api_key: str
        base_url: str

    def main(gryd_resource: gryd, vehicle_registration: str) -> dict:
        headers = {
            'Authorization': f"Bearer {gryd_resource['api_key']}"
        }
        url = f"{gryd_resource['base_url']}/ulez-lookup/{vehicle_registration}"
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # This will raise an error for non-2xx responses
        return response.json()
  id: |-
    synthetic_get-vehicle-ulez-data
  instructions: |-
    Fetches ULEZ data for a specific vehicle from the Gryd API in gryd
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    gryd
  resource_type_def: |-
    class gryd(TypedDict):
        api_key: str
        endpoint_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    class f15five(TypedDict):
        api_key: str
        base_url: str

    def main(f15five_resource: f15five, checkin_id: str) -> Dict[str, Any]:
        import requests

        headers = {
            'Authorization': f"Bearer {f15five_resource['api_key']}"
        }

        url = f"{f15five_resource['base_url']}/checkins/{checkin_id}"

        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()
  good: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the f15five integration
    class f15five(TypedDict):
        api_key: str
        base_url: str

    # Import any libraries you need here
    import requests

    # Define the main function
    def main(f15five_resource: f15five, check_in_id: str) -> Dict[str, Any]:
        # Construct the headers with the API key
        headers = {
            'Authorization': f"Bearer {f15five_resource['api_key']}"
        }

        # Construct the URL for the check-in object details
        url = f"{f15five_resource['base_url']}/api/v1/check_ins/{check_in_id}"

        # Make the request to get the check-in object details
        response = requests.get(url, headers=headers)

        # Check if the request was successful
        if response.status_code == 200:
            # Return the check-in object details
            return response.json()
        else:
            # Handle errors (e.g., log them, raise an exception, etc.)
            response.raise_for_status()

    # Example usage:
    # result = main(f15five_resource={'api_key': 'your_api_key', 'base_url': 'https://api.15five.com'}, check_in_id='your_check_in_id')
    # print(result)
  id: |-
    synthetic_get-checkin-details
  instructions: |-
    Get check-in object details in f15five
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    f15five
  resource_type_def: |-
    class f15five(TypedDict):
        api_key: str
        base_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { encode } from "npm:querystring";

    type Discogs = {
        consumerKey: string;
        consumerSecret: string;
        token: string;
        tokenSecret: string;
    }

    export async function main(discogsResource: Discogs, releaseId: number, condition: string, price: number, comments: string, allowOffers: boolean, status: string) {
        const url = `https://api.discogs.com/marketplace/listings`;
        const method = 'POST';
        const headers = new Headers({
            'Authorization': `OAuth oauth_consumer_key="${discogsResource.consumerKey}",oauth_token="${discogsResource.token}",oauth_signature_method="PLAINTEXT",oauth_timestamp="${Math.floor(Date.now() / 1000)}",oauth_nonce="${Math.random().toString(36).substring(2, 15)}",oauth_version="1.0",oauth_signature="${discogsResource.consumerSecret}&${discogsResource.tokenSecret}"`,
            'Content-Type': 'application/x-www-form-urlencoded'
        });
        const body = encode({
            release_id: releaseId,
            condition: condition,
            price: price,
            comments: comments,
            allow_offers: allowOffers,
            status: status
        });

        const response = await fetch(url, {
            method: method,
            headers: headers,
            body: body
        });

        const result = await response.json();
        return result;
    }
  good: |-
    import { encode } from "npm:base-64";

    type Discogs = {
        consumerKey: string;
        consumerSecret: string;
        accessToken: string;
        accessTokenSecret: string;
    }

    export async function main(discogsResource: Discogs, releaseId: number, condition: string, price: number, comments: string, allowOffers: boolean, status: string) {
        const url = `https://api.discogs.com/marketplace/listings`;
        const method = 'POST';
        const body = JSON.stringify({
            release_id: releaseId,
            condition: condition,
            price: price,
            comments: comments,
            allow_offers: allowOffers,
            status: status
        });
        const headers = {
            'Authorization': `OAuth oauth_consumer_key="${discogsResource.consumerKey}",oauth_token="${discogsResource.accessToken}",oauth_signature_method="PLAINTEXT",oauth_timestamp="${Math.floor(Date.now() / 1000)}",oauth_nonce="${Math.random().toString(36).substring(2, 15)}",oauth_version="1.0",oauth_signature="${discogsResource.consumerSecret}&${discogsResource.accessTokenSecret}"`,
            'Content-Type': 'application/json',
            'User-Agent': 'YourAppName/1.0'
        };

        const response = await fetch(url, {
            method: method,
            headers: headers,
            body: body
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    }
  id: |-
    synthetic_create-marketplace-listing
  instructions: |-
    Creates a new listing in the Discogs marketplace in discogs
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Discogs
  resource_type_def: |-
    type Discogs = {
        consumerKey: string;
        consumerSecret: string;
        token: string;
        tokenSecret: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    // Import any libraries you need here
    import { Maintainx } from 'npm:@maintainx/sdk';

    type Maintainx = {
        apiKey: string;
    }

    export async function main(maintainxResource: Maintainx, workOrderId: string, status: string, notes?: string) {
        // Initialize the Maintainx SDK with the provided API key
        const maintainx = new Maintainx(maintainxResource.apiKey);

        // Prepare the update payload
        const updatePayload = {
            status: status,
            notes: notes,
        };

        // Update the work order with the new status and optional notes
        const result = await maintainx.workOrders.update(workOrderId, updatePayload);

        // Return the result of the update operation
        return result;
    }
  good: |-
    // Import any libraries you need here
    import { WorkOrderUpdate, WorkOrder } from "npm:@maintainx/sdk";

    type Maintainx = {
        apiKey: string;
    }

    export async function main(maintainxResource: Maintainx, workOrderId: string, updateData: WorkOrderUpdate) {
        // Set up the headers for the API request
        const headers = new Headers({
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${maintainxResource.apiKey}`
        });

        // Prepare the URL and the request options
        const url = `https://api.maintainx.com/api/v1/workorders/${workOrderId}`;
        const requestOptions: RequestInit = {
            method: 'PATCH',
            headers: headers,
            body: JSON.stringify(updateData)
        };

        // Make the API request to update the work order
        const response = await fetch(url, requestOptions);
        if (!response.ok) {
            throw new Error(`Failed to update work order: ${response.status} ${response.statusText}`);
        }

        // Parse the response to JSON
        const updatedWorkOrder: WorkOrder = await response.json();

        // Return the updated work order
        return updatedWorkOrder;
    }
  id: |-
    synthetic_update-work-order
  instructions: |-
    Updates a work order in maintainx
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    Maintainx
  resource_type_def: |-
    type Maintainx = {
        apiKey: string;
    }
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any, Dict

    # Define the resource type for the 'data_stores' integration
    class data_stores(TypedDict):
        api_key: str
        store_url: str

    # Define the main function that will be exported
    def main(data_stores_resource: data_stores, item_id: str, comparison_fields: Dict[str, Any]):
        # Assuming there is a library to interact with the data store
        from data_store_client import get_item as fetch_item  # Renamed to avoid conflict

        # Retrieve the item from the data store
        item_data = fetch_item(data_stores_resource['store_url'], data_stores_resource['api_key'], item_id)

        # Calculate the differences based on the comparison fields
        differences = {}
        for field, expected_value in comparison_fields.items():
            actual_value = item_data.get(field)
            if actual_value != expected_value:
                differences[field] = {'expected': expected_value, 'actual': actual_value}

        # Return the result
        return differences

    # The script ends here, with the main function ready to be used with the required parameters
  good: |-
    from typing import TypedDict, Dict

    # Define the resource type for the 'data_stores' integration
    class data_stores(TypedDict):
        api_key: str
        endpoint_url: str

    def main(data_store_resource_1: data_stores, data_store_resource_2: data_stores) -> Dict[str, str]:
        # Assuming we have a function to fetch data from the data store
        # This function is not implemented here as it's outside the scope of the instructions
        def fetch_data_from_store(store_resource: data_stores) -> Dict[str, str]:
            # Placeholder for fetching data logic
            pass

        # Fetch data from both data stores
        data_store_1_data = fetch_data_from_store(data_store_resource_1)
        data_store_2_data = fetch_data_from_store(data_store_resource_2)

        # Find the difference between the two data stores
        difference = {
            key: value
            for key, value in data_store_1_data.items()
            if key not in data_store_2_data
        }
        difference.update({
            key: value
            for key, value in data_store_2_data.items()
            if key not in data_store_1_data
        })

        # Return the result containing key/value pairs where the key exists in one data store, but not the other
        return difference
  id: |-
    synthetic_get-difference
  instructions: |-
    Get the difference between two data stores. Result contains key/value pairs where the key exists in one data store, but not the other. in data stores
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    data_stores
  resource_type_def: |-
    class data_stores(TypedDict):
        api_key: str
        store_url: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    from typing import TypedDict, Any
    import openai as openai_lib  # Renamed the imported module to avoid conflict

    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, message: str, engine: str = 'davinci') -> Any:
        openai_lib.api_key = openai_resource['api_key']
        response = openai_lib.Completion.create(
            engine=engine,
            prompt=message,
            max_tokens=150
        )
        return response
  good: |-
    from typing import TypedDict, Any
    import openai as openai_client

    class openai(TypedDict):
        api_key: str

    def main(openai_resource: openai, thread_id: str, message: str) -> Any:
        openai_client.api_key = openai_resource['api_key']

        response = openai_client.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": message}
            ],
            thread_id=thread_id
        )

        return response
  id: |-
    synthetic_create-message
  instructions: |-
    Create a message in a thread in openai
  lang: |-
    python
  main_func_score: 1
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
  resource_type_score: 1
  syntax_score: 1
- bad: |-
    import { FacebookGroups } from "npm:@types/facebook-js-sdk";

    type FacebookGroupsResource = {
        accessToken: string;
        groupId: string;
    }

    export async function main(facebookGroupsResource: FacebookGroupsResource, postId: string) {
        const url = `https://graph.facebook.com/v14.0/${facebookGroupsResource.groupId}_${postId}?fields=message,from,created_time&access_token=${facebookGroupsResource.accessToken}`;

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const post = await response.json();
        return post;
    }
  good: |-
    // Import any libraries you need here
    import { fetch } from "npm:@deno/fetch";

    type FacebookGroups = {
        accessToken: string;
    }

    export async function main(facebookGroupsResource: FacebookGroups, groupId: string, postId: string) {
        const url = `https://graph.facebook.com/v14.0/${groupId}_${postId}?access_token=${facebookGroupsResource.accessToken}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching post:', error);
            throw error;
        }
    }
  id: |-
    synthetic_get-post
  instructions: |-
    Retrieves post in a group in facebook groups
  lang: |-
    deno
  main_func_score: 1
  resource_type: |-
    FacebookGroups
  resource_type_def: |-
    type FacebookGroups = {
        accessToken: string;
    }
  resource_type_score: 1
  syntax_score: 1
