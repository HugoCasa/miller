- edit_instructions: |-
    Modify the function to return the sum of the digits of the input number instead of the last digit.
  id: |-
    hubedit_mbpp_py_435
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        return sum(int(digit) for digit in str(n))
  original_code: |-
    def main(n: int) -> int:
        return (n % 10)
  original_instructions: |-
    find the last digit of a given number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the average of the maximum and minimum values in the list instead of their sum.
  id: |-
    hubedit_mbpp_py_476
  lang: |-
    python
  modified_code: |-
    from typing import List, Union

    def main(nums: List[Union[int, float]]) -> Union[int, float]:
        average_value = (max(nums) + min(nums)) / 2
        return average_value
  original_code: |-
    from typing import List, Union

    def main(nums: List[Union[int, float]]) -> Union[int, float]:
        sum_value = max(nums) + min(nums)
        return sum_value
  original_instructions: |-
    find the sum of the largest and smallest value in a given array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the `n` items with the lowest prices instead of the highest by using `heapq.nsmallest` instead of `heapq.nlargest`.
  id: |-
    hubedit_mbpp_py_585
  lang: |-
    python
  modified_code: |-
    from typing import List, Dict

    import heapq

    def main(items: List[Dict[str, float]], n: int) -> List[Dict[str, float]]:
        main = heapq.nsmallest(n, items, key=lambda s: s['price'])
        return main
  original_code: |-
    from typing import List, Dict

    import heapq

    def main(items: List[Dict[str, float]], n: int) -> List[Dict[str, float]]:
        main = heapq.nlargest(n, items, key=lambda s: s['price'])
        return main
  original_instructions: |-
    find the n most expensive items in a given dataset
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the pattern to match any string that starts with 'a' and ends with 'b', regardless of what is in between, including new lines.
  id: |-
    hubedit_mbpp_py_794
  lang: |-
    python
  modified_code: |-
    import re
    from typing import Optional, Match

    def main(text: str) -> Optional[Match[str]]:
        patterns = r'a[\s\S]*b$'
        return re.search(patterns, text, re.MULTILINE)
  original_code: |-
    import re
    from typing import Optional, Match

    def main(text: str) -> Optional[Match[str]]:
        patterns = 'a.*?b$'
        return re.search(patterns, text)
  original_instructions: |-
    matches a string that has an 'a' followed by anything, ending in 'b'
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the number of times a digit appears in `n` is exactly equal to the digit itself, instead of being less than or equal to the digit.
  id: |-
    hubedit_mbpp_py_283
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> bool:
        for i in range(10):
            temp = n
            count = 0
            while temp:
                if temp % 10 == i:
                    count += 1
                temp //= 10
            if count != 0 and count != i:
                return False
        return True
  original_code: |-
    def main(n: int) -> bool:
        for i in range(10):
            temp = n
            count = 0
            while (temp):
                if (temp % 10 == i):
                    count += 1
                if (count > i):
                    return False
                temp //= 10
        return True
  original_instructions: |-
    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the n smallest numbers from the list instead of the n largest.
  id: |-
    hubedit_mbpp_py_4
  lang: |-
    python
  modified_code: |-
    import heapq as hq
    from typing import List

    def main(nums: List[int], n: int) -> List[int]:
      smallest_nums = hq.nsmallest(n, nums)
      return smallest_nums
  original_code: |-
    import heapq as hq
    from typing import List

    def main(nums: List[int], n: int) -> List[int]:
      largest_nums = hq.nlargest(n, nums)
      return largest_nums
  original_instructions: |-
    find the n largest integers from a given list of numbers, returned in descending order
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the regular expression to also allow for comma separators for thousands, and ensure it still allows for up to two decimal places.
  id: |-
    hubedit_mbpp_py_759
  lang: |-
    python
  modified_code: |-
    def main(num: str) -> bool:
        import re
        dnumre = re.compile(r"""^([0-9]{1,3}(,[0-9]{3})*|([0-9]+))(\.[0-9]{1,2})?$""")
        result = dnumre.search(num)
        return bool(result)
  original_code: |-
    def main(num: str) -> bool:
        import re
        dnumre = re.compile(r"""^[0-9]+(\.[0-9]{1,2})?$""")
        result = dnumre.search(num)
        return bool(result)
  original_instructions: |-
    check whether a given string is a decimal number with a precision of 2
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the area of a square instead of the perimeter by multiplying the side length by itself.
  id: |-
    hubedit_mbpp_py_17
  lang: |-
    python
  modified_code: |-
    def main(a: float) -> float:
      area = a * a
      return area
  original_code: |-
    def main(a: float) -> float:
      perimeter = 4 * a
      return perimeter
  original_instructions: |-
    returns the perimeter of a square given its side length as input
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to check if the list is strictly decreasing instead of non-decreasing by changing the comparison operator from `<=` to `>=` and reversing the list order in the comparison.
  id: |-
    hubedit_mbpp_py_567
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(list1: List[int]) -> bool:
        result = all(list1[i] >= list1[i+1] for i in range(len(list1)-1))
        return result
  original_code: |-
    from typing import List

    def main(list1: List[int]) -> bool:
        result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))
        return result
  original_instructions: |-
    check whether a specified list is sorted or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the substring appears at the beginning of the main string.
  id: |-
    hubedit_mbpp_py_91
  lang: |-
    python
  modified_code: |-
    def main(str1: str, sub_str: str) -> bool:
        return str1.startswith(sub_str)
  original_code: |-
    def main(str1: str, sub_str: str) -> bool:
       if any(sub_str in s for s in str1):
           return True
       return False
  original_instructions: |-
    check if a string is present as a substring in a given list of string values
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to sort the list in descending order instead of ascending order by changing the comparison condition within the inner while loop.
  id: |-
    hubedit_mbpp_py_428
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(my_list: List[int]) -> List[int]:
        gap = len(my_list) // 2
        while gap > 0:
            for i in range(gap, len(my_list)):
                current_item = my_list[i]
                j = i
                while j >= gap and my_list[j - gap] < current_item:  # Changed comparison here
                    my_list[j] = my_list[j - gap]
                    j -= gap
                my_list[j] = current_item
            gap //= 2

        return my_list
  original_code: |-
    from typing import List

    def main(my_list: List[int]) -> List[int]:
        gap = len(my_list) // 2
        while gap > 0:
            for i in range(gap, len(my_list)):
                current_item = my_list[i]
                j = i
                while j >= gap and my_list[j - gap] > current_item:
                    my_list[j] = my_list[j - gap]
                    j -= gap
                my_list[j] = current_item
            gap //= 2

        return my_list
  original_instructions: |-
    sort the given array by using shell sort
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the maximum product of a subarray that includes at least one negative number. If no negative numbers are present in the array, return 0.
  id: |-
    hubedit_mbpp_py_468
  lang: |-
    python
  modified_code: |-
    def main(arr: list) -> int:
        n = len(arr)
        max_product_including_negative = 0
        max_ending_here = 1
        min_ending_here = 1
        has_negative = False

        for i in range(n):
            if arr[i] > 0:
                max_ending_here *= arr[i]
                min_ending_here = min(min_ending_here * arr[i], 1)
            elif arr[i] == 0:
                max_ending_here = 1
                min_ending_here = 1
            else:
                has_negative = True
                temp = max_ending_here
                max_ending_here = max(min_ending_here * arr[i], 1)
                min_ending_here = temp * arr[i]

            max_product_including_negative = max(max_product_including_negative, max_ending_here)

        return max_product_including_negative if has_negative else 0
  original_code: |-
    def main(arr: list) -> int:
      n = len(arr)
      mpis = arr[:]
      for i in range(n):
        current_prod = arr[i]
        j = i + 1
        while j < n:
          if arr[j-1] > arr[j]:
            break
          current_prod *= arr[j]
          if current_prod > mpis[j]:
            mpis[j] = current_prod
          j = j + 1
      return max(mpis)
  original_instructions: |-
    find the maximum product formed by multiplying numbers of an increasing subsequence of that array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the function to return the square of N instead of subtracting one from it.
  id: |-
    hubedit_mbpp_py_89
  lang: |-
    python
  modified_code: |-
    def main(N: int) -> int:
      return N * N
  original_code: |-
    def main(N: int) -> int:
      return (N - 1)
  original_instructions: |-
    find the closest smaller number than n
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of unique elements across all sublists in the given list of lists, instead of counting unique sorted tuples of sublists.
  id: |-
    hubedit_mbpp_py_400
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> int:
        unique_elements = set(element for sublist in test_list for element in sublist)
        res = len(unique_elements)
        return res
  original_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> int:
        res = len(list(set(tuple(sorted(sub)) for sub in test_list)))
        return res
  original_instructions: |-
    extract the number of unique tuples in the given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of strings that are longer than the specified length instead of equal to it.
  id: |-
    hubedit_mbpp_py_450
  lang: |-
    python
  modified_code: |-
    def main(str_list: list, length: int) -> list:
        result = [e for e in str_list if len(e) > length]
        return result
  original_code: |-
    def main(str_list: list, length: int) -> list:
        result = [e for e in str_list if len(e) == length]
        return result
  original_instructions: |-
    extract specified size of strings from a given list of string values
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the student with the minimum total marks instead of the maximum.
  id: |-
    hubedit_mbpp_py_299
  lang: |-
    python
  modified_code: |-
    from collections import defaultdict
    from typing import List, Tuple, Dict

    def main(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:
        temp: Dict[str, int] = defaultdict(int)
        for name, marks in stdata:
            temp[name] += marks
        return min(temp.items(), key=lambda x: x[1])
  original_code: |-
    from collections import defaultdict
    from typing import List, Tuple, Dict

    def main(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:
        temp: Dict[str, int] = defaultdict(int)
        for name, marks in stdata:
            temp[name] += marks
        return max(temp.items(), key=lambda x: x[1])
  original_instructions: |-
    calculate the maximum aggregate from the list of tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if all elements in the array are unique instead of checking if all elements are the same.
  id: |-
    hubedit_mbpp_py_760
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(arr: List[int]) -> bool:
        s = set(arr)
        return len(s) == len(arr)
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> bool:
        s = set(arr)
        return len(s) == 1
  original_instructions: |-
    check whether a list of numbers contains only one distinct element or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the base case to return 0 when n is 0 and 1 when n is 1, and adjust the recursive calls to use n-2 and n-1 instead of n-1 and n-main(n-1).
  id: |-
    hubedit_mbpp_py_84
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n == 0:
            return 0
        elif n == 1:
            return 1
        else:
            return main(n-2) + main(n-1)
  original_code: |-
    def main(n: int) -> int:
        if n == 1 or n == 2:
            return 1
        else:
            return main(main(n-1)) + main(n-main(n-1))
  original_instructions: |-
    find the nth number in the newman conway sequence
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the matrix is a magic square, where the sums of the numbers in each row, each column, and both main diagonals are equal, but also check if all the numbers in the matrix are distinct.
  id: |-
    hubedit_mbpp_py_129
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(my_matrix: List[List[int]]) -> bool:
        if not my_matrix or not all(len(row) == len(my_matrix) for row in my_matrix):
            return False  # Not a square matrix

        iSize = len(my_matrix)
        sum_list = []
        unique_numbers = set()

        # Check rows and collect unique numbers
        for row in my_matrix:
            sum_list.append(sum(row))
            unique_numbers.update(row)

        # Check columns
        for col in range(iSize):
            sum_list.append(sum(row[col] for row in my_matrix))

        # Check diagonals
        sum_list.append(sum(my_matrix[i][i] for i in range(iSize)))
        sum_list.append(sum(my_matrix[i][iSize - 1 - i] for i in range(iSize)))

        # Check if all sums are equal and if all numbers are distinct
        return len(set(sum_list)) == 1 and len(unique_numbers) == iSize * iSize
  original_code: |-
    from typing import List

    def main(my_matrix: List[List[int]]) -> bool:
        iSize = len(my_matrix[0])
        sum_list = []
        sum_list.extend([sum(lines) for lines in my_matrix])
        for col in range(iSize):
            sum_list.append(sum(row[col] for row in my_matrix))
        result1 = 0
        for i in range(0, iSize):
            result1 += my_matrix[i][i]
        sum_list.append(result1)
        result2 = 0
        for i in range(iSize-1, -1, -1):
            result2 += my_matrix[i][iSize - 1 - i]
        sum_list.append(result2)
        if len(set(sum_list)) > 1:
            return False
        return True
  original_instructions: |-
    calculate whether the matrix is a magic square
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the sum of a and b instead of the smaller value.
  id: |-
    hubedit_mbpp_py_404
  lang: |-
    python
  modified_code: |-
    def main(a: float, b: float) -> float:
        return a + b
  original_code: "def main(a: float, b: float) -> float:\n    if a <= b:\n       \
    \ return a\n    else:\n        return b "
  original_instructions: |-
    find the minimum of two numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to use `bisect_left` instead of `bisect_right` to find the insertion point of `x` in `a` which would return the leftmost place in the sorted list to insert `x`.
  id: |-
    hubedit_mbpp_py_786
  lang: |-
    python
  modified_code: |-
    import bisect
    from typing import List, Any

    def main(a: List[Any], x: Any) -> int:
        return bisect.bisect_left(a, x)
  original_code: |-
    import bisect
    from typing import List, Any

    def main(a: List[Any], x: Any) -> int:
        return bisect.bisect_right(a, x)
  original_instructions: |-
    locate the right insertion point for a specified value in sorted order
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the regex pattern to match strings that end with a digit, instead of starting with a vowel.
  id: |-
    hubedit_mbpp_py_737
  lang: |-
    python
  modified_code: |-
    import re
    from typing import Optional, Match

    regex = '[A-Za-z0-9_]*\d$'

    def main(string: str) -> Optional[Match[str]]:
        return re.search(regex, string)
  original_code: |-
    import re
    from typing import Optional, Match

    regex = '^[aeiouAEIOU][A-Za-z0-9_]*'

    def main(string: str) -> Optional[Match[str]]:
        return re.search(regex, string)
  original_instructions: |-
    check whether the given string is starting with a vowel or not using regex
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the sum of the elements instead of the maximum, by replacing the `max` function with a sum of the current index `i` and the elements at indices `i/2`, `i/3`, `i/4`, and `i/5`.
  id: |-
    hubedit_mbpp_py_392
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        res = list()
        res.append(0)
        res.append(1)
        i = 2
        while i < n + 1:
            res.append(i + (res[int(i / 2)]
                            + res[int(i / 3)] +
                                res[int(i / 4)]
                            + res[int(i / 5)]))
            i = i + 1
        return res[n]
  original_code: |-
    def main(n: int) -> int:
        res = list()
        res.append(0)
        res.append(1)
        i = 2
        while i < n + 1:
            res.append(max(i, (res[int(i / 2)]
                            + res[int(i / 3)] +
                                res[int(i / 4)]
                            + res[int(i / 5)])))
            i = i + 1
        return res[n]
  original_instructions: |-
    find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the first elements of all tuples in the list if they are integers or floats.
  id: |-
    hubedit_mbpp_py_596
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple, Any

    def main(tuple_list: List[Tuple[Any, ...]]) -> float:
        return sum(item[0] for item in tuple_list if isinstance(item[0], (int, float)))
  original_code: |-
    import sys
    from typing import List, Tuple, Any

    def main(tuple_list: List[Tuple[Any, ...]]) -> int:
        return sys.getsizeof(tuple_list)
  original_instructions: |-
    find the size in bytes of the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate and return the sum of the minimum and maximum elements in the array instead of their difference.
  id: |-
    hubedit_mbpp_py_145
  lang: |-
    python
  modified_code: |-
    def main(arr: list) -> int:
        n = len(arr)
        minEle = arr[0]
        maxEle = arr[0]
        for i in range(1, n):
            minEle = min(minEle, arr[i])
            maxEle = max(maxEle, arr[i])
        return minEle + maxEle
  original_code: "def main(arr: list) -> int:\n    n = len(arr)\n    minEle = arr[0]\n\
    \    maxEle = arr[0]\n    for i in range(1, n):\n        minEle = min(minEle,\
    \ arr[i])\n        maxEle = max(maxEle, arr[i])\n    return (maxEle - minEle) "
  original_instructions: |-
    find the maximum difference between any two elements in a given array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to accept an additional parameter that specifies the animal type (e.g., "dog" or "cat"), and adjust the age calculation formula based on the animal type, using different multipliers or base values for each type.
  id: |-
    hubedit_mbpp_py_264
  lang: |-
    python
  modified_code: |-
    def main(h_age: float, animal_type: str) -> float:
        if h_age < 0:
            exit()

        if animal_type.lower() == "dog":
            if h_age <= 2:
                d_age = h_age * 10.5
            else:
                d_age = 21 + (h_age - 2) * 4
        elif animal_type.lower() == "cat":
            if h_age <= 2:
                d_age = h_age * 12.5
            else:
                d_age = 25 + (h_age - 2) * 4
        else:
            raise ValueError("Unsupported animal type")

        return d_age
  original_code: |-
    def main(h_age: float) -> float:
        if h_age < 0:
            exit()
        elif h_age <= 2:
            d_age = h_age * 10.5
        else:
            d_age = 21 + (h_age - 2) * 4
        return d_age
  original_instructions: |-
    calculate a dog's age in dog's years
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the product of all values in the dictionary instead of their sum.
  id: |-
    hubedit_mbpp_py_796
  lang: |-
    python
  modified_code: |-
    def main(dict: dict[int, int]) -> int:
      product = 1
      for i in dict.values():
        product *= i
      return product
  original_code: |-
    def main(dict: dict[int, int]) -> int:
      sum = 0
      for i in dict.values():
        sum = sum + i
      return sum
  original_instructions: |-
    Write function to find the sum of all items in the given dictionary
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the remainder of the division instead of the quotient.
  id: |-
    hubedit_mbpp_py_292
  lang: |-
    python
  modified_code: |-
    def main(n: int, m: int) -> int:
        remainder = n % m
        return remainder
  original_code: |-
    def main(n: int, m: int) -> int:
        q = n // m
        return q
  original_instructions: |-
    find quotient of two numbers (rounded down to the nearest integer)
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the factorial of the number instead of the sum and average, and return the factorial.
  id: |-
    hubedit_mbpp_py_599
  lang: |-
    python
  modified_code: |-
    def main(number: int) -> int:
        factorial = 1
        for value in range(1, number + 1):
            factorial *= value
        return factorial
  original_code: |-
    def main(number: int) -> tuple:
        total = 0
        for value in range(1, number + 1):
            total = total + value
        average = total / number
        return (total, average)
  original_instructions: |-
    find sum and average of first n natural numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the script to perform a bubble sort instead of the current sorting algorithm by repeatedly swapping adjacent elements if they are in the wrong order.
  id: |-
    hubedit_mbpp_py_141
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        arr_len = len(nums)
        for i in range(arr_len):
            for j in range(0, arr_len-i-1):
                if nums[j] > nums[j+1]:
                    nums[j], nums[j+1] = nums[j+1], nums[j]
        return nums
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        arr_len = len(nums)
        while arr_len > 1:
            mi = nums.index(max(nums[0:arr_len]))
            nums = nums[mi::-1] + nums[mi+1:len(nums)]
            nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]
            arr_len -= 1
        return nums
  original_instructions: |-
    sort a list of elements
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to remove an element from the list at index m instead of appending a new element n.
  id: |-
    hubedit_mbpp_py_307
  lang: |-
    python
  modified_code: |-
    from copy import deepcopy
    from typing import Tuple, List, Any

    def main(tuplex: Tuple[List[Any], ...], m: int, n: Any) -> Tuple[List[Any], ...]:
        tuplex_colon = deepcopy(tuplex)
        if n in tuplex_colon[m]:
            tuplex_colon[m].remove(n)
        return tuplex_colon
  original_code: |-
    from copy import deepcopy
    from typing import Tuple, List, Any

    def main(tuplex: Tuple[List[Any], ...], m: int, n: Any) -> Tuple[List[Any], ...]:
        tuplex_colon = deepcopy(tuplex)
        tuplex_colon[m].append(n)
        return tuplex_colon
  original_instructions: |-
    get a colon of a tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the order of the elements in the list before adding the string and converting it to a tuple.
  id: |-
    hubedit_mbpp_py_788
  lang: |-
    python
  modified_code: |-
    def main(test_list: list, test_str: str) -> tuple:
      return tuple(reversed(test_list) + [test_str])
  original_code: |-
    def main(test_list: list, test_str: str) -> tuple:
      return tuple(test_list + [test_str])
  original_instructions: |-
    create a new tuple from the given string and list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to sort the resulting tuple in ascending order before returning it.
  id: |-
    hubedit_mbpp_py_106
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple

    def main(test_list: List, test_tup: Tuple) -> Tuple:
        res = tuple(sorted(list(test_tup) + test_list))
        return res
  original_code: |-
    from typing import List, Tuple

    def main(test_list: List, test_tup: Tuple) -> Tuple:
        res = tuple(list(test_tup) + test_list)
        return res
  original_instructions: |-
    append the given list to the given tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if all even-indexed elements are even and all odd-indexed elements are odd, instead of checking if the element's parity matches its index's parity.
  id: |-
    hubedit_mbpp_py_775
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[int]) -> bool:
        return all(nums[i] % 2 == 0 if i % 2 == 0 else nums[i] % 2 == 1 for i in range(len(nums)))
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> bool:
        return all(nums[i] % 2 == i % 2 for i in range(len(nums)))
  original_instructions: |-
    check whether every odd index contains odd numbers of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a tuple containing the squares of the original tuple's elements instead of the pairwise sums.
  id: |-
    hubedit_mbpp_py_470
  lang: |-
    python
  modified_code: |-
    def main(test_tup: tuple[int, ...]) -> tuple[int, ...]:
        res = tuple(i ** 2 for i in test_tup)
        return res
  original_code: |-
    def main(test_tup: tuple[int, ...]) -> tuple[int, ...]:
        res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))
        return res
  original_instructions: |-
    find the pairwise addition of the neighboring elements of the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of tuples, where each tuple contains a perfect square from the range and its square root.
  id: |-
    hubedit_mbpp_py_589
  lang: |-
    python
  modified_code: |-
    def main(a: int, b: int) -> list:
        lists = []
        for i in range(a, b+1):
            j = 1
            while j*j <= i:
                if j*j == i:
                    lists.append((i, j))
                j = j+1
        return lists
  original_code: |-
    def main(a: int, b: int) -> list:
        lists = []
        for i in range(a, b+1):
            j = 1
            while j*j <= i:
                if j*j == i:
                    lists.append(i)
                j = j+1
        return lists
  original_instructions: |-
    find perfect squares between two given numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to cache the results of previous computations using a dictionary to avoid redundant calculations and improve performance.
  id: |-
    hubedit_mbpp_py_389
  lang: |-
    python
  modified_code: |-
    def main(n: int, cache: dict = None) -> int:
        if cache is None:
            cache = {0: 2, 1: 1}
        if n in cache:
            return cache[n]
        cache[n] = main(n - 1, cache) + main(n - 2, cache)
        return cache[n]
  original_code: "def main(n: int) -> int:\n    if (n == 0):\n        return 2\n \
    \   if (n == 1):\n        return 1\n    return main(n - 1) + main(n - 2) "
  original_instructions: |-
    find the n'th lucas number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to replace each vowel in the input string with the next vowel in the sequence 'aeiou' (cyclically, so after 'u' comes 'a'), while keeping the case of the original vowel (uppercase remains uppercase, lowercase remains lowercase).
  id: |-
    hubedit_mbpp_py_131
  lang: |-
    python
  modified_code: |-
    def main(str1: str) -> str:
        vowel_sequence = "aeiou"
        result_string = ""
        for char in str1:
            if char.lower() in vowel_sequence:
                # Find the index of the current vowel in the sequence
                index = vowel_sequence.find(char.lower())
                # Get the next vowel in the sequence, wrapping around if necessary
                next_vowel = vowel_sequence[(index + 1) % len(vowel_sequence)]
                # Preserve the case of the original vowel
                result_string += next_vowel.upper() if char.isupper() else next_vowel
            else:
                result_string += char
        return result_string
  original_code: |-
    def main(str1: str) -> str:
        vowels = ""
        for char in str1:
            if char in "aeiouAEIOU":
                vowels += char
        result_string = ""
        for char in str1:
            if char in "aeiouAEIOU":
                result_string += vowels[-1]
                vowels = vowels[:-1]
            else:
                result_string += char
        return result_string
  original_instructions: |-
    reverse only the vowels of a given string (where y is not a vowel)
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to sum up only the odd-indexed elements of the array that are also odd numbers.
  id: |-
    hubedit_mbpp_py_270
  lang: |-
    python
  modified_code: |-
    def main(arr: list[int]) -> int:
        sum = 0
        for i in range(1, len(arr), 2):
            if (arr[i] % 2 != 0):
                sum += arr[i]
        return sum
  original_code: |-
    def main(arr: list[int]) -> int:
        sum = 0
        for i in range(0, len(arr), 2):
            if (arr[i] % 2 == 0):
                sum += arr[i]
        return sum
  original_instructions: |-
    find the sum of even numbers at even positions of a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the recurrence relation so that each term is the sum of the previous three terms instead of the sum of the previous term and twice the term before that.
  id: |-
    hubedit_mbpp_py_752
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n < 3:
            return n
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n+1):
            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
        return dp[n]
  original_code: |-
    def main(n: int) -> int:
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i - 1] + 2 * dp[i - 2]
        return dp[n]
  original_instructions: |-
    find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ..
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the minimum length of the elements in the list and the element with the minimum length instead of the maximum.
  id: |-
    hubedit_mbpp_py_290
  lang: |-
    python
  modified_code: |-
    from typing import List, Any, Tuple

    def main(list1: List[Any]) -> Tuple[int, Any]:
        min_value = min(len(x) for x in list1)
        min_list = min(list1, key=len)
        return (min_value, min_list)
  original_code: |-
    from typing import List, Any, Tuple

    def main(list1: List[Any]) -> Tuple[int, Any]:
        main_value = max(len(x) for x in list1)
        max_list = max(list1, key=len)
        return (main_value, max_list)
  original_instructions: |-
    find the list of maximum length in a list of lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the lambda function to calculate the square of each number instead of the cube.
  id: |-
    hubedit_mbpp_py_447
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        main = list(map(lambda x: x ** 2, nums))
        return main
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        main = list(map(lambda x: x ** 3, nums))
        return main
  original_instructions: |-
    find cubes of individual elements in a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the percentage of negative numbers in the array instead of positive numbers.
  id: |-
    hubedit_mbpp_py_442
  lang: |-
    python
  modified_code: |-
    from array import array
    def main(nums: array) -> float:
        n = len(nums)
        n_neg = 0
        for x in nums:
            if x < 0:
                n_neg += 1
        return round(n_neg/n, 2)
  original_code: |-
    from array import array
    def main(nums: array) -> float:
        n = len(nums)
        n1 = 0
        for x in nums:
            if x > 0:
                n1 += 1
            else:
              None
        return round(n1/n,2)
  original_instructions: |-
    find the ration of positive numbers in an array of integers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return both the maximum subarray sum and the start and end indices of the subarray within the original array, even when the array is traversed multiple times due to the k factor.
  id: |-
    hubedit_mbpp_py_286
  lang: |-
    python
  modified_code: |-
    def main(a: list, n: int, k: int) -> tuple:
        max_so_far = -2147483648
        max_ending_here = 0
        start = 0
        end = 0
        s = 0
        total_sum = sum(a)

        # If k is more than 1 and total sum of array is positive, we can add (k-2)*total_sum to max subarray sum
        # because we can take the whole array sum for (k-2) times in between the first and the last traversal
        extra = (k - 2) * total_sum if k > 1 and total_sum > 0 else 0

        for i in range(min(n*k, n*2)):  # We only need to traverse the array at most twice
            max_ending_here += a[i % n]

            if max_so_far < max_ending_here:
                max_so_far = max_ending_here
                start = s
                end = i % n

            if max_ending_here < 0:
                max_ending_here = 0
                s = (i % n) + 1

        return max_so_far + extra, start, end
  original_code: |-
    def main(a: list, n: int, k: int) -> int:
        max_so_far = -2147483648
        max_ending_here = 0
        for i in range(n*k):
            max_ending_here = max_ending_here + a[i % n]
            if (max_so_far < max_ending_here):
                max_so_far = max_ending_here
            if (max_ending_here < 0):
                max_ending_here = 0
        return max_so_far
  original_instructions: |-
    find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the count of words with an even number of characters instead of checking for words with an odd number of characters.
  id: |-
    hubedit_mbpp_py_79
  lang: |-
    python
  modified_code: |-
    def main(s: str) -> int:
        words = s.split(' ')
        even_count = 0
        for word in words:
            if len(word) % 2 == 0:
                even_count += 1
        return even_count
  original_code: |-
    def main(s: str) -> bool:
        words = s.split(' ')
        for word in words:
            if len(word) % 2 != 0:
                return True
        return False  # Moved outside the loop to check all words before returning False
  original_instructions: |-
    check whether the length of the word is odd or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a new dictionary that includes only the items where the value is of type `int`.
  id: |-
    hubedit_mbpp_py_465
  lang: |-
    python
  modified_code: |-
    def main(dict1: dict) -> dict:
      dict1 = {key: value for (key, value) in dict1.items() if isinstance(value, int)}
      return dict1
  original_code: |-
    def main(dict1: dict) -> dict:
      dict1 = {key: value for (key, value) in dict1.items() if value is not None}
      return dict1
  original_instructions: |-
    drop empty items from a given dictionary
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list of strings where each string is converted to uppercase instead of being reversed.
  id: |-
    hubedit_mbpp_py_456
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(stringlist: List[str]) -> List[str]:
        result = [x.upper() for x in stringlist]
        return result
  original_code: |-
    from typing import List

    def main(stringlist: List[str]) -> List[str]:
        result = [x[::-1] for x in stringlist]
        return result
  original_instructions: |-
    reverse each string in a given list of string values
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the volume of a sphere instead of the surface area.
  id: |-
    hubedit_mbpp_py_85
  lang: |-
    python
  modified_code: |-
    import math
    def main(r: float) -> float:
      volume = (4/3) * math.pi * r**3
      return volume
  original_code: |-
    import math
    def main(r: float) -> float:
      surfacearea = 4 * math.pi * r * r
      return surfacearea
  original_instructions: |-
    find the surface area of a sphere
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the surface area of the cylinder instead of the volume.
  id: |-
    hubedit_mbpp_py_276
  lang: |-
    python
  modified_code: |-
    def main(r: float, h: float) -> float:
      surface_area = 2 * 3.1415 * r * (r + h)
      return surface_area
  original_code: |-
    def main(r: float, h: float) -> float:
      volume = 3.1415 * r * r * h
      return volume
  original_instructions: |-
    takes in the radius and height of a cylinder and returns the the volume
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the product of the unique elements in the array instead of their sum.
  id: |-
    hubedit_mbpp_py_777
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        arr.sort()
        product = arr[0]
        for i in range(len(arr)-1):
            if (arr[i] != arr[i+1]):
                product *= arr[i+1]
        return product
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        arr.sort()
        sum = arr[0]
        for i in range(len(arr)-1):
            if (arr[i] != arr[i+1]):
                sum = sum + arr[i+1]
        return sum
  original_instructions: |-
    find the sum of non-repeated elements in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list of even numbers instead of odd numbers by checking if each number is divisible by 2 without a remainder.
  id: |-
    hubedit_mbpp_py_554
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(numbers: List[int]) -> List[int]:
        ev_li = []
        for i in numbers:
            if (i % 2 == 0):
                ev_li.append(i)
        return ev_li
  original_code: |-
    from typing import List

    def main(numbers: List[int]) -> List[int]:
        od_li = []
        for i in numbers:
            if (i % 2 != 0):
                od_li.append(i)
        return od_li
  original_instructions: |-
    Write a python function which takes a list of integers and only returns the odd ones
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the factorial of the given number instead of the current recursive sum.
  id: |-
    hubedit_mbpp_py_248
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n <= 1:
            return 1
        else:
            return n * main(n - 1)
  original_code: |-
    def main(n: int) -> float:
        if n < 2:
            return 1.0
        else:
            return 1 / n + (main(n - 1))
  original_instructions: |-
    takes in an integer n and calculates the harmonic sum of n-1
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of elements in the list that start with an uppercase letter and have all remaining letters in lowercase, instead of returning the length of the concatenated string of such elements.
  id: |-
    hubedit_mbpp_py_639
  lang: |-
    python
  modified_code: |-
    def main(maines: list) -> int:
      maines = list(filter(lambda el: el[0].isupper() and el[1:].islower(), maines))
      return len(maines)
  original_code: |-
    def main(maines: list) -> int:
      maines = list(filter(lambda el: el[0].isupper() and el[1:].islower(), maines))
      return len(''.join(maines))
  original_instructions: |-
    sum the length of the names of a given list of names after removing the names that start with a lowercase letter
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to sort the numbers in descending order instead of ascending order by changing the comparison condition from `if nums[i] > nums[i+gaps]` to `if nums[i] < nums[i+gaps]`.
  id: |-
    hubedit_mbpp_py_71
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[float]) -> List[float]:
        shrink_fact = 1.3
        gaps = len(nums)
        swapped = True
        i = 0
        while gaps > 1 or swapped:
            gaps = int(float(gaps) / shrink_fact)
            swapped = False
            i = 0
            while gaps + i < len(nums):
                if nums[i] < nums[i+gaps]:
                    nums[i], nums[i+gaps] = nums[i+gaps], nums[i]
                    swapped = True
                i += 1
        return nums
  original_code: |-
    from typing import List

    def main(nums: List[float]) -> List[float]:
        shrink_fact = 1.3
        gaps = len(nums)
        swapped = True
        i = 0
        while gaps > 1 or swapped:
            gaps = int(float(gaps) / shrink_fact)
            swapped = False
            i = 0
            while gaps + i < len(nums):
                if nums[i] > nums[i+gaps]:
                    nums[i], nums[i+gaps] = nums[i+gaps], nums[i]
                    swapped = True
                i += 1
        return nums
  original_instructions: |-
    sort a list of elements
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a tuple of tuples containing the element-wise minimum instead of the maximum between the two input tuples.
  id: |-
    hubedit_mbpp_py_259
  lang: |-
    python
  modified_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(min(a, b) for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup2))
        return res
  original_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    maximize the given two tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to merge the dictionaries such that the values from `dict1` take precedence over those in `dict2` and `dict3`, and values from `dict2` take precedence over those in `dict3`.
  id: |-
    hubedit_mbpp_py_87
  lang: |-
    python
  modified_code: |-
    import collections as ct
    from typing import Dict, Any

    def main(dict1: Dict[Any, Any], dict2: Dict[Any, Any], dict3: Dict[Any, Any]) -> Dict[Any, Any]:
        merged_dict = dict(ct.ChainMap(dict1, dict2, dict3))
        return merged_dict
  original_code: |-
    import collections as ct
    from typing import Dict, Any

    def main(dict1: Dict[Any, Any], dict2: Dict[Any, Any], dict3: Dict[Any, Any]) -> Dict[Any, Any]:
        merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))
        return merged_dict
  original_instructions: |-
    merge three dictionaries into a single dictionary
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to memoize previously computed results to optimize the recursive calls and prevent redundant calculations.
  id: |-
    hubedit_mbpp_py_260
  lang: |-
    python
  modified_code: |-
    def main(n: int, memo=None) -> int:
        if memo is None:
            memo = {}
        if n in memo:
            return memo[n]
        if n == 0 or n == 1:
            memo[n] = 1
            return 1
        memo[n] = 2 * main(n - 1, memo) + main(n - 2, memo)
        return memo[n]
  original_code: |-
    def main(n: int) -> int:
        if n == 0 or n == 1:
            return 1
        return 2 * main(n - 1) + main(n - 2)
  original_instructions: "find the nth newman\u2013shanks\u2013williams prime number"
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of tuples, where each tuple contains a unique number from the input list and its corresponding count in the list.
  id: |-
    hubedit_mbpp_py_572
  lang: |-
    python
  modified_code: |-
    from typing import List
    from collections import Counter

    def main(nums: List[int]) -> List[(int, int)]:
        counts = Counter(nums)
        return list(counts.items())
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        return [i for i in nums if nums.count(i) == 1]
  original_instructions: |-
    remove duplicate numbers from a given number of lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the sum of the divisors of `n` instead of their count.
  id: |-
    hubedit_mbpp_py_96
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        return sum([i for i in range(1, n+1) if n % i == 0])
  original_code: |-
    def main(n: int) -> int:
        return len([i for i in range(1, n+1) if n % i == 0])
  original_instructions: |-
    find the number of divisors of a given integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all unique elements in the array instead of the XOR of all elements.
  id: |-
    hubedit_mbpp_py_119
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        unique_elements = set(arr)
        return sum(unique_elements)
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        n = len(arr)
        XOR = 0
        for i in range(n):
            XOR = XOR ^ arr[i]
        return XOR
  original_instructions: |-
    find the element that appears only once in a sorted array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the median of the combined array when the total number of elements in both arrays is odd by adjusting the count condition and the return statement.
  id: |-
    hubedit_mbpp_py_622
  lang: |-
    python
  modified_code: |-
    def main(arr1: list, arr2: list, n: int) -> float:
      i = 0
      j = 0
      m1 = -1
      count = 0
      while count < n:
        count += 1
        if i == n:
          m1 = arr2[0]
          break
        elif j == n:
          m1 = arr1[0]
          break
        if arr1[i] <= arr2[j]:
          m1 = arr1[i]
          i += 1
        else:
          m1 = arr2[j]
          j += 1
      return m1
  original_code: |-
    def main(arr1: list, arr2: list, n: int) -> float:
      i = 0
      j = 0
      m1 = -1
      m2 = -1
      count = 0
      while count < n + 1:
        count += 1
        if i == n:
          m1 = m2
          m2 = arr2[0]
          break
        elif j == n:
          m1 = m2
          m2 = arr1[0]
          break
        if arr1[i] <= arr2[j]:
          m1 = m2
          m2 = arr1[i]
          i += 1
        else:
          m1 = m2
          m2 = arr2[j]
          j += 1
      return (m1 + m2)/2
  original_instructions: |-
    find the median of two sorted lists of same size
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the index of the first occurrence of x in the list a instead of the count of x's occurrences.
  id: |-
    hubedit_mbpp_py_168
  lang: |-
    python
  modified_code: |-
    def main(a: list, x: int) -> int:
        for i in range(len(a)):
            if a[i] == x:
                return i
        return -1  # Return -1 if x is not found
  original_code: "def main(a: list, x: int) -> int:\n    count = 0\n    for i in a:\n\
    \      if i == x:\n        count += 1\n\n    return count "
  original_instructions: |-
    count the number of occurrences of a number in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the list A is a palindrome, meaning it reads the same forward and backward.
  id: |-
    hubedit_mbpp_py_68
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(A: List[int]) -> bool:
        return A == A[::-1]
  original_code: "from typing import List\n\ndef main(A: List[int]) -> bool:\n   \
    \ return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i]\
    \ >= A[i + 1] for i in range(len(A) - 1))) "
  original_instructions: |-
    check whether the given array is monotonic or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to calculate the circumference of a circle instead of the area by using the formula 2 * pi * r.
  id: |-
    hubedit_mbpp_py_626
  lang: |-
    python
  modified_code: |-
    import math

    def main(r: float) -> float:
        if r < 0:
            return None
        return 2 * math.pi * r
  original_code: "def main(r: float) -> float:\n    if r < 0 :\n        return None\n\
    \    return r * r "
  original_instructions: |-
    find the area of the largest triangle that can be inscribed in a semicircle with a given radius
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to create a dictionary where the keys are the even-indexed elements and the values are the subsequent odd-indexed elements, instead of creating pairs from consecutive elements.
  id: |-
    hubedit_mbpp_py_740
  lang: |-
    python
  modified_code: |-
    from typing import Tuple, Any, Dict

    def main(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:
        res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup) - 1, 2)}
        return res
  original_code: |-
    from typing import Tuple, Any, Dict

    def main(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:
        res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))
        return res
  original_instructions: |-
    convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to filter out any tuples where the first element is not a string or the second element is not a float, instead of converting them.
  id: |-
    hubedit_mbpp_py_117
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple, Union

    def main(test_list: List[Tuple[Union[str, float], Union[str, float]]]) -> List[Tuple[str, float]]:
      res = []
      for tup in test_list:
        if isinstance(tup[0], str) and isinstance(tup[1], float):
          res.append((tup[0], tup[1]))
      return res
  original_code: |-
    from typing import List, Tuple, Union

    def main(test_list: List[Tuple[Union[str, float], Union[str, float]]]) -> List[Tuple[str, float]]:
      res = []
      for tup in test_list:
        temp = []
        for ele in tup:
          if isinstance(ele, str) and ele.isalpha():
            temp.append(ele)
          else:
            temp.append(float(ele))
        res.append((temp[0], temp[1]))
      return res
  original_instructions: |-
    convert all possible convertible elements in a list of lists to floats
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the hexadecimal representation of the integer instead of the binary representation.
  id: |-
    hubedit_mbpp_py_99
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> str:
        return hex(n).replace("0x", "")
  original_code: "def main(n: int) -> str:\n    return bin(n).replace(\"0b\",\"\"\
    ) "
  original_instructions: |-
    convert the given decimal number to its binary equivalent, represented as a string with no leading zeros
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the minimum path sum instead of the maximum by modifying the max function to min in the nested loop.
  id: |-
    hubedit_mbpp_py_721
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(cost: List[List[int]]) -> float:
      N = len(cost)
      dp = [[0 for i in range(N + 1)] for j in range(N + 1)]
      dp[0][0] = cost[0][0]
      for i in range(1, N):
        dp[i][0] = dp[i - 1][0] + cost[i][0]
      for j in range(1, N):
        dp[0][j] = dp[0][j - 1] + cost[0][j]
      for i in range(1, N):
        for j in range(1, N):
          dp[i][j] = min(dp[i - 1][j],
                         dp[i][j - 1]) + cost[i][j]
      return dp[N - 1][N - 1] / (2 * N - 1)
  original_code: |-
    from typing import List

    def main(cost: List[List[int]]) -> float:
      N = len(cost)
      dp = [[0 for i in range(N + 1)] for j in range(N + 1)]
      dp[0][0] = cost[0][0]
      for i in range(1, N):
        dp[i][0] = dp[i - 1][0] + cost[i][0]
      for j in range(1, N):
        dp[0][j] = dp[0][j - 1] + cost[0][j]
      for i in range(1, N):
        for j in range(1, N):
          dp[i][j] = max(dp[i - 1][j],
                         dp[i][j - 1]) + cost[i][j]
      return dp[N - 1][N - 1] / (2 * N - 1)
  original_instructions: |-
    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the count of set bits (1s) in the binary representation of the input number x instead of returning a boolean value.
  id: |-
    hubedit_mbpp_py_406
  lang: |-
    python
  modified_code: |-
    def main(x: int) -> int:
        count = 0
        while x:
            count += x & 1
            x >>= 1
        return count
  original_code: |-
    def main(x: int) -> bool:
        y = x ^ (x >> 1)
        y = y ^ (y >> 2)
        y = y ^ (y >> 4)
        y = y ^ (y >> 8)
        y = y ^ (y >> 16)
        if (y & 1):
            return True
        return False
  original_instructions: |-
    find whether the parity of a given number is odd
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to sort the array in such a way that all the positive numbers are at the beginning and the negative numbers are at the end, while maintaining the relative order of the positive numbers.
  id: |-
    hubedit_mbpp_py_229
  lang: |-
    python
  modified_code: |-
    def main(arr: list, n: int) -> list:
        positive = [num for num in arr if num >= 0]
        negative = [num for num in arr if num < 0]
        return positive + negative
  original_code: |-
    def main(arr: list, n: int) -> list:
      j = 0
      for i in range(0, n):
        if (arr[i] < 0):
          temp = arr[i]
          arr[i] = arr[j]
          arr[j] = temp
          j = j + 1
      return arr
  original_instructions: |-
    takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if each pattern is associated with exactly one color, but allow multiple patterns to be associated with the same color.
  id: |-
    hubedit_mbpp_py_74
  lang: |-
    python
  modified_code: |-
    def main(colors: list, patterns: list) -> bool:
        if len(colors) != len(patterns):
            return False
        sdict = {}
        for i in range(len(patterns)):
            if patterns[i] in sdict and sdict[patterns[i]] != colors[i]:
                return False
            sdict[patterns[i]] = colors[i]
        return True
  original_code: |-
    def main(colors: list, patterns: list) -> bool:
        if len(colors) != len(patterns):
            return False
        sdict = {}
        pset = set()
        sset = set()
        for i in range(len(patterns)):
            pset.add(patterns[i])
            sset.add(colors[i])
            if patterns[i] not in sdict:
                sdict[patterns[i]] = []

            keys = sdict[patterns[i]]
            keys.append(colors[i])

        if len(pset) != len(sset):
            return False

        for values in sdict.values():
            for i in range(len(values) - 1):
                if values[i] != values[i+1]:
                    return False

        return True
  original_instructions: |-
    check whether it follows the sequence given in the patterns array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the least common multiples (LCM) of all pairs of integers from 1 to min(a, b) instead of the sum of common divisors.
  id: |-
    hubedit_mbpp_py_126
  lang: |-
    python
  modified_code: |-
    def gcd(x: int, y: int) -> int:
        while y:
            x, y = y, x % y
        return x

    def lcm(x: int, y: int) -> int:
        return x * y // gcd(x, y)

    def main(a: int, b: int) -> int:
        main_result = 0
        for i in range(1, min(a, b) + 1):
            main_result += lcm(i, a) + lcm(i, b)
        return main_result
  original_code: |-
    def main(a: int, b: int) -> int:
        main_result = 0
        for i in range(1, min(a, b) + 1):
            if (a % i == 0 and b % i == 0):
                main_result += i
        return main_result
  original_instructions: |-
    find the sum of common divisors of two given numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a tuple of the sums of each pair of consecutive numbers in the input string.
  id: |-
    hubedit_mbpp_py_785
  lang: |-
    python
  modified_code: |-
    def main(test_str: str) -> tuple:
        numbers = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))
        return tuple(numbers[i] + numbers[i+1] for i in range(len(numbers) - 1))
  original_code: |-
    def main(test_str: str) -> tuple:
        res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))
        return res
  original_instructions: |-
    convert tuple string to integer tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return True if the dictionary contains at least one key-value pair, and False if it is empty.
  id: |-
    hubedit_mbpp_py_582
  lang: |-
    python
  modified_code: |-
    def main(dict1: dict) -> bool:
        return bool(dict1)
  original_code: |-
    def main(dict1: dict) -> bool:
      if bool(dict1):
         return False
      else:
         return True
  original_instructions: |-
    check if a dictionary is empty
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the symmetric difference of the sets instead of the intersection, which will give you the elements that are in either of the two sets but not in both.
  id: |-
    hubedit_mbpp_py_473
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple, Set

    def main(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:
        res = set([tuple(sorted(ele)) for ele in test_list1]) ^ set([tuple(sorted(ele)) for ele in test_list2])
        return res
  original_code: |-
    from typing import List, Tuple, Set

    def main(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:
        res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])
        return res
  original_instructions: |-
    find the tuple intersection of elements in the given tuple list irrespective of their order
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the number that appears the least frequently instead of the most frequently.
  id: |-
    hubedit_mbpp_py_130
  lang: |-
    python
  modified_code: |-
    from collections import defaultdict
    from typing import List

    def main(nums: List[int]) -> int:
        dict = defaultdict(int)
        for i in nums:
            dict[i] += 1
        result = min(dict.items(), key=lambda x: x[1])
        return result[0]
  original_code: |-
    from collections import defaultdict
    from typing import List

    def main(nums: List[int]) -> int:
        dict = defaultdict(int)
        for i in nums:
            dict[i] += 1
        result = max(dict.items(), key=lambda x: x[1])
        return result[0]
  original_instructions: |-
    find the item with maximum frequency in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to create a list of dictionaries where each dictionary contains keys from l1 with corresponding values being lists that combine elements from l2 and l3 at the same index.
  id: |-
    hubedit_mbpp_py_391
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(l1: List[Any], l2: List[Any], l3: List[Any]) -> List[dict]:
        result = [{x: [y, z]} for (x, y, z) in zip(l1, l2, l3)]
        return result
  original_code: |-
    from typing import List, Any

    def main(l1: List[Any], l2: List[Any], l3: List[Any]) -> List[dict]:
         result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]
         return result
  original_instructions: |-
    convert more than one list to nested dictionary
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the first even and the first odd number from the list instead of their difference.
  id: |-
    hubedit_mbpp_py_594
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(list1: List[int]) -> int:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even + first_odd
  original_code: |-
    from typing import List

    def main(list1: List[int]) -> int:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even - first_odd
  original_instructions: |-
    find the difference of the first even and first odd number of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the regular expression pattern to allow for numbers at the end of the string, after the underscore.
  id: |-
    hubedit_mbpp_py_16
  lang: |-
    python
  modified_code: |-
    import re
    def main(text: str) -> bool:
            patterns = '^[a-z]+_[a-z0-9]+$'
            if re.search(patterns,  text):
                    return True
            else:
                    return False
  original_code: |-
    import re
    def main(text: str) -> bool:
            patterns = '^[a-z]+_[a-z]+$'
            if re.search(patterns,  text):
                    return True
            else:
                    return False
  original_instructions: |-
    that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the digits in the tuple instead of concatenating them into a single integer.
  id: |-
    hubedit_mbpp_py_116
  lang: |-
    python
  modified_code: |-
    def main(nums: tuple) -> int:
        result = sum(nums)
        return result
  original_code: |-
    def main(nums: tuple) -> int:
        result = int(''.join(map(str, nums)))
        return result
  original_instructions: |-
    convert a given tuple of positive integers into a single integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the regular expression pattern to match strings that contain at least two 'z' characters separated by three letters.
  id: |-
    hubedit_mbpp_py_454
  lang: |-
    python
  modified_code: |-
    import re
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        patterns = 'z\w{3}z'
        if re.search(patterns, text):
            return True
        else:
            return False
  original_code: |-
    import re
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        patterns = '\w*z.\w*'
        if re.search(patterns, text):
            return True
        else:
            return False
  original_instructions: |-
    matches a word containing 'z'
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the differences between each pair of consecutive elements in the list.
  id: |-
    hubedit_mbpp_py_588
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[int]) -> int:
        return sum(abs(nums[i] - nums[i-1]) for i in range(1, len(nums)))
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> int:
        diff = max(nums) - min(nums)
        return diff
  original_instructions: |-
    find the difference between largest and smallest value in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return True if all dictionaries in the list have at least one key-value pair, and False otherwise.
  id: |-
    hubedit_mbpp_py_115
  lang: |-
    python
  modified_code: |-
    from typing import List, Dict

    def main(list1: List[Dict]) -> bool:
        return all(d for d in list1)
  original_code: |-
    from typing import List, Dict

    def main(list1: List[Dict]) -> bool:
        main = all(not d for d in list1)
        return main
  original_instructions: |-
    check whether all dictionaries in a list are empty or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to shuffle the remaining elements of the list after removing the element at index L.
  id: |-
    hubedit_mbpp_py_610
  lang: |-
    python
  modified_code: |-
    import random

    def main(list1: list, L: int) -> list:
        new_list = list1[:L-1] + list1[L:]
        random.shuffle(new_list)
        return new_list
  original_code: |-
    def main(list1: list, L: int) -> list:
        return list1[:L-1] + list1[L:]
  original_instructions: |-
    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the length of the longest substring that is the same when read forwards and backwards (a palindrome).
  id: |-
    hubedit_mbpp_py_9
  lang: |-
    python
  modified_code: |-
    def main(s: str) -> int:
        def expand_around_center(left: int, right: int) -> int:
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return right - left - 1

        if len(s) == 0:
            return 0

        max_length = 1
        for i in range(len(s)):
            len1 = expand_around_center(i, i)
            len2 = expand_around_center(i, i + 1)
            max_length = max(max_length, len1, len2)
        return max_length
  original_code: "def main(str: str) -> int:\n    tmp = str + str\n    n = len(str)\n\
    \    for i in range(1, n + 1):\n        substring = tmp[i: i + n]\n        if\
    \ (str == substring):\n            return i\n    return n "
  original_instructions: |-
    find the minimum number of rotations (greater than 0) required to get the same string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the largest power of 2 that is less than or equal to the given number n, instead of the smallest power of 2 that is greater than or equal to n.
  id: |-
    hubedit_mbpp_py_167
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n == 0:
            return 0

        n |= (n >> 1)
        n |= (n >> 2)
        n |= (n >> 4)
        n |= (n >> 8)
        n |= (n >> 16)
        n |= (n >> 32)  # This line is for the case when n is a 64-bit integer

        return (n + 1) >> 1
  original_code: |-
    def main(n: int) -> int:
      if n and not n & (n - 1):
        return n

      count = 0
      while n != 0:
        n >>= 1
        count += 1

      return 1 << count
  original_instructions: |-
    find the smallest power of 2 greater than or equal to n
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the product of all elements in the array instead of the current computation.
  id: |-
    hubedit_mbpp_py_734
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        product = 1
        for num in arr:
            product *= num
        return product
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        ans = 0
        res = 0
        i = len(arr) - 1
        while (i >= 0):
            incr = arr[i]*(1 + res)
            ans += incr
            res = incr
            i -= 1
        return ans
  original_instructions: |-
    find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the occurrences of each first element in the tuples and return a list of tuples with the first element and its count.
  id: |-
    hubedit_mbpp_py_417
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple, Dict, Any

    def main(Input: List[Tuple[Any, ...]]) -> List[Tuple[Any, int]]:
        out: Dict[Any, int] = {}
        for elem in Input:
            if elem[0] in out:
                out[elem[0]] += 1
            else:
                out[elem[0]] = 1
        return [(key, count) for key, count in out.items()]

    # Example usage:
    # counts = main([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')])
    # print(counts)  # Output: [(1, 2), (2, 2)]
  original_code: |-
    from typing import List, Tuple, Dict, Any

    def main(Input: List[Tuple[Any, ...]]) -> List[Tuple[Any, ...]]:
        out: Dict[Any, List[Any]] = {}
        for elem in Input:
            try:
                out[elem[0]].extend(elem[1:])
            except KeyError:
                out[elem[0]] = list(elem[1:])  # Fixed to not include the key in the values list
        return [tuple([key] + values) for key, values in out.items()]  # Include the key in the tuple

    # Example usage:
    # grouped = main([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')])
    # print(grouped)  # Output: [(1, 'a', 'c'), (2, 'b', 'd')]
  original_instructions: |-
    find common first element in given list of tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the total surface area of a cylinder, including both the lateral surface and the areas of the top and bottom circles.
  id: |-
    hubedit_mbpp_py_233
  lang: |-
    python
  modified_code: |-
    def main(r: float, h: float) -> float:
        lateral_surface = 2 * 3.1415 * r * h
        base_area = 3.1415 * r * r
        total_surface_area = lateral_surface + 2 * base_area
        return total_surface_area
  original_code: |-
    def main(r: float, h: float) -> float:
        lateralsurface = 2 * 3.1415 * r * h
        return lateralsurface
  original_instructions: |-
    find the lateral surface area of a cylinder
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the absolute values of the products of the pairs instead of finding the maximum.
  id: |-
    hubedit_mbpp_py_120
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple

    def main(list1: List[Tuple[int, int]]) -> int:
        result_sum = sum([abs(x * y) for x, y in list1])
        return result_sum
  original_code: |-
    from typing import List, Tuple

    def main(list1: List[Tuple[int, int]]) -> int:
        result_max = max([abs(x * y) for x, y in list1])
        return result_max
  original_instructions: |-
    find the maximum absolute product between numbers in pairs of tuples within a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count only the vowels ('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u') that are at the correct index position according to their ASCII value.
  id: |-
    hubedit_mbpp_py_165
  lang: |-
    python
  modified_code: |-
    def main(str1: str) -> int:
        count_vowels = 0
        vowels = 'AEIOUaeiou'
        for i in range(len(str1)):
            if str1[i] in vowels:
                if ((i == ord(str1[i]) - ord('A')) or
                    (i == ord(str1[i]) - ord('a'))):
                    count_vowels += 1
        return count_vowels
  original_code: "def main(str1: str) -> int:\n    count_chars = 0\n    for i in range(len(str1)):\n\
    \        if ((i == ord(str1[i]) - ord('A')) or\n            (i == ord(str1[i])\
    \ - ord('a'))):\n            count_chars += 1\n    return count_chars "
  original_instructions: |-
    count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive)
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of words that are exactly n characters long, instead of words that are longer than n.
  id: |-
    hubedit_mbpp_py_128
  lang: |-
    python
  modified_code: |-
    def main(n: int, str: str) -> list:
        word_len = []
        txt = str.split(" ")
        for x in txt:
            if len(x) == n:
                word_len.append(x)
        return word_len
  original_code: |-
    def main(n: int, str: str) -> list:
        word_len = []
        txt = str.split(" ")
        for x in txt:
            if len(x) > n:
                word_len.append(x)
        return word_len
  original_instructions: |-
    find words that are longer than n characters from a given list of words
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to return a dictionary that maps each unique element in the tuple to the number of times it appears, instead of counting just one specific element.
  id: |-
    hubedit_mbpp_py_250
  lang: |-
    python
  modified_code: |-
    def main(tup: tuple) -> dict:
        count_dict = {}
        for ele in tup:
            if ele in count_dict:
                count_dict[ele] += 1
            else:
                count_dict[ele] = 1
        return count_dict
  original_code: "def main(tup: tuple, x: object) -> int:\n    count = 0\n    for\
    \ ele in tup:\n        if (ele == x):\n            count = count + 1\n    return\
    \ count "
  original_instructions: |-
    takes in a tuple and an element and counts the occcurences of the element in the tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check for perfect squares instead of prime numbers, returning True if the number is a perfect square and False otherwise.
  id: |-
    hubedit_mbpp_py_605
  lang: |-
    python
  modified_code: |-
    def main(num: int) -> bool:
        if num < 1:
            return False
        root = int(num**0.5)
        return num == root * root
  original_code: |-
    def main(num: int) -> bool:
        if num > 1:
            for i in range(2, num//2 + 1):
                if (num % i) == 0:
                    return False
            return True
        else:
            return False
  original_instructions: |-
    check if the given integer is a prime number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the entire alphabet string shifted by the sum calculated, wrapping around from 'z' to 'a' as necessary.
  id: |-
    hubedit_mbpp_py_83
  lang: |-
    python
  modified_code: |-
    def main(strr: str) -> str:
        summ = 0
        for i in range(len(strr)):
            summ += (ord(strr[i]) - ord('a') + 1)
        shift = summ % 26
        shifted_alphabet = ''
        for i in range(26):
            shifted_char = chr(((i + shift) % 26) + ord('a'))
            shifted_alphabet += shifted_char
        return shifted_alphabet
  original_code: |-
    def main(strr: str) -> str:
        summ = 0
        for i in range(len(strr)):
            summ += (ord(strr[i]) - ord('a') + 1)
        if (summ % 26 == 0):
            return 'z'
        else:
            summ = summ % 26
            return chr(ord('a') + summ - 1)
  original_instructions: |-
    find the character made by adding the ASCII value of all the characters of the given string modulo 26
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all the integers and floats in the list instead of finding the maximum value.
  id: |-
    hubedit_mbpp_py_294
  lang: |-
    python
  modified_code: |-
    from typing import List, Union

    def main(listval: List[Union[int, float]]) -> Union[int, float]:
        total_sum = sum(i for i in listval if isinstance(i, (int, float)))
        return total_sum
  original_code: |-
    from typing import List, Union

    def main(listval: List[Union[int, float]]) -> Union[int, float]:
        main = max(i for i in listval if isinstance(i, (int, float)))
        return main
  original_instructions: |-
    find the maximum value in a given heterogeneous list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to sort each sublist in descending order instead of ascending order.
  id: |-
    hubedit_mbpp_py_569
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(list1: List[List[int]]) -> List[List[int]]:
        result = list(map(lambda x: sorted(x, reverse=True), list1))
        return result
  original_code: |-
    from typing import List

    def main(list1: List[List[int]]) -> List[List[int]]:
        result = list(map(sorted, list1))
        return result
  original_instructions: |-
    sort each sublist of strings in a given list of lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the cubes of the binomial coefficients instead of the squares.
  id: |-
    hubedit_mbpp_py_300
  lang: |-
    python
  modified_code: "def main(n: int) -> float:\n    nCr = 1\n    res = 1\n    for r\
    \ in range(1, n + 1):\n        nCr = (nCr * (n + 1 - r)) / r\n        res += nCr\
    \ ** 3\n    return res "
  original_code: "def main(n: int) -> float:\n    nCr = 1\n    res = 1\n    for r\
    \ in range(1, n + 1):\n        nCr = (nCr * (n + 1 - r)) / r\n        res += nCr\
    \ * nCr\n    return res "
  original_instructions: |-
    find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list of unique characters from the input word, sorted alphabetically.
  id: |-
    hubedit_mbpp_py_565
  lang: |-
    python
  modified_code: |-
    def main(word: str) -> list:
        return sorted(set(word))
  original_code: |-
    def main(word: str) -> list:
        return [char for char in word]
  original_instructions: |-
    split a string into characters
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse each formatted string before adding it to the resulting list.
  id: |-
    hubedit_mbpp_py_390
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(list_: List[int], string: str) -> List[str]:
        main = [string.format(i)[::-1] for i in list_]
        return main
  original_code: |-
    from typing import List

    def main(list_: List[int], string: str) -> List[str]:
        main = [string.format(i) for i in list_]
        return main
  original_instructions: |-
    apply a given format string to all of the elements in a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the integers in the list instead of concatenating them into a single integer.
  id: |-
    hubedit_mbpp_py_439
  lang: |-
    python
  modified_code: |-
    def main(L: list) -> int:
      return sum(L)
  original_code: |-
    def main(L: list) -> int:
      x = int("".join(map(str, L)))
      return x
  original_instructions: |-
    join a list of multiple integers into a single integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count non-prime numbers instead of prime numbers by incrementing the counter when a divisor is found.
  id: |-
    hubedit_mbpp_py_256
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        ctr = 0
        for num in range(n):
            if num <= 1:
                ctr += 1  # Count 0 and 1 as non-prime numbers
                continue
            for i in range(2, int(num ** 0.5) + 1):
                if (num % i) == 0:
                    ctr += 1  # Increment counter when a divisor is found
                    break
            else:
                continue  # Continue to the next number if no divisors are found
        return ctr
  original_code: |-
    def main(n: int) -> int:
        ctr = 0
        for num in range(n):
            if num <= 1:
                continue
            for i in range(2, int(num ** 0.5) + 1):  # Optimized to check up to the square root of num
                if (num % i) == 0:
                    break
            else:
                ctr += 1
        return ctr
  original_instructions: |-
    takes in a non-negative number and returns the number of prime numbers less than the given non-negative number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `div_sum` function to also include the number itself in the sum of its divisors, effectively calculating the sum of all divisors including the number.
  id: |-
    hubedit_mbpp_py_164
  lang: |-
    python
  modified_code: |-
    import math
    def div_sum(n: int) -> int:
      total = 1 + n  # Include the number itself in the sum
      i = 2

      while i * i < n:  # Change condition to strictly less than
        if (n % i == 0):
          total += i
          if i != n // i:  # Avoid adding the square root twice if n is a perfect square
            total += n // i
        i += 1

      return total
  original_code: |-
    import math
    def div_sum(n: int) -> int:
      total = 1
      i = 2

      while i * i <= n:
        if (n % i == 0):
          total = (total + i + math.floor(n / i))
        i += 1

      return total

    def main(num1: int, num2: int) -> bool:
        return div_sum(num1) == div_sum(num2)
  original_instructions: |-
    determine if the sum of the divisors of two integers are the same
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return a list of all possible pairs of integers (i, j) such that i * a + j * b = n, instead of returning just the first pair found or None.
  id: |-
    hubedit_mbpp_py_160
  lang: |-
    python
  modified_code: |-
    def main(a: int, b: int, n: int) -> list[tuple[int, int]]:
        pairs = []
        i = 0
        while i * a <= n:
            if (n - (i * a)) % b == 0:
                j = (n - (i * a)) // b
                pairs.append((i, j))
            i = i + 1
        return pairs
  original_code: |-
    def main(a: int, b: int, n: int) -> tuple[int, int] | None:
        i = 0
        while i * a <= n:
            if (n - (i * a)) % b == 0:
                return (i, (n - (i * a)) // b)
            i = i + 1
        return None
  original_instructions: |-
    returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a tuple containing only the unique characters from the input string, excluding spaces.
  id: |-
    hubedit_mbpp_py_310
  lang: |-
    python
  modified_code: |-
    def main(str1: str) -> tuple:
        result = tuple(sorted(set(x for x in str1 if not x.isspace()), key=str1.index))
        return result
  original_code: |-
    def main(str1: str) -> tuple:
        result = tuple(x for x in str1 if not x.isspace())
        return result
  original_instructions: |-
    convert a given string to a tuple of characters
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to rotate the list to the left by k positions instead of reversing the first k elements and appending the rest.
  id: |-
    hubedit_mbpp_py_644
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(input: List, k: int) -> List:
      return input[k:] + input[:k]
  original_code: "from typing import List\n\ndef main(input: List, k: int) -> List:\n\
    \  return (input[k-1::-1] + input[k:]) "
  original_instructions: |-
    reverse an array upto a given position
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the regex pattern to match strings that start and end with the same vowel, regardless of what's in between.
  id: |-
    hubedit_mbpp_py_396
  lang: |-
    python
  modified_code: |-
    import re
    regex = r'^([aeiou]).*\1$'
    def main(string: str) -> str:
        if(re.search(regex, string, re.IGNORECASE)):
            return "Valid"
        else:
            return "Invalid"
  original_code: "import re\nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef main(string: str)\
    \ -> str:\n    if(re.search(regex, string)):\n        return \"Valid\"\n    else:\n\
    \        return \"Invalid\" "
  original_instructions: |-
    check whether the given string starts and ends with the same character or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to insert the element 'x' into the list 'a' at the index found by bisect_left, then return the modified list.
  id: |-
    hubedit_mbpp_py_736
  lang: |-
    python
  modified_code: |-
    import bisect
    from typing import List, Any

    def main(a: List[Any], x: Any) -> List[Any]:
        i = bisect.bisect_left(a, x)
        a.insert(i, x)
        return a
  original_code: |-
    import bisect
    from typing import List, Any

    def main(a: List[Any], x: Any) -> int:
        i = bisect.bisect_left(a, x)
        return i
  original_instructions: |-
    locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the occurrences of a different substring, such as 'abc', instead of 'std'.
  id: |-
    hubedit_mbpp_py_172
  lang: |-
    python
  modified_code: |-
    def main(s: str) -> int:
      count = 0
      for i in range(len(s) - 2):
        if (s[i] == 'a' and s[i+1] == 'b' and s[i+2] == 'c'):
          count = count + 1
      return count
  original_code: |-
    def main(s: str) -> int:
      count = 0
      for i in range(len(s) - 2):
        if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):
          count = count + 1
      return count
  original_instructions: |-
    count the number of occurence of the string 'std' in a given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the maximum sum of a subsequence of length 'index + 1' instead of the value at dp[index][k].
  id: |-
    hubedit_mbpp_py_306
  lang: |-
    python
  modified_code: |-
    def main(a: list[int], n: int, index: int, k: int) -> int:
        dp = [[0 for i in range(n)]
                for i in range(n)]
        for i in range(n):
            if a[i] > a[0]:
                dp[0][i] = a[i] + a[0]
            else:
                dp[0][i] = a[i]
        for i in range(1, n):
            for j in range(n):
                if a[j] > a[i] and j > i:
                    if dp[i - 1][i] + a[j] > dp[i - 1][j]:
                        dp[i][j] = dp[i - 1][i] + a[j]
                    else:
                        dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]

        # Find the maximum sum of a subsequence of length 'index + 1'
        max_sum = 0
        for j in range(n):
            max_sum = max(max_sum, dp[index][j])

        return max_sum
  original_code: |-
    def main(a: list[int], n: int, index: int, k: int) -> int:
        dp = [[0 for i in range(n)]
                for i in range(n)]
        for i in range(n):
            if a[i] > a[0]:
                dp[0][i] = a[i] + a[0]
            else:
                dp[0][i] = a[i]
        for i in range(1, n):
            for j in range(n):
                if a[j] > a[i] and j > i:
                    if dp[i - 1][i] + a[j] > dp[i - 1][j]:
                        dp[i][j] = dp[i - 1][i] + a[j]
                    else:
                        dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[index][k]
  original_instructions: "find the maximum sum of increasing subsequence from prefix\
    \ until ith index and also including a given kth element which is after i, i.e.,\
    \ k > i "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to perform the rotations in the opposite direction, shifting elements to the right instead of to the left within the specified range.
  id: |-
    hubedit_mbpp_py_304
  lang: |-
    python
  modified_code: |-
    def main(arr: list, ranges: list[tuple[int, int]], rotations: int, index: int) -> int:
        for i in range(rotations):
            left = ranges[i][0]
            right = ranges[i][1]
            if left <= index and right >= index:
                if index == right:
                    index = left
                else:
                    index = index + 1
        return arr[index]
  original_code: "def main(arr: list, ranges: list[tuple[int, int]], rotations: int,\
    \ index: int) -> int:\n    for i in range(rotations - 1, -1, -1):\n        left\
    \ = ranges[i][0]\n        right = ranges[i][1]\n        if left <= index and right\
    \ >= index:\n            if index == left:\n                index = right\n  \
    \          else:\n                index = index - 1\n    return arr[index] "
  original_instructions: |-
    find element at a given index after number of rotations
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the least common elements instead of the most common ones by reversing the sorted list of elements.
  id: |-
    hubedit_mbpp_py_475
  lang: |-
    python
  modified_code: |-
    from collections import Counter
    from typing import Dict, List, Tuple, Any

    def main(dict1: Dict[Any, int]) -> List[Tuple[Any, int]]:
        x = Counter(dict1)
        sorted_counter = x.most_common()[::-1]  # Reverse the list of most common elements
        return sorted_counter
  original_code: |-
    from collections import Counter
    from typing import Dict, List, Tuple, Any

    def main(dict1: Dict[Any, int]) -> List[Tuple[Any, int]]:
        x = Counter(dict1)
        sorted_counter = x.most_common()
        return sorted_counter
  original_instructions: |-
    sort a dictionary by value
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all prime factors of the given number n instead of the current functionality.
  id: |-
    hubedit_mbpp_py_453
  lang: |-
    python
  modified_code: |-
    import math

    def main(n: int) -> int:
        sum_of_primes = 0
        # Check for divisibility by 2
        while n % 2 == 0:
            sum_of_primes += 2
            n = n // 2

        # Check for divisibility by odd numbers
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            while n % i == 0:
                sum_of_primes += i
                n = n // i

        # If n is a prime number greater than 2
        if n > 2:
            sum_of_primes += n

        return sum_of_primes
  original_code: |-
    import math
    def main(n: int) -> int:
        if (n % 2 != 0) :
            return 0
        res = 1
        for i in range(2, (int)(math.sqrt(n)) + 1) :
            count = 0
            curr_sum = 1
            curr_term = 1
            while (n % i == 0) :
                count= count + 1
                n = n // i
                if (i == 2 and count == 1) :
                    curr_sum = 0
                curr_term = curr_term * i
                curr_sum = curr_sum + curr_term
            res = res * curr_sum
        if (n >= 2) :
            res = res * (1 + n)
        return res
  original_instructions: |-
    find the sum of even factors of a number
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to remove all occurrences of the character `ch` from the string `s`, not just the first and last occurrences.
  id: |-
    hubedit_mbpp_py_11
  lang: |-
    python
  modified_code: |-
    def main(s: str, ch: str) -> str:
        return s.replace(ch, '')
  original_code: "def main(s: str, ch: str) -> str:\n    for i in range(len(s)):\n\
    \        if (s[i] == ch):\n            s = s[0 : i] + s[i + 1:]\n            break\n\
    \    for i in range(len(s) - 1, -1, -1):\n        if (s[i] == ch):\n         \
    \   s = s[0 : i] + s[i + 1:]\n            break\n    return s "
  original_instructions: |-
    remove first and last occurrence of a given character from the string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list containing the n-th element from each sub-list only if that element is an integer.
  id: |-
    hubedit_mbpp_py_413
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(list1: List[List[Any]], n: int) -> List[int]:
        result = [x[n] for x in list1 if isinstance(x[n], int)]
        return result
  original_code: |-
    from typing import List, Any

    def main(list1: List[List[Any]], n: int) -> List[Any]:
        result = [x[n] for x in list1]
        return result
  original_instructions: |-
    extract the nth element from a given list of tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of even numbers instead of odd numbers.
  id: |-
    hubedit_mbpp_py_426
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        even_nums = list(filter(lambda x: x % 2 == 0, nums))
        return even_nums
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        odd_nums = list(filter(lambda x: x % 2 != 0, nums))
        return odd_nums
  original_instructions: |-
    filter odd numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the perimeter of a rectangle instead of the diagonal.
  id: |-
    hubedit_mbpp_py_293
  lang: |-
    python
  modified_code: |-
    def main(w: float, h: float) -> float:
      p = 2 * (w + h)
      return p
  original_code: |-
    import math
    def main(w: float, h: float) -> float:
      s = math.sqrt((w * w) + (h * h))
      return s
  original_instructions: |-
    find the third side of a right angled triangle
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the number of unique elements in the list instead of a boolean value.
  id: |-
    hubedit_mbpp_py_281
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(test_list: List[Any]) -> int:
        return len(set(test_list))
  original_code: |-
    from typing import List, Any

    def main(test_list: List[Any]) -> bool:
        if len(test_list) > len(set(test_list)):
            return False
        return True
  original_instructions: |-
    check if the elements of a given list are unique or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script so that it only appends the given element to the end of the list, instead of inserting it before every existing element.
  id: |-
    hubedit_mbpp_py_251
  lang: |-
    python
  modified_code: |-
    from typing import List, TypeVar

    T = TypeVar('T')

    def main(list: List[T], element: T) -> List[T]:
        list.append(element)
        return list
  original_code: |-
    from typing import List, TypeVar

    T = TypeVar('T')

    def main(list: List[T], element: T) -> List[T]:
        list = [v for elt in list for v in (element, elt)]
        return list
  original_instructions: |-
    takes in a list and an element and inserts the element before each element in the list, and returns the resulting list
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check if the given month number corresponds to a month with 31 days instead of 30 days.
  id: |-
    hubedit_mbpp_py_762
  lang: |-
    python
  modified_code: |-
    def main(monthnum3: int) -> bool:
      return monthnum3 == 1 or monthnum3 == 3 or monthnum3 == 5 or monthnum3 == 7 or monthnum3 == 8 or monthnum3 == 10 or monthnum3 == 12
  original_code: |-
    def main(monthnum3: int) -> bool:
      return monthnum3 == 4 or monthnum3 == 6 or monthnum3 == 9 or monthnum3 == 11
  original_instructions: |-
    check whether the given month number contains 30 days or not. Months are given as number from 1 to 12
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to concatenate characters from the input string that are at odd indices instead of even indices.
  id: |-
    hubedit_mbpp_py_437
  lang: |-
    python
  modified_code: |-
    def main(str1: str) -> str:
        str2 = ''
        for i in range(1, len(str1) + 1):
            if(i % 2 != 0):  # Changed condition to check for odd indices
                str2 = str2 + str1[i - 1]
        return str2
  original_code: |-
    def main(str1: str) -> str:
        str2 = ''
        for i in range(1, len(str1) + 1):
            if(i % 2 == 0):
                str2 = str2 + str1[i - 1]
        return str2
  original_instructions: |-
    remove odd characters in a string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the surface area of the cone instead of the volume.
  id: |-
    hubedit_mbpp_py_312
  lang: |-
    python
  modified_code: |-
    import math
    def main(r: float, h: float) -> float:
      slant_height = math.sqrt(r**2 + h**2)
      base_area = math.pi * r**2
      lateral_surface_area = math.pi * r * slant_height
      surface_area = base_area + lateral_surface_area
      return surface_area
  original_code: |-
    import math
    def main(r: float, h: float) -> float:
      volume = (1.0/3) * math.pi * r * r * h
      return volume
  original_instructions: |-
    find the volume of a cone
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to perform a right circular shift instead of a left circular shift.
  id: |-
    hubedit_mbpp_py_799
  lang: |-
    python
  modified_code: |-
    def main(n: int, d: int) -> int:
        INT_BITS = 32
        return (n >> d)|(n << (INT_BITS - d))
  original_code: |-
    def main(n: int, d: int) -> int:
        INT_BITS = 32
        return (n << d)|(n >> (INT_BITS - d))
  original_instructions: |-
    that rotate left bits by d bits a given number. We assume that the number is 32 bit
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the function to return the sum of the unique numbers instead of returning 0 or 4 minus the length of the set.
  id: |-
    hubedit_mbpp_py_801
  lang: |-
    python
  modified_code: |-
    def main(x: int, y: int, z: int) -> int:
        result = set([x, y, z])
        return sum(result)
  original_code: |-
    def main(x: int, y: int, z: int) -> int:
      result = set([x, y, z])
      if len(result) == 3:
        return 0
      else:
        return 4 - len(result)
  original_instructions: |-
    count the number of equal numbers from three given integers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of all even numbers in the list instead of the first odd number.
  id: |-
    hubedit_mbpp_py_807
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums: List[int]) -> int:
        return sum(el for el in nums if el % 2 == 0)
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> int:
      main = next((el for el in nums if el % 2 != 0), -1)
      return main
  original_instructions: |-
    find the first odd number in a given list of numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of occurrences of the character 'ch' in 'str1' before replacing it with 'newch', and return both the modified string and the count as a tuple.
  id: |-
    hubedit_mbpp_py_474
  lang: |-
    python
  modified_code: |-
    def main(str1: str, ch: str, newch: str) -> (str, int):
        count = str1.count(ch)
        str2 = str1.replace(ch, newch)
        return (str2, count)
  original_code: |-
    def main(str1: str, ch: str, newch: str) -> str:
        str2 = str1.replace(ch, newch)
        return str2
  original_instructions: |-
    replace characters in a string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of a number instead of its current operation. Modify the inner loop to compute the factorial of 'i' when 'j' is equal to 'n'.
  id: |-
    hubedit_mbpp_py_239
  lang: |-
    python
  modified_code: |-
    def main(m: int, n: int) -> int:
        T=[[0 for i in range(n+1)] for i in range(m+1)]
        for i in range(m+1):
            for j in range(n+1):
                if j == n:  # Modify the condition to calculate factorial when j equals n
                    if i == 0:
                        T[i][j] = 1  # 0! is 1
                    else:
                        T[i][j] = i * T[i-1][j]  # Calculate factorial using previous value
                else:
                    T[i][j] = 0  # Set other values to 0 as they are not needed
        return T[m][n]
  original_code: |-
    def main(m: int, n: int) -> int:
        T=[[0 for i in range(n+1)] for i in range(m+1)]
        for i in range(m+1):
            for j in range(n+1):
                if i==0 or j==0:
                    T[i][j]=0
                elif i<j:
                    T[i][j]=0
                elif j==1:
                    T[i][j]=i
                else:
                    T[i][j]=T[i-1][j]+T[i//2][j-1]
        return T[m][n]
  original_instructions: |-
    takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of substrings where the sum of the digits is equal to the length of the substring. This would involve changing the condition inside the loop to check for `sum == (i + 1)` instead of `sum - (i + 1)`.
  id: |-
    hubedit_mbpp_py_61
  lang: |-
    python
  modified_code: |-
    from collections import defaultdict
    def main(s: str) -> int:
        n = len(s)
        count, sum = 0, 0
        mp = defaultdict(lambda: 0)
        for i in range(n):
            sum += ord(s[i]) - ord('0')
            if sum == (i + 1):
                count += 1
            mp[sum] += 1
            count += mp[sum - (i + 1)]
        return count
  original_code: |-
    from collections import defaultdict
    def main(s: str) -> int:
        n = len(s)
        count, sum = 0, 0
        mp = defaultdict(lambda: 0)
        mp[0] += 1
        for i in range(n):
            sum += ord(s[i]) - ord('0')
            count += mp[sum - (i + 1)]
            mp[sum - (i + 1)] += 1
        return count
  original_instructions: |-
    count the number of substrings with the sum of digits equal to their length
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the `set_middle_bits` function to set only the even-positioned bits to 1, and modify the `main` function to return the bitwise AND of `n` and the result of `set_middle_bits(n)`.
  id: |-
    hubedit_mbpp_py_735
  lang: |-
    python
  modified_code: |-
    def set_even_bits(n: int) -> int:
        even_mask = 0xAAAAAAAA  # This mask has 1s in even positions (assuming 32-bit integer)
        return n | even_mask

    def main(n: int) -> int:
        return n & set_even_bits(n)
  original_code: |-
    def set_middle_bits(n: int) -> int:
        n |= n >> 1
        n |= n >> 2
        n |= n >> 4
        n |= n >> 8
        n |= n >> 16
        return (n >> 1) ^ 1

    def main(n: int) -> int:
        if n == 1:
            return 1
        return n ^ set_middle_bits(n)
  original_instructions: |-
    toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to replace leading zeros in each octet of the IP address with a single zero instead of removing them completely.
  id: |-
    hubedit_mbpp_py_593
  lang: |-
    python
  modified_code: |-
    import re

    def main(ip: str) -> str:
        string = re.sub(r'\b0+(\d)', r'0\1', ip)
        return string
  original_code: |-
    import re

    def main(ip: str) -> str:
        string = re.sub(r'\.(0+)', '.', ip)
        return string
  original_instructions: |-
    remove leading zeroes from an ip address
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of `n` instead of the square root of 2 times 10 raised to the power of `n - 1`.
  id: |-
    hubedit_mbpp_py_739
  lang: |-
    python
  modified_code: |-
    import math

    def main(n: int) -> int:
        return math.factorial(n)
  original_code: |-
    import math

    def main(n: int) -> int:
        x = math.sqrt(2 * math.pow(10, (n - 1)))
        return round(x)
  original_instructions: |-
    find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the number `n` is a prime number instead of checking if it is a perfect square.
  id: |-
    hubedit_mbpp_py_803
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> bool:
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while (i * i <= n):
            if (n % i == 0 or n % (i + 2) == 0):
                return False
            i = i + 6
        return True
  original_code: |-
    def main(n: int) -> bool:
        i = 1
        while (i * i <= n):
            if ((n % i == 0) and (n / i == i)):
                return True
            i = i + 1
        return False
  original_instructions: |-
    check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the regular expression to match any string that contains at least one digit, instead of searching for the letter 'z' not at a word boundary.
  id: |-
    hubedit_mbpp_py_643
  lang: |-
    python
  modified_code: |-
    import re
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        return bool(re.search(r'\d', text))
  original_code: |-
    import re
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        return bool(re.search(r'\Bz\B', text))
  original_instructions: |-
    checks if a strings contains 'z', except at the start and end of the word
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of pairs (i, j) such that arr[i] is equal to arr[j] instead of counting inversions.
  id: |-
    hubedit_mbpp_py_296
  lang: |-
    python
  modified_code: |-
    def main(arr: list) -> int:
        equal_count = 0
        for i in range(len(arr)):
            for j in range(i + 1, len(arr)):
                if arr[i] == arr[j]:
                    equal_count += 1
        return equal_count
  original_code: "def main(arr: list) -> int:\n    inv_count = 0\n    for i in range(len(arr)):\n\
    \        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n\
    \                inv_count += 1\n    return inv_count "
  original_instructions: |-
    count inversions in an array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count only unique palindrome pairs, where a pair is considered unique if the indices of the elements in the pair are different from all previously counted pairs.
  id: |-
    hubedit_mbpp_py_757
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(test_list: List[str]) -> int:
        unique_pairs = set()
        for idx in range(len(test_list)):
            for idxn in range(idx, len(test_list)):
                if idx != idxn and test_list[idxn] == str(''.join(reversed(test_list[idx]))):
                    # Sort the indices to ensure uniqueness (e.g., (1,2) is the same as (2,1))
                    pair = tuple(sorted((idx, idxn)))
                    unique_pairs.add(pair)
        return len(unique_pairs)
  original_code: |-
    from typing import List

    def main(test_list: List[str]) -> int:
      res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len(test_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))])
      return res
  original_instructions: |-
    count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to add the corresponding elements of the tuples instead of multiplying them.
  id: |-
    hubedit_mbpp_py_445
  lang: |-
    python
  modified_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(a + b for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup2))
        return res
  original_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(a * b for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    perform index wise multiplication of tuple elements in the given two tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a tuple containing the union of elements instead of the intersection for each pair of elements from the given tuples.
  id: |-
    hubedit_mbpp_py_429
  lang: |-
    python
  modified_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 | ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res
  original_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    extract the elementwise and tuples from the given two tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the script to count the number of zero bits instead of one bits in the binary representation of the given integer.
  id: |-
    hubedit_mbpp_py_224
  lang: |-
    python
  modified_code: "def main(n: int) -> int:\n    count = 0\n    while (n):\n      \
    \  count += not (n & 1)\n        n >>= 1\n    return count "
  original_code: "def main(n: int) -> int:\n    count = 0\n    while (n):\n      \
    \  count += n & 1\n        n >>= 1\n    return count "
  original_instructions: |-
    count the number of set bits (binary digits with value 1) in a given number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return only subsets of a specific size given as an additional parameter to the main function.
  id: |-
    hubedit_mbpp_py_462
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(list1: List[Any], subset_size: int) -> List[List[Any]]:
        def generate_subsets(index: int, current_subset: List[Any]):
            if len(current_subset) == subset_size:
                result.append(current_subset[:])
                return
            if index == len(list1):
                return
            # Include the current element
            current_subset.append(list1[index])
            generate_subsets(index + 1, current_subset)
            # Exclude the current element
            current_subset.pop()
            generate_subsets(index + 1, current_subset)

        result = []
        generate_subsets(0, [])
        return result
  original_code: |-
    from typing import List, Any

    def main(list1: List[Any]) -> List[List[Any]]:
        if len(list1) == 0:
            return [[]]
        result = []
        for el in main(list1[1:]):
            result += [el, el+[list1[0]]]
        return result
  original_instructions: |-
    find all possible combinations of the elements of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate and return the entire nth row of the Bell Triangle instead of just the first element of the nth row.
  id: |-
    hubedit_mbpp_py_67
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> list:
        bell = [[0 for i in range(n+1)] for j in range(n+1)]
        bell[0][0] = 1
        for i in range(1, n+1):
            bell[i][0] = bell[i-1][i-1]
            for j in range(1, i+1):
                bell[i][j] = bell[i-1][j-1] + bell[i][j-1]
        return bell[n][:n+1]
  original_code: "def main(n: int) -> int:\n    bell = [[0 for i in range(n+1)] for\
    \ j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0]\
    \ = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] =\
    \ bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0] "
  original_instructions: |-
    find the number of ways to partition a set of Bell numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the first even and first odd number from the list instead of their product.
  id: |-
    hubedit_mbpp_py_784
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(list1: List[int]) -> int:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even + first_odd
  original_code: |-
    from typing import List

    def main(list1: List[int]) -> int:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even * first_odd
  original_instructions: |-
    find the product of first even and odd number of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to find the last occurrence of x in the sorted list A instead of the first occurrence.
  id: |-
    hubedit_mbpp_py_733
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(A: List[Any], x: Any) -> int:
        (left, right) = (0, len(A) - 1)
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if x == A[mid]:
                result = mid
                left = mid + 1  # Move to the right to find the last occurrence
            elif x < A[mid]:
                right = mid - 1
            else:
                left = mid + 1
        return result
  original_code: |-
    from typing import List, Any

    def main(A: List[Any], x: Any) -> int:
        (left, right) = (0, len(A) - 1)
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if x == A[mid]:
                result = mid
                right = mid - 1
            elif x < A[mid]:
                right = mid - 1
            else:
                left = mid + 1
        return result
  original_instructions: |-
    find the index of the first occurrence of a given number in a sorted array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the average of the two largest numbers instead of returning the smallest number.
  id: |-
    hubedit_mbpp_py_227
  lang: |-
    python
  modified_code: |-
    def main(a: float, b: float, c: float) -> float:
        if (a >= b) and (a >= c):
            largest1 = a
            largest2 = max(b, c)
        elif (b >= a) and (b >= c):
            largest1 = b
            largest2 = max(a, c)
        else:
            largest1 = c
            largest2 = max(a, b)
        return (largest1 + largest2) / 2
  original_code: "def main(a: float, b: float, c: float) -> float:\n      if (a <=\
    \ b) and (a <= c):\n        smallest = a\n      elif (b <= a) and (b <= c):\n\
    \        smallest = b\n      else:\n        smallest = c\n      return smallest "
  original_instructions: |-
    find minimum of three numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the given number is present in the array instead of checking if it is greater than the maximum element in the array.
  id: |-
    hubedit_mbpp_py_433
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(arr: List[int], number: int) -> bool:
      return number in arr
  original_code: |-
    from typing import List

    def main(arr: List[int], number: int) -> bool:
      arr.sort()
      return number > arr[-1]
  original_instructions: |-
    check whether the entered number is greater than the elements of the given array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list containing the elements that are common to both list1 and list2, instead of elements that are in list1 but not in list2.
  id: |-
    hubedit_mbpp_py_161
  lang: |-
    python
  modified_code: |-
    def main(list1: list, list2: list) -> list:
        result = [x for x in list1 if x in list2]
        return result
  original_code: |-
    def main(list1: list, list2: list) -> list:
        result = [x for x in list1 if x not in list2]
        return result
  original_instructions: |-
    remove all elements from a given list present in another list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to find the maximum difference between any two consecutive elements in the sorted array instead of the minimum difference.
  id: |-
    hubedit_mbpp_py_763
  lang: |-
    python
  modified_code: "from typing import List\n\ndef main(arr: List[int], n: int) -> int:\n\
    \    arr = sorted(arr)\n    max_diff = 0\n    for i in range(n-1):\n        if\
    \ arr[i+1] - arr[i] > max_diff:\n            max_diff = arr[i+1] - arr[i]\n  \
    \  return max_diff "
  original_code: "from typing import List\n\ndef main(arr: List[int], n: int) -> int:\n\
    \    arr = sorted(arr)\n    diff = 10**20\n    for i in range(n-1):\n        if\
    \ arr[i+1] - arr[i] < diff:\n            diff = arr[i+1] - arr[i]\n    return\
    \ diff "
  original_instructions: |-
    find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the regular expression pattern to match any string that contains at least one 'a' followed by one or more 'b's, with the 'b's being greedy instead of non-greedy.
  id: |-
    hubedit_mbpp_py_756
  lang: |-
    python
  modified_code: |-
    import re
    def main(text: str) -> bool:
            patterns = 'ab+'
            if re.search(patterns,  text):
                    return True
            else:
                    return False
  original_code: |-
    import re
    def main(text: str) -> bool:
            patterns = 'ab+?'
            if re.search(patterns,  text):
                    return True
            else:
                    return False
  original_instructions: |-
    matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the original string with each word reversed, instead of reversing the order of the words.
  id: |-
    hubedit_mbpp_py_604
  lang: |-
    python
  modified_code: |-
    def main(s: str) -> str:
        return ' '.join(word[::-1] for word in s.split())
  original_code: |-
    def main(s: str) -> str:
            return ' '.join(reversed(s.split()))
  original_instructions: |-
    reverse words seperated by spaces in a given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the maximum value from the second elements of the tuples in the list instead of the first element of the tuple with the minimum second element.
  id: |-
    hubedit_mbpp_py_94
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple

    def main(test_list: List[Tuple[int, int]]) -> int:
        res = max(test_list, key=lambda x: x[1])[1]
        return res
  original_code: |-
    from typing import List, Tuple
    from operator import itemgetter

    def main(test_list: List[Tuple[int, int]]) -> int:
        res = min(test_list, key=itemgetter(1))[0]
        return res
  original_instructions: |-
    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to concatenate every third character of the string instead of every second character.
  id: |-
    hubedit_mbpp_py_226
  lang: |-
    python
  modified_code: |-
    def main(s: str) -> str:
      result = ""
      for i in range(len(s)):
        if i % 3 == 0:
          result = result + s[i]
      return result
  original_code: |-
    def main(s: str) -> str:
      result = ""
      for i in range(len(s)):
        if i % 2 == 0:
          result = result + s[i]
      return result
  original_instructions: |-
    remove the characters which have odd index values of a given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the minimum value from the N-th index of each sublist in test_list instead of the maximum value.
  id: |-
    hubedit_mbpp_py_611
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]], N: int) -> Any:
        res = min(sub[N] for sub in test_list)
        return res
  original_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]], N: int) -> Any:
        res = max(sub[N] for sub in test_list)
        return res
  original_instructions: |-
    Write a function which given a matrix represented as a list of lists returns the max of the n'th column
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the union of all elements from the nested lists instead of the intersection.
  id: |-
    hubedit_mbpp_py_111
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(nestedlist: List[List[Any]]) -> List[Any]:
        result = list(set.union(*map(set, nestedlist)))
        return result
  original_code: |-
    from typing import List, Any

    def main(nestedlist: List[List[Any]]) -> List[Any]:
        result = list(set.intersection(*map(set, nestedlist)))
        return result
  original_instructions: |-
    find the common elements in given nested lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the string contains all unique characters instead of checking if all characters are the same as the first character.
  id: |-
    hubedit_mbpp_py_741
  lang: |-
    python
  modified_code: |-
    def main(s: str) -> bool:
        seen = set()
        for char in s:
            if char in seen:
                return False
            seen.add(char)
        return True
  original_code: |-
    def main(s: str) -> bool:
        n = len(s)
        for i in range(1, n):
            if s[i] != s[0]:
                return False
        return True
  original_instructions: |-
    check whether all the characters are same or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of the given number n instead of the current polynomial expression.
  id: |-
    hubedit_mbpp_py_279
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n == 0:
            return 1
        else:
            return n * main(n - 1)
  original_code: "def main(n: int) -> int:\n    return 4 * n * n - 3 * n "
  original_instructions: |-
    find the nth decagonal number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of all integer elements in the tuple before the first nested tuple is encountered.
  id: |-
    hubedit_mbpp_py_278
  lang: |-
    python
  modified_code: |-
    def main(test_tup: tuple) -> int:
        total = 0
        for ele in test_tup:
            if isinstance(ele, tuple):
                break
            if isinstance(ele, int):
                total += ele
        return total
  original_code: |-
    def main(test_tup: tuple) -> int:
        for count, ele in enumerate(test_tup):
            if isinstance(ele, tuple):
                break
        return count
  original_instructions: |-
    find the number of elements that occurs before the tuple element in the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the order of the digits before appending them to the result string.
  id: |-
    hubedit_mbpp_py_619
  lang: |-
    python
  modified_code: |-
    def main(test_str: str) -> str:
      res = ''
      dig = ''
      for ele in test_str:
        if ele.isdigit():
          dig = ele + dig  # Prepend the digit to reverse the order
        else:
          res += ele
      res += dig
      return res
  original_code: |-
    def main(test_str: str) -> str:
      res = ''
      dig = ''
      for ele in test_str:
        if ele.isdigit():
          dig += ele
        else:
          res += ele
      res += dig
      return res
  original_instructions: |-
    move all the numbers to the end of the given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the focus of a parabola given by the equation y = ax^2 + bx + c, instead of the directrix.
  id: |-
    hubedit_mbpp_py_430
  lang: |-
    python
  modified_code: |-
    def main(a: float, b: float, c: float) -> tuple:
        # The focus of a parabola y = ax^2 + bx + c is given by the formula:
        # (h, k) where h = -b/(2a) and k = c - b^2/(4a)
        h = -b / (2 * a)
        k = c - (b ** 2) / (4 * a)
        focus = (h, k)
        return focus
  original_code: |-
    def main(a: float, b: float, c: float) -> int:
        directrix = int(c - ((b * b) + 1) * 4 * a)
        return directrix
  original_instructions: |-
    find the directrix of a parabola
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to replace all digits with asterisks (*) instead of removing whitespace.
  id: |-
    hubedit_mbpp_py_451
  lang: |-
    python
  modified_code: |-
    import re
    def main(text1: str) -> str:
      return re.sub(r'\d', '*', text1)
  original_code: |-
    import re
    def main(text1: str) -> str:
      return re.sub(r'\s+', '', text1)
  original_instructions: |-
    remove all whitespaces from the given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the sum of the cubes of odd numbers only, instead of the cubes of twice each number.
  id: |-
    hubedit_mbpp_py_420
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        sum = 0
        for i in range(1, n + 1):
            if i % 2 != 0:
                sum += i**3
        return sum
  original_code: |-
    def main(n: int) -> int:
        sum = 0
        for i in range(1, n + 1):
            sum += (2*i)**3
        return sum
  original_instructions: |-
    find the cube sum of first n even natural numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sine of the angle in radians instead of just converting degrees to radians.
  id: |-
    hubedit_mbpp_py_606
  lang: |-
    python
  modified_code: |-
    import math
    def main(degree: float) -> float:
        radian = degree * (math.pi / 180)
        sine_value = math.sin(radian)
        return sine_value
  original_code: |-
    import math
    def main(degree: float) -> float:
        radian = degree * (math.pi / 180)
        return radian
  original_instructions: |-
    convert degrees to radians
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the merged list without duplicates by converting the result of heapq.merge into a set before converting it back into a list.
  id: |-
    hubedit_mbpp_py_108
  lang: |-
    python
  modified_code: |-
    import heapq
    from typing import List

    def main(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:
        num1 = sorted(num1)
        num2 = sorted(num2)
        num3 = sorted(num3)
        result = heapq.merge(num1, num2, num3)
        return list(set(result))
  original_code: |-
    import heapq
    from typing import List

    def main(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:
        num1 = sorted(num1)
        num2 = sorted(num2)
        num3 = sorted(num3)
        result = heapq.merge(num1, num2, num3)
        return list(result)
  original_instructions: |-
    merge three lists into a single sorted list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to perform element-wise multiplication instead of integer division between the elements of the two tuples.
  id: |-
    hubedit_mbpp_py_261
  lang: |-
    python
  modified_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 * ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res
  original_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    takes in two tuples and performs mathematical division operation element-wise across the given tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the number is a prime number instead of checking if it is an Armstrong number.
  id: |-
    hubedit_mbpp_py_598
  lang: |-
    python
  modified_code: |-
    def main(number: int) -> bool:
        if number <= 1:
            return False
        if number <= 3:
            return True
        if number % 2 == 0 or number % 3 == 0:
            return False
        i = 5
        while i * i <= number:
            if number % i == 0 or number % (i + 2) == 0:
                return False
            i += 6
        return True
  original_code: |-
    def main(number: int) -> bool:
        sum = 0
        times = 0
        temp = number
        while temp > 0:
            times = times + 1
            temp = temp // 10
        temp = number
        while temp > 0:
            reminder = temp % 10
            sum = sum + (reminder ** times)
            temp //= 10
        if number == sum:
            return True
        else:
            return False
  original_instructions: |-
    check whether the given number is armstrong or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of elements that are common to all inner lists, instead of returning a list of unique elements from all inner lists.
  id: |-
    hubedit_mbpp_py_140
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> List[Any]:
        if not test_list:
            return []
        common_elements: Set[Any] = set(test_list[0])
        for inner in test_list[1:]:
            common_elements.intersection_update(inner)
        return list(common_elements)
  original_code: |-
    from typing import List, Any, Set

    def main(test_list: List[List[Any]]) -> List[Any]:
        res: List[Any] = []
        temp: Set[Any] = set()
        for inner in test_list:
            for ele in inner:
                if ele not in temp:
                    temp.add(ele)
                    res.append(ele)
        return res
  original_instructions: |-
    flatten the list of lists into a single set of numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to sort the sublists in descending order based on the maximum element in each sublist.
  id: |-
    hubedit_mbpp_py_12
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(M: List[List[int]]) -> List[List[int]]:
        result = sorted(M, key=lambda x: max(x), reverse=True)
        return result
  original_code: |-
    from typing import List

    def main(M: List[List[int]]) -> List[List[int]]:
        result = sorted(M, key=sum)
        return result
  original_instructions: |-
    sort a given matrix in ascending order according to the sum of its rows
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the function to calculate the factorial of `n` instead of its current operation.
  id: |-
    hubedit_mbpp_py_448
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n == 0:
            return 1
        factorial = 1
        for i in range(1, n + 1):
            factorial *= i
        return factorial
  original_code: |-
    def main(n: int) -> int:
        a = 3
        b = 0
        c = 2
        if n == 0:
            return 3
        if n == 1:
            return 3
        if n == 2:
            return 5
        sum = 5
        while n > 2:
            d = a + b
            sum = sum + d
            a = b
            b = c
            c = d
            n = n - 1
        return sum
  original_instructions: |-
    calculate the sum of perrin numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of elements in nums1 that are greater than the corresponding elements in nums2.
  id: |-
    hubedit_mbpp_py_723
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums1: List[int], nums2: List[int]) -> int:
        result = sum(x > y for x, y in zip(nums1, nums2))
        return result
  original_code: |-
    from operator import eq
    from typing import List

    def main(nums1: List[int], nums2: List[int]) -> int:
        result = sum(map(eq, nums1, nums2))
        return result
  original_instructions: |-
    The input is defined as two lists of the same length. count indices where the lists have the same values
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a tuple containing only the elements that are tuples themselves, instead of the elements that are not tuples.
  id: |-
    hubedit_mbpp_py_791
  lang: |-
    python
  modified_code: |-
    def main(test_tup: tuple) -> tuple:
        res: tuple = tuple()
        for ele in test_tup:
            if isinstance(ele, tuple):
                res = res + (ele, )
        return res
  original_code: |-
    def main(test_tup: tuple) -> tuple:
        res: tuple = tuple()
        for count, ele in enumerate(test_tup):
            if not isinstance(ele, tuple):
                res = res + (ele, )
        return res
  original_instructions: |-
    remove tuples from the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the median of each tuple instead of the average when zipped together.
  id: |-
    hubedit_mbpp_py_615
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple
    import statistics

    def main(nums: List[Tuple[float, ...]]) -> List[float]:
        result = [statistics.median(x) for x in zip(*nums)]
        return result
  original_code: |-
    from typing import List, Tuple

    def main(nums: List[Tuple[float, ...]]) -> List[float]:
        result = [sum(x) / len(x) for x in zip(*nums)]
        return result
  original_instructions: |-
    Write a function which takes a tuple of tuples and returns the average value for each tuple as a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the difference between the pairs instead of the sum, resulting in tuples that represent the difference between the elements of each pair.
  id: |-
    hubedit_mbpp_py_780
  lang: |-
    python
  modified_code: |-
    from itertools import combinations
    from typing import List, Tuple

    def main(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        res = [(b1 - a1, b2 - a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]
        return res
  original_code: |-
    from itertools import combinations
    from typing import List, Tuple

    def main(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]
        return res
  original_instructions: |-
    find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a conditional statement to check if the input number is even or odd. If it's even, return the original formula; if it's odd, return the square of the input number.
  id: |-
    hubedit_mbpp_py_59
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
        if n % 2 == 0:
            return 3 * n * n - 2 * n
        else:
            return n * n
  original_code: "def main(n: int) -> int:\n    return 3 * n * n - 2 * n "
  original_instructions: |-
    find the nth octagonal number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to fill each dictionary in the list with a key-value pair where the key is 'index' and the value is the current index in the loop.
  id: |-
    hubedit_mbpp_py_568
  lang: |-
    python
  modified_code: |-
    def main(length: int) -> list:
        main = [{'index': i} for i in range(length)]
        return main
  original_code: |-
    def main(length: int) -> list:
        main = [{} for _ in range(length)]
        return main
  original_instructions: |-
    create a list of N empty dictionaries
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the entire list instead of just swapping the first and last elements.
  id: |-
    hubedit_mbpp_py_591
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(newList: List) -> List:
        return newList[::-1]
  original_code: "from typing import List\n\ndef main(newList: List) -> List:\n  \
    \  size = len(newList)\n    temp = newList[0]\n    newList[0] = newList[size -\
    \ 1]\n    newList[size - 1] = temp\n    return newList "
  original_instructions: |-
    interchange the first and last elements in a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of the number instead of the sum of its digits.
  id: |-
    hubedit_mbpp_py_566
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> int:
      if n == 0 or n == 1:
        return 1
      else:
        return n * main(n - 1)
  original_code: |-
    def main(n: int) -> int:
      if n == 0:
        return 0
      else:
        return n % 10 + main(int(n / 10))
  original_instructions: |-
    get the sum of the digits of a non-negative integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to generate a list of the first `n` prime numbers instead of ludic numbers.
  id: |-
    hubedit_mbpp_py_603
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> list:
        primes = []
        candidate = 2
        while len(primes) < n:
            is_prime = True
            for prime in primes:
                if candidate % prime == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(candidate)
            candidate += 1
        return primes
  original_code: |-
    def main(n: int) -> list:
        ludics = []
        for i in range(1, n + 1):
            ludics.append(i)
        index = 1
        while(index != len(ludics)):
            first_ludic = ludics[index]
            remove_index = index + first_ludic
            while(remove_index < len(ludics)):
                ludics.remove(ludics[remove_index])
                remove_index = remove_index + first_ludic - 1
            index += 1
        return ludics
  original_instructions: |-
    get all lucid numbers smaller than or equal to a given integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the first element of each inner list instead of the last element.
  id: |-
    hubedit_mbpp_py_272
  lang: |-
    python
  modified_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> List[Any]:
        res = [lis[0] for lis in test_list]
        return res
  original_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> List[Any]:
        res = [lis[-1] for lis in test_list]
        return res
  original_instructions: |-
    takes in a list of tuples and returns a list containing the rear element of each tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Introduce memoization by creating a dictionary to store the results of previously computed values of the function to avoid redundant calculations and improve efficiency.
  id: |-
    hubedit_mbpp_py_583
  lang: |-
    python
  modified_code: |-
    def main(num: int, memo: dict = None) -> int:
        if memo is None:
            memo = {}
        if num in memo:
            return memo[num]
        if num <= 1:
            return 1
        res_num = 0
        for i in range(num):
            res_num += main(i, memo) * main(num - i - 1, memo)
        memo[num] = res_num
        return res_num
  original_code: |-
    def main(num: int) -> int:
        if num <= 1:
             return 1
        res_num = 0
        for i in range(num):
            res_num += main(i) * main(num - i - 1)
        return res_num
  original_instructions: |-
    Write a function which returns nth catalan number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the volume of a cylinder by treating 'b' as the radius and 's' as the height, and include the constant pi in the calculation.
  id: |-
    hubedit_mbpp_py_581
  lang: |-
    python
  modified_code: |-
    import math

    def main(radius: float, height: float) -> float:
        return math.pi * pow(radius, 2) * height
  original_code: "def main(b: float, s: float) -> float:\n    return 2 * b * s + pow(b,\
    \ 2) "
  original_instructions: |-
    find the surface area of a square pyramid with a given base edge and height
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of elements that are in ascending order (m < n < o) instead of being equal across the three lists.
  id: |-
    hubedit_mbpp_py_142
  lang: |-
    python
  modified_code: |-
    def main(list1: list, list2: list, list3: list) -> int:
        result = sum(m < n < o for m, n, o in zip(list1, list2, list3))
        return result
  original_code: |-
    def main(list1: list, list2: list, list3: list) -> int:
        result = sum(m == n == o for m, n, o in zip(list1, list2, list3))
        return result
  original_instructions: |-
    count number items that are identical in the same position of three given lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to reverse the entire list instead of just swapping the first and last elements.
  id: |-
    hubedit_mbpp_py_625
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(newList: List) -> List:
        return newList[::-1]
  original_code: "from typing import List\n\ndef main(newList: List) -> List:\n  \
    \  size = len(newList)\n    temp = newList[0]\n    newList[0] = newList[size -\
    \ 1]\n    newList[size - 1] = temp\n    return newList "
  original_instructions: |-
    interchange the first and last element in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the intersection of the two lists instead of the symmetric difference.
  id: |-
    hubedit_mbpp_py_769
  lang: |-
    python
  modified_code: |-
    def main(li1: list, li2: list) -> list:
        return list(set(li1) & set(li2))
  original_code: |-
    def main(li1: list, li2: list) -> list:
        return list(set(li1) - set(li2)) + list(set(li2) - set(li1))
  original_instructions: |-
    get the difference between two lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the function to return True only if the number is a prime number, otherwise return False.
  id: |-
    hubedit_mbpp_py_72
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> bool:
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
  original_code: |-
    def main(n: int) -> bool:
        if (n % 4 != 2):
            return True
        return False
  original_instructions: |-
    check whether the given number can be represented as the difference of two squares or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count the number of vowels in the input string instead of the total number of characters.
  id: |-
    hubedit_mbpp_py_242
  lang: |-
    python
  modified_code: |-
    def main(str1: str) -> int:
        vowels = 'aeiouAEIOU'
        total = 0
        for i in str1:
            if i in vowels:
                total = total + 1
        return total
  original_code: |-
    def main(str1: str) -> int:
        total = 0
        for i in str1:
            total = total + 1
        return total
  original_instructions: |-
    count the total number of characters in a string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to shuffle the list before splitting it into two parts, so that the returned sublists contain random elements from the original list.
  id: |-
    hubedit_mbpp_py_262
  lang: |-
    python
  modified_code: |-
    import random

    def main(list1: list, L: int) -> tuple:
        random.shuffle(list1)
        return list1[:L], list1[L:]
  original_code: |-
    def main(list1: list, L: int) -> tuple:
        return list1[:L], list1[L:]
  original_instructions: |-
    takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the k-th largest element instead of the k-th smallest element after merging the two arrays.
  id: |-
    hubedit_mbpp_py_597
  lang: |-
    python
  modified_code: |-
    def main(arr1: list, arr2: list, k: int) -> int:
        m = len(arr1)
        n = len(arr2)
        sorted1 = [0] * (m + n)
        i = m - 1
        j = n - 1
        d = m + n - 1
        while (i >= 0 and j >= 0):
            if (arr1[i] > arr2[j]):
                sorted1[d] = arr1[i]
                i -= 1
            else:
                sorted1[d] = arr2[j]
                j -= 1
            d -= 1
        while (i >= 0):
            sorted1[d] = arr1[i]
            d -= 1
            i -= 1
        while (j >= 0):
            sorted1[d] = arr2[j]
            d -= 1
            j -= 1
        return sorted1[k - 1]
  original_code: |-
    def main(arr1: list, arr2: list, k: int) -> int:
        m = len(arr1)
        n = len(arr2)
        sorted1 = [0] * (m + n)
        i = 0
        j = 0
        d = 0
        while (i < m and j < n):
            if (arr1[i] < arr2[j]):
                sorted1[d] = arr1[i]
                i += 1
            else:
                sorted1[d] = arr2[j]
                j += 1
            d += 1
        while (i < m):
            sorted1[d] = arr1[i]
            d += 1
            i += 1
        while (j < n):
            sorted1[d] = arr2[j]
            d += 1
            j += 1
        return sorted1[k - 1]
  original_instructions: |-
    find kth element from the given two sorted arrays
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count pairs where the bitwise XOR of the two elements is an odd number instead of an even number.
  id: |-
    hubedit_mbpp_py_166
  lang: |-
    python
  modified_code: |-
    def main(A: list) -> int:
      count = 0
      for i in range(0, len(A)):
        for j in range(i+1, len(A)):
            if ((A[i] ^ A[j]) % 2 != 0):  # Changed condition to check for odd number
              count += 1

      return count
  original_code: |-
    def main(A: list) -> int:
      count = 0
      for i in range(0, len(A)):
        for j in range(i+1, len(A)):
            if ((A[i] ^ A[j]) % 2 == 0):
              count += 1

      return count
  original_instructions: |-
    counts the number of pairs of integers in a list that xor to an even number
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to replace each space with an underscore instead of "%20".
  id: |-
    hubedit_mbpp_py_628
  lang: |-
    python
  modified_code: |-
    def main(string: str) -> str:
      return string.replace(" ", "_")
  original_code: |-
    def main(string: str) -> str:
      return string.replace(" ", "%20")
  original_instructions: |-
    replace all spaces in the given string with '%20'
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the top N products instead of the list of products.
  id: |-
    hubedit_mbpp_py_308
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(nums1: List[int], nums2: List[int], N: int) -> int:
        result = sum(sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N])
        return result
  original_code: |-
    from typing import List

    def main(nums1: List[int], nums2: List[int], N: int) -> List[int]:
        result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]
        return result
  original_instructions: |-
    find the specified number of largest products from two given lists, selecting one factor from each list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `is_majority` function to count the occurrences of `x` in `arr` and return True if the count is greater than `n//2`, making it independent of the array's sorted order.
  id: |-
    hubedit_mbpp_py_223
  lang: |-
    python
  modified_code: |-
    def is_majority(arr: list, n: int, x: int) -> bool:
        count = arr.count(x)
        return count > n//2
  original_code: |-
    def is_majority(arr: list, n: int, x: int) -> bool:
        i = main(arr, 0, n-1, x)
        if i == -1:
            return False
        if ((i + n//2) <= (n -1)) and arr[i + n//2] == x:
            return True
        else:
            return False

    def main(arr: list, low: int, high: int, x: int) -> int:
        if high >= low:
            mid = (low + high)//2
            if (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):
                return mid
            elif x > arr[mid]:
                return main(arr, (mid + 1), high, x)
            else:
                return main(arr, low, (mid -1), x)
        return -1
  original_instructions: |-
    takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count the number of vowels (a, e, i, o, u) in the input string instead of digits.
  id: |-
    hubedit_mbpp_py_764
  lang: |-
    python
  modified_code: |-
    def main(input_str: str) -> int:
        vowel_count = 0
        vowels = "aeiouAEIOU"
        for char in input_str:
            if char in vowels:
                vowel_count += 1
        return vowel_count
  original_code: |-
    def main(str: str) -> int:
        main = 0
        for i in range(len(str)):
            if str[i] >= '0' and str[i] <= '9':
                main += 1
        return main
  original_instructions: |-
    count number of digits in a given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the `n` smallest numbers instead of the largest ones by changing the sort comparison function to sort in ascending order and adjusting the slice operation accordingly.
  id: |-
    hubedit_mbpp_ts_4
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[], n: number): Promise<number[]> {
      const smallest_nums = nums.sort((a, b) => a - b).slice(0, n);
      return smallest_nums;
    }
  original_code: |-
    export async function main(nums: number[], n: number): Promise<number[]> {
      const largest_nums = nums.sort((a, b) => b - a).slice(0, n);
      return largest_nums;
    }
  original_instructions: |-
    find the n largest integers from a given list of numbers, returned in descending order
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the index of the first character in the second occurrence of `str` within `tmp` instead of the length of the string shift.
  id: |-
    hubedit_mbpp_ts_9
  lang: |-
    deno
  modified_code: |-
    export async function main(str: string): Promise<number> {
        const tmp = str + str;
        const n = str.length;
        for (let i = 1; i <= n; i++) {
            const substring = tmp.substring(i, i + n);
            if (str === substring) {
                return i + n; // Return the index of the first character in the second occurrence
            }
        }
        return -1; // If not found, return -1 or an appropriate error value
    }
  original_code: |-
    export async function main(str: string): Promise<number> {
        const tmp = str + str;
        const n = str.length;
        for (let i = 1; i <= n; i++) {
            const substring = tmp.substring(i, i + n);
            if (str === substring) {
                return i;
            }
        }
        return n;
    }
  original_instructions: |-
    find the minimum number of rotations (greater than 0) required to get the same string
  resource_type: null
  resource_type_def: null
- edit_instructions: "\nChange the function to calculate the volume of a cylinder\
    \ by taking the radius and height as parameters and using the formula \u03C0 *\
    \ radius^2 * height.\n"
  id: |-
    hubedit_mbpp_ts_14
  lang: |-
    deno
  modified_code: |-
    export async function main(radius: number, height: number): Promise<number> {
        return (Math.PI * Math.pow(radius, 2) * height);
    }
  original_code: |-
    export async function main(l: number, b: number, h: number): Promise<number> {
        return ((l * b * h) / 2);
    }
  original_instructions: |-
    find the volume of a triangular prism
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the regular expression to allow for numbers at the end of the string after the underscore.
  id: |-
    hubedit_mbpp_ts_16
  lang: |-
    deno
  modified_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = '^[a-z]+_[a-z0-9]+$';
        return new RegExp(patterns).test(text);
    }
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = '^[a-z]+_[a-z]+$';
        return new RegExp(patterns).test(text);
    }
  original_instructions: |-
    that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the area of a square instead of the perimeter by multiplying the side length `a` by itself.
  id: |-
    hubedit_mbpp_ts_17
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number): Promise<number> {
      const area: number = a * a;
      return area;
    }
  original_code: |-
    export async function main(a: number): Promise<number> {
      const perimeter: number = 4 * a;
      return perimeter;
    }
  original_instructions: |-
    returns the perimeter of a square given its side length as input
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the mathematical operation to calculate the factorial of the number n instead of the current polynomial expression.
  id: |-
    hubedit_mbpp_ts_59
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        if (n < 0) {
            throw new Error("Factorial is not defined for negative numbers");
        }

        let factorial = 1;
        for (let i = 2; i <= n; i++) {
            factorial *= i;
        }
        return factorial;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        return 3 * n * n - 2 * n;
    }
  original_instructions: |-
    find the nth octagonal number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of substrings where the sum of the ASCII values of the characters is a prime number.
  id: |-
    hubedit_mbpp_ts_61
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<number> {
        const n: number = s.length;
        let count: number = 0;
        const mp: { [key: number]: number } = {};

        // Helper function to check if a number is prime
        function isPrime(num: number): boolean {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            for (let i = 5; i * i <= num; i += 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }

        // Initialize the map with the sum 0
        mp[0] = 1;
        let sum: number = 0;

        for (let i = 0; i < n; i++) {
            sum += s.charCodeAt(i) - '0'.charCodeAt(0);
            for (let j = 0; j <= sum; j++) {
                if (isPrime(sum - j)) {
                    count += mp[j] ? mp[j] : 0;
                }
            }
            if (mp[sum] === undefined) {
                mp[sum] = 0;
            }
            mp[sum] += 1;
        }
        return count;
    }
  original_code: |-
    export async function main(s: string): Promise<number> {
        const n: number = s.length;
        let count: number = 0, sum: number = 0;
        const mp: { [key: number]: number } = {};
        mp[0] = 1;
        for (let i = 0; i < n; i++) {
            sum += s.charCodeAt(i) - '0'.charCodeAt(0);
            if (mp[sum - (i + 1)] === undefined) {
                mp[sum - (i + 1)] = 0;
            }
            count += mp[sum - (i + 1)];
            mp[sum - (i + 1)] += 1;
        }
        return count;
    }
  original_instructions: |-
    count the number of substrings with the sum of digits equal to their length
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the array A is a mountain array, which means it first strictly increases to a peak, then strictly decreases.
  id: |-
    hubedit_mbpp_ts_68
  lang: |-
    deno
  modified_code: |-
    export async function main(A: number[]): Promise<boolean> {
        if (A.length < 3) return false;

        let i = 0;

        // walk up
        while (i + 1 < A.length && A[i] < A[i + 1]) {
            i++;
        }

        // peak can't be first or last
        if (i === 0 || i === A.length - 1) return false;

        // walk down
        while (i + 1 < A.length && A[i] > A[i + 1]) {
            i++;
        }

        return i === A.length - 1;
    }
  original_code: |-
    export async function main(A: number[]): Promise<boolean> {
        return (A.every((_, i) => i === A.length - 1 || A[i] <= A[i + 1]) ||
                A.every((_, i) => i === A.length - 1 || A[i] >= A[i + 1]));
    }
  original_instructions: |-
    check whether the given array is monotonic or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if `s` is a subset of `l` regardless of the order of elements, rather than checking if `s` is a contiguous subsequence of `l`.
  id: |-
    hubedit_mbpp_ts_69
  lang: |-
    deno
  modified_code: |-
    export async function main(l: any[], s: any[]): Promise<boolean> {
        let subSet: boolean = true;
        const lSet = new Set(l);
        for (const item of s) {
            if (!lSet.has(item)) {
                subSet = false;
                break;
            }
        }
        return subSet;
    }
  original_code: |-
    export async function main(l: any[], s: any[]): Promise<boolean> {
        let subSet: boolean = false;
        if (s.length === 0) {
            subSet = true;
        } else if (s === l) {
            subSet = true;
        } else if (s.length > l.length) {
            subSet = false;
        } else {
            for (let i = 0; i <= l.length - s.length; i++) {
                if (l[i] === s[0]) {
                    let n: number = 1;
                    while (n < s.length && l[i + n] === s[n]) {
                        n++;
                    }
                    if (n === s.length) {
                        subSet = true;
                        break;
                    }
                }
            }
        }
        return subSet;
    }
  original_instructions: |-
    check whether a list contains the given sublist or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the sum of all even numbers up to `n` instead of a boolean value.
  id: |-
    hubedit_mbpp_ts_72
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        for (let i = 0; i <= n; i += 2) {
            sum += i;
        }
        return sum;
    }
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n % 4 !== 2) {
            return true;
        }
        return false;
    }
  original_instructions: |-
    check whether the given number can be represented as the difference of two squares or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if each pattern is associated with multiple colors, and if so, return false. Otherwise, return true if each pattern is associated with exactly one unique color.
  id: |-
    hubedit_mbpp_ts_74
  lang: |-
    deno
  modified_code: |-
    export async function main(colors: string[], patterns: string[]): Promise<boolean> {
        if (colors.length !== patterns.length) {
            return false;
        }
        const sdict: Record<string, string> = {};

        for (let i = 0; i < patterns.length; i++) {
            const pattern = patterns[i];
            const color = colors[i];

            if (sdict[pattern] && sdict[pattern] !== color) {
                // If the pattern already exists with a different color, return false
                return false;
            }

            sdict[pattern] = color;
        }

        // If we reach this point, each pattern is associated with exactly one unique color
        return true;
    }
  original_code: |-
    export async function main(colors: string[], patterns: string[]): Promise<boolean> {
        if (colors.length !== patterns.length) {
            return false;
        }
        const sdict: Record<string, string[]> = {};
        const pset: Set<string> = new Set();
        const sset: Set<string> = new Set();
        for (let i = 0; i < patterns.length; i++) {
            pset.add(patterns[i]);
            sset.add(colors[i]);
            if (!sdict[patterns[i]]) {
                sdict[patterns[i]] = [];
            }

            let keys = sdict[patterns[i]];
            keys.push(colors[i]);
        }

        if (pset.size !== sset.size) {
            return false;
        }

        for (let values of Object.values(sdict)) {
            for (let i = 0; i < values.length - 1; i++) {
                if (values[i] !== values[i + 1]) {
                    return false;
                }
            }
        }

        return true;
    }
  original_instructions: |-
    check whether it follows the sequence given in the patterns array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return true only if all words in the string have an odd number of characters, otherwise return false.
  id: |-
    hubedit_mbpp_ts_79
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<boolean> {
        const words = s.split(' ');
        for (const word of words) {
            if (word.length % 2 === 0) {
                return false;
            }
        }
        return true;
    }
  original_code: |-
    export async function main(s: string): Promise<boolean> {
        const words = s.split(' ');
        for (const word of words) {
            if (word.length % 2 !== 0) {
                return true;
            }
        }
        return false;
    }
  original_instructions: |-
    check whether the length of the word is odd or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the character positions in the alphabet as a string instead of returning a single character.
  id: |-
    hubedit_mbpp_ts_83
  lang: |-
    deno
  modified_code: |-
    export async function main(strr: string): Promise<string> {
        let summ: number = 0;
        for (let i = 0; i < strr.length; i++) {
            summ += (strr.charCodeAt(i) - 'a'.charCodeAt(0) + 1);
        }
        return summ.toString();
    }
  original_code: |-
    export async function main(strr: string): Promise<string> {
        let summ: number = 0;
        for (let i = 0; i < strr.length; i++) {
            summ += (strr.charCodeAt(i) - 'a'.charCodeAt(0) + 1);
        }
        if (summ % 26 === 0) {
            return 'z';
        } else {
            summ = summ % 26;
            return String.fromCharCode('a'.charCodeAt(0) + summ - 1);
        }
    }
  original_instructions: |-
    find the character made by adding the ASCII value of all the characters of the given string modulo 26
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Add memoization to store and reuse the results of previously computed values to improve the efficiency of the function.
  id: |-
    hubedit_mbpp_ts_84
  lang: |-
    deno
  modified_code: |-
    const memo = new Map<number, number>();

    export async function main(n: number): Promise<number> {
        if (memo.has(n)) {
            return memo.get(n)!;
        }

        let result: number;
        if (n === 1 || n === 2) {
            result = 1;
        } else {
            const prevValue = await main(n - 1);
            result = (await main(prevValue)) + (await main(n - prevValue));
        }

        memo.set(n, result);
        return result;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 1 || n === 2) {
            return 1;
        } else {
            return (await main(await main(n - 1))) + (await main(n - (await main(n - 1))));
        }
    }
  original_instructions: |-
    find the nth number in the newman conway sequence
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the volume of a sphere instead of the surface area.
  id: |-
    hubedit_mbpp_ts_85
  lang: |-
    deno
  modified_code: |-
    export async function main(r: number): Promise<number> {
      const volume: number = (4 / 3) * Math.PI * r * r * r;
      return volume;
    }
  original_code: |-
    export async function main(r: number): Promise<number> {
      const surfaceArea: number = 4 * Math.PI * r * r;
      return surfaceArea;
    }
  original_instructions: |-
    find the surface area of a sphere
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the square of the input number instead of subtracting one.
  id: |-
    hubedit_mbpp_ts_89
  lang: |-
    deno
  modified_code: |-
    export async function main(N: number): Promise<number> {
      return N * N;
    }
  original_code: |-
    export async function main(N: number): Promise<number> {
      return (N - 1);
    }
  original_instructions: |-
    find the closest smaller number than n
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the function to calculate the sum of all divisors of `n` instead of counting them.
  id: |-
    hubedit_mbpp_ts_96
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        return [...Array(n).keys()].map(i => i + 1).filter(i => n % i === 0).reduce((sum, i) => sum + i, 0);
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        return [...Array(n).keys()].map(i => i + 1).filter(i => n % i === 0).length;
    }
  original_instructions: |-
    find the number of divisors of a given integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the hexadecimal representation of the number instead of the binary representation.
  id: |-
    hubedit_mbpp_ts_99
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<string> {
        return n.toString(16);
    }
  original_code: |-
    export async function main(n: number): Promise<string> {
        return n.toString(2);
    }
  original_instructions: |-
    convert the given decimal number to its binary equivalent, represented as a string with no leading zeros
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to reverse the order of the words after splitting them by underscores before joining them back together.
  id: |-
    hubedit_mbpp_ts_102
  lang: |-
    deno
  modified_code: |-
    export async function main(word: string): Promise<string> {
        return word.split('_').reverse().map(x => x.charAt(0).toUpperCase() + x.slice(1)).join('');
    }
  original_code: |-
    export async function main(word: string): Promise<string> {
        return word.split('_').map(x => x.charAt(0).toUpperCase() + x.slice(1)).join('');
    }
  original_instructions: |-
    convert a snake case string to camel case string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the union of all arrays in the nested list instead of the intersection.
  id: |-
    hubedit_mbpp_ts_111
  lang: |-
    deno
  modified_code: |-
    export async function main(nestedList: Array<Array<any>>): Promise<Array<any>> {
        const result = Array.from(new Set(nestedList.flat()));
        return result;
    }
  original_code: |-
    export async function main(nestedList: Array<Array<any>>): Promise<Array<any>> {
        const result = Array.from(new Set(nestedList.reduce((a, b) => a.filter(c => new Set(b).has(c)))));
        return result;
    }
  original_instructions: |-
    find the common elements in given nested lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all the numbers in the array instead of concatenating them into a single number.
  id: |-
    hubedit_mbpp_ts_116
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number> {
        const result = nums.reduce((sum, current) => sum + current, 0);
        return result;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        const result = parseInt(nums.join(''));
        return result;
    }
  original_instructions: |-
    convert a given tuple of positive integers into a single integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the sum of all elements in the array instead of the XOR.
  id: |-
    hubedit_mbpp_ts_119
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        const n = arr.length;
        let sum = 0;
        for (let i = 0; i < n; i++) {
            sum += arr[i];
        }
        return sum;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        const n = arr.length;
        let XOR = 0;
        for (let i = 0; i < n; i++) {
            XOR = XOR ^ arr[i];
        }
        return XOR;
    }
  original_instructions: |-
    find the element that appears only once in a sorted array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all unique prime factors of both numbers instead of the sum of their common divisors.
  id: |-
    hubedit_mbpp_ts_126
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number): Promise<number> {
        const primeFactors = (num: number): number[] => {
            const factors: number[] = [];
            let divisor = 2;

            while (num >= 2) {
                if (num % divisor == 0) {
                    if (!factors.includes(divisor)) {
                        factors.push(divisor);
                    }
                    num = num / divisor;
                } else {
                    divisor++;
                }
            }

            return factors;
        };

        const uniquePrimeFactors = new Set<number>([...primeFactors(a), ...primeFactors(b)]);
        let sum = 0;
        for (let factor of uniquePrimeFactors) {
            sum += factor;
        }

        return sum;
    }
  original_code: |-
    export async function main(a: number, b: number): Promise<number> {
        let main_result = 0;
        for (let i = 1; i <= Math.min(a, b); i++) {
            if (a % i === 0 && b % i === 0) {
                main_result += i;
            }
        }
        return main_result;
    }
  original_instructions: |-
    find the sum of common divisors of two given numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return words that are exactly `n` characters long instead of words that are longer than `n`.
  id: |-
    hubedit_mbpp_ts_128
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number, str: string): Promise<string[]> {
        let word_len: string[] = [];
        let txt = str.split(" ");
        for (let x of txt) {
            if (x.length === n) {
                word_len.push(x);
            }
        }
        return word_len;
    }
  original_code: |-
    export async function main(n: number, str: string): Promise<string[]> {
        let word_len: string[] = [];
        let txt = str.split(" ");
        for (let x of txt) {
            if (x.length > n) {
                word_len.push(x);
            }
        }
        return word_len;
    }
  original_instructions: |-
    find words that are longer than n characters from a given list of words
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the consonants instead of the vowels, leaving the vowels in their original positions.
  id: |-
    hubedit_mbpp_ts_131
  lang: |-
    deno
  modified_code: |-
    export async function main(str1: string): Promise<string> {
        let consonants = "";
        for (const char of str1) {
            if (!"aeiouAEIOU".includes(char)) {
                consonants += char;
            }
        }
        let resultString = "";
        let consonantIndex = consonants.length - 1;
        for (const char of str1) {
            if (!"aeiouAEIOU".includes(char)) {
                resultString += consonants[consonantIndex--];
            } else {
                resultString += char;
            }
        }
        return resultString;
    }
  original_code: |-
    export async function main(str1: string): Promise<string> {
        let vowels = "";
        for (const char of str1) {
            if ("aeiouAEIOU".includes(char)) {
                vowels += char;
            }
        }
        let resultString = "";
        for (const char of str1) {
            if ("aeiouAEIOU".includes(char)) {
                resultString += vowels[vowels.length - 1];
                vowels = vowels.slice(0, -1);
            } else {
                resultString += char;
            }
        }
        return resultString;
    }
  original_instructions: |-
    reverse only the vowels of a given string (where y is not a vowel)
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of elements that are present in all three lists, not just the count of matching positions.
  id: |-
    hubedit_mbpp_ts_142
  lang: |-
    deno
  modified_code: |-
    export async function main(list1: number[], list2: number[], list3: number[]): Promise<number> {
        const commonElements = list1.filter((item) => list2.includes(item) && list3.includes(item));
        const uniqueCommonElements = [...new Set(commonElements)];
        const sum = uniqueCommonElements.reduce((a, b) => a + b, 0);
        return sum;
    }
  original_code: |-
    export async function main(list1: number[], list2: number[], list3: number[]): Promise<number> {
        const result = list1.map((m, i) => m === list2[i] && m === list3[i] ? 1 : 0).reduce((a, b) => a + b, 0);
        return result;
    }
  original_instructions: |-
    count number items that are identical in the same position of three given lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all elements in the array instead of the difference between the maximum and minimum elements.
  id: |-
    hubedit_mbpp_ts_145
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        const n = arr.length;
        let sum = 0;
        for (let i = 0; i < n; i++) {
            sum += arr[i];
        }
        return sum;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        const n = arr.length;
        let minEle = arr[0];
        let maxEle = arr[0];
        for (let i = 1; i < n; i++) {
            minEle = Math.min(minEle, arr[i]);
            maxEle = Math.max(maxEle, arr[i]);
        }
        return (maxEle - minEle);
    }
  original_instructions: |-
    find the maximum difference between any two elements in a given array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `div_sum` function to also include the number itself in the sum of its divisors. Then, update the `main` function to check if the numbers are perfect numbers (where the sum of a number's divisors including itself is equal to twice the number) instead of checking if the sum of their divisors is equal.
  id: |-
    hubedit_mbpp_ts_164
  lang: |-
    deno
  modified_code: |-
    function div_sum(n: number): number {
      let total = n; // Include the number itself in the sum
      let i = 2;

      while (i * i <= n) {
        if (n % i == 0) {
          total += i;
          if (i !== n / i) { // Avoid adding the square root twice if n is a perfect square
            total += n / i;
          }
        }
        i += 1;
      }

      return total;
    }

    export async function main(num1: number, num2: number): Promise<boolean> {
      // Check if the numbers are perfect numbers
      return div_sum(num1) === 2 * num1 && div_sum(num2) === 2 * num2;
    }
  original_code: |-
    function div_sum(n: number): number {
      let total = 1;
      let i = 2;

      while (i * i <= n) {
        if (n % i == 0) {
          total += i + Math.floor(n / i);
        }
        i += 1;
      }

      return total;
    }

    export async function main(num1: number, num2: number): Promise<boolean> {
      return div_sum(num1) === div_sum(num2);
    }
  original_instructions: |-
    determine if the sum of the divisors of two integers are the same
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count only the vowels (A, E, I, O, U, a, e, i, o, u) that are in the correct alphabetical position relative to their ASCII values.
  id: |-
    hubedit_mbpp_ts_165
  lang: |-
    deno
  modified_code: |-
    export async function main(str1: string): Promise<number> {
        let count_chars: number = 0;
        const vowels: string = 'AEIOUaeiou';
        for (let i = 0; i < str1.length; i++) {
            if (vowels.includes(str1[i]) && (i === str1.charCodeAt(i) - 'A'.charCodeAt(0) || i === str1.charCodeAt(i) - 'a'.charCodeAt(0))) {
                count_chars += 1;
            }
        }
        return count_chars;
    }
  original_code: |-
    export async function main(str1: string): Promise<number> {
        let count_chars: number = 0;
        for (let i = 0; i < str1.length; i++) {
            if ((i === str1.charCodeAt(i) - 'A'.charCodeAt(0)) ||
                (i === str1.charCodeAt(i) - 'a'.charCodeAt(0))) {
                count_chars += 1;
            }
        }
        return count_chars;
    }
  original_instructions: |-
    count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive)
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count only pairs where the bitwise XOR of the two numbers is an odd number instead of an even number.
  id: |-
    hubedit_mbpp_ts_166
  lang: |-
    deno
  modified_code: |-
    export async function main(A: number[]): Promise<number> {
      let count = 0;
      for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
          if (((A[i] ^ A[j]) % 2) !== 0) { // Changed === to !== to count odd results
            count += 1;
          }
        }
      }
      return count;
    }
  original_code: |-
    export async function main(A: number[]): Promise<number> {
      let count = 0;
      for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
          if (((A[i] ^ A[j]) % 2) === 0) {
            count += 1;
          }
        }
      }
      return count;
    }
  original_instructions: |-
    counts the number of pairs of integers in a list that xor to an even number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the nearest power of 2 that is less than the given number, instead of the nearest power of 2 that is greater than or equal to the given number.
  id: |-
    hubedit_mbpp_ts_167
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
      if (n <= 1) {
        return 0;
      }

      let count = -1;
      while (n > 1) {
        n >>= 1;
        count += 1;
      }

      return 1 << count;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
      if (n && !(n & (n - 1))) {
        return n;
      }

      let count = 0;
      while (n !== 0) {
        n >>= 1;
        count += 1;
      }

      return 1 << count;
    }
  original_instructions: |-
    find the smallest power of 2 greater than or equal to n
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to return the indices of the array where the element equals x instead of the count.
  id: |-
    hubedit_mbpp_ts_168
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number[], x: number): Promise<number[]> {
        let indices: number[] = [];
        for (let i = 0; i < a.length; i++) {
            if (a[i] === x) {
                indices.push(i);
            }
        }
        return indices;
    }
  original_code: |-
    export async function main(a: number[], x: number): Promise<number> {
        let count = 0;
        for (let i of a) {
            if (i === x) {
                count += 1;
            }
        }
        return count;
    }
  original_instructions: |-
    count the number of occurrences of a number in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the area of a regular pentagon given the side length instead of the perimeter.
  id: |-
    hubedit_mbpp_ts_171
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number): Promise<number> {
      const area: number = (Math.sqrt(5 * (5 + 2 * Math.sqrt(5))) * a * a) / 4;
      return area;
    }
  original_code: |-
    export async function main(a: number): Promise<number> {
      const perimeter: number = (5 * a);
      return perimeter;
    }
  original_instructions: |-
    find the perimeter of a regular pentagon from the length of its sides
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count the number of times the word 'deno' appears in the string instead of the sequence 'std'.
  id: |-
    hubedit_mbpp_ts_172
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<number> {
      let count = 0;
      for (let i = 0; i < s.length - 3; i++) {
        if (s[i] === 'd' && s[i + 1] === 'e' && s[i + 2] === 'n' && s[i + 3] === 'o') {
          count = count + 1;
        }
      }
      return count;
    }
  original_code: |-
    export async function main(s: string): Promise<number> {
      let count = 0;
      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === 's' && s[i + 1] === 't' && s[i + 2] === 'd') {
          count = count + 1;
        }
      }
      return count;
    }
  original_instructions: |-
    count the number of occurence of the string 'std' in a given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count the number of zero bits instead of one bits in the binary representation of the input number.
  id: |-
    hubedit_mbpp_ts_224
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let count = 0;
        while (n) {
            if ((n & 1) === 0) {
                count++;
            }
            n >>= 1;
        }
        // Count the leading zeros since the loop stops when n becomes 0
        const totalBits = 32; // Assuming we're dealing with 32-bit integers
        const leadingZeros = totalBits - Math.floor(Math.log2(n) + 1);
        count += leadingZeros;
        return count;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let count = 0;
        while (n) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
  original_instructions: |-
    count the number of set bits (binary digits with value 1) in a given number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return every third character of the string instead of every second character.
  id: |-
    hubedit_mbpp_ts_226
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<string> {
      let result = "";
      for (let i = 0; i < s.length; i++) {
        if (i % 3 === 2) { // Changed from i % 2 === 0 to i % 3 === 2 to get every third character
          result += s[i];
        }
      }
      return result;
    }
  original_code: |-
    export async function main(s: string): Promise<string> {
      let result = "";
      for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0) {
          result += s[i];
        }
      }
      return result;
    }
  original_instructions: |-
    remove the characters which have odd index values of a given string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the average of the three numbers instead of finding the smallest.
  id: |-
    hubedit_mbpp_ts_227
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
      const average: number = (a + b + c) / 3;
      return average;
    }
  original_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
      let smallest: number;
      if (a <= b && a <= c) {
        smallest = a;
      } else if (b <= a && b <= c) {
        smallest = b;
      } else {
        smallest = c;
      }
      return smallest;
    }
  original_instructions: |-
    find minimum of three numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Add a function to calculate the total surface area of the cylinder, including the top and bottom circles, and return this value instead of just the lateral surface area.
  id: |-
    hubedit_mbpp_ts_233
  lang: |-
    deno
  modified_code: |-
    export async function main(r: number, h: number): Promise<number> {
        const lateralSurface: number = 2 * Math.PI * r * h;
        const baseArea: number = Math.PI * r * r;
        const totalSurfaceArea: number = lateralSurface + 2 * baseArea;
        return totalSurfaceArea;
    }
  original_code: |-
    export async function main(r: number, h: number): Promise<number> {
        const lateralsurface: number = 2 * 3.1415 * r * h;
        return lateralsurface;
    }
  original_instructions: |-
    find the lateral surface area of a cylinder
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the base case for when `j == 1` to return a constant value other than `i`, such as `1`. This will alter the computations for all subsequent cells in the table.
  id: |-
    hubedit_mbpp_ts_239
  lang: |-
    deno
  modified_code: |-
    export async function main(m: number, n: number): Promise<number> {
        let T: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) {
            for (let j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    T[i][j] = 0;
                } else if (i < j) {
                    T[i][j] = 0;
                } else if (j == 1) {
                    T[i][j] = 1; // Changed from i to 1
                } else {
                    T[i][j] = T[i - 1][j] + T[Math.floor(i / 2)][j - 1];
                }
            }
        }
        return T[m][n];
    }
  original_code: |-
    export async function main(m: number, n: number): Promise<number> {
        let T: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) {
            for (let j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    T[i][j] = 0;
                } else if (i < j) {
                    T[i][j] = 0;
                } else if (j == 1) {
                    T[i][j] = i;
                } else {
                    T[i][j] = T[i - 1][j] + T[Math.floor(i / 2)][j - 1];
                }
            }
        }
        return T[m][n];
    }
  original_instructions: |-
    takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of vowels in the input string instead of counting all characters.
  id: |-
    hubedit_mbpp_ts_242
  lang: |-
    deno
  modified_code: |-
    export async function main(str1: string): Promise<number> {
        let total = 0;
        const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
        for (const char of str1) {
            if (vowels.has(char)) {
                total += 1;
            }
        }
        return total;
    }
  original_code: |-
    export async function main(str1: string): Promise<number> {
        let total = 0;
        for (const i of str1) {
            total = total + 1;
        }
        return total;
    }
  original_instructions: |-
    count the total number of characters in a string
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the cube root instead of the square root by adjusting the iterative method to use the cube root approximation formula.
  id: |-
    hubedit_mbpp_ts_246
  lang: |-
    deno
  modified_code: |-
    export async function main(number: number): Promise<number> {
        if (number === 0) {
            return 0;
        }
        let g: number = number / 3.0;
        let g2: number = g + 1;
        while (g !== g2) {
            const n: number = number / (g * g);
            g2 = g;
            g = (2 * g + n) / 3;
        }
        return g;
    }
  original_code: |-
    export async function main(number: number): Promise<number> {
        if (number === 0) {
            return 0;
        }
        let g: number = number / 2.0;
        let g2: number = g + 1;
        while (g !== g2) {
            const n: number = number / g;
            g2 = g;
            g = (g + n) / 2;
        }
        return g;
    }
  original_instructions: |-
    Write a function for computing square roots using the babylonian method
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the factorial of the number n instead of the current harmonic series.
  id: |-
    hubedit_mbpp_ts_248
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        if (n <= 1) {
            return 1;
        } else {
            return n * await main(n - 1);
        }
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n < 2) {
            return 1.0;
        } else {
            return 1 / n + await main(n - 1);
        }
    }
  original_instructions: |-
    takes in an integer n and calculates the harmonic sum of n-1
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the indices of the array where the element `x` is found, instead of the count.
  id: |-
    hubedit_mbpp_ts_250
  lang: |-
    deno
  modified_code: |-
    export async function main(tup: any[], x: any): Promise<number[]> {
        let indices: number[] = [];
        for (let i = 0; i < tup.length; i++) {
            if (tup[i] === x) {
                indices.push(i);
            }
        }
        return indices;
    }
  original_code: |-
    export async function main(tup: any[], x: any): Promise<number> {
        let count = 0;
        for (const ele of tup) {
            if (ele === x) {
                count = count + 1;
            }
        }
        return count;
    }
  original_instructions: |-
    takes in a tuple and an element and counts the occcurences of the element in the tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count and return the number of composite (non-prime) numbers instead of prime numbers within the given range.
  id: |-
    hubedit_mbpp_ts_256
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let ctr = 0;
        for (let num = 2; num < n; num++) { // Start from 2, as 0 and 1 are not composite
            let isComposite = false;
            for (let i = 2; i < num; i++) { // Check divisibility from 2 to num-1
                if (num % i === 0) {
                    isComposite = true;
                    break;
                }
            }
            if (isComposite) {
                ctr++;
            }
        }
        return ctr;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let ctr = 0;
        for (let num = 0; num < n; num++) {
            if (num <= 1) {
                continue;
            }
            let isPrime = true;
            for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {
                if (num % i === 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                ctr++;
            }
        }
        return ctr;
    }
  original_instructions: |-
    takes in a non-negative number and returns the number of prime numbers less than the given non-negative number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Introduce memoization to store and reuse the results of previously computed values to optimize the function's performance.
  id: |-
    hubedit_mbpp_ts_260
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number, memo: Map<number, number> = new Map()): Promise<number> {
        if (n === 0 || n === 1) {
            return 1;
        }
        if (memo.has(n)) {
            return memo.get(n)!;
        }
        const result = 2 * await main(n - 1, memo) + await main(n - 2, memo);
        memo.set(n, result);
        return result;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 0 || n === 1) {
            return 1;
        }
        return 2 * await main(n - 1) + await main(n - 2);
    }
  original_instructions: "find the nth newman\u2013shanks\u2013williams prime number"
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the remainder of the division instead of the quotient by using the modulus operator (%) instead of the division operator (/).
  id: |-
    hubedit_mbpp_ts_261
  lang: |-
    deno
  modified_code: |-
    export async function main(test_tup1: number[], test_tup2: number[]): Promise<number[]> {
        const res: number[] = test_tup1.map((ele1, index) => ele1 % test_tup2[index]);
        return res;
    }
  original_code: |-
    export async function main(test_tup1: number[], test_tup2: number[]): Promise<number[]> {
        const res: number[] = test_tup1.map((ele1, index) => Math.floor(ele1 / test_tup2[index]));
        return res;
    }
  original_instructions: |-
    takes in two tuples and performs mathematical division operation element-wise across the given tuples
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to include a check for non-numeric input and throw an error if the input is not a number. Additionally, change the calculation to account for dog breeds with different aging rates.
  id: |-
    hubedit_mbpp_ts_264
  lang: |-
    deno
  modified_code: |-
    export async function main(h_age: any): Promise<number> {
        if (typeof h_age !== 'number' || isNaN(h_age)) {
            throw new Error('Input must be a numeric value.');
        }

        if (h_age < 0) {
            throw new Error('Human age cannot be negative.');
        }

        let d_age: number;
        // Assuming the breed is a small dog breed with a different aging rate
        const smallBreedMultiplier = 12.5;
        const largeBreedMultiplier = 9.0;
        const breed = 'small'; // This could be dynamic based on actual breed input

        if (h_age <= 2) {
            d_age = h_age * (breed === 'small' ? smallBreedMultiplier : largeBreedMultiplier);
        } else {
            // Assuming the first two years are the same for all breeds
            d_age = 2 * (breed === 'small' ? smallBreedMultiplier : largeBreedMultiplier);
            // Adjust the multiplier for subsequent years based on the breed
            d_age += (h_age - 2) * (breed === 'small' ? 4 : 5);
        }

        return d_age;
    }
  original_code: |-
    export async function main(h_age: number): Promise<number> {
        if (h_age < 0) {
            process.exit();
        }

        let d_age: number;
        if (h_age <= 2) {
            d_age = h_age * 10.5;
        } else {
            d_age = 21 + (h_age - 2) * 4;
        }

        return d_age;
    }
  original_instructions: |-
    calculate a dog's age in dog's years
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to sum only the odd-indexed elements of the array instead of the even-indexed elements.
  id: |-
    hubedit_mbpp_ts_270
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        let sum = 0;
        for (let i = 1; i < arr.length; i += 2) {
            sum += arr[i];
        }
        return sum;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let sum = 0;
        for (let i = 0; i < arr.length; i += 2) {
            if (arr[i] % 2 === 0) {
                sum += arr[i];
            }
        }
        return sum;
    }
  original_instructions: |-
    find the sum of even numbers at even positions of a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of the given number n instead of calculating 2 to the power of (n - 1).
  id: |-
    hubedit_mbpp_ts_274
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let factorial = 1;
        for (let i = 2; i <= n; i++) {
            factorial *= i;
        }
        return factorial;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        return (1 << (n - 1));
    }
  original_instructions: |-
    takes in a positive integer n and finds the sum of even index binomial coefficients
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the surface area of a cylinder instead of the volume.
  id: |-
    hubedit_mbpp_ts_276
  lang: |-
    deno
  modified_code: |-
    export async function main(r: number, h: number): Promise<number> {
      const surfaceArea: number = 2 * 3.1415 * r * (r + h);
      return surfaceArea;
    }
  original_code: |-
    export async function main(r: number, h: number): Promise<number> {
      const volume: number = 3.1415 * r * r * h;
      return volume;
    }
  original_instructions: |-
    takes in the radius and height of a cylinder and returns the the volume
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the script to count the number of elements that are not arrays, and continue counting even after encountering the first array in the list.
  id: |-
    hubedit_mbpp_ts_278
  lang: |-
    deno
  modified_code: |-
    export async function main(test_tup: any[]): Promise<number> {
        let count: number = 0;
        for (const ele of test_tup) {
            if (!(ele instanceof Array)) {
                count++;
            }
        }
        return count;
    }
  original_code: |-
    export async function main(test_tup: any[]): Promise<number> {
        let count: number = 0;
        for (const ele of test_tup) {
            if (ele instanceof Array) {
                break;
            }
            count++;
        }
        return count;
    }
  original_instructions: |-
    find the number of elements that occurs before the tuple element in the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a conditional statement to check if the input number is even or odd, and if it's even, return the current calculation, but if it's odd, return the square of the input number.
  id: |-
    hubedit_mbpp_ts_279
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        if (n % 2 === 0) {
            return 4 * n * n - 3 * n;
        } else {
            return n * n;
        }
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        return 4 * n * n - 3 * n;
    }
  original_instructions: |-
    find the nth decagonal number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if all elements in the list are of the same type, returning true if they are and false otherwise.
  id: |-
    hubedit_mbpp_ts_281
  lang: |-
    deno
  modified_code: |-
    export async function main(test_list: any[]): Promise<boolean> {
        if (test_list.length === 0) {
            return true; // Empty list, all elements can be considered the same type
        }

        const firstType = typeof test_list[0];
        return test_list.every(item => typeof item === firstType);
    }
  original_code: |-
    export async function main(test_list: any[]): Promise<boolean> {
        if (test_list.length > new Set(test_list).size) {
            return false;
        }
        return true;
    }
  original_instructions: |-
    check if the elements of a given list are unique or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the occurrences of each digit in the number and return the sum of all counts instead of a boolean.
  id: |-
    hubedit_mbpp_ts_283
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let sumOfCounts = 0;
        for (let i = 0; i < 10; i++) {
            let temp = n;
            let count = 0;
            while (temp) {
                if (temp % 10 === i) {
                    count += 1;
                }
                temp = Math.floor(temp / 10);
            }
            sumOfCounts += count;
        }
        return sumOfCounts;
    }
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        for (let i = 0; i < 10; i++) {
            let temp = n;
            let count = 0;
            while (temp) {
                if (temp % 10 === i) {
                    count += 1;
                }
                if (count > i) {
                    return false;
                }
                temp = Math.floor(temp / 10);
            }
        }
        return true;
    }
  original_instructions: |-
    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the minimum contiguous subarray sum instead of the maximum by initializing `min_so_far` with a large positive value and updating it when `min_ending_here` is less than `min_so_far`.
  id: |-
    hubedit_mbpp_ts_286
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number[], n: number, k: number): Promise<number> {
        let min_so_far: number = 2147483647;
        let min_ending_here: number = 0;
        for (let i = 0; i < n * k; i++) {
            min_ending_here = min_ending_here + a[i % n];
            if (min_so_far > min_ending_here) {
                min_so_far = min_ending_here;
            }
            if (min_ending_here > 0) {
                min_ending_here = 0;
            }
        }
        return min_so_far;
    }
  original_code: |-
    export async function main(a: number[], n: number, k: number): Promise<number> {
        let max_so_far: number = -2147483648;
        let max_ending_here: number = 0;
        for (let i = 0; i < n * k; i++) {
            max_ending_here = max_ending_here + a[i % n];
            if (max_so_far < max_ending_here) {
                max_so_far = max_ending_here;
            }
            if (max_ending_here < 0) {
                max_ending_here = 0;
            }
        }
        return max_so_far;
    }
  original_instructions: |-
    find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the base cases for the dynamic programming array to different values, which will alter the sequence generated for `dp`.
  id: |-
    hubedit_mbpp_ts_291
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number, k: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        const total: number = k;
        const mod: number = 1000000007;
        // Changed base cases
        dp[1] = k + 1; // New base case for dp[1]
        dp[2] = (k * k) + 1; // New base case for dp[2]
        for (let i = 3; i <= n; i++) {
            dp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod;
        }
        return dp[n];
    }
  original_code: |-
    export async function main(n: number, k: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        const total: number = k;
        const mod: number = 1000000007;
        dp[1] = k;
        dp[2] = k * k;
        for (let i = 3; i <= n; i++) {
            dp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod;
        }
        return dp[n];
    }
  original_instructions: |-
    find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the remainder of the division instead of the quotient.
  id: |-
    hubedit_mbpp_ts_292
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number, m: number): Promise<number> {
        let r = n % m;
        return r;
    }
  original_code: |-
    export async function main(n: number, m: number): Promise<number> {
        let q = Math.floor(n / m);
        return q;
    }
  original_instructions: |-
    find quotient of two numbers (rounded down to the nearest integer)
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the perimeter of the rectangle instead of the diagonal.
  id: |-
    hubedit_mbpp_ts_293
  lang: |-
    deno
  modified_code: |-
    export async function main(w: number, h: number): Promise<number> {
      const p: number = 2 * (w + h);
      return p;
    }
  original_code: |-
    export async function main(w: number, h: number): Promise<number> {
      const s: number = Math.sqrt((w * w) + (h * h));
      return s;
    }
  original_instructions: |-
    find the third side of a right angled triangle
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all the numbers in the list instead of finding the maximum value.
  id: |-
    hubedit_mbpp_ts_294
  lang: |-
    deno
  modified_code: |-
    export async function main(listval: Array<number>): Promise<number> {
        const sum = listval.reduce((acc, val) => acc + val, 0);
        return sum;
    }
  original_code: |-
    export async function main(listval: Array<number>): Promise<number> {
        const main = Math.max(...listval.filter(i => typeof i === 'number'));
        return main;
    }
  original_instructions: |-
    find the maximum value in a given heterogeneous list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of pairs (i, j) such that arr[i] is exactly twice as large as arr[j].
  id: |-
    hubedit_mbpp_ts_296
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        let pair_count = 0;
        for (let i = 0; i < arr.length; i++) {
            for (let j = 0; j < arr.length; j++) {
                if (arr[i] === 2 * arr[j]) {
                    pair_count++;
                }
            }
        }
        return pair_count;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let inv_count = 0;
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    inv_count++;
                }
            }
        }
        return inv_count;
    }
  original_instructions: |-
    count inversions in an array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the cubes of the binomial coefficients instead of the squares.
  id: |-
    hubedit_mbpp_ts_300
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let nCr: number = 1;
        let res: number = 1;
        for (let r = 1; r <= n; r++) {
            nCr = (nCr * (n + 1 - r)) / r;
            res += Math.pow(nCr, 3);
        }
        return res;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let nCr: number = 1;
        let res: number = 1;
        for (let r = 1; r <= n; r++) {
            nCr = (nCr * (n + 1 - r)) / r;
            res += nCr * nCr;
        }
        return res;
    }
  original_instructions: |-
    find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to perform the rotations in the opposite direction, shifting the elements to the right instead of to the left within the specified range.
  id: |-
    hubedit_mbpp_ts_304
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[], ranges: [number, number][], rotations: number, index: number): Promise<number> {
        for (let i = rotations - 1; i >= 0; i--) {
            const [left, right] = ranges[i];
            if (left <= index && right >= index) {
                if (index === right) {
                    index = left;
                } else {
                    index += 1;
                }
            }
        }
        return arr[index];
    }
  original_code: |-
    export async function main(arr: number[], ranges: [number, number][], rotations: number, index: number): Promise<number> {
        for (let i = rotations - 1; i >= 0; i--) {
            const [left, right] = ranges[i];
            if (left <= index && right >= index) {
                if (index === left) {
                    index = right;
                } else {
                    index -= 1;
                }
            }
        }
        return arr[index];
    }
  original_instructions: |-
    find element at a given index after number of rotations
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the maximum sum of a subsequence where each element in the subsequence is strictly greater than the previous element and the subsequence length is exactly `k`.
  id: |-
    hubedit_mbpp_ts_306
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number[], n: number, k: number): Promise<number> {
        const dp: number[][] = Array.from({ length: k }, () => Array(n).fill(0));

        // Initialize the first row of the dp array
        for (let i = 0; i < n; i++) {
            dp[0][i] = a[i];
        }

        // Build the dp array
        for (let i = 1; i < k; i++) {
            for (let j = 0; j < n; j++) {
                dp[i][j] = 0;
                for (let p = 0; p < j; p++) {
                    if (a[p] < a[j]) {
                        dp[i][j] = Math.max(dp[i][j], dp[i - 1][p] + a[j]);
                    }
                }
            }
        }

        // Find the maximum sum of a subsequence of length k
        let maxSum = 0;
        for (let i = 0; i < n; i++) {
            maxSum = Math.max(maxSum, dp[k - 1][i]);
        }

        return maxSum;
    }
  original_code: |-
    export async function main(a: number[], n: number, index: number, k: number): Promise<number> {
        const dp: number[][] = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            if (a[i] > a[0]) {
                dp[0][i] = a[i] + a[0];
            } else {
                dp[0][i] = a[i];
            }
        }
        for (let i = 1; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (a[j] > a[i] && j > i) {
                    if (dp[i - 1][i] + a[j] > dp[i - 1][j]) {
                        dp[i][j] = dp[i - 1][i] + a[j];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[index][k];
    }
  original_instructions: "find the maximum sum of increasing subsequence from prefix\
    \ until ith index and also including a given kth element which is after i, i.e.,\
    \ k > i "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the volume of a cylinder instead of a cone by removing the (1.0 / 3) factor from the volume calculation.
  id: |-
    hubedit_mbpp_ts_312
  lang: |-
    deno
  modified_code: |-
    export async function main(r: number, h: number): Promise<number> {
      const volume: number = Math.PI * r * r * h;
      return volume;
    }
  original_code: |-
    export async function main(r: number, h: number): Promise<number> {
      const volume: number = (1.0 / 3) * Math.PI * r * r * h;
      return volume;
    }
  original_instructions: |-
    find the volume of a cone
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Introduce memoization to store and reuse the results of previously computed values to optimize the function and reduce the number of recursive calls.
  id: |-
    hubedit_mbpp_ts_389
  lang: |-
    deno
  modified_code: |-
    const memo = new Map<number, number>();

    export async function main(n: number): Promise<number> {
        if (memo.has(n)) {
            return memo.get(n)!;
        }
        if (n === 0) {
            memo.set(n, 2);
            return 2;
        }
        if (n === 1) {
            memo.set(n, 1);
            return 1;
        }
        const result = (await main(n - 1)) + (await main(n - 2));
        memo.set(n, result);
        return result;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 0) {
            return 2;
        }
        if (n === 1) {
            return 1;
        }
        return (await main(n - 1)) + (await main(n - 2));
    }
  original_instructions: |-
    find the n'th lucas number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the Fibonacci sequence instead of the current algorithm by modifying the push operation inside the loop to add the last two elements of the array.
  id: |-
    hubedit_mbpp_ts_392
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        const res: number[] = [0, 1];
        for (let i = 2; i <= n; i++) {
            res.push(res[i - 1] + res[i - 2]);
        }
        return res[n];
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        const res: number[] = [];
        res.push(0);
        res.push(1);
        let i = 2;
        while (i < n + 1) {
            res.push(Math.max(i, (res[Math.floor(i / 2)]
                                + res[Math.floor(i / 3)] +
                                    res[Math.floor(i / 4)]
                                + res[Math.floor(i / 5)])));
            i = i + 1;
        }
        return res[n];
    }
  original_instructions: |-
    find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the regular expression to match strings that contain at least one digit and modify the function to return "Contains digit" if such a string is found.
  id: |-
    hubedit_mbpp_ts_396
  lang: |-
    deno
  modified_code: |-
    export async function main(string: string): Promise<string> {
        const regex = /\d/;
        if (regex.test(string)) {
            return "Contains digit";
        } else {
            return "Invalid";
        }
    }
  original_code: |-
    export async function main(string: string): Promise<string> {
        const regex = /^[a-z]$|^([a-z]).*\1$/;
        if (regex.test(string)) {
            return "Valid";
        } else {
            return "Invalid";
        }
    }
  original_instructions: |-
    check whether the given string starts and ends with the same character or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the sum of the two numbers instead of the smaller one.
  id: |-
    hubedit_mbpp_ts_404
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number): Promise<number> {
        return a + b;
    }
  original_code: |-
    export async function main(a: number, b: number): Promise<number> {
        if (a <= b) {
            return a;
        } else {
            return b;
        }
    }
  original_instructions: |-
    find the minimum of two numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the bitwise XOR operations to bitwise AND operations to alter the way the number is manipulated before checking the last bit.
  id: |-
    hubedit_mbpp_ts_406
  lang: |-
    deno
  modified_code: |-
    export async function main(x: number): Promise<boolean> {
        let y = x & (x >> 1);
        y = y & (y >> 2);
        y = y & (y >> 4);
        y = y & (y >> 8);
        y = y & (y >> 16);
        return (y & 1) === 1;
    }
  original_code: |-
    export async function main(x: number): Promise<boolean> {
        let y = x ^ (x >> 1);
        y = y ^ (y >> 2);
        y = y ^ (y >> 4);
        y = y ^ (y >> 8);
        y = y ^ (y >> 16);
        return (y & 1) === 1;
    }
  original_instructions: |-
    find whether the parity of a given number is odd
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the script to calculate the factorial of the number `n` instead of the sum of cubes.
  id: |-
    hubedit_mbpp_ts_420
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let factorial = 1;
        for (let i = 1; i <= n; i++) {
            factorial *= i;
        }
        return factorial;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += Math.pow(2 * i, 3);
        }
        return sum;
    }
  original_instructions: |-
    find the cube sum of first n even natural numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to calculate the discriminant of a quadratic equation ax^2 + bx + c instead of the directrix, and return whether the roots are real, complex, or equal based on the discriminant value.
  id: |-
    hubedit_mbpp_ts_430
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number, c: number): Promise<string> {
        const discriminant: number = (b * b) - (4 * a * c);
        if (discriminant > 0) {
            return 'real';
        } else if (discriminant === 0) {
            return 'equal';
        } else {
            return 'complex';
        }
    }
  original_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
        const directrix: number = Math.floor(c - ((b * b) + 1) * 4 * a);
        return directrix;
    }
  original_instructions: |-
    find the directrix of a parabola
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check if the given number is smaller than the smallest number in the array instead of checking if it's greater than the largest number.
  id: |-
    hubedit_mbpp_ts_433
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[], number: number): Promise<boolean> {
      arr.sort((a, b) => a - b);
      return number < arr[0];
    }
  original_code: |-
    export async function main(arr: number[], number: number): Promise<boolean> {
      arr.sort((a, b) => a - b);
      return number > arr[arr.length - 1];
    }
  original_instructions: |-
    check whether the entered number is greater than the elements of the given array
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the sum of all digits in the given number instead of the remainder when the number is divided by 10.
  id: |-
    hubedit_mbpp_ts_435
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        while (n > 0) {
            sum += n % 10;
            n = Math.floor(n / 10);
        }
        return sum;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        return (n % 10);
    }
  original_instructions: |-
    find the last digit of a given number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all the numbers in the array L instead of concatenating them into a single number.
  id: |-
    hubedit_mbpp_ts_439
  lang: |-
    deno
  modified_code: |-
    export async function main(L: number[]): Promise<number> {
      const sum: number = L.reduce((acc, current) => acc + current, 0);
      return sum;
    }
  original_code: |-
    export async function main(L: number[]): Promise<number> {
      const x: number = parseInt(L.map(String).join(""));
      return x;
    }
  original_instructions: |-
    join a list of multiple integers into a single integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the volume of a cube instead of the surface area by multiplying the length `l` by itself three times.
  id: |-
    hubedit_mbpp_ts_441
  lang: |-
    deno
  modified_code: |-
    export async function main(l: number): Promise<number> {
      const volume: number = l * l * l;
      return volume;
    }
  original_code: |-
    export async function main(l: number): Promise<number> {
      const surfacearea: number = 6 * l * l;
      return surfacearea;
    }
  original_instructions: |-
    find the surface area of a cube of a given size
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the average of the positive numbers instead of the proportion of positive numbers to the total count.
  id: |-
    hubedit_mbpp_ts_442
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number> {
        const positiveNums = nums.filter(x => x > 0);
        const sumPositiveNums = positiveNums.reduce((acc, x) => acc + x, 0);
        const average = positiveNums.length > 0 ? sumPositiveNums / positiveNums.length : 0;
        return parseFloat(average.toFixed(2));
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        const n = nums.length;
        let n1 = 0;
        for (const x of nums) {
            if (x > 0) {
                n1 += 1;
            }
        }
        return parseFloat((n1 / n).toFixed(2));
    }
  original_instructions: |-
    find the ration of positive numbers in an array of integers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the square root of each number in the array instead of the cube.
  id: |-
    hubedit_mbpp_ts_447
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        const main: number[] = nums.map(x => Math.sqrt(x));
        return main;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        const main: number[] = nums.map(x => x ** 3);
        return main;
    }
  original_instructions: |-
    find cubes of individual elements in a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of the input number instead of its current operation.
  id: |-
    hubedit_mbpp_ts_448
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        if (n < 0) {
            throw new Error("Factorial is not defined for negative numbers");
        }
        let factorial: number = 1;
        for (let i: number = 2; i <= n; i++) {
            factorial *= i;
        }
        return factorial;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let a: number = 3;
        let b: number = 0;
        let c: number = 2;
        if (n === 0) {
            return 3;
        }
        if (n === 1) {
            return 3;
        }
        if (n === 2) {
            return 5;
        }
        let sum: number = 5;
        while (n > 2) {
            let d: number = a + b;
            sum = sum + d;
            a = b;
            b = c;
            c = d;
            n = n - 1;
        }
        return sum;
    }
  original_instructions: |-
    calculate the sum of perrin numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of all prime factors of the input number instead of the current calculation.
  id: |-
    hubedit_mbpp_ts_453
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        // Count the number of 2s that divide n
        while (n % 2 === 0) {
            sum += 2;
            n = n / 2;
        }
        // n must be odd at this point. So a skip of 2 (i = i + 2) can be used
        for (let i = 3; i <= Math.sqrt(n); i = i + 2) {
            // While i divides n, add i and divide n
            while (n % i === 0) {
                sum += i;
                n = n / i;
            }
        }
        // This condition is to handle the case when n is a prime number
        // greater than 2
        if (n > 2) {
            sum += n;
        }
        return sum;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n % 2 !== 0) {
            return 0;
        }
        let res = 1;
        for (let i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {
            let count = 0;
            let curr_sum = 1;
            let curr_term = 1;
            while (n % i === 0) {
                count++;
                n = Math.floor(n / i);
                if (i === 2 && count === 1) {
                    curr_sum = 0;
                }
                curr_term *= i;
                curr_sum += curr_term;
            }
            res *= curr_sum;
        }
        if (n >= 2) {
            res *= (1 + n);
        }
        return res;
    }
  original_instructions: |-
    find the sum of even factors of a number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the regular expression pattern to match strings that contain at least two consecutive vowels instead of the current pattern which looks for a 'z' followed by any character.
  id: |-
    hubedit_mbpp_ts_454
  lang: |-
    deno
  modified_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = '[aeiou]{2,}';
        return new RegExp(patterns, 'i').test(text);
    }
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = '\\w*z.\\w*';
        return new RegExp(patterns).test(text);
    }
  original_instructions: |-
    matches a word containing 'z'
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the minimum product subarray instead of the maximum product subarray by initializing `mpis` with positive infinity values, changing the comparison to check for a smaller product, and returning the minimum value from `mpis` at the end.
  id: |-
    hubedit_mbpp_ts_468
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
      const n: number = arr.length;
      const mpis: number[] = new Array(n).fill(Number.POSITIVE_INFINITY);
      for (let i = 0; i < n; i++) {
        let current_prod: number = arr[i];
        let j: number = i + 1;
        mpis[i] = Math.min(mpis[i], current_prod); // Initialize mpis[i] with arr[i]
        while (j < n) {
          if (arr[j - 1] > arr[j]) {
            break;
          }
          current_prod *= arr[j];
          if (current_prod < mpis[j]) {
            mpis[j] = current_prod;
          }
          j++;
        }
      }
      return Math.min(...mpis);
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
      const n: number = arr.length;
      const mpis: number[] = arr.slice();
      for (let i = 0; i < n; i++) {
        let current_prod: number = arr[i];
        let j: number = i + 1;
        while (j < n) {
          if (arr[j - 1] > arr[j]) {
            break;
          }
          current_prod *= arr[j];
          if (current_prod > mpis[j]) {
            mpis[j] = current_prod;
          }
          j++;
        }
      }
      return Math.max(...mpis);
    }
  original_instructions: |-
    find the maximum product formed by multiplying numbers of an increasing subsequence of that array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the cumulative sum of the array elements, where each element in the result is the sum of all previous elements in the input array up to the current index.
  id: |-
    hubedit_mbpp_ts_470
  lang: |-
    deno
  modified_code: |-
    export async function main(test_tup: number[]): Promise<number[]> {
        const res: number[] = [];
        test_tup.reduce((acc, curr, index) => {
            const sum = acc + curr;
            res.push(sum);
            return sum;
        }, 0);
        return res;
    }
  original_code: |-
    export async function main(test_tup: number[]): Promise<number[]> {
        const res = test_tup.slice(0, -1).map((value, index) => value + test_tup[index + 1]);
        return res;
    }
  original_instructions: |-
    find the pairwise addition of the neighboring elements of the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check if the list contains duplicate numbers by comparing the length of the original list with the length of a Set created from the list.
  id: |-
    hubedit_mbpp_ts_472
  lang: |-
    deno
  modified_code: |-
    export async function main(l: number[]): Promise<boolean> {
        const setFromList = new Set(l);
        return l.length === setFromList.size;
    }
  original_code: |-
    export async function main(l: number[]): Promise<boolean> {
        const sortedList = [...l].sort((a, b) => a - b);
        const rangeList = Array.from({ length: Math.max(...l) - Math.min(...l) + 1 }, (_, i) => i + Math.min(...l));
        return JSON.stringify(sortedList) === JSON.stringify(rangeList);
    }
  original_instructions: |-
    check whether the given list contains consecutive numbers or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the average of the numbers in the array instead of the sum of the maximum and minimum values.
  id: |-
    hubedit_mbpp_ts_476
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: Array<number>): Promise<number> {
        const sum: number = nums.reduce((acc, val) => acc + val, 0);
        const average: number = sum / nums.length;
        return average;
    }
  original_code: |-
    export async function main(nums: Array<number>): Promise<number> {
        const sumValue: number = Math.max(...nums) + Math.min(...nums);
        return sumValue;
    }
  original_instructions: |-
    find the sum of the largest and smallest value in a given array
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return an array containing only the even numbers from the input array instead of the odd numbers.
  id: |-
    hubedit_mbpp_ts_554
  lang: |-
    deno
  modified_code: |-
    export async function main(numbers: number[]): Promise<number[]> {
        let ev_li: number[] = [];
        for (let i of numbers) {
            if (i % 2 === 0) {
                ev_li.push(i);
            }
        }
        return ev_li;
    }
  original_code: |-
    export async function main(numbers: number[]): Promise<number[]> {
        let od_li: number[] = [];
        for (let i of numbers) {
            if (i % 2 !== 0) {
                od_li.push(i);
            }
        }
        return od_li;
    }
  original_instructions: |-
    Write a python function which takes a list of integers and only returns the odd ones
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the product of the digits of the number instead of the sum.
  id: |-
    hubedit_mbpp_ts_566
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
      if (n === 0) {
        return 1;
      } else {
        const digit = n % 10;
        return (digit === 0 ? 1 : digit) * await main(Math.floor(n / 10));
      }
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
      if (n === 0) {
        return 0;
      } else {
        return n % 10 + await main(Math.floor(n / 10));
      }
    }
  original_instructions: |-
    get the sum of the digits of a non-negative integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the array is sorted in descending order instead of ascending order.
  id: |-
    hubedit_mbpp_ts_567
  lang: |-
    deno
  modified_code: |-
    export async function main(list1: number[]): Promise<boolean> {
        const result = list1.every((value, index, array) => index === 0 || array[index - 1] >= value);
        return result;
    }
  original_code: |-
    export async function main(list1: number[]): Promise<boolean> {
        const result = list1.every((value, index, array) => index === 0 || array[index - 1] <= value);
        return result;
    }
  original_instructions: |-
    check whether a specified list is sorted or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to fill each object in the array with a unique identifier property, such as an incrementing number or a UUID.
  id: |-
    hubedit_mbpp_ts_568
  lang: |-
    deno
  modified_code: |-
    import { v4 as uuidv4 } from "https://deno.land/std/uuid/mod.ts";

    export async function main(length: number): Promise<Record<string, any>[]> {
        const main: Record<string, any>[] = Array.from({ length }, () => ({ id: uuidv4() }));
        return main;
    }
  original_code: |-
    export async function main(length: number): Promise<Record<string, any>[]> {
        const main: Record<string, any>[] = Array.from({ length }, () => ({}));
        return main;
    }
  original_instructions: |-
    create a list of N empty dictionaries
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return an array of numbers that appear exactly twice in the input array instead of numbers that appear only once.
  id: |-
    hubedit_mbpp_ts_572
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        return nums.filter(i => nums.filter(num => num === i).length === 2)
                   .filter((item, index, arr) => arr.indexOf(item) === index);
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        return nums.filter(i => nums.filter(num => num === i).length === 1);
    }
  original_instructions: |-
    remove duplicate numbers from a given number of lists
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the starting index of the subsequence B in A if B is a subsequence of A, otherwise return -1.
  id: |-
    hubedit_mbpp_ts_576
  lang: |-
    deno
  modified_code: |-
    export async function main(A: number[], B: number[]): Promise<number> {
        let n: number = A.length;
        let m: number = B.length;
        let i: number = 0;
        let j: number = 0;
        let startIndex: number = -1;
        while (i < n && j < m) {
            if (A[i] === B[j]) {
                if (startIndex === -1) {
                    startIndex = i;
                }
                i += 1;
                j += 1;
                if (j === m) {
                    return startIndex;
                }
            } else {
                if (startIndex !== -1) {
                    i = startIndex + 1;
                } else {
                    i += 1;
                }
                j = 0;
                startIndex = -1;
            }
        }
        return -1;
    }
  original_code: |-
    export async function main(A: number[], B: number[]): Promise<boolean> {
        let n: number = A.length;
        let m: number = B.length;
        let i: number = 0;
        let j: number = 0;
        while (i < n && j < m) {
            if (A[i] === B[j]) {
                i += 1;
                j += 1;
                if (j === m) {
                    return true;
                }
            } else {
                i = i - j + 1;
                j = 0;
            }
        }
        return false;
    }
  original_instructions: |-
    check whether a list is sublist of another or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to calculate the factorial of the number 'n' instead of returning hardcoded values.
  id: |-
    hubedit_mbpp_ts_577
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        if (n < 0) {
            throw new Error("Factorial is not defined for negative numbers.");
        }

        let result = 1;
        for (let i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 0) return 1;
        else if (n <= 2) return n;
        else if (n === 3) return 6;
        else if (n === 4) return 4;
        else return 0;
    }
  original_instructions: |-
    find the last digit in factorial of a given number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a new parameter to the function that allows the user to choose whether the result should be rounded to the nearest integer.
  id: |-
    hubedit_mbpp_ts_581
  lang: |-
    deno
  modified_code: |-
    export async function main(b: number, s: number, roundResult: boolean): Promise<number> {
        let result = 2 * b * s + Math.pow(b, 2);
        return roundResult ? Math.round(result) : result;
    }
  original_code: |-
    export async function main(b: number, s: number): Promise<number> {
        return 2 * b * s + Math.pow(b, 2);
    }
  original_instructions: |-
    find the surface area of a square pyramid with a given base edge and height
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Introduce memoization to store and reuse the results of previously computed values to optimize the function's performance.
  id: |-
    hubedit_mbpp_ts_583
  lang: |-
    deno
  modified_code: |-
    export async function main(num: number, memo: Map<number, number> = new Map()): Promise<number> {
        if (num <= 1) {
            return 1;
        }
        if (memo.has(num)) {
            return memo.get(num)!;
        }
        let res_num = 0;
        for (let i = 0; i < num; i++) {
            res_num += await main(i, memo) * await main(num - i - 1, memo);
        }
        memo.set(num, res_num);
        return res_num;
    }
  original_code: |-
    export async function main(num: number): Promise<number> {
        if (num <= 1) {
            return 1;
        }
        let res_num = 0;
        for (let i = 0; i < num; i++) {
            res_num += await main(i) * await main(num - i - 1);
        }
        return res_num;
    }
  original_instructions: |-
    Write a function which returns nth catalan number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of all the numbers in the array instead of the difference between the maximum and minimum values.
  id: |-
    hubedit_mbpp_ts_588
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number> {
        const sum = nums.reduce((acc, num) => acc + num, 0);
        return sum;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        const diff = Math.max(...nums) - Math.min(...nums);
        return diff;
    }
  original_instructions: |-
    find the difference between largest and smallest value in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list of prime numbers instead of perfect squares within the given range from a to b.
  id: |-
    hubedit_mbpp_ts_589
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number): Promise<number[]> {
        const primes: number[] = [];

        for (let i = a; i <= b; i++) {
            if (isPrime(i)) {
                primes.push(i);
            }
        }

        return primes;
    }

    function isPrime(num: number): boolean {
        if (num <= 1) return false;
        if (num <= 3) return true;

        if (num % 2 === 0 || num % 3 === 0) return false;

        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }

        return true;
    }
  original_code: |-
    export async function main(a: number, b: number): Promise<number[]> {
        const lists: number[] = [];
        for (let i = a; i <= b; i++) {
            let j = 1;
            while (j * j <= i) {
                if (j * j === i) {
                    lists.push(i);
                }
                j = j + 1;
            }
        }
        return lists;
    }
  original_instructions: |-
    find perfect squares between two given numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to reverse the order of the elements in the array before swapping the first and last elements.
  id: |-
    hubedit_mbpp_ts_591
  lang: |-
    deno
  modified_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        newList.reverse();
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return newList;
    }
  original_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return newList;
    }
  original_instructions: |-
    interchange the first and last elements in a list
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the sum of the first even and the first odd number from the list instead of their difference.
  id: |-
    hubedit_mbpp_ts_594
  lang: |-
    deno
  modified_code: |-
    export async function main(list1: number[]): Promise<number> {
        const first_even = list1.find(el => el % 2 === 0) ?? 0;
        const first_odd = list1.find(el => el % 2 !== 0) ?? 0;
        return first_even + first_odd;
    }
  original_code: |-
    export async function main(list1: number[]): Promise<number> {
        const first_even = list1.find(el => el % 2 === 0) ?? -1;
        const first_odd = list1.find(el => el % 2 !== 0) ?? -1;
        return first_even - first_odd;
    }
  original_instructions: |-
    find the difference of the first even and first odd number of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the k-th largest element instead of the k-th smallest element after merging the two arrays.
  id: |-
    hubedit_mbpp_ts_597
  lang: |-
    deno
  modified_code: |-
    export async function main(arr1: number[], arr2: number[], k: number): Promise<number> {
        const m: number = arr1.length;
        const n: number = arr2.length;
        const sorted1: number[] = new Array(m + n);
        let i: number = m - 1;
        let j: number = n - 1;
        let d: number = m + n - 1;

        while (i >= 0 && j >= 0) {
            if (arr1[i] > arr2[j]) {
                sorted1[d] = arr1[i];
                i -= 1;
            } else {
                sorted1[d] = arr2[j];
                j -= 1;
            }
            d -= 1;
        }

        while (i >= 0) {
            sorted1[d] = arr1[i];
            d -= 1;
            i -= 1;
        }

        while (j >= 0) {
            sorted1[d] = arr2[j];
            d -= 1;
            j -= 1;
        }

        return sorted1[k - 1];
    }
  original_code: |-
    export async function main(arr1: number[], arr2: number[], k: number): Promise<number> {
        const m: number = arr1.length;
        const n: number = arr2.length;
        const sorted1: number[] = new Array(m + n);
        let i: number = 0;
        let j: number = 0;
        let d: number = 0;

        while (i < m && j < n) {
            if (arr1[i] < arr2[j]) {
                sorted1[d] = arr1[i];
                i += 1;
            } else {
                sorted1[d] = arr2[j];
                j += 1;
            }
            d += 1;
        }

        while (i < m) {
            sorted1[d] = arr1[i];
            d += 1;
            i += 1;
        }

        while (j < n) {
            sorted1[d] = arr2[j];
            d += 1;
            j += 1;
        }

        return sorted1[k - 1];
    }
  original_instructions: |-
    find kth element from the given two sorted arrays
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the number is a prime number instead of checking if it is an Armstrong number.
  id: |-
    hubedit_mbpp_ts_598
  lang: |-
    deno
  modified_code: |-
    export async function main(number: number): Promise<boolean> {
        if (number <= 1) {
            return false;
        }
        if (number <= 3) {
            return true;
        }
        if (number % 2 === 0 || number % 3 === 0) {
            return false;
        }
        let i: number = 5;
        while (i * i <= number) {
            if (number % i === 0 || number % (i + 2) === 0) {
                return false;
            }
            i += 6;
        }
        return true;
    }
  original_code: |-
    export async function main(number: number): Promise<boolean> {
        let sum: number = 0;
        let times: number = 0;
        let temp: number = number;
        while (temp > 0) {
            times = times + 1;
            temp = Math.floor(temp / 10);
        }
        temp = number;
        while (temp > 0) {
            const reminder: number = temp % 10;
            sum = sum + Math.pow(reminder, times);
            temp = Math.floor(temp / 10);
        }
        if (number === sum) {
            return true;
        } else {
            return false;
        }
    }
  original_instructions: |-
    check whether the given number is armstrong or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the factorial of the given number instead of the sum and average, and return the factorial as the only result.
  id: |-
    hubedit_mbpp_ts_599
  lang: |-
    deno
  modified_code: |-
    export async function main(number: number): Promise<number> {
        let factorial = 1;
        for (let value = 1; value <= number; value++) {
            factorial *= value;
        }
        return factorial;
    }
  original_code: |-
    export async function main(number: number): Promise<[number, number]> {
        let total = 0;
        for (let value = 1; value <= number; value++) {
            total += value;
        }
        const average = total / number;
        return [total, average];
    }
  original_instructions: |-
    find sum and average of first n natural numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to generate Fibonacci numbers instead of ludic numbers, up to the nth Fibonacci number.
  id: |-
    hubedit_mbpp_ts_603
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number[]> {
        const fibonacci: number[] = [0, 1];
        for (let i = 2; i < n; i++) {
            fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
        }
        return fibonacci.slice(0, n);
    }
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        const ludics: number[] = [];
        for (let i = 1; i <= n; i++) {
            ludics.push(i);
        }
        let index = 1;
        while (index !== ludics.length) {
            const first_ludic = ludics[index];
            let remove_index = index + first_ludic;
            while (remove_index < ludics.length) {
                ludics.splice(remove_index, 1);
                remove_index = remove_index + first_ludic - 1;
            }
            index += 1;
        }
        return ludics;
    }
  original_instructions: |-
    get all lucid numbers smaller than or equal to a given integer
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check for prime numbers in a given range instead of checking a single number, and return an array of all prime numbers found within that range.
  id: |-
    hubedit_mbpp_ts_605
  lang: |-
    deno
  modified_code: |-
    export async function findPrimesInRange(start: number, end: number): Promise<number[]> {
        const primes: number[] = [];

        for (let num = start; num <= end; num++) {
            if (num > 1) {
                let isPrime = true;
                for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {
                    if (num % i === 0) {
                        isPrime = false;
                        break;
                    }
                }
                if (isPrime) {
                    primes.push(num);
                }
            }
        }

        return primes;
    }
  original_code: |-
    export async function main(num: number): Promise<boolean> {
        if (num > 1) {
            for (let i = 2; i <= Math.floor(num / 2); i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }
  original_instructions: |-
    check if the given integer is a prime number
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sine of the angle in radians instead of just converting degrees to radians.
  id: |-
    hubedit_mbpp_ts_606
  lang: |-
    deno
  modified_code: |-
    export async function main(degree: number): Promise<number> {
        const radian = degree * (Math.PI / 180);
        const sineValue = Math.sin(radian);
        return sineValue;
    }
  original_code: |-
    export async function main(degree: number): Promise<number> {
        const radian = degree * (Math.PI / 180);
        return radian;
    }
  original_instructions: |-
    convert degrees to radians
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the median of the merged array instead of the average of the middle two elements when the total number of elements is even.
  id: |-
    hubedit_mbpp_ts_622
  lang: |-
    deno
  modified_code: |-
    export async function main(arr1: number[], arr2: number[], n: number): Promise<number> {
      let i = 0;
      let j = 0;
      let m1 = -1;
      let m2 = -1;
      let count = 0;
      const totalLength = n * 2;
      while (count <= totalLength / 2) {
        m1 = m2;
        if (i !== n && (j === n || arr1[i] <= arr2[j])) {
          m2 = arr1[i];
          i++;
        } else {
          m2 = arr2[j];
          j++;
        }
        count++;
      }
      if (totalLength % 2 === 0) {
        return (m1 + m2) / 2;
      } else {
        return m2;
      }
    }
  original_code: |-
    export async function main(arr1: number[], arr2: number[], n: number): Promise<number> {
      let i = 0;
      let j = 0;
      let m1 = -1;
      let m2 = -1;
      let count = 0;
      while (count < n + 1) {
        count += 1;
        if (i === n) {
          m1 = m2;
          m2 = arr2[0];
          break;
        } else if (j === n) {
          m1 = m2;
          m2 = arr1[0];
          break;
        }
        if (arr1[i] <= arr2[j]) {
          m1 = m2;
          m2 = arr1[i];
          i += 1;
        } else {
          m1 = m2;
          m2 = arr2[j];
          j += 1;
        }
      }
      return (m1 + m2) / 2;
    }
  original_instructions: |-
    find the median of two sorted lists of same size
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the order of the elements in the array before swapping the first and last elements.
  id: |-
    hubedit_mbpp_ts_625
  lang: |-
    deno
  modified_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        newList.reverse();
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return newList;
    }
  original_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return newList;
    }
  original_instructions: |-
    interchange the first and last element in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the square root of the number instead of the square if the input is non-negative.
  id: |-
    hubedit_mbpp_ts_626
  lang: |-
    deno
  modified_code: |-
    export async function main(r: number): Promise<number | null> {
        if (r < 0) {
            return null;
        }
        return Math.sqrt(r);
    }
  original_code: |-
    export async function main(r: number): Promise<number | null> {
        if (r < 0) {
            return null;
        }
        return r * r;
    }
  original_instructions: |-
    find the area of the largest triangle that can be inscribed in a semicircle with a given radius
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the regular expression to match any string that contains at least one digit, instead of searching for the letter 'z' not at the word boundaries.
  id: |-
    hubedit_mbpp_ts_643
  lang: |-
    deno
  modified_code: |-
    export async function main(text: string): Promise<boolean> {
        const regex = /\d+/;
        return regex.test(text);
    }
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const regex = /\Bz\B/;
        return regex.test(text);
    }
  original_instructions: |-
    checks if a strings contains 'z', except at the start and end of the word
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the minimum path sum instead of the maximum by modifying the Math.max function to Math.min within the nested for loops.
  id: |-
    hubedit_mbpp_ts_721
  lang: |-
    deno
  modified_code: |-
    export async function main(cost: number[][]): Promise<number> {
      const N = cost.length;
      const dp: number[][] = Array.from({ length: N + 1 }, () => Array(N + 1).fill(0));
      dp[0][0] = cost[0][0];
      for (let i = 1; i < N; i++) {
        dp[i][0] = dp[i - 1][0] + cost[i][0];
      }
      for (let j = 1; j < N; j++) {
        dp[0][j] = dp[0][j - 1] + cost[0][j];
      }
      for (let i = 1; i < N; i++) {
        for (let j = 1; j < N; j++) {
          dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];
        }
      }
      return dp[N - 1][N - 1] / (2 * N - 1);
    }
  original_code: |-
    export async function main(cost: number[][]): Promise<number> {
      const N = cost.length;
      const dp: number[][] = Array.from({ length: N + 1 }, () => Array(N + 1).fill(0));
      dp[0][0] = cost[0][0];
      for (let i = 1; i < N; i++) {
        dp[i][0] = dp[i - 1][0] + cost[i][0];
      }
      for (let j = 1; j < N; j++) {
        dp[0][j] = dp[0][j - 1] + cost[0][j];
      }
      for (let i = 1; i < N; i++) {
        for (let j = 1; j < N; j++) {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];
        }
      }
      return dp[N - 1][N - 1] / (2 * N - 1);
    }
  original_instructions: |-
    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the elements in `nums1` that are not present in `nums2`.
  id: |-
    hubedit_mbpp_ts_723
  lang: |-
    deno
  modified_code: |-
    export async function main(nums1: number[], nums2: number[]): Promise<number> {
        const nums2Set = new Set(nums2);
        const result = nums1.reduce((acc, num) => acc + (!nums2Set.has(num) ? num : 0), 0);
        return result;
    }
  original_code: |-
    export async function main(nums1: number[], nums2: number[]): Promise<number> {
        const result = nums1.reduce((acc, num, index) => acc + (num === nums2[index] ? 1 : 0), 0);
        return result;
    }
  original_instructions: |-
    The input is defined as two lists of the same length. count indices where the lists have the same values
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the average of the array elements instead of the current calculation.
  id: |-
    hubedit_mbpp_ts_734
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return arr.length > 0 ? sum / arr.length : 0;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ans = 0;
        let res = 0;
        let i = arr.length - 1;
        while (i >= 0) {
            const incr = arr[i] * (1 + res);
            ans += incr;
            res = incr;
            i -= 1;
        }
        return ans;
    }
  original_instructions: |-
    find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to set only the even-indexed bits of the number instead of setting the middle bits.
  id: |-
    hubedit_mbpp_ts_735
  lang: |-
    deno
  modified_code: |-
    function setEvenIndexedBits(n: number): number {
        let mask = 0xAAAAAAAA; // 10101010... in binary, sets all even-indexed bits
        return n | mask;
    }

    export async function main(n: number): Promise<number> {
        return setEvenIndexedBits(n);
    }
  original_code: |-
    function setMiddleBits(n: number): number {
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return (n >> 1) ^ 1;
    }

    export async function main(n: number): Promise<number> {
        if (n === 1) {
            return 1;
        }
        return n ^ setMiddleBits(n);
    }
  original_instructions: |-
    toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the regular expression to match strings that end with a digit, instead of starting with a vowel.
  id: |-
    hubedit_mbpp_ts_737
  lang: |-
    deno
  modified_code: |-
    type Match = RegExpMatchArray | null;

    const regex: RegExp = /[A-Za-z0-9_]*\d$/;

    export async function main(string: string): Promise<Match> {
        return string.match(regex);
    }
  original_code: |-
    type Match = RegExpMatchArray | null;

    const regex: RegExp = /^[aeiouAEIOU][A-Za-z0-9_]*/;

    export async function main(string: string): Promise<Match> {
        return string.match(regex);
    }
  original_instructions: |-
    check whether the given string is starting with a vowel or not using regex
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of the input number instead of the square root of 2 times 10 to the power of (n - 1).
  id: |-
    hubedit_mbpp_ts_739
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let factorial = 1;
        for (let i = 2; i <= n; i++) {
            factorial *= i;
        }
        return factorial;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        const x = Math.sqrt(2 * Math.pow(10, (n - 1)));
        return Math.round(x);
    }
  original_instructions: |-
    find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the input string is a palindrome, meaning it reads the same backward as forward.
  id: |-
    hubedit_mbpp_ts_741
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<boolean> {
        const n: number = s.length;
        for (let i = 0; i < n / 2; i++) {
            if (s[i] !== s[n - 1 - i]) {
                return false;
            }
        }
        return true;
    }
  original_code: |-
    export async function main(s: string): Promise<boolean> {
        const n: number = s.length;
        for (let i = 1; i < n; i++) {
            if (s[i] !== s[0]) {
                return false;
            }
        }
        return true;
    }
  original_instructions: |-
    check whether all the characters are same or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the recurrence relation so that each term is the sum of the previous three terms instead of the sum of the previous term and twice the term before that.
  id: |-
    hubedit_mbpp_ts_752
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1; // Initialize the second term for the base case of the new recurrence relation
        for (let i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
        }
        return dp[n];
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        dp[0] = 0;
        dp[1] = 1;
        for (let i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + 2 * dp[i - 2];
        }
        return dp[n];
    }
  original_instructions: |-
    find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ..
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the regular expression to match any string that contains at least one digit by using the \d pattern.
  id: |-
    hubedit_mbpp_ts_756
  lang: |-
    deno
  modified_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = /\d+/;
        return patterns.test(text);
    }
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = /ab+?/;
        return patterns.test(text);
    }
  original_instructions: |-
    matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the regular expression to allow for negative numbers as well by including an optional minus sign at the beginning of the pattern.
  id: |-
    hubedit_mbpp_ts_759
  lang: |-
    deno
  modified_code: |-
    export async function main(num: string): Promise<boolean> {
        const dnumre: RegExp = /^-?[0-9]+(\.[0-9]{1,2})?$/;
        const result: RegExpExecArray | null = dnumre.exec(num);
        return Boolean(result);
    }
  original_code: |-
    export async function main(num: string): Promise<boolean> {
        const dnumre: RegExp = /^[0-9]+(\.[0-9]{1,2})?$/;
        const result: RegExpExecArray | null = dnumre.exec(num);
        return Boolean(result);
    }
  original_instructions: |-
    check whether a given string is a decimal number with a precision of 2
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if all elements in the array are even numbers instead of checking if all elements are the same.
  id: |-
    hubedit_mbpp_ts_760
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<boolean> {
        return arr.every(num => num % 2 === 0);
    }
  original_code: |-
    export async function main(arr: number[]): Promise<boolean> {
        const s = new Set(arr);
        return s.size === 1;
    }
  original_instructions: |-
    check whether a list of numbers contains only one distinct element or not
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check if the given month number corresponds to a month with 31 days instead of 30 days.
  id: |-
    hubedit_mbpp_ts_762
  lang: |-
    deno
  modified_code: |-
    export async function main(monthnum3: number): Promise<boolean> {
      return monthnum3 === 1 || monthnum3 === 3 || monthnum3 === 5 || monthnum3 === 7 || monthnum3 === 8 || monthnum3 === 10 || monthnum3 === 12;
    }
  original_code: |-
    export async function main(monthnum3: number): Promise<boolean> {
      return monthnum3 === 4 || monthnum3 === 6 || monthnum3 === 9 || monthnum3 === 11;
    }
  original_instructions: |-
    check whether the given month number contains 30 days or not. Months are given as number from 1 to 12
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the maximum difference between any two consecutive elements in the sorted array instead of the minimum difference.
  id: |-
    hubedit_mbpp_ts_763
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[], n: number): Promise<number> {
        arr = arr.sort((a, b) => a - b);
        let maxDiff: number = 0;
        for (let i = 0; i < n - 1; i++) {
            if (arr[i + 1] - arr[i] > maxDiff) {
                maxDiff = arr[i + 1] - arr[i];
            }
        }
        return maxDiff;
    }
  original_code: |-
    export async function main(arr: number[], n: number): Promise<number> {
        arr = arr.sort((a, b) => a - b);
        let diff: number = 10 ** 20;
        for (let i = 0; i < n - 1; i++) {
            if (arr[i + 1] - arr[i] < diff) {
                diff = arr[i + 1] - arr[i];
            }
        }
        return diff;
    }
  original_instructions: |-
    find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the array is sorted in ascending order instead of checking if the indices match the parity of the numbers.
  id: |-
    hubedit_mbpp_ts_775
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<boolean> {
        for (let i = 1; i < nums.length; i++) {
            if (nums[i] < nums[i - 1]) {
                return false;
            }
        }
        return true;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<boolean> {
        return nums.every((num, i) => num % 2 === i % 2);
    }
  original_instructions: |-
    check whether every odd index contains odd numbers of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the product of the unique elements in the array instead of their sum.
  id: |-
    hubedit_mbpp_ts_777
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        arr.sort((a, b) => a - b);
        let product = arr[0];
        for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] !== arr[i + 1]) {
                product *= arr[i + 1];
            }
        }
        return product;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        arr.sort((a, b) => a - b);
        let sum = arr[0];
        for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] !== arr[i + 1]) {
                sum += arr[i + 1];
            }
        }
        return sum;
    }
  original_instructions: |-
    find the sum of non-repeated elements in a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the first even and the first odd number from the list instead of their product.
  id: |-
    hubedit_mbpp_ts_784
  lang: |-
    deno
  modified_code: |-
    export async function main(list1: number[]): Promise<number> {
        const firstEven = list1.find(el => el % 2 === 0) ?? 0;
        const firstOdd = list1.find(el => el % 2 !== 0) ?? 0;
        return firstEven + firstOdd;
    }
  original_code: |-
    export async function main(list1: number[]): Promise<number> {
        const firstEven = list1.find(el => el % 2 === 0) ?? -1;
        const firstOdd = list1.find(el => el % 2 !== 0) ?? -1;
        return firstEven * firstOdd;
    }
  original_instructions: |-
    find the product of first even and odd number of a given list
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to filter out any non-numeric values after splitting the string and before mapping to integers.
  id: |-
    hubedit_mbpp_ts_785
  lang: |-
    deno
  modified_code: |-
    export async function main(test_str: string): Promise<number[]> {
        const res: number[] = test_str
            .replace('(', '')
            .replace(')', '')
            .replace('...', '')
            .split(', ')
            .filter(str => !isNaN(Number(str))) // Filter out non-numeric values
            .map(num => parseInt(num));
        return res;
    }
  original_code: |-
    export async function main(test_str: string): Promise<tuple> {
        const res: number[] = test_str.replace('(', '').replace(')', '').replace('...', '').split(', ').map(num => parseInt(num));
        return res as unknown as tuple;
    }
  original_instructions: |-
    convert tuple string to integer tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the elements of the array before returning it.
  id: |-
    hubedit_mbpp_ts_791
  lang: |-
    deno
  modified_code: |-
    export async function main(test_tup: any[]): Promise<any[]> {
        let res: any[] = [];
        for (let count = 0; count < test_tup.length; count++) {
            const ele = test_tup[count];
            if (!(ele instanceof Array)) {
                res.push(ele);
            }
        }
        return res.reverse();
    }
  original_code: |-
    export async function main(test_tup: any[]): Promise<any[]> {
        let res: any[] = [];
        for (let count = 0; count < test_tup.length; count++) {
            const ele = test_tup[count];
            if (!(ele instanceof Array)) {
                res.push(ele);
            }
        }
        return res;
    }
  original_instructions: |-
    remove tuples from the given tuple
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the product of the values instead of their sum.
  id: |-
    hubedit_mbpp_ts_796
  lang: |-
    deno
  modified_code: |-
    export async function main(dict: Record<number, number>): Promise<number> {
      let product = 1;
      for (const i of Object.values(dict)) {
        product *= i;
      }
      return product;
    }
  original_code: |-
    export async function main(dict: Record<number, number>): Promise<number> {
      let sum = 0;
      for (const i of Object.values(dict)) {
        sum = sum + i;
      }
      return sum;
    }
  original_instructions: |-
    Write function to find the sum of all items in the given dictionary
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to perform a right circular shift instead of a left circular shift by swapping the shift operations.
  id: |-
    hubedit_mbpp_ts_799
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number, d: number): Promise<number> {
        const INT_BITS: number = 32;
        return (n >>> d) | (n << (INT_BITS - d));
    }
  original_code: |-
    export async function main(n: number, d: number): Promise<number> {
        const INT_BITS: number = 32;
        return (n << d) | (n >>> (INT_BITS - d));
    }
  original_instructions: |-
    that rotate left bits by d bits a given number. We assume that the number is 32 bit
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the sum of the unique numbers instead of returning 0 or 4 - result.size.
  id: |-
    hubedit_mbpp_ts_801
  lang: |-
    deno
  modified_code: |-
    export async function main(x: number, y: number, z: number): Promise<number> {
      const uniqueNumbers = new Set([x, y, z]);
      let sum = 0;
      for (let num of uniqueNumbers) {
        sum += num;
      }
      return sum;
    }
  original_code: |-
    export async function main(x: number, y: number, z: number): Promise<number> {
      const result = new Set([x, y, z]);
      if (result.size === 3) {
        return 0;
      } else {
        return 4 - result.size;
      }
    }
  original_instructions: |-
    count the number of equal numbers from three given integers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the number `n` is a prime number instead of checking if it is a perfect square.
  id: |-
    hubedit_mbpp_ts_803
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n <= 1) {
            return false;
        }
        if (n <= 3) {
            return true;
        }
        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }
        let i = 5;
        while (i * i <= n) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
            i += 6;
        }
        return true;
    }
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        let i = 1;
        while (i * i <= n) {
            if ((n % i == 0) && (n / i == i)) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
  original_instructions: |-
    check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of all even numbers in the array instead of finding the first odd number.
  id: |-
    hubedit_mbpp_ts_807
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number> {
      const sum = nums.reduce((acc, el) => el % 2 === 0 ? acc + el : acc, 0);
      return sum;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
      const main = nums.find(el => el % 2 !== 0) ?? -1;
      return main;
    }
  original_instructions: |-
    find the first odd number in a given list of numbers
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a feature to send a direct message to a user or multiple users on Slack with a summary of the error and success information when the schedule recovers.
  id: |-
    hubedit_hub_1031
  lang: |-
    python
  modified_code: |-
    import os
    import json
    from typing import TypedDict, Any, List
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack(TypedDict):
        token: str

    def format_error(error: Any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def send_direct_message(web: WebClient, users: List[str], message: str, blocks: List[dict]):
        for user in users:
            web.chat_postMessage(
                channel=user,
                text=message,
                blocks=blocks
            )

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        error_started_at: str,
        success_times: int,
        success_result: dict,
        success_started_at: str,
        slack: slack,
        channel: str,
        users_to_notify: List[str] = [],  # Add an optional parameter for user IDs
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}{'/flows/get/' if is_flow else '/scripts/get/'}{path}"
        web = WebClient(token=slack['token'])

        recovery_message = f"Schedule {schedule_path} recovered {success_times > 1 and (str(success_times) + ' times in a row') or ''}"
        recovery_blocks = [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Schedule <{schedule_url}|{schedule_path}> recovered*{success_times > 1 and (' ' + str(success_times) + ' times in a row') or ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                },
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"Last failure at: {datetime.fromisoformat(error_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                },
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"Last success at: {datetime.fromisoformat(success_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n```\n{json.dumps(success_result, indent=2)}\n```",
                },
            },
        ]

        # Post to channel
        web.chat_postMessage(
            channel=channel,
            text=recovery_message,
            blocks=recovery_blocks,
        )

        # Send direct messages if users are specified
        if users_to_notify:
            send_direct_message(web, users_to_notify, recovery_message, recovery_blocks)
  original_code: |-
    import os
    import json
    from typing import TypedDict, Any
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack(TypedDict):
        token: str

    def format_error(error: Any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        error_started_at: str,
        success_times: int,
        success_result: dict,
        success_started_at: str,
        slack: slack,
        channel: str,
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}{'/flows/get/' if is_flow else '/scripts/get/'}{path}"
        web = WebClient(token=slack['token'])

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} recovered {success_times > 1 and (str(success_times) + ' times in a row') or ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> recovered*{success_times > 1 and (' ' + str(success_times) + ' times in a row') or ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                    },
                },
            ],
            attachments=[
                {
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"Last failure at: {datetime.fromisoformat(error_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                            },
                        },
                    ],
                },
                {
                    "color": "#00ff00",
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"Last success at: {datetime.fromisoformat(success_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n```\n{json.dumps(success_result, indent=2)}\n```",
                            },
                        },
                    ],
                },
            ],
        )
  original_instructions: |-
    Schedule recovery handler in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |-
    Add functionality to upload a file to the specified S3 bucket by taking an additional parameter for the file content and using the `put_object` method of the `s3_client`.
  id: |-
    hubedit_hub_392
  lang: |-
    python
  modified_code: |-
    import boto3
    from typing import TypedDict

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def upload_file(s3_config: s3, path: str, file_content: bytes):
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )
        response = s3_client.put_object(Bucket=s3_config['bucket'], Key=path, Body=file_content)
        return response

    def main(s3_config: s3, path: str, file_content: bytes = None):
        if file_content is not None:
            return upload_file(s3_config, path, file_content)
        else:
            session = boto3.session.Session()
            s3_client = session.client(
                service_name='s3',
                aws_access_key_id=s3_config['accessKey'],
                aws_secret_access_key=s3_config['secretKey'],
                endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
                region_name=s3_config['region'],
                use_ssl=s3_config['useSSL'],
                config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
            )
            response = s3_client.get_object(Bucket=s3_config['bucket'], Key=path)
            return response['Body'].read().decode('utf-8')
  original_code: |-
    import boto3
    from typing import TypedDict

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, path: str):
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )
        response = s3_client.get_object(Bucket=s3_config['bucket'], Key=path)
        return response['Body'].read().decode('utf-8')
  original_instructions: |-
    Get object in bucket as text in s3
  resource_type: |-
    s3
  resource_type_def: |-
    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str
- edit_instructions: |2

    Add functionality to update an existing collection's name, permissions, and document security if the collection_id is provided instead of creating a new collection.
  id: |-
    hubedit_hub_329
  lang: |-
    python
  modified_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: Optional[str] = None,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        if collection_id:
            # Update an existing collection
            response = db.update_collection(
                database_id=database_id,
                collection_id=collection_id,
                name=collection_name,
                read=collection_permissions or [],
                write=collection_permissions or [],
                document_security=collection_document_security or False
            )
        else:
            # Create a new collection
            collection_id = client.call('utils', 'id')
            response = db.create_collection(
                database_id=database_id,
                collection_id=collection_id,
                name=collection_name,
                read=collection_permissions or [],
                write=collection_permissions or [],
                document_security=collection_document_security or False
            )

        return response
  original_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: Optional[str] = None,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        if collection_id is None:
            collection_id = client.call('utils', 'id')

        response = db.create_collection(
            database_id=database_id,
            collection_id=collection_id,
            name=collection_name,
            read=collection_permissions or [],
            write=collection_permissions or [],
            document_security=collection_document_security or False
        )

        return response
  original_instructions: |-
    Create Collection in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add a feature to log the output to a file instead of printing it to the console. Include a new boolean parameter to toggle between logging and printing.
  id: |-
    hubedit_hub_1028
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Any
    import logging

    class error_details(TypedDict):
        message: str
        code: int

    class success_result_type(TypedDict):
        data: Any
        status: str

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: error_details,
        error_started_at: str,
        success_times: int,
        success_result: success_result_type,
        success_started_at: str,
        log_to_file: bool = False,
        log_file_path: str = 'log.txt'
    ) -> error_details:
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

        if log_to_file:
            file_handler = logging.FileHandler(log_file_path)
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)
        else:
            console_handler = logging.StreamHandler()
            console_handler.setFormatter(formatter)
            logger.addHandler(console_handler)

        message = (
            f"Schedule {schedule_path} recovered "
            f"{success_times > 1 and (str(success_times) + ' times in a row') or ''}\n"
            f"{'Flow' if is_flow else 'Script'}: {path}\n"
            f"Last failure at {error_started_at}: {error}\n"
            f"Last success at {success_started_at}: {success_result}"
        )

        if log_to_file:
            logger.info(message)
        else:
            print(message)

        # Remove all handlers after use to prevent duplicate logs
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)

        return error
  original_code: |-
    from typing import TypedDict, Any

    class error_details(TypedDict):
        # Define the structure of the error details as per your requirements
        message: str
        code: int
        # Add more fields as needed

    class success_result_type(TypedDict):
        # Define the structure of the success result as per your requirements
        data: Any
        status: str
        # Add more fields as needed

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: error_details,
        error_started_at: str,
        success_times: int,
        success_result: success_result_type,
        success_started_at: str,
    ) -> error_details:
        print(
            f"Schedule {schedule_path} recovered "
            f"{success_times > 1 and (str(success_times) + ' times in a row') or ''}\n"
            f"{'Flow' if is_flow else 'Script'}: {path}"
        )
        print(f"Last failure at {error_started_at}:", error)
        print(f"Last success at {success_started_at}:", success_result)
        return error
  original_instructions: |-
    Schedule recovery handler template in windmill
  resource_type: |-
    error_details
  resource_type_def: |-
    class error_details(TypedDict):
        # Define the structure of the error details as per your requirements
        message: str
        code: int
        # Add more fields as needed
- edit_instructions: |2

    Add a feature to log the response from the `get_signed_url` method to a file for auditing purposes.
  id: |-
    hubedit_hub_231
  lang: |-
    python
  modified_code: |-
    import logging
    from typing import TypedDict, Optional
    from hubspot import HubSpot

    class hubspot(TypedDict):
        token: str

    # Configure logging
    logging.basicConfig(filename='hubspot_audit.log', level=logging.INFO, format='%(asctime)s - %(message)s')

    def main(
        auth: hubspot,
        file_id: str,
        size: Optional[str] = None,
        expiration_seconds: Optional[int] = None,
        upscale: Optional[bool] = None
    ):
        client = HubSpot(api_key=auth['token'])

        try:
            response = client.files.get_signed_url(
                file_id,
                size,
                expiration_seconds,
                upscale
            )
            # Log the response
            logging.info(f"Signed URL response: {response}")
            return response
        except Exception as e:
            logging.error(f"Error obtaining signed URL: {e}")
            raise Exception(f"{e}\nMessage: {str(e)}\n")
  original_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot

    class hubspot(TypedDict):
        token: str

    def main(
        auth: hubspot,
        file_id: str,
        size: Optional[str] = None,
        expiration_seconds: Optional[int] = None,
        upscale: Optional[bool] = None
    ):
        client = HubSpot(api_key=auth['token'])

        try:
            return client.files.get_signed_url(
                file_id,
                size,
                expiration_seconds,
                upscale
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")
  original_instructions: |-
    Get File Public URL in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the requests.post call, checking for HTTP status codes that indicate failure and raise a custom exception with the error details.
  id: |-
    hubedit_hub_263
  lang: |-
    python
  modified_code: |-
    class FaunaDBError(Exception):
        """Custom exception for FaunaDB errors."""
        def __init__(self, message, status_code):
            super().__init__(message)
            self.status_code = status_code

    def main(auth: faunadb, query: str, variables: Optional[Dict[str, Any]] = None, operationName: Optional[str] = None):
        region = auth['region'] if auth['region'] in ["us", "eu"] else ""
        try:
            response = requests.post(f'https://graphql.{region}.fauna.com/graphql', headers={
                'Authorization': 'Bearer ' + auth['secret'],
            }, json={
                'query': query,
                'variables': variables or {},
                'operationName': operationName or None,
            })
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.exceptions.HTTPError as http_err:
            raise FaunaDBError(f'HTTP error occurred: {http_err}', response.status_code) from http_err
        except requests.exceptions.RequestException as err:
            raise FaunaDBError(f'Request error occurred: {err}', response.status_code if response else None) from err

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Optional, Dict, Any

    class faunadb(TypedDict):
        region: str
        secret: str

    def main(auth: faunadb, query: str, variables: Optional[Dict[str, Any]] = None, operationName: Optional[str] = None):
        region = auth['region'] if auth['region'] in ["us", "eu"] else ""
        response = requests.post(f'https://graphql.{region}.fauna.com/graphql', headers={
            'Authorization': 'Bearer ' + auth['secret'],
        }, json={
            'query': query,
            'variables': variables or {},
            'operationName': operationName or None,
        })
        return response.json()
  original_instructions: |-
    Execute GraphQL Query in faunadb
  resource_type: |-
    faunadb
  resource_type_def: |-
    class faunadb(TypedDict):
        region: str
        secret: str
- edit_instructions: |2

    Modify the script to send a custom text message to the specified chat_id instead of exporting the chat invite link.
  id: |-
    hubedit_hub_233
  lang: |-
    python
  modified_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message: str):
        client = TeleBot(auth['token'])
        client.send_message(chat_id, message)
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str):
        client = TeleBot(auth['token'])
        return client.export_chat_invite_link(chat_id)
  original_instructions: |-
    Export Chat Invite Link in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter and return only users with a specific email domain by adding a post-processing step after retrieving the user list from the client.
  id: |-
    hubedit_hub_349
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def filter_users_by_email_domain(users, domain: str):
        return [user for user in users if user['person']['email'].endswith(f"@{domain}")]

    def main(auth: notion, start_cursor: Optional[str] = None, page_size: Optional[int] = None, email_domain: str = 'example.com'):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'page_size': page_size,
            'start_cursor': start_cursor,
        })
        response = client.users.list(**args)
        users = response.get('results', [])
        filtered_users = filter_users_by_email_domain(users, email_domain)
        return filtered_users
  original_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: notion, start_cursor: Optional[str] = None, page_size: Optional[int] = None):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'page_size': page_size,
            'start_cursor': start_cursor,
        })
        return client.users.list(**args)
  original_instructions: |-
    List Users in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to move the file to the trash instead of permanently deleting it by adding a query parameter to the DELETE_FILE_URL.
  id: |-
    hubedit_hub_49
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str, moveToTrash: bool = False):
        supportsAllDrives = True
        DELETE_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}"

        token = gdrive_auth["token"]

        headers = {
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        }

        params = {
            "supportsAllDrives": supportsAllDrives
        }

        if moveToTrash:
            # To move the file to trash, we need to update its 'trashed' field to true
            response = requests.patch(DELETE_FILE_URL, headers=headers, params=params, json={"trashed": True})
        else:
            # To permanently delete the file, we use the delete method
            response = requests.delete(DELETE_FILE_URL, headers=headers, params=params)

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        supportsAllDrives = True
        DELETE_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/?supportsAllDrives={supportsAllDrives}"

        token = gdrive_auth["token"]

        response = requests.delete(DELETE_FILE_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        return response.text
  original_instructions: |-
    Delete File in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to retry the failed schedule automatically after a certain delay, and include the number of retries left in the Slack message.
  id: |-
    hubedit_hub_1030
  lang: |-
    python
  modified_code: |-
    import os
    import json
    import time
    from typing import TypedDict
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack(TypedDict):
        token: str

    def format_error(error: any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def retry_schedule(path: str, is_flow: bool, retries: int, delay: int):
        # Placeholder for the actual retry logic
        # You would need to implement the actual retry logic here
        # For example, you might call another function that attempts to run the schedule again
        print(f"Retrying {'flow' if is_flow else 'script'} {path}. Retries left: {retries}")
        time.sleep(delay)  # Wait for the specified delay before retrying

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        started_at: str,
        failed_times: int,
        slack: slack,
        channel: str,
        retries_left: int = 3,  # Number of retries left
        retry_delay: int = 60,  # Delay in seconds before retrying
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}/{'flows/get' if is_flow else 'scripts/get'}/{path}"
        web = WebClient(token=slack['token'])

        if retries_left > 0:
            retry_schedule(path, is_flow, retries_left, retry_delay)
            retries_left -= 1

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} failed {failed_times if failed_times > 1 else ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> failed*{f' {failed_times} times in a row' if failed_times > 1 else ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>\n- Retries left: {retries_left}",
                    },
                },
            ],
            attachments=[
                {
                    "color": "#ff0000",
                    "blocks": [{
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"Last failure at: {datetime.fromisoformat(started_at).astimezone(pytz.UTC).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                        },
                    }],
                },
            ],
        )
  original_code: |-
    import os
    import json
    from typing import TypedDict
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack(TypedDict):
        token: str

    def format_error(error: any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        started_at: str,
        failed_times: int,
        slack: slack,
        channel: str,
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}/{'flows/get' if is_flow else 'scripts/get'}/{path}"
        web = WebClient(token=slack['token'])

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} failed {failed_times if failed_times > 1 else ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> failed*{f' {failed_times} times in a row' if failed_times > 1 else ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                    },
                },
            ],
            attachments=[
                {
                    "color": "#ff0000",
                    "blocks": [{
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"Last failure at: {datetime.fromisoformat(started_at).astimezone(pytz.UTC).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                        },
                    }],
                },
            ],
        )
  original_instructions: |-
    Schedule error handler in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the requests.post call, checking for HTTP status codes that indicate failure (like 4xx or 5xx) and raise a custom exception with a meaningful error message.
  id: |-
    hubedit_hub_264
  lang: |-
    python
  modified_code: |-
    class FaunaDBError(Exception):
        """Custom exception for FaunaDB errors."""
        pass

    def main(auth: faunadb, schema: str, mode: str = "merge"):
        region = auth['region'] if auth['region'] in ["us", "eu"] else ""
        try:
            response = requests.post(
                f"https://graphql.{region}.fauna.com/import?mode={mode}",
                headers={
                    "Authorization": "Bearer " + auth['secret'],
                },
                data=schema,
            )
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.exceptions.HTTPError as http_err:
            raise FaunaDBError(f"HTTP error occurred: {http_err}") from http_err
        except requests.exceptions.RequestException as err:
            raise FaunaDBError(f"Error occurred during request to FaunaDB: {err}") from err
        return response.text
  original_code: |-
    from typing import TypedDict
    import requests

    class faunadb(TypedDict):
        region: str
        secret: str

    def main(auth: faunadb, schema: str, mode: str = "merge"):
        region = auth['region'] if auth['region'] in ["us", "eu"] else ""
        response = requests.post(
            f"https://graphql.{region}.fauna.com/import?mode={mode}",
            headers={
                "Authorization": "Bearer " + auth['secret'],
            },
            data=schema,
        )
        return response.text
  original_instructions: |-
    Import GraphQL schema in faunadb
  resource_type: |-
    faunadb
  resource_type_def: |-
    class faunadb(TypedDict):
        region: str
        secret: str
- edit_instructions: |2

    Add a filter to the request parameters to only return resources that match a specific query or category.
  id: |-
    hubedit_hub_168
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Any

    class Resource(TypedDict):
        resources: List[Any]

    def main(query: str, category: str) -> Resource:
        url = "https://hub.windmill.dev/searchResourceData"
        params = {
            'query': query,
            'category': category
        }
        response = requests.get(url, params=params)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class resource(TypedDict):
        resources: List[Any]

    def main() -> resource:
        url = "https://hub.windmill.dev/searchResourceData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List Resource Types in windmillhub
  resource_type: |-
    resource
  resource_type_def: |-
    class resource(TypedDict):
        resources: List[Any]
- edit_instructions: |2

    Modify the script to post a message to a specified Slack channel by changing the HTTP method to POST, updating the URL to the message posting endpoint, and adding the necessary payload for the message and channel.
  id: |-
    hubedit_hub_299
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    import requests

    class SlackAuth(TypedDict):
        token: str

    def post_message_to_channel(auth: SlackAuth, channel_id: str, message: str):
        url = 'https://slack.com/api/chat.postMessage'
        headers = {'Authorization': f'Bearer {auth["token"]}', 'Content-Type': 'application/json'}
        payload = {
            'channel': channel_id,
            'text': message
        }
        response = requests.post(url, headers=headers, json=payload)
        return response.json()

    # Example usage:
    # auth = SlackAuth(token='your-slack-token')
    # post_message_to_channel(auth, 'channel-id', 'Hello, world!')
  original_code: |-
    from typing import TypedDict, Optional
    import requests

    class slack(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: slack, cursor: Optional[str] = None, limit: Optional[int] = None):
        client = auth['token']
        params = remove_empty_fields({'cursor': cursor, 'limit': limit})
        response = requests.get('https://slack.com/api/users.list', headers={'Authorization': f'Bearer {client}'}, params=params)
        return response.json()
  original_instructions: |-
    List Users in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the server, such as checking if the response status code indicates success or failure, and then log or raise an appropriate message or exception based on the result.
  id: |-
    hubedit_hub_325
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import requests

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: str):
        session = requests.Session()
        session.headers.update({
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        })

        if auth['self_signed']:
            session.verify = False

        try:
            response = session.delete(f"{auth['endpoint']}/users/{id}")
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.exceptions.HTTPError as http_err:
            print(f"HTTP error occurred: {http_err}")  # Python 3.6+
            raise
        except Exception as err:
            print(f"An error occurred: {err}")
            raise
        else:
            return response.json()
  original_code: |-
    from typing import TypedDict
    import requests

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: str):
        session = requests.Session()
        session.headers.update({
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        })

        if auth['self_signed']:
            session.verify = False

        response = session.delete(f"{auth['endpoint']}/users/{id}")
        return response.json()
  original_instructions: |-
    Delete User in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add functionality to save the response from the OpenAI API to a local file in JSON format.
  id: |-
    hubedit_hub_245
  lang: |-
    python
  modified_code: |-
    import openai
    import json
    from typing import TypedDict, Optional, Dict, Any

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def remove_object_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def save_response_to_file(response: Dict[str, Any], file_path: str) -> None:
        with open(file_path, 'w') as f:
            json.dump(response, f, ensure_ascii=False, indent=4)

    def main(
        auth: openai_typeddict,
        model: str = "text-davinci-003",
        prompt: Optional[str] = None,
        suffix: Optional[str] = None,
        max_tokens: Optional[int] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        n: Optional[int] = None,
        stream: Optional[bool] = None,
        logprobs: Optional[int] = None,
        echo: Optional[bool] = None,
        stop: Optional[str] = None,
        presence_penalty: Optional[float] = None,
        frequency_penalty: Optional[float] = None,
        best_of: Optional[int] = None,
        logit_bias: Optional[Dict[str, float]] = None,
        save_path: Optional[str] = "response.json",  # Add a parameter for the save path
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        request = remove_object_empty_fields({
            "model": model,
            "prompt": prompt,
            "suffix": suffix,
            "max_tokens": max_tokens,
            "temperature": temperature,
            "top_p": top_p,
            "n": n,
            "stream": stream,
            "logprobs": logprobs,
            "echo": echo,
            "stop": stop,
            "presence_penalty": presence_penalty,
            "frequency_penalty": frequency_penalty,
            "best_of": best_of,
            "logit_bias": logit_bias,
        })
        response = openai.Completion.create(**request)

        if save_path:
            save_response_to_file(response, save_path)

        return response
  original_code: |-
    import openai
    from typing import TypedDict, Optional, Dict, Any

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def remove_object_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: openai_typeddict,
        model: str = "text-davinci-003",
        prompt: Optional[str] = None,
        suffix: Optional[str] = None,
        max_tokens: Optional[int] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        n: Optional[int] = None,
        stream: Optional[bool] = None,
        logprobs: Optional[int] = None,
        echo: Optional[bool] = None,
        stop: Optional[str] = None,
        presence_penalty: Optional[float] = None,
        frequency_penalty: Optional[float] = None,
        best_of: Optional[int] = None,
        logit_bias: Optional[Dict[str, float]] = None,
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        request = remove_object_empty_fields({
            "model": model,
            "prompt": prompt,
            "suffix": suffix,
            "max_tokens": max_tokens,
            "temperature": temperature,
            "top_p": top_p,
            "n": n,
            "stream": stream,
            "logprobs": logprobs,
            "echo": echo,
            "stop": stop,
            "presence_penalty": presence_penalty,
            "frequency_penalty": frequency_penalty,
            "best_of": best_of,
            "logit_bias": logit_bias,
        })
        response = openai.Completion.create(**request)
        return response
  original_instructions: |-
    Create Completion in openai
  resource_type: |-
    openai_typeddict
  resource_type_def: |-
    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str
- edit_instructions: |2

    Modify the script to add a new feature that allows copying a range of cells from one sheet to another within the same spreadsheet before deleting the columns.
  id: |-
    hubedit_hub_70
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        source_sheetId: int,
        target_sheetId: int,
        source_range: str,
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        BATCH_UPDATE_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        # Step 1: Copy the range of cells from the source sheet to the target sheet
        copy_request = {
            "copyPaste": {
                "source": {
                    "sheetId": source_sheetId,
                    "startRowIndex": 0,
                    "endRowIndex": 1,
                    "startColumnIndex": start_index,
                    "endColumnIndex": end_index
                },
                "destination": {
                    "sheetId": target_sheetId,
                    "startRowIndex": 0,
                    "endRowIndex": 1,
                    "startColumnIndex": start_index,
                    "endColumnIndex": end_index
                },
                "pasteType": "PASTE_NORMAL",
                "pasteOrientation": "NORMAL"
            }
        }

        # Step 2: Delete the columns from the source sheet
        delete_request = {
            "deleteDimension": {
                "range": {
                    "sheetId": source_sheetId,
                    "dimension": "COLUMNS",
                    "startIndex": start_index,
                    "endIndex": end_index,
                },
            },
        }

        body = {
            "requests": [copy_request, delete_request],
        }

        response = requests.post(
            BATCH_UPDATE_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return "Cells copied and columns deleted."
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: int,
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        DELETE_COLUMN_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "deleteDimension": {
                        "range": {
                            "sheetId": sheetId,
                            "dimension": "COLUMNS",
                            "startIndex": start_index,
                            "endIndex": end_index,
                        },
                    },
                },
            ],
        }
        response = requests.post(
            DELETE_COLUMN_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return "Columns deleted."
  original_instructions: |-
    Clear Columns in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to post a new release instead of retrieving an existing one by changing the HTTP method from GET to POST and including the necessary data for the release in the request body.
  id: |-
    hubedit_hub_414
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: int, releaseTag: str, releaseName: str, releaseDescription: str):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/releases"
        headers = {"PRIVATE-TOKEN": glab['token']}
        data = {
            'tag_name': releaseTag,
            'name': releaseName,
            'description': releaseDescription
        }
        response = requests.post(url, headers=headers, json=data)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: int, releaseTag: str):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/releases/{releaseTag}"
        response = requests.get(url, headers={"PRIVATE-TOKEN": glab['token']})
        return response.json()
  original_instructions: |-
    Get release in gitlab
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the requests.post call, checking for HTTP status codes that indicate failure (like 4xx or 5xx) and raise an appropriate exception or return a custom error message.
  id: |-
    hubedit_hub_112
  lang: |-
    python
  modified_code: |-
    import json
    import requests
    from typing import TypedDict

    class sql(TypedDict):
        statement: str
        timeout: int
        database: str
        schema: str

    def main(token: str, account_id: str, database: str, schema: str, sql: sql):
        POST_URL = f'https://{account_id}.snowflakecomputing.com/api/statements'

        body = {
            'statement': sql['statement'],
            'timeout': 60,
            'database': database,
            'schema': schema,
        }

        try:
            response = requests.post(POST_URL, data=json.dumps(body), headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            })

            # Check if the response was successful
            response.raise_for_status()

        except requests.exceptions.HTTPError as http_err:
            # You can log the error here if needed
            # print(f'HTTP error occurred: {http_err}')
            return {'error': f'HTTP error occurred: {http_err}', 'status_code': response.status_code}
        except requests.exceptions.RequestException as err:
            # You can log the error here if needed
            # print(f'Error occurred: {err}')
            return {'error': f'Error occurred: {err}', 'status_code': response.status_code if response else 'N/A'}
        else:
            return response.json()
  original_code: |-
    import json
    import requests
    from typing import TypedDict

    class sql(TypedDict):
        statement: str
        timeout: int
        database: str
        schema: str

    def main(token: str, account_id: str, database: str, schema: str, sql: sql):
        POST_URL = f'https://{account_id}.snowflakecomputing.com/api/statements'

        body = {
            'statement': sql['statement'],
            'timeout': 60,
            'database': database,
            'schema': schema,
        }

        response = requests.post(POST_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        return response.json()
  original_instructions: |-
    Execute Query & Return Results in snowflake
  resource_type: |-
    sql
  resource_type_def: |-
    class sql(TypedDict):
        statement: str
        timeout: int
        database: str
        schema: str
- edit_instructions: |2

    Add a feature to verify a given password against a stored hash to confirm if they match or not.
  id: |-
    hubedit_hub_85
  lang: |-
    python
  modified_code: |-
    import bcrypt

    def main(password: str, salt_num: int) -> str:
        salt = bcrypt.gensalt(rounds=salt_num)
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass.decode('utf-8')

    def verify_password(stored_hash: str, password_to_verify: str) -> bool:
        return bcrypt.checkpw(password_to_verify.encode('utf-8'), stored_hash.encode('utf-8'))
  original_code: |-
    import bcrypt

    def main(password: str, salt_num: int) -> str:
        salt = bcrypt.gensalt(rounds=salt_num)
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass.decode('utf-8')
  original_instructions: |-
    Hash Password with Manual Salt in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to delete a record from the Airtable table by providing an additional function that takes the record ID as an argument and uses the `delete` method from the `pyairtable` API.
  id: |-
    hubedit_hub_1022
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: str, new_record: dict):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        update_single_record = table.update(record_id, new_record)
        return update_single_record

    def delete_record(at_con: airtable, at_table: airtableTable, record_id: str):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        deleted_record = table.delete(record_id)
        return deleted_record
  original_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: str, new_record: dict):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        update_single_record = table.update(record_id, new_record)
        return update_single_record
  original_instructions: |-
    Update record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add a parameter to specify the style of the generated images, such as photorealistic, oil painting, or pencil sketch, and pass this parameter to the Image.create function.
  id: |-
    hubedit_hub_244
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Literal
    import openai

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def main(
        auth: openai_typeddict,
        prompt: str,
        number_of_images: Literal["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"] = "1",
        size: Literal["256x256", "512x512", "1024x1024"] = "1024x1024",
        response_format: Literal["url", "b64_json"] = "url",
        style: Literal["photorealistic", "oil_painting", "pencil_sketch"] = "photorealistic",
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Image.create(
            prompt=prompt,
            n=int(number_of_images),
            size=size,
            response_format=response_format,
            style=style,  # Added style parameter
        )
        return response['data']
  original_code: |-
    from typing import TypedDict, Literal
    import openai

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def main(
        auth: openai_typeddict,
        prompt: str,
        number_of_images: Literal["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"] = "1",
        size: Literal["256x256", "512x512", "1024x1024"] = "1024x1024",
        response_format: Literal["url", "b64_json"] = "url",
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Image.create(
            prompt=prompt,
            n=int(number_of_images),
            size=size,
            response_format=response_format,
        )
        return response['data']
  original_instructions: |-
    Generate Image in openai
  resource_type: |-
    openai_typeddict
  resource_type_def: |-
    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str
- edit_instructions: |2

    Add functionality to save the search results to a JSON file with a timestamp in the filename.
  id: |-
    hubedit_hub_353
  lang: |-
    python
  modified_code: |-
    import json
    from datetime import datetime
    from typing import TypedDict, Optional, Dict, Any
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def save_to_json(data: Any, filename: str) -> None:
        with open(filename, 'w') as f:
            json.dump(data, f, indent=4)

    def main(
        auth: notion,
        query: Optional[str] = None,
        filter: Optional[Dict[str, str]] = None,
        sort: Optional[Dict[str, str]] = None,
        start_cursor: Optional[str] = None,
        page_size: Optional[int] = None,
    ) -> Any:
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'query': query,
            'filter': filter,
            'sort': sort,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        results = client.search(**args)

        # Generate a timestamped filename
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        filename = f"search_results_{timestamp}.json"

        # Save the results to a JSON file
        save_to_json(results, filename)

        return results
  original_code: |-
    from typing import TypedDict, Optional, Dict, Any
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: notion,
        query: Optional[str] = None,
        filter: Optional[Dict[str, str]] = None,
        sort: Optional[Dict[str, str]] = None,
        start_cursor: Optional[str] = None,
        page_size: Optional[int] = None,
    ) -> Any:
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'query': query,
            'filter': filter,
            'sort': sort,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        return client.search(**args)
  original_instructions: |-
    Search by Title in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to update a specific block's content instead of listing block children by changing the `client.blocks.children.list` method call to `client.blocks.update` and adding the necessary parameters for the update operation.
  id: |-
    hubedit_hub_354
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: notion, block_id: str, content: dict):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'block_id': block_id,
            'children': content,  # Assuming 'content' is a list of block objects
        })
        return client.blocks.update(**args)
  original_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: notion, block_id: str, start_cursor: Optional[str] = None, page_size: Optional[int] = None):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'block_id': block_id,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        return client.blocks.children.list(**args)
  original_instructions: |-
    Retrieve Block Children in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update a cell or range of cells in the spreadsheet with new data provided as an argument to the main function.
  id: |-
    hubedit_hub_52
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, read_range: str, write_range: str, values: List[List[str]]):
        token = gsheets_auth["token"]

        # Read values from the spreadsheet
        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{read_range}"
        response = requests.get(
            GET_VALUES_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )
        read_values = response.json()

        # Update values in the spreadsheet
        UPDATE_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{write_range}:batchUpdate"
        update_body = {
            "valueInputOption": "USER_ENTERED",
            "data": [
                {
                    "range": write_range,
                    "values": values
                }
            ]
        }
        response = requests.post(
            UPDATE_VALUES_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
            json=update_body
        )

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, range: str):
        token = gsheets_auth["token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{range}"

        response = requests.get(
            GET_VALUES_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Get Values in Range in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to save the moderation response to a JSON file with a timestamp in the filename.
  id: |-
    hubedit_hub_246
  lang: |-
    python
  modified_code: |-
    import json
    from datetime import datetime
    from typing import TypedDict
    from openai import OpenAI, ModerationCreateResponse

    class openai(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai, prompt: str, model: str = "text-moderation-latest") -> ModerationCreateResponse:
        openai_api = OpenAI(api_key=auth['api_key'], organization=auth['organization_id'])

        response = openai_api.Moderation.create(
            input=prompt,
            model=model
        )

        # Save the response to a JSON file with a timestamp in the filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"moderation_response_{timestamp}.json"
        with open(filename, 'w') as outfile:
            json.dump(response, outfile)

        return response
  original_code: |-
    from typing import TypedDict
    from openai import OpenAI, ModerationCreateResponse

    class openai(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai, prompt: str, model: str = "text-moderation-latest") -> ModerationCreateResponse:
        openai_api = OpenAI(api_key=auth['api_key'], organization=auth['organization_id'])

        response = openai_api.Moderation.create(
            input=prompt,
            model=model
        )
        return response
  original_instructions: |-
    Create Moderation in openai
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
        organization_id: str
- edit_instructions: |2

    Add a feature to log the output to a file instead of printing it to the console.
  id: |-
    hubedit_hub_158
  lang: |-
    python
  modified_code: |-
    import os
    from typing import TypedDict

    class windmill(TypedDict):
        message: str
        flow_id: str

    def log_to_file(message: str, file_path: str = "output.log"):
        with open(file_path, "a") as file:
            file.write(message + "\n")

    def main(message: str, name: str) -> windmill:
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        log_message = f"message: {message}, name: {name}, flow_id: {flow_id}"
        log_to_file(log_message)
        return {"message": message, "flow_id": flow_id}
  original_code: |-
    import os
    from typing import TypedDict

    class windmill(TypedDict):
        message: str
        flow_id: str

    def main(message: str, name: str) -> windmill:
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        print("message", message)
        print("name", name)
        return {"message": message, "flow_id": flow_id}
  original_instructions: |-
    Log error in windmill
  resource_type: |-
    windmill
  resource_type_def: |-
    class windmill(TypedDict):
        message: str
        flow_id: str
- edit_instructions: |2

    Add functionality to specify the parent folder ID where the new folder should be created on Google Drive.
  id: |-
    hubedit_hub_58
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, title: str, parent_id: Optional[str] = None):
        supports_all_drives = True
        create_folder_url = f"https://www.googleapis.com/drive/v3/files/?supportsAllDrives={supports_all_drives}"

        token = gdrive_auth["token"]
        body = {
            "name": title,
            "mimeType": "application/vnd.google-apps.folder",
        }
        if parent_id:
            body['parents'] = [parent_id]
        response = requests.post(create_folder_url, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        })

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, title: str):
        supports_all_drives = True
        create_folder_url = f"https://www.googleapis.com/drive/v3/files/?supportsAllDrives={supports_all_drives}"

        token = gdrive_auth["token"]
        body = {
            "name": title,
            "mimeType": "application/vnd.google-apps.folder",
        }
        response = requests.post(create_folder_url, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        })

        return response.text
  original_instructions: |-
    Create Folder in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage API request failures or invalid input data, and log the errors to a file for later review.
  id: |-
    hubedit_hub_1025
  lang: |-
    python
  modified_code: |-
    import logging
    from typing import TypedDict, List
    from pyairtable import Table
    from pyairtable.api import ApiError

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    # Configure logging to write errors to a file
    logging.basicConfig(filename='error.log', level=logging.ERROR,
                        format='%(asctime)s:%(levelname)s:%(message)s')

    def main(at_con: airtable, at_table: airtableTable, record_list: List[dict]):
        try:
            table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
            create_multiple = table.batch_create(record_list)
            return create_multiple
        except ApiError as e:
            logging.error(f"API error occurred: {e}")
            return None
        except Exception as e:
            logging.error(f"An unexpected error occurred: {e}")
            return None
  original_code: |-
    from typing import TypedDict, List
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_list: List[dict]):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        create_multiple = table.batch_create(record_list)
        return create_multiple
  original_instructions: |-
    Create Multiple Records in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add functionality to list all branches of the specified repository by modifying the URL to include "/branches" at the end and adjust the function to handle the new endpoint.
  id: |-
    hubedit_hub_313
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import requests

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/branches"
        response = requests.get(url, headers=headers)
        return response.json()
  original_code: |-
    from typing import TypedDict
    import requests

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}"
        response = requests.get(url, headers=headers)
        return response.json()
  original_instructions: |-
    Get Repo in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to attach images to the issue by uploading them to GitHub and referencing them in the body of the issue.
  id: |-
    hubedit_hub_315
  lang: |-
    python
  modified_code: |-
    import requests
    import base64
    from typing import List, Optional, Union, TypedDict

    class github(TypedDict):
        token: str

    def upload_image(gh_auth: github, owner: str, repo: str, image_path: str) -> str:
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "Accept": "application/vnd.github.v3+json"
        }
        with open(image_path, "rb") as image_file:
            image_content = base64.b64encode(image_file.read()).decode()
        data = {
            "message": f"Upload image {image_path}",
            "content": image_content
        }
        response = requests.post(
            f"https://api.github.com/repos/{owner}/{repo}/contents/{image_path}",
            headers=headers,
            json=data
        )
        response_data = response.json()
        if response.status_code == 201:
            return response_data['content']['download_url']
        else:
            raise Exception(f"Image upload failed: {response_data.get('message', 'Unknown error')}")

    def main(
        gh_auth: github,
        owner: str,
        repo: str,
        title: str,
        body: str,
        assignees: Optional[List[str]] = None,
        milestone: Optional[Union[str, int]] = None,
        labels: Optional[List[str]] = None,
        image_paths: Optional[List[str]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json"
        }
        # Upload images and get their URLs
        image_urls = []
        if image_paths:
            for image_path in image_paths:
                image_url = upload_image(gh_auth, owner, repo, image_path)
                image_urls.append(image_url)
            # Append image URLs to the body
            body += "\n" + "\n".join(f"![{image_path}]({image_url})" for image_path, image_url in zip(image_paths, image_urls))

        data = {
            "title": title,
            "body": body,
            "assignees": assignees or [],
            "milestone": milestone,
            "labels": labels
        }
        # Filter out None values
        data = {k: v for k, v in data.items() if v is not None}

        response = requests.post(
            f"https://api.github.com/repos/{owner}/{repo}/issues",
            headers=headers,
            json=data
        )
        return response.json()
  original_code: |-
    import requests
    from typing import List, Optional, Union, TypedDict

    class github(TypedDict):
        token: str

    def main(
        gh_auth: github,
        owner: str,
        repo: str,
        title: str,
        body: str,
        assignees: Optional[List[str]] = None,
        milestone: Optional[Union[str, int]] = None,
        labels: Optional[List[str]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json"
        }
        data = {
            "title": title,
            "body": body,
            "assignees": assignees or [],
            "milestone": milestone,
            "labels": labels
        }
        # Filter out None values
        data = {k: v for k, v in data.items() if v is not None}

        response = requests.post(
            f"https://api.github.com/repos/{owner}/{repo}/issues",
            headers=headers,
            json=data
        )
        return response.json()
  original_instructions: |-
    Create Issue in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update existing cells instead of appending new rows by changing the request endpoint to use the "batchUpdate" method and modifying the request body to include the necessary parameters for updating cells.
  id: |-
    hubedit_hub_37
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import List, Any, TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        sheet_id: str,
        values: List[List[Any]],
        range: str = "Sheet1"
    ):
        body = {
            "valueInputOption": "USER_ENTERED",
            "data": [
                {
                    "range": range,
                    "values": values
                }
            ],
            "includeValuesInResponse": True
        }

        BATCH_UPDATE_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{sheet_id}/values:batchUpdate"

        token = gsheets_auth["token"]

        response = requests.post(
            BATCH_UPDATE_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return {'result': result}
  original_code: |-
    import requests
    from typing import List, Any, TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        sheet_id: str,
        values: List[List[Any]],
        range: str = "Sheet1"
    ):
        body = {
            'values': values,
        }

        valueInputOption = "USER_ENTERED"
        insertDataOption = "INSERT_ROWS"
        includeValuesInResponse = True
        APPEND_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{sheet_id}/values/{range}:append/?valueInputOption={valueInputOption}&insertDataOption={insertDataOption}&includeValuesInResponse={includeValuesInResponse}"

        token = gsheets_auth["token"]

        response = requests.post(
            APPEND_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return {'result': result}
  original_instructions: |-
    Add Rows in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update the status of an issue by sending a PUT request with a new status parameter to the GitLab API.
  id: |-
    hubedit_hub_146
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def update_issue_status(glab: gitlab, projectId: int, issueId: int, new_status: str):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/issues/{issueId}"
        headers = {'Authorization': f'Bearer {glab["token"]}'}
        data = {'state_event': new_status}
        response = requests.put(url, headers=headers, json=data)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: int, issueId: int):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/issues/{issueId}"
        headers = {'Authorization': f'Bearer: {glab["token"]}'}
        response = requests.get(url, headers=headers)
        return response.json()
  original_instructions: |-
    Get Issue in gitlab
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Modify the script to filter out customers based on a specific email domain, only returning customers with email addresses that end in "@example.com".
  id: |-
    hubedit_hub_265
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import time
    import stripe as stripe_module

    def getState():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def setState(value):
        with open('state.txt', 'w') as file:
            file.write(str(value))

    class stripe(TypedDict):
        token: str

    def main(auth: stripe):
        stripe_client = stripe_module.Stripe(auth['token'])
        lastCheck = getState()
        setState(int(time.time()))
        customers = stripe_client.Customer.list(created={'gt': lastCheck})
        filtered_customers = [customer for customer in customers.auto_paging_iter() if customer.email.endswith('@example.com')]
        return filtered_customers
  original_code: |-
    from typing import TypedDict
    import time
    import stripe as stripe_module

    # Assuming getState and setState are functions that need to be implemented
    # to get and set the last checked timestamp in a persistent storage.
    # For the sake of this example, we'll use a simple file-based approach.

    def getState():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def setState(value):
        with open('state.txt', 'w') as file:
            file.write(str(value))

    class stripe(TypedDict):
        token: str

    def main(auth: stripe):
        stripe_client = stripe_module.Stripe(auth['token'])
        lastCheck = getState()
        setState(int(time.time()))
        customers = stripe_client.Customer.list(created={'gt': lastCheck})
        return [customer for customer in customers.auto_paging_iter()]
  original_instructions: |-
    Get recently added customers in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the possibility of a failed request or a non-JSON response. If the request fails or the response is not JSON, return an empty 'windmillhub' dictionary.
  id: |-
    hubedit_hub_170
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Any

    class windmillhub(TypedDict):
        asks: List[Any]

    def main() -> windmillhub:
        url = "https://hub.windmill.dev/searchData"
        try:
            response = requests.get(url)
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
            return response.json()  # This will raise a ValueError if the response isn't JSON
        except (requests.RequestException, ValueError):
            # If there's a request error or the response isn't JSON, return an empty 'windmillhub' dictionary
            return {'asks': []}

    # Example usage
    if __name__ == "__main__":
        result = main()
        print(result)
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class windmillhub(TypedDict):
        asks: List[Any]

    def main() -> windmillhub:
        url = "https://hub.windmill.dev/searchData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List suggestions in windmillhub
  resource_type: |-
    windmillhub
  resource_type_def: |-
    class windmillhub(TypedDict):
        asks: List[Any]
- edit_instructions: |2

    Add error handling to manage the response from the request, checking for HTTP status codes that indicate failure (like 4xx and 5xx) and raise an appropriate exception or return a meaningful error message.
  id: |-
    hubedit_hub_369
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class nocodb(TypedDict):
        apiUrl: str
        xc_token: str
        table: str
        workspace: str

    def main(nocodb: nocodb, limit: int):
        try:
            # request from nocodb
            res = requests.get(
                f"{nocodb['apiUrl']}/api/v1/db/data/v1/{nocodb['workspace']}/{nocodb['table']}?limit={limit}",
                headers={
                    "Content-Type": "application/json",
                    "xc-token": nocodb['xc_token'],
                },
            )

            # Check if the response was successful
            res.raise_for_status()

        except requests.exceptions.HTTPError as http_err:
            # Handle HTTP errors
            return f"HTTP error occurred: {http_err}"
        except requests.exceptions.ConnectionError as conn_err:
            # Handle connection errors
            return f"Connection error occurred: {conn_err}"
        except requests.exceptions.Timeout as timeout_err:
            # Handle timeout errors
            return f"Timeout error occurred: {timeout_err}"
        except requests.exceptions.RequestException as req_err:
            # Handle other request-related errors
            return f"Request error occurred: {req_err}"
        except Exception as e:
            # Handle other exceptions such as JSON decoding errors
            return f"An error occurred: {e}"

        # If no exceptions were raised, process the data
        data = res.json()
        return data
  original_code: |-
    import requests
    from typing import TypedDict

    class nocodb(TypedDict):
        apiUrl: str
        xc_token: str
        table: str
        workspace: str

    def main(nocodb: nocodb, limit: int):
        # request from nocodb
        res = requests.get(
            f"{nocodb['apiUrl']}/api/v1/db/data/v1/{nocodb['workspace']}/{nocodb['table']}?limit={limit}",
            headers={
                "Content-Type": "application/json",
                "xc-token": nocodb['xc_token'],
            },
        )
        data = res.json()
        return data
  original_instructions: |-
    Get item list from a NocoDb table in nocodb
  resource_type: |-
    nocodb
  resource_type_def: |-
    class nocodb(TypedDict):
        apiUrl: str
        xc_token: str
        table: str
        workspace: str
- edit_instructions: |2

    Add functionality to read the content from a file specified by the path instead of directly taking a string as content.
  id: |-
    hubedit_hub_108
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, file_path: str):
        session = boto3.session.Session()
        client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        try:
            with open(file_path, 'rb') as file:
                client.put_object(Bucket=s3_config['bucket'], Key=file_path, Body=file)
        except FileNotFoundError:
            print(f"The file {file_path} was not found.")
        except NoCredentialsError:
            print("Credentials not available")
  original_code: |-
    from typing import TypedDict
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, path: str, content: str):
        session = boto3.session.Session()
        client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        try:
            client.put_object(Bucket=s3_config['bucket'], Key=path, Body=content)
        except NoCredentialsError:
            print("Credentials not available")
  original_instructions: |-
    Upload text in bucket in s3
  resource_type: |-
    s3
  resource_type_def: |-
    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str
- edit_instructions: |2

    Modify the script to create a new user in the Nextcloud instance by changing the HTTP method from GET to POST and including the necessary user data in the request body.
  id: |-
    hubedit_hub_163
  lang: |-
    python
  modified_code: |-
    import base64
    import requests
    from typing import TypedDict

    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str
        new_username: str
        new_password: str

    def main(nextcloud_res: nextcloud) -> str:
        url = f"{nextcloud_res['baseUrl']}/ocs/v1.php/cloud/users"
        credentials = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['password']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {credentials}",
            'OCS-APIRequest': 'true',
            'Content-Type': 'application/x-www-form-urlencoded',
        }
        data = {
            'userid': nextcloud_res['new_username'],
            'password': nextcloud_res['new_password'],
        }
        resp = requests.post(url, headers=headers, data=data)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str

    def main(nextcloud_res: nextcloud) -> str:
        url = f"{nextcloud_res['baseUrl']}/ocs/v1.php/cloud/users"
        credentials = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['password']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {credentials}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_instructions: |-
    List user IDs in ocs
  resource_type: |-
    nextcloud
  resource_type_def: |-
    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str
- edit_instructions: |2

    Add a filter option to the script that allows the user to specify a field and a value to filter the query results based on that field's value.
  id: |-
    hubedit_hub_356
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional, Tuple
    from firebase_admin import credentials, firestore, initialize_app
    from google.cloud.firestore_v1 import Client, CollectionReference, Query

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        order_by: Optional[str] = None,
        order_direction: str = "asc",
        start_at: Optional[str] = None,
        end_at: Optional[str] = None,
        limit: Optional[int] = None,
        filter_by: Optional[Tuple[str, str]] = None,  # Added filter_by parameter
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['private_key_id'],
            "private_key": auth['private_key'],
            "client_email": auth['client_email'],
            "client_id": auth['client_id'],
            "auth_uri": auth['auth_uri'],
            "token_uri": auth['token_uri'],
            "auth_provider_x509_cert_url": auth['auth_provider_x509_cert_url'],
            "client_x509_cert_url": auth['client_x509_cert_url']
        })
        app = initialize_app(cred)
        store: Client = firestore.client(app)

        col_ref: CollectionReference = store.collection(collection_id)
        constraints = []

        if order_by:
            constraints.append(Query(col_ref).order_by(order_by, direction=order_direction))
        if start_at:
            constraints.append(Query(col_ref).start_at([start_at]))
        if end_at:
            constraints.append(Query(col_ref).end_at([end_at]))
        if limit:
            constraints.append(Query(col_ref).limit(limit))
        if filter_by:  # Added filter condition
            field, value = filter_by
            constraints.append(Query(col_ref).where(field, '==', value))

        query_ref = col_ref
        for constraint in constraints:
            query_ref = constraint

        snapshot = query_ref.stream()
        list = [doc.to_dict() for doc in snapshot]

        return list
  original_code: |-
    from typing import TypedDict, Optional
    from firebase_admin import credentials, firestore, initialize_app
    from google.cloud.firestore_v1 import Client, CollectionReference, Query

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        order_by: Optional[str] = None,
        order_direction: str = "asc",
        start_at: Optional[str] = None,
        end_at: Optional[str] = None,
        limit: Optional[int] = None,
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['private_key_id'],
            "private_key": auth['private_key'],
            "client_email": auth['client_email'],
            "client_id": auth['client_id'],
            "auth_uri": auth['auth_uri'],
            "token_uri": auth['token_uri'],
            "auth_provider_x509_cert_url": auth['auth_provider_x509_cert_url'],
            "client_x509_cert_url": auth['client_x509_cert_url']
        })
        app = initialize_app(cred)
        store: Client = firestore.client(app)

        col_ref: CollectionReference = store.collection(collection_id)
        constraints = []

        if order_by:
            constraints.append(Query(col_ref).order_by(order_by, direction=order_direction))
        if start_at:
            constraints.append(Query(col_ref).start_at([start_at]))
        if end_at:
            constraints.append(Query(col_ref).end_at([end_at]))
        if limit:
            constraints.append(Query(col_ref).limit(limit))

        query_ref = col_ref
        for constraint in constraints:
            query_ref = constraint

        snapshot = query_ref.stream()
        list = [doc.to_dict() for doc in snapshot]

        return list
  original_instructions: |-
    List Documents in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- edit_instructions: |2

    Modify the script to send a new message to a specified chat instead of pinning an existing message.
  id: |-
    hubedit_hub_239
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import telebot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, text: str):
        client = telebot.TeleBot(auth['token'])
        return client.send_message(chat_id, text)
  original_code: |-
    from typing import TypedDict
    import telebot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message_id: int):
        client = telebot.TeleBot(auth['token'])
        return client.pin_chat_message(chat_id, message_id)
  original_instructions: |-
    Pin a Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter the returned room state events by a specific event type, such as "m.room.member" or "m.room.message", by adding an optional parameter to the main function for the event type and modifying the request URL accordingly.
  id: |-
    hubedit_hub_160
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, event_type: Optional[str] = None):
        base_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}"
        url = f"{base_url}/state"
        if event_type:
            url = f"{base_url}/state/{requests.utils.quote(event_type)}"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return {
            'events': resp.json(),
        }
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return {
            'events': resp.json(),
        }
  original_instructions: |-
    Get entire room state in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Modify the script to add a new worksheet to the spreadsheet instead of deleting an existing one.
  id: |-
    hubedit_hub_67
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, title: str):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            'requests': [
                {
                    'addSheet': {
                        'properties': {
                            'title': title,
                        },
                    },
                },
            ],
        }

        response = requests.post(
            ADD_WORKSHEET_URL,
            json=body,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            },
        )

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, sheetId: int):
        token = gsheets_auth["token"]

        DELETE_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            'requests': [
                {
                    'deleteSheet': {
                        'sheetId': sheetId,
                    },
                },
            ],
        }

        response = requests.post(
            DELETE_WORKSHEET_URL,
            json=body,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            },
        )

        return response.text
  original_instructions: |-
    Delete Worksheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to the script to handle the response from the PATCH request, checking if the edit was successful and printing an appropriate message to the console based on the success or failure of the operation.
  id: |-
    hubedit_hub_132
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, messageId: str, newMessageContent: str):
        webhook_url = discord_webhook['webhook_url']
        edit_url = f"{webhook_url}/messages/{messageId}"
        payload = {
            "content": newMessageContent
        }
        headers = {
            "Content-Type": "application/json"
        }
        response = requests.patch(edit_url, json=payload, headers=headers)

        if response.status_code == 200:
            print("Message edited successfully.")
        else:
            print(f"Failed to edit message. Status code: {response.status_code}, Response: {response.text}")

        return response.json()

    # Example usage:
    # webhook_info = {"webhook_url": "https://discord.com/api/webhooks/..."}
    # main(webhook_info, "messageId", "New message content")
  original_code: |-
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, messageId: str, newMessageContent: str):
        webhook_url = discord_webhook['webhook_url']
        edit_url = f"{webhook_url}/messages/{messageId}"
        payload = {
            "content": newMessageContent
        }
        headers = {
            "Content-Type": "application/json"
        }
        ret = requests.patch(edit_url, json=payload, headers=headers)
        return ret.json()
  original_instructions: |-
    Edit message in discord
  resource_type: |-
    discordwebhook
  resource_type_def: |-
    class discordwebhook(TypedDict):
        webhook_url: str
- edit_instructions: |2

    Add functionality to cache the response data in a local file to avoid repeated requests for the same data, and check the cache before making a new request.
  id: |-
    hubedit_hub_223
  lang: |-
    python
  modified_code: |-
    import json
    import requests
    import os
    from typing import TypedDict, Optional
    from hashlib import md5

    class sendgrid(TypedDict):
        token: str

    def get_cache_filename(api_token: sendgrid, page_size: Optional[int], page_token: Optional[int]) -> str:
        # Create a unique cache filename based on the API token, page size, and page token
        cache_key = f"{api_token['token']}_{page_size}_{page_token}"
        # Use MD5 to ensure the filename is a valid and unique string
        filename = md5(cache_key.encode('utf-8')).hexdigest()
        return f"cache_{filename}.json"

    def read_cache(filename: str):
        # Check if the cache file exists and read it
        if os.path.exists(filename):
            with open(filename, 'r') as file:
                return json.load(file)
        return None

    def write_cache(filename: str, data):
        # Write the response data to the cache file
        with open(filename, 'w') as file:
            json.dump(data, file)

    def main(api_token: sendgrid, page_size: Optional[int] = None, page_token: Optional[int] = None):
        # Generate the cache filename
        cache_filename = get_cache_filename(api_token, page_size, page_token)

        # Check if the data is in the cache
        cached_data = read_cache(cache_filename)
        if cached_data is not None:
            return cached_data

        headers = {
            "Authorization": f"Bearer {api_token['token']}"
        }
        params = {
            "page_size": page_size,
            "page_token": page_token
        }
        url = "https://api.sendgrid.com/v3/marketing/lists"

        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            data = response.json()
            # Cache the response data
            write_cache(cache_filename, data)
            return data
        else:
            raise Exception("\n" + json.dumps(response.json()))
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, page_size: Optional[int] = None, page_token: Optional[int] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}"
        }
        params = {
            "page_size": page_size,
            "page_token": page_token
        }
        url = "https://api.sendgrid.com/v3/marketing/lists"

        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + json.dumps(response.json()))
  original_instructions: |-
    Get Contact Lists in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to update a specific property of the page with a new value provided as an additional argument to the main function.
  id: |-
    hubedit_hub_351
  lang: |-
    python
  modified_code: |-
    from notion_client import Client
    from typing import List, TypedDict, Optional

    class notion(TypedDict):
        token: str

    def main(auth: notion, page_id: str, property_name: str, new_value, filter_properties: Optional[List[str]] = None):
        client = Client(auth=auth['token'])
        if not filter_properties or not any(filter_properties):
            filter_properties = None

        # Retrieve the page to get the current properties and their types
        page = client.pages.retrieve({"page_id": page_id})
        properties = page.get('properties', {})

        # Check if the property exists in the page
        if property_name not in properties:
            raise ValueError(f"The property '{property_name}' does not exist in the page.")

        # Update the specific property with the new value
        update_payload = {
            "page_id": page_id,
            "properties": {
                property_name: new_value
            }
        }

        # Perform the update
        updated_page = client.pages.update(update_payload)

        return updated_page
  original_code: |-
    from notion_client import Client
    from typing import List, TypedDict, Optional

    class notion(TypedDict):
        token: str

    def main(auth: notion, page_id: str, filter_properties: Optional[List[str]] = None):
        client = Client(auth=auth['token'])
        if not filter_properties or not any(filter_properties):
            filter_properties = None
        return client.pages.retrieve({
            "page_id": page_id,
            "filter_properties": filter_properties,
        })
  original_instructions: |-
    Retrieve Page in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing user by sending a PUT request if a user ID is provided in the zammad_data dictionary.
  id: |-
    hubedit_hub_155
  lang: |-
    python
  modified_code: |-
    def main(zammad_data: zammad):
        user_agent = zammad_data.get('user_agent', "Public windmill.dev script")
        headers = {
            'Authorization': f"Bearer {zammad_data['zammad_token']}",
            'User-Agent': user_agent,
        }
        payload = {
            'firstname': zammad_data['firstname'],
            'lastname': zammad_data['lastname'],
            'email': zammad_data['email'],
        }
        if 'login' in zammad_data:
            payload['login'] = zammad_data['login']
        if 'organisation' in zammad_data:
            payload['organisation'] = zammad_data['organisation']
        if 'roles' in zammad_data:
            payload['roles'] = zammad_data['roles']

        if 'user_id' in zammad_data:
            response = requests.put(f"{zammad_data['zammad_host']}/api/v1/users/{zammad_data['user_id']}", headers=headers, json=payload)
        else:
            response = requests.post(f"{zammad_data['zammad_host']}/api/v1/users", headers=headers, json=payload)

        if not response.ok and response.status_code != 422:
            raise Exception(f"Failed to create/update user: Error HTTP{response.status_code}")

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Optional, List

    class zammad(TypedDict, total=False):
        zammad_host: str
        zammad_token: str
        user_agent: Optional[str]
        firstname: str
        lastname: str
        email: str
        login: Optional[str]
        organisation: Optional[str]
        roles: Optional[List[str]]

    def main(zammad_data: zammad):
        user_agent = zammad_data.get('user_agent', "Public windmill.dev script")
        headers = {
            'Authorization': f"Bearer {zammad_data['zammad_token']}",
            'User-Agent': user_agent,
        }
        payload = {
            'firstname': zammad_data['firstname'],
            'lastname': zammad_data['lastname'],
            'email': zammad_data['email'],
        }
        if 'login' in zammad_data:
            payload['login'] = zammad_data['login']
        if 'organisation' in zammad_data:
            payload['organisation'] = zammad_data['organisation']
        if 'roles' in zammad_data:
            payload['roles'] = zammad_data['roles']

        response = requests.post(f"{zammad_data['zammad_host']}/api/v1/users", headers=headers, json=payload)

        if not response.ok and response.status_code != 422:
            raise Exception(f"Failed to create user: Error HTTP{response.status_code}")

        return response.json()
  original_instructions: |-
    Create user in zammad
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to update an existing document with new data instead of deleting it. You will need to provide the new data as an additional parameter to the main function and use the `update_document` method from the `Databases` service.
  id: |-
    hubedit_hub_338
  lang: |-
    python
  modified_code: |-
    from appwrite.client import Client
    from appwrite.services.databases import Databases
    from typing import TypedDict, Dict

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, document_id: str, data: Dict):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)
        return db.update_document(database_id, collection_id, document_id, data)
  original_code: |-
    from appwrite.client import Client
    from appwrite.services.databases import Databases
    from typing import TypedDict

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, document_id: str):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)
        return db.delete_document(database_id, collection_id, document_id)
  original_instructions: |-
    Delete Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add a feature to verify a given password against the hashed password to confirm if they match or not.
  id: |-
    hubedit_hub_86
  lang: |-
    python
  modified_code: |-
    import bcrypt

    def main(password: str) -> str:
        salt = bcrypt.gensalt()
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass.decode('utf-8')

    def verify_password(provided_password: str, stored_hash: str) -> bool:
        return bcrypt.checkpw(provided_password.encode('utf-8'), stored_hash.encode('utf-8'))
  original_code: |-
    import bcrypt

    def main(password: str) -> str:
        salt = bcrypt.gensalt()
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass.decode('utf-8')
  original_instructions: |-
    Hash Password with Random Salt in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a caching mechanism to store and retrieve the results of queries, reducing the need to make repeated requests for the same data.
  id: |-
    hubedit_hub_319
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Any, Optional, Dict
    from functools import lru_cache

    class surrealdb(TypedDict):
        url: str
        token: str

    # Define a simple cache decorator to memoize query results
    def cache_query(maxsize: int = 128):
        def decorator(func):
            memo = {}

            def wrapper(*args, **kwargs):
                # Create a unique key based on the query and its variables
                key = (args[2], args[3], frozenset(kwargs.get('variables', {}).items()))
                if key not in memo:
                    memo[key] = func(*args, **kwargs)
                return memo[key]
            return wrapper
        return decorator

    @cache_query()
    def main(auth: surrealdb, namespace: str, database: str, query: str, variables: Optional[Dict[str, Any]] = None) -> Any:
        headers = {
            'Authorization': f'Bearer {auth["token"]}',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        }
        use_query = f'USE {namespace}::{database};'
        full_query = use_query + query
        payload = {'query': full_query}
        if variables:
            payload['variables'] = variables
        response = requests.post(auth['url'], json=payload, headers=headers)
        if response.status_code != 200:
            raise Exception(f"Error: {response.text}")
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Any, Optional, Dict

    class surrealdb(TypedDict):
        url: str
        token: str

    def main(auth: surrealdb, namespace: str, database: str, query: str, variables: Optional[Dict[str, Any]] = None) -> Any:
        headers = {
            'Authorization': f'Bearer {auth["token"]}',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        }
        use_query = f'USE {namespace}::{database};'
        full_query = use_query + query
        payload = {'query': full_query}
        if variables:
            payload['variables'] = variables
        response = requests.post(auth['url'], json=payload, headers=headers)
        if response.status_code != 200:
            raise Exception(f"Error: {response.text}")
        return response.json()
  original_instructions: |-
    Run Arbitrary Query in surrealdb
  resource_type: |-
    surrealdb
  resource_type_def: |-
    class surrealdb(TypedDict):
        url: str
        token: str
- edit_instructions: |2

    Modify the script to send a new message to the specified chat_id instead of unpinning a message.
  id: |-
    hubedit_hub_240
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import telebot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, text: str):
        client = telebot.TeleBot(auth['token'])
        return client.send_message(chat_id, text)
  original_code: |-
    from typing import TypedDict
    import telebot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message_id: int):
        client = telebot.TeleBot(auth['token'])
        return client.unpin_chat_message(chat_id, message_id)
  original_instructions: |-
    Unpin a Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to send a message to the room after successfully joining it by making an additional HTTP POST request to the appropriate endpoint with the message content.
  id: |-
    hubedit_hub_97
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict
    import json

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room: str, message: str):
        if not matrix_res['token']:
            raise ValueError("Joining a room requires an access token.")

        join_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/join/{requests.utils.quote(room)}"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        join_resp = requests.post(join_url, headers=headers)

        if not join_resp.ok:
            raise ValueError(f"Failed to join room: Error HTTP{join_resp.status_code}")

        # After joining the room, send a message
        room_id = join_resp.json().get("room_id")
        if not room_id:
            raise ValueError("Failed to retrieve room_id from join response.")

        send_message_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/send/m.room.message"
        message_content = {
            "msgtype": "m.text",
            "body": message
        }

        send_resp = requests.post(send_message_url, headers=headers, data=json.dumps(message_content))

        if not send_resp.ok:
            raise ValueError(f"Failed to send message: Error HTTP{send_resp.status_code}")
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room: str):
        if not matrix_res['token']:
            raise ValueError("Joining a room requires an access token.")

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/join/{requests.utils.quote(room)}"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        resp = requests.post(url, headers=headers)

        if not resp.ok:
            raise ValueError(f"Failed to join room: Error HTTP{resp.status_code}")
  original_instructions: |-
    Join room in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add a feature to retry the request if it fails due to a network error or a 5xx server error, with a maximum number of retries and a delay between retries.
  id: |-
    hubedit_hub_271
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional
    from time import sleep

    class windmill(TypedDict):
        workspace: str
        id: str
        requestBody: dict

    def get_workspace() -> str:
        # Placeholder for the actual implementation to get the workspace
        return "your_workspace"

    def main(id: str, resume_payload: Optional[dict] = None, max_retries: int = 3, retry_delay: int = 5) -> dict:
        resume_payload = resume_payload or {}
        job_service_url = "https://api.windmill.com/v1/resumeSuspendedFlowAsOwner"

        payload: windmill = {
            "workspace": get_workspace(),
            "id": id,
            "requestBody": resume_payload,
        }

        retries = 0
        while retries < max_retries:
            try:
                response = requests.post(job_service_url, json=payload)
                if response.status_code // 100 == 5:  # Check for 5xx server errors
                    raise requests.exceptions.HTTPError(f"Server error: {response.status_code}")
                return response.json()
            except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.HTTPError) as e:
                retries += 1
                if retries < max_retries:
                    sleep(retry_delay)
                else:
                    raise e  # Re-raise the last exception if all retries failed
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class windmill(TypedDict):
        workspace: str
        id: str
        requestBody: dict

    def get_workspace() -> str:
        # Placeholder for the actual implementation to get the workspace
        return "your_workspace"

    def main(id: str, resume_payload: Optional[dict] = None) -> dict:
        resume_payload = resume_payload or {}
        job_service_url = "https://api.windmill.com/v1/resumeSuspendedFlowAsOwner"

        payload: windmill = {
            "workspace": get_workspace(),
            "id": id,
            "requestBody": resume_payload,
        }

        response = requests.post(job_service_url, json=payload)
        return response.json()
  original_instructions: |-
    Resume Suspended Flow as Owner in windmill
  resource_type: |-
    windmill
  resource_type_def: |-
    class windmill(TypedDict):
        workspace: str
        id: str
        requestBody: dict
- edit_instructions: |2

    Modify the script to update the content of the specified block with new text instead of retrieving the block's information.
  id: |-
    hubedit_hub_352
  lang: |-
    python
  modified_code: |-
    from notion_client import Client
    from typing import TypedDict

    class NotionAuth(TypedDict):
        token: str

    def update_block_content(auth: NotionAuth, block_id: str, new_text: str):
        client = Client(auth=auth['token'])
        response = client.blocks.update(
            block_id=block_id,
            block={
                "paragraph": {
                    "text": [
                        {
                            "type": "text",
                            "text": {
                                "content": new_text
                            }
                        }
                    ]
                }
            }
        )
        return response
  original_code: |-
    from notion_client import Client
    from typing import TypedDict

    class notion(TypedDict):
        token: str

    def main(auth: notion, block_id: str):
        client = Client(auth=auth['token'])
        return client.blocks.retrieve(block_id=block_id)
  original_instructions: |-
    Retrieve Block in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to send a custom message to the chat informing users about the kicked member after the action is performed.
  id: |-
    hubedit_hub_238
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    import telebot  # You might need to install pyTelegramBotAPI package (`pip install pyTelegramBotAPI`)

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, user_id: int, custom_message: str, until_date: Optional[int] = None, revoke_messages: Optional[bool] = None):
        client = telebot.TeleBot(auth['token'])
        if revoke_messages is None:
            revoke_messages = False
        kick_result = client.kick_chat_member(chat_id, user_id, until_date=until_date, revoke_messages=revoke_messages)
        client.send_message(chat_id, custom_message)
        return kick_result
  original_code: |-
    from typing import TypedDict, Optional
    import telebot  # You might need to install pyTelegramBotAPI package (`pip install pyTelegramBotAPI`)

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, user_id: int, until_date: Optional[int] = None, revoke_messages: Optional[bool] = None):
        client = telebot.TeleBot(auth['token'])
        if revoke_messages is None:
            revoke_messages = False
        return client.kick_chat_member(chat_id, user_id, until_date=until_date, revoke_messages=revoke_messages)
  original_instructions: |-
    Kick a Chat Member in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to add a new worksheet to the spreadsheet instead of updating cells in an existing sheet.
  id: |-
    hubedit_hub_66
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, title: str):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "addSheet": {
                        "properties": {
                            "title": title,
                        },
                    },
                },
            ],
        }

        response = requests.post(
            ADD_WORKSHEET_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, sheetId: int):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheetId,
                        },
                        "fields": "userEnteredValue",
                    },
                },
            ],
        }

        response = requests.post(
            ADD_WORKSHEET_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Clear All Values in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to perform an update operation on the specified table instead of a delete operation, allowing the user to pass in a dictionary of column-value pairs to specify the new data for the updated records.
  id: |-
    hubedit_hub_285
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional, Union, Any, Dict
    import requests

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        # This is a placeholder for the refreshAndRetryIfExpired logic.
        # In a real-world scenario, you would implement token refresh logic here.
        # For the purpose of this example, we'll assume the token is valid and directly call the action.
        return action()

    def main(
        auth: supabase,
        table: str,
        filter: Dict[str, Any],
        update_data: Dict[str, Any],
        return_deleted: bool = False,
        token: Optional[Dict[str, Union[str, int]]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            params = {
                'select': '*' if return_deleted else '',
                'filter': f"{filter['column']}.{filter['operator']}.{filter['value']}"
            }
            if count:
                params['count'] = count

            response = requests.patch(f"{auth['url']}/{table}", headers=headers, params=params, json=update_data)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  original_code: |-
    from typing import TypedDict, Optional, Union, Any, Dict
    import requests

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        # This is a placeholder for the refreshAndRetryIfExpired logic.
        # In a real-world scenario, you would implement token refresh logic here.
        # For the purpose of this example, we'll assume the token is valid and directly call the action.
        return action()

    def main(
        auth: supabase,
        table: str,
        filter: Dict[str, Any],
        return_deleted: bool = False,
        token: Optional[Dict[str, Union[str, int]]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            params = {
                'select': '*' if return_deleted else '',
                'filter': f"{filter['column']}.{filter['operator']}.{filter['value']}"
            }
            if count:
                params['count'] = count

            response = requests.delete(f"{auth['url']}/{table}", headers=headers, params=params)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  original_instructions: |-
    Delete data in supabase
  resource_type: |-
    supabase
  resource_type_def: |-
    class supabase(TypedDict):
        url: str
        key: str
- edit_instructions: |2

    Add functionality to create a new document within the specified collection with predefined data fields.
  id: |-
    hubedit_hub_332
  lang: |-
    python
  modified_code: |-
    def create_document(
        database_id: str,
        collection_id: str,
        data: dict,
        read_permissions: Optional[List[str]] = None,
        write_permissions: Optional[List[str]] = None,
    ):
        return db.create_document(
            database_id=database_id,
            collection_id=collection_id,
            data=data,
            read=read_permissions,
            write=write_permissions,
        )

    # You would call the create_document function like this:
    # document_data = {
    #     "name": "John Doe",
    #     "email": "johndoe@example.com",
    #     "age": 30
    # }
    # document = create_document(
    #     database_id="your_database_id",
    #     collection_id="your_collection_id",
    #     data=document_data,
    #     read_permissions=["role:member"],
    #     write_permissions=["role:member"]
    # )
  original_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: str,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
        collection_enabled: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        return db.update_collection(
            database_id=database_id,
            collection_id=collection_id,
            name=collection_name,
            permissions=collection_permissions,
            document_security=collection_document_security,
            enabled=collection_enabled,
        )
  original_instructions: |-
    Update Collection in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Modify the script to generate a random floating-point number between the minimum and maximum values instead of an integer.
  id: |-
    hubedit_hub_101
  lang: |-
    python
  modified_code: |-
    import random

    def main(min: float = 0.0, max: float = 100.0) -> float:
        return random.uniform(min, max)
  original_code: |-
    import random

    def main(min: int = 0, max: int = 100) -> int:
        return random.randint(min, max)
  original_instructions: |-
    Random Integer in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to handle bulk updates by accepting a list of filter-document pairs and iterating through them to perform multiple update operations in a single call to the main function.
  id: |-
    hubedit_hub_261
  lang: |-
    python
  modified_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Mapping, List, Tuple

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        updates: List[Tuple[Mapping[str, Any], Mapping[str, Any]]],
        upsert: bool = False
    ):
        client = MongoClient(auth['endpoint'])
        db = client[database]
        coll = db[collection]
        upsert_option = upsert
        bulk_operations = []

        for filter, document in updates:
            bulk_operations.append(
                pymongo.UpdateOne(filter, {'$set': document}, upsert=upsert_option)
            )

        if bulk_operations:
            return coll.bulk_write(bulk_operations)
        else:
            return None
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Mapping

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Mapping[str, Any],
        document: Mapping[str, Any],
        upsert: bool = False
    ):
        client = MongoClient(auth['endpoint'])
        db = client[database]
        coll = db[collection]
        upsert_option = upsert
        return coll.update_one(filter, {'$set': document}, upsert=upsert_option)
  original_instructions: |-
    Update a Document in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Add functionality to handle new interaction types such as MESSAGE_COMPONENT or MODAL_SUBMIT by extending the InteractionType class and implementing the corresponding logic in the main function.
  id: |-
    hubedit_hub_377
  lang: |-
    python
  modified_code: |-
    import json
    from typing import TypedDict
    from nacl.signing import VerifyKey
    from nacl.exceptions import BadSignatureError

    # Define the TypedDict for the Discord bot configuration
    class discordbotconfiguration(TypedDict):
        public_key: str
        application_id: str

    # Define the InteractionType and InteractionResponseType enums
    class InteractionType:
        PING = 1
        APPLICATION_COMMAND = 2
        MESSAGE_COMPONENT = 3
        MODAL_SUBMIT = 5

    class InteractionResponseType:
        PONG = 1
        CHANNEL_MESSAGE_WITH_SOURCE = 4
        DEFERRED_UPDATE_MESSAGE = 6
        UPDATE_MESSAGE = 7

    def main(x_signature_ed25519: str, x_signature_timestamp: str, raw_string: str, discord_config: discordbotconfiguration):
        # Verify the request signature
        try:
            verify_key = VerifyKey(bytes.fromhex(discord_config['public_key']))
            verify_key.verify(f'{x_signature_timestamp}{raw_string}'.encode(), bytes.fromhex(x_signature_ed25519))
        except BadSignatureError:
            return {'windmill_status_code': 401}

        interaction = json.loads(raw_string)

        # Respond to a PING interaction
        if interaction['type'] == InteractionType.PING:
            return {'type': InteractionResponseType.PONG}

        # Handle an APPLICATION_COMMAND interaction
        elif interaction['type'] == InteractionType.APPLICATION_COMMAND:
            message = f"Received command: ```json\n{json.dumps({'id': interaction['id'], 'sender': interaction.get('member', {}).get('user'), 'data': interaction['data']}, indent=2)}\n```"
            return {
                'type': InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                'data': {
                    'content': message,
                },
            }

        # Handle a MESSAGE_COMPONENT interaction
        elif interaction['type'] == InteractionType.MESSAGE_COMPONENT:
            custom_id = interaction['data']['custom_id']
            message = f"Received component interaction: {custom_id}"
            return {
                'type': InteractionResponseType.UPDATE_MESSAGE,
                'data': {
                    'content': message,
                },
            }

        # Handle a MODAL_SUBMIT interaction
        elif interaction['type'] == InteractionType.MODAL_SUBMIT:
            custom_id = interaction['data']['custom_id']
            message = f"Received modal submit: {custom_id}"
            return {
                'type': InteractionResponseType.UPDATE_MESSAGE,
                'data': {
                    'content': message,
                },
            }
  original_code: |-
    import json
    from typing import TypedDict
    from nacl.signing import VerifyKey
    from nacl.exceptions import BadSignatureError

    # Define the TypedDict for the Discord bot configuration
    class discordbotconfiguration(TypedDict):
        public_key: str
        application_id: str

    # Define the InteractionType and InteractionResponseType enums
    class InteractionType:
        PING = 1
        APPLICATION_COMMAND = 2

    class InteractionResponseType:
        PONG = 1
        CHANNEL_MESSAGE_WITH_SOURCE = 4

    def main(x_signature_ed25519: str, x_signature_timestamp: str, raw_string: str, discord_config: discordbotconfiguration):
        # Verify the request signature
        try:
            verify_key = VerifyKey(bytes.fromhex(discord_config['public_key']))
            verify_key.verify(f'{x_signature_timestamp}{raw_string}'.encode(), bytes.fromhex(x_signature_ed25519))
        except BadSignatureError:
            return {'windmill_status_code': 401}

        interaction = json.loads(raw_string)

        # Respond to a PING interaction
        if interaction['type'] == InteractionType.PING:
            return {'type': InteractionResponseType.PONG}

        # Handle an APPLICATION_COMMAND interaction
        if interaction['type'] == InteractionType.APPLICATION_COMMAND:
            message = f"Received command: ```json\n{json.dumps({'id': interaction['id'], 'sender': interaction.get('member', {}).get('user'), 'data': interaction['data']}, indent=2)}\n```"
            return {
                'type': InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                'data': {
                    'content': message,
                },
            }
  original_instructions: |-
    Receive Application Command Sample in discord
  resource_type: |-
    discordbotconfiguration
  resource_type_def: |-
    class discordbotconfiguration(TypedDict):
        public_key: str
        application_id: str
- edit_instructions: |2

    Add functionality to specify a new name for the copied file by including a JSON body with the 'name' field in the POST request.
  id: |-
    hubedit_hub_57
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str, new_name: str):
        supportsAllDrives = True
        COPY_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/copy/?supportsAllDrives={supportsAllDrives}"

        token = gdrive_auth["token"]

        response = requests.post(
            COPY_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
            json={"name": new_name},  # Include the new name in the JSON body of the POST request
        )

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        supportsAllDrives = True
        COPY_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/copy/?supportsAllDrives={supportsAllDrives}"

        token = gdrive_auth["token"]

        response = requests.post(
            COPY_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Copy File in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to handle connection errors and retries with exponential backoff.
  id: |-
    hubedit_hub_366
  lang: |-
    python
  modified_code: |-
    import time
    import psycopg2
    from psycopg2 import OperationalError
    from typing import TypedDict

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    class Cacertificate(TypedDict):
        certificate: str

    def main(db_config: postgresql, cacertificate: Cacertificate, sql: str = "SELECT 1 as id"):
        max_retries = 5
        backoff_factor = 2
        retry_count = 0

        while retry_count < max_retries:
            try:
                connection = psycopg2.connect(
                    host=db_config['host'],
                    port=db_config['port'],
                    user=db_config['user'],
                    dbname=db_config['dbname'],
                    password=db_config['password'],
                    sslmode=db_config['sslmode'],
                    sslrootcert=cacertificate['certificate']
                )

                cursor = connection.cursor(cursor_factory=psycopg2.extras.DictCursor)
                cursor.execute(sql)
                rows = cursor.fetchall()
                cursor.close()
                connection.close()

                return [dict(row) for row in rows]

            except OperationalError as e:
                retry_count += 1
                if retry_count >= max_retries:
                    raise e
                sleep_time = backoff_factor ** retry_count
                time.sleep(sleep_time)
                continue

        raise Exception("Failed to connect to the database after several retries.")
  original_code: |-
    from typing import TypedDict
    import psycopg2
    import psycopg2.extras

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    class Cacertificate(TypedDict):
        certificate: str

    def main(db_config: postgresql, cacertificate: Cacertificate, sql: str = "SELECT 1 as id"):
        connection = psycopg2.connect(
            host=db_config['host'],
            port=db_config['port'],
            user=db_config['user'],
            dbname=db_config['dbname'],
            password=db_config['password'],
            sslmode=db_config['sslmode'],
            sslrootcert=cacertificate['certificate']
        )

        cursor = connection.cursor(cursor_factory=psycopg2.extras.DictCursor)
        cursor.execute(sql)
        rows = cursor.fetchall()
        cursor.close()
        connection.close()

        return [dict(row) for row in rows]
  original_instructions: |-
    Postgres with TLS  / SSL  in postgresql
  resource_type: |-
    postgresql
  resource_type_def: |-
    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str
- edit_instructions: |2

    Modify the script to allow searching for files within a specific shared drive by updating the `q` variable with a search query that includes the shared drive ID and the name or type of the file you are looking for.
  id: |-
    hubedit_hub_61
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str
        shared_drive_id: str
        file_name: str  # Assuming we are searching by file name

    def main(gdrive_auth: gdrive):
        shared_drive_id = gdrive_auth["shared_drive_id"]
        file_name = gdrive_auth["file_name"]
        q = f"'{shared_drive_id}' in parents and name = '{file_name}' and trashed = false"
        SEARCH_FILES_URL = f"https://www.googleapis.com/drive/v3/files?q={q}"

        token = gdrive_auth["token"]

        response = requests.get(
            SEARCH_FILES_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
            params={
                "supportsAllDrives": True,
                "includeItemsFromAllDrives": True,
                "driveId": shared_drive_id,
                "corpora": "drive"
            }
        )

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive):
        q = ""
        SEARCH_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/?q={q}"

        token = gdrive_auth["token"]

        response = requests.get(
            SEARCH_SHARED_DRIVE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Search Shared Drives in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing user's details if the user ID is provided, instead of always attempting to create a new user.
  id: |-
    hubedit_hub_323
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.users import Users

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: Optional[str] = None, email: Optional[str] = None,
             phone: Optional[str] = None, password: Optional[str] = None,
             name: Optional[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        users = Users(client)

        if id is not None:
            # Update an existing user
            return users.update(id, email=email, password=password, name=name)
        else:
            # Create a new user with a unique ID
            user_id = 'unique()'
            return users.create(user_id, email, password, name)
  original_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.users import Users

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: Optional[str] = None, email: Optional[str] = None,
             phone: Optional[str] = None, password: Optional[str] = None,
             name: Optional[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        users = Users(client)

        user_id = id if id is not None else 'unique()'
        return users.create(user_id, email, password, name)
  original_instructions: |-
    Create User in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add error handling to manage the case where the request fails due to network issues or an invalid URL, and return an appropriate error message in the 'response' field of the http TypedDict.
  id: |-
    hubedit_hub_26
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        response: str

    def main(url: str, request_type: str) -> http:
        try:
            resp = requests.request(request_type, url)
            resp.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.exceptions.RequestException as e:
            return {'response': f'An error occurred: {e}'}
        return {'response': resp.text}
  original_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        response: str

    def main(url: str, request_type: str) -> http:
        resp = requests.request(request_type, url)
        return {'response': resp.text}
  original_instructions: |-
    Send any HTTP Request in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        response: str
- edit_instructions: |2

    Modify the script to allow updating a document in the collection by adding a new function that takes a dictionary of fields to update and applies those changes to the document with the specified document_id.
  id: |-
    hubedit_hub_255
  lang: |-
    python
  modified_code: |-
    def update_document(auth: mongodbrest, data_source: str, database: str, collection: str, document_id: str, update_fields: Dict):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        update_fields = remove_empty_fields(update_fields)
        result = coll.update_one({'_id': ObjectId(document_id)}, {'$set': update_fields})
        return result.modified_count
  original_code: |-
    from typing import TypedDict, Optional, Dict
    from pymongo import MongoClient
    from bson import ObjectId

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def remove_empty_fields(d: Dict):
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document_id: str, projection: Optional[Dict[str, int]] = None):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        projection = remove_empty_fields(projection) if projection else None
        return coll.find_one({'_id': ObjectId(document_id)}, projection)
  original_instructions: |-
    Find Document by Id in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Add a feature to resize the image before uploading it to Slack, allowing users to specify the desired dimensions or a scaling factor.
  id: |-
    hubedit_hub_110
  lang: |-
    python
  modified_code: |-
    import base64
    import requests
    from typing import TypedDict
    from PIL import Image
    import io

    class slack(TypedDict):
        token: str

    def resize_image(image_data: bytes, width: int = None, height: int = None, scale: float = None) -> bytes:
        with Image.open(io.BytesIO(image_data)) as img:
            if scale is not None:
                width = int(img.width * scale)
                height = int(img.height * scale)
            elif width is None or height is None:
                raise ValueError("Width and height must be provided if scale is not used.")

            resized_img = img.resize((width, height), Image.ANTIALIAS)
            with io.BytesIO() as output:
                resized_img.save(output, format='PNG')
                return output.getvalue()

    def main(image: str, channel: str, slack: slack, imagename: str = "image.png", width: int = None, height: int = None, scale: float = None):
        decoded_image = base64.b64decode(image)

        if width is not None or height is not None or scale is not None:
            decoded_image = resize_image(decoded_image, width, height, scale)

        files = {
            'file': (imagename, decoded_image, 'image/png'),
        }
        payload = {
            'token': slack['token'],
            'channels': channel,
            'filename': imagename,
            'filetype': 'auto'
        }
        response = requests.post("https://slack.com/api/files.upload", params=payload, files=files)
        return response.json()
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class slack(TypedDict):
        token: str

    def main(image: str, channel: str, slack: slack, imagename: str = "image.png"):
        decoded_image = base64.b64decode(image)
        files = {
            'file': (imagename, decoded_image, 'image/png'),
        }
        payload = {
            'token': slack['token'],
            'channels': channel,
            'filename': imagename,
            'filetype': 'auto'
        }
        response = requests.post("https://slack.com/api/files.upload", params=payload, files=files)
        return response.json()
  original_instructions: |-
    Send an image to channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to specify the start and end times for the event, allowing the user to create events with specific durations rather than quick add events.
  id: |-
    hubedit_hub_46
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict
    from datetime import datetime

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, eventText: str, startTime: datetime, endTime: datetime):
        EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events"
        token = gcal_auth["token"]

        event_data = {
            "summary": eventText,
            "start": {
                "dateTime": startTime.isoformat(),
                "timeZone": "UTC"
            },
            "end": {
                "dateTime": endTime.isoformat(),
                "timeZone": "UTC"
            }
        }

        response = requests.post(
            EVENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
            json=event_data
        )

        result = response.json()
        return result
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, eventText: str):
        sendUpdates = "all"
        QUICK_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/quickAdd/?text={eventText}&sendUpdates={sendUpdates}"
        token = gcal_auth["token"]

        response = requests.post(
            QUICK_EVENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        result = response.json()
        return result
  original_instructions: |-
    Create Quick Event in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to upload a file to Slack before retrieving its information, and then delete the file from Slack after the information has been retrieved.
  id: |-
    hubedit_hub_16
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, file_path: str, channels: str, count: Optional[int] = None, page: Optional[int] = None):
        web = WebClient(token=slack_auth['token'])

        # Upload the file to Slack
        try:
            upload_response = web.files_upload(
                channels=channels,
                file=file_path
            )
            file_id = upload_response['file']['id']
        except SlackApiError as e:
            return {'error': f"File upload failed: {e.response['error']}"}

        # Retrieve file information
        try:
            info_response = web.files_info(
                file=file_id,
                count=count,
                page=page
            )
        except SlackApiError as e:
            return {'error': f"File info retrieval failed: {e.response['error']}"}

        # Delete the file from Slack
        try:
            web.files_delete(file=file_id)
        except SlackApiError as e:
            return {'error': f"File deletion failed: {e.response['error']}"}

        return {'response': info_response}
  original_code: |-
    from typing import TypedDict, Optional
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, file: str, count: Optional[int] = None, page: Optional[int] = None):
        web = WebClient(token=slack_auth['token'])

        response = web.files_info(
            file=file,
            count=count,
            page=page
        )

        return {'response': response}
  original_instructions: |-
    Get File in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the Stripe API, such as checking the status code of the response and raising an exception if the request was unsuccessful.
  id: |-
    hubedit_hub_117
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, cancel_id: str):
        STRIPE_CANCEL_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{cancel_id}/cancel'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_CANCEL_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        if response.status_code != 200:
            # You can customize the exception and message as needed
            raise Exception(f"Error cancelling payout: {response.status_code} {response.text}")

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, cancel_id: str):
        STRIPE_CANCEL_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{cancel_id}/cancel'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_CANCEL_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Cancel a Payment Intent in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to cache the response data in a local file to avoid repeated requests for the same campaign_id, and check the cache before making a new request.
  id: |-
    hubedit_hub_206
  lang: |-
    python
  modified_code: |-
    import requests
    import json
    import os
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def cache_response(campaign_id: str, data: dict):
        cache_file = f'campaign_{campaign_id}_cache.json'
        with open(cache_file, 'w') as file:
            json.dump(data, file)

    def get_cached_response(campaign_id: str) -> Optional[dict]:
        cache_file = f'campaign_{campaign_id}_cache.json'
        if os.path.exists(cache_file):
            with open(cache_file, 'r') as file:
                return json.load(file)
        return None

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        cached_response = get_cached_response(campaign_id)
        if cached_response is not None:
            return cached_response

        base_url = f"https://{auth['server']}.api.mailchimp.com/3.0/reports/{campaign_id}"
        params = {}
        if fields:
            params['fields'] = ','.join(fields)
        if exclude_fields:
            params['exclude_fields'] = ','.join(exclude_fields)

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if response.status_code != 200:
            raise Exception(response.text)

        response_data = response.json()
        cache_response(campaign_id, response_data)
        return response_data
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        base_url = f"https://{auth['server']}.api.mailchimp.com/3.0/reports/{campaign_id}"
        params = {}
        if fields:
            params['fields'] = ','.join(fields)
        if exclude_fields:
            params['exclude_fields'] = ','.join(exclude_fields)

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if response.status_code != 200:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Get A Campaign Report in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add functionality to update an existing document in the collection if the document_id is provided, instead of always creating a new document.
  id: |-
    hubedit_hub_334
  lang: |-
    python
  modified_code: |-
    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_data: Dict[str, Any],
        document_id: Optional[str] = None,
        document_permissions: Optional[List[str]] = None
    ):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
            'content-type': 'application/json'
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings()

        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents"

        data = {
            'data': document_data
        }

        if document_permissions:
            data['permissions'] = document_permissions

        if document_id:
            # Update an existing document
            url += f"/{document_id}"
            response = requests.patch(url, json=data, headers=headers, verify=not auth['self_signed'])
        else:
            # Create a new document with a random UUID
            document_id = str(uuid4())
            data['documentId'] = document_id
            response = requests.post(url, json=data, headers=headers, verify=not auth['self_signed'])

        return response.json()
  original_code: |-
    from typing import TypedDict, Dict, Any, Optional, List
    import requests
    from uuid import uuid4

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_data: Dict[str, Any],
        document_id: Optional[str] = None,
        document_permissions: Optional[List[str]] = None
    ):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
            'content-type': 'application/json'
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings()

        document_id = document_id or str(uuid4())
        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents"

        data = {
            'documentId': document_id,
            'data': document_data
        }

        if document_permissions:
            data['permissions'] = document_permissions

        response = requests.post(url, json=data, headers=headers, verify=not auth['self_signed'])
        return response.json()
  original_instructions: |-
    Create Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Modify the script to update an existing worksheet's title instead of adding a new one by changing the "addSheet" request to an "updateSheetProperties" request with the appropriate fields to specify the sheet to be updated and its new title.
  id: |-
    hubedit_hub_65
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, sheetId: int, new_title: str):
        token = gsheets_auth["token"]

        UPDATE_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            "requests": [
                {
                    "updateSheetProperties": {
                        "properties": {
                            "sheetId": sheetId,
                            "title": new_title
                        },
                        "fields": "title"
                    }
                }
            ]
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.post(UPDATE_WORKSHEET_URL, json=body, headers=headers)

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, title: str):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            "requests": [
                {
                    "addSheet": {
                        "properties": {
                            "title": title,
                            "gridProperties": {
                                "rowCount": 20,
                                "columnCount": 12
                            },
                            "tabColor": {
                                "red": 1.0,
                                "green": 0.3,
                                "blue": 0.4
                            }
                        }
                    }
                }
            ]
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.post(ADD_WORKSHEET_URL, json=body, headers=headers)

        return response.text
  original_instructions: |-
    Create Worksheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to the script that allows it to handle GET requests to retrieve the current state of a room when the json_content parameter is not provided.
  id: |-
    hubedit_hub_190
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None, json_content: Optional[str] = None):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/{requests.utils.quote(type)}/"
        if state_key:
            url += requests.utils.quote(state_key)
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }

        if json_content is not None:
            # PUT request to update the room state
            resp = requests.put(url, headers=headers, data=json_content)
        else:
            # GET request to retrieve the current room state
            resp = requests.get(url, headers=headers)

        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return resp.json()
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None, json_content: str = None):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/{requests.utils.quote(type)}/"
        if state_key:
            url += requests.utils.quote(state_key)
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        resp = requests.put(url, headers=headers, data=json_content)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return resp.json()
  original_instructions: |-
    Set room state in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add functionality to cache the response for a given objectType and propertyName combination to reduce the number of API calls if the same request is made within a short time frame, such as 5 minutes.
  id: |-
    hubedit_hub_361
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import TypedDict

    class hubspot(TypedDict):
        token: str

    # Cache dictionary to store responses
    cache = {}

    def main(auth: hubspot, objectType: str, propertyName: str):
        # Create a unique key for the cache based on objectType and propertyName
        cache_key = f"{objectType}_{propertyName}"

        # Check if the response is in the cache and if it is still valid
        if cache_key in cache:
            cached_response, timestamp = cache[cache_key]
            if time.time() - timestamp < 300:  # 5 minutes = 300 seconds
                return cached_response

        # If not in cache or cache is expired, make the API call
        url = f"https://api.hubapi.com/crm/v3/properties/{objectType}/{propertyName}?archived=false"
        headers = {
            "Authorization": f"Bearer {auth['token']}",
            "Accept": "application/json",
        }
        response = requests.get(url, headers=headers)
        json_res = response.json()

        # Check for errors in the response
        if json_res.get("status") == "error":
            print(json_res)
            raise ValueError(json_res.get("message"))

        # Cache the response with the current timestamp
        cache[cache_key] = (json_res, time.time())

        return json_res
  original_code: |-
    import requests
    from typing import TypedDict

    class hubspot(TypedDict):
        token: str

    def main(auth: hubspot, objectType: str, propertyName: str):
        url = f"https://api.hubapi.com/crm/v3/properties/{objectType}/{propertyName}?archived=false"
        headers = {
            "Authorization": f"Bearer {auth['token']}",
            "Accept": "application/json",
        }
        response = requests.get(url, headers=headers)
        json_res = response.json()
        if json_res.get("status") == "error":
            print(json_res)
            raise ValueError(json_res.get("message"))
        return json_res
  original_instructions: |-
    Get a properties configuration from hubspot crm in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage exceptions such as connection errors or timeouts when making the HTTP request.
  id: |-
    hubedit_hub_98
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str) -> http:
        try:
            resp = requests.get(url)
            return {
                'ok': resp.ok,
                'status': resp.status_code,
                'text': resp.text,
            }
        except requests.exceptions.RequestException as e:
            return {
                'ok': False,
                'status': None,
                'text': str(e),
            }
  original_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str) -> http:
        resp = requests.get(url)

        return {
            'ok': resp.ok,
            'status': resp.status_code,
            'text': resp.text,
        }
  original_instructions: |-
    Send GET Request in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        ok: bool
        status: int
        text: str
- edit_instructions: |2

    Add a new key-value pair to the returned dictionary where the key is 'length' and the value is the length of the 'arg' string.
  id: |-
    hubedit_hub_25
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict

    class main_return(TypedDict):
        arg: str
        length: int

    def main(arg: str) -> main_return:
        return {"arg": arg, "length": len(arg)}
  original_code: |-
    from typing import TypedDict

    class main_return(TypedDict):
        arg: str

    def main(arg: str) -> main_return:
        return {"arg": arg}
  original_instructions: |-
    Echo argument in windmill
  resource_type: |-
    main_return
  resource_type_def: |-
    class main_return(TypedDict):
        arg: str
- edit_instructions: |2

    Modify the script to append the text at a specific location in the document by including the "location" parameter in the "insertText" request.
  id: |-
    hubedit_hub_56
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, documentId: str, text: str, location: int):
        token = gdocs_auth["token"]

        APPEND_TEXT_URL = f"https://docs.googleapis.com/v1/documents/{documentId}:batchUpdate"

        body = {
            "requests": [
                {
                    "insertText": {
                        "location": {
                            "index": location
                        },
                        "text": text
                    }
                }
            ]
        }
        response = requests.post(APPEND_TEXT_URL, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        })

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, documentId: str, text: str):
        token = gdocs_auth["token"]

        APPEND_TEXT_URL = f"https://docs.googleapis.com/v1/documents/{documentId}:batchUpdate"

        body = {
            "requests": [
                {
                    "insertText": {"text": text}
                }
            ]
        }
        response = requests.post(APPEND_TEXT_URL, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        })

        return response.text
  original_instructions: |-
    Append Text in gdocs
  resource_type: |-
    gdocs
  resource_type_def: |-
    class gdocs(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage HTTP request failures and print a user-friendly message when an error occurs.
  id: |-
    hubedit_hub_90
  lang: |-
    python
  modified_code: |-
    import base64
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        DOWNLOAD_FILE_URL = f'https://www.googleapis.com/drive/v3/files/{fileId}?alt=media'

        token = gdrive_auth["token"]

        try:
            response = requests.get(DOWNLOAD_FILE_URL, headers={
                'Authorization': f'Bearer {token}',
                'Accept': 'application/json',
            })

            # Check if the request was successful
            response.raise_for_status()

            # If the request was successful, encode the content
            return base64.b64encode(response.content).decode('utf-8')

        except requests.exceptions.HTTPError as http_err:
            # Handle HTTP errors
            print(f'HTTP error occurred: {http_err}')
        except requests.exceptions.ConnectionError as conn_err:
            # Handle connection errors
            print(f'Connection error occurred: {conn_err}')
        except requests.exceptions.Timeout as timeout_err:
            # Handle timeout errors
            print(f'Timeout error occurred: {timeout_err}')
        except requests.exceptions.RequestException as req_err:
            # Handle other request errors
            print(f'Error occurred during the request: {req_err}')
        except Exception as e:
            # Handle other exceptions
            print(f'An error occurred: {e}')

        return None
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        DOWNLOAD_FILE_URL = f'https://www.googleapis.com/drive/v3/files/{fileId}?alt=media'

        token = gdrive_auth["token"]

        response = requests.get(DOWNLOAD_FILE_URL, headers={
            'Authorization': f'Bearer {token}',
            'Accept': 'application/json',
        })

        if response:
            return base64.b64encode(response.content).decode('utf-8')
  original_instructions: |-
    Download a file in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update a document in the collection by making a PATCH request with a new data payload.
  id: |-
    hubedit_hub_336
  lang: |-
    python
  modified_code: |-
    def update_document(auth: appwrite, database_id: str, collection_id: str, document_id: str, data: dict):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
            'Content-Type': 'application/json'
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents/{document_id}"

        response = requests.patch(url, headers=headers, json=data, verify=not auth['self_signed'])
        return response.json()
  original_code: |-
    from typing import TypedDict, List
    import requests

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, document_id: str, queries: List[str] = None):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents/{document_id}"

        params = {}
        if queries:
            params['queries'] = queries

        response = requests.get(url, headers=headers, params=params, verify=not auth['self_signed'])
        return response.json()
  original_instructions: |-
    Get Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add error handling to manage the response from the Airtable API, checking for HTTP status codes that indicate failure (e.g., 400, 401, 403, 404, 500) and raise an appropriate exception or return a meaningful error message.
  id: |-
    hubedit_hub_1024
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Dict

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, new_record: Dict):
        base_url = f"https://api.airtable.com/v0/{at_table['baseId']}/{at_table['tableName']}"
        headers = {
            "Authorization": f"Bearer {at_con['apiKey']}",
            "Content-Type": "application/json"
        }
        response = requests.post(base_url, headers=headers, json={"fields": new_record})

        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError as http_err:
            # You can handle different status codes with specific messages if needed
            error_message = f"HTTP error occurred: {http_err} - Status Code: {response.status_code}"
            if response.status_code == 400:
                error_message += " - Bad Request: The request was unacceptable, often due to missing a required parameter."
            elif response.status_code == 401:
                error_message += " - Unauthorized: No valid API key provided."
            elif response.status_code == 403:
                error_message += " - Forbidden: The API key doesn't have permissions to perform the request."
            elif response.status_code == 404:
                error_message += " - Not Found: The requested resource doesn't exist."
            elif response.status_code == 500:
                error_message += " - Internal Server Error: Something went wrong on Airtable's end."
            raise Exception(error_message)
        except Exception as err:
            raise Exception(f"An error occurred: {err}")

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Dict

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, new_record: Dict):
        base_url = f"https://api.airtable.com/v0/{at_table['baseId']}/{at_table['tableName']}"
        headers = {
            "Authorization": f"Bearer {at_con['apiKey']}",
            "Content-Type": "application/json"
        }
        response = requests.post(base_url, headers=headers, json={"fields": new_record})
        return response.json()
  original_instructions: |-
    Create single record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add a retry mechanism that attempts the PUT request up to three times if the initial request fails due to a connection error or a timeout.
  id: |-
    hubedit_hub_99
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Dict
    from requests.exceptions import ConnectionError, Timeout

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str, body: Dict = None) -> http:
        if body is None:
            body = {}

        max_retries = 3
        retries = 0

        while retries < max_retries:
            try:
                resp = requests.put(url, json=body, headers={"Content-Type": "application/json"})
                return {
                    "ok": resp.ok,
                    "status": resp.status_code,
                    "text": resp.text,
                }
            except (ConnectionError, Timeout):
                retries += 1
                if retries == max_retries:
                    return {
                        "ok": False,
                        "status": None,
                        "text": "Max retries reached. Connection failed or timed out.",
                    }
  original_code: |-
    import requests
    from typing import TypedDict, Dict

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str, body: Dict = None) -> http:
        if body is None:
            body = {}

        resp = requests.put(url, json=body, headers={"Content-Type": "application/json"})

        return {
            "ok": resp.ok,
            "status": resp.status_code,
            "text": resp.text,
        }
  original_instructions: |-
    Send PUT Request in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        ok: bool
        status: int
        text: str
- edit_instructions: |2

    Modify the script to send a message to the channel notifying members that a user has been kicked after successfully executing the `conversations_kick` method.
  id: |-
    hubedit_hub_14
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class SlackAuth(TypedDict):
        token: str

    def main(slack_auth: SlackAuth, channel: str, user: str):
        web = WebClient(token=slack_auth['token'])

        try:
            # Attempt to kick the user from the channel
            web.conversations_kick(
                channel=channel,
                user=user
            )

            # Notify the channel that the user has been kicked
            message = f"The user <@{user}> has been kicked from the channel."
            web.chat_postMessage(
                channel=channel,
                text=message
            )

            return {"message": "Successfully kicked user and sent notification."}

        except SlackApiError as e:
            # Handle exceptions for the Slack API errors
            error_message = e.response["error"]
            return {"error": f"Failed to kick user or send notification: {error_message}"}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, user: str):
        web = WebClient(token=slack_auth['token'])

        web.conversations_kick(
            channel=channel,
            user=user
        )

        return {"message": "Successfully Kicked user"}
  original_instructions: |-
    Kick User in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add a new field to the `value_typeddict` class with a specific type, such as an integer or string, to enforce type checking on the input dictionary.
  id: |-
    hubedit_hub_102
  lang: |-
    python
  modified_code: |-
    import json
    from typing import TypedDict

    class value_typeddict(TypedDict):
        my_field: int  # You can change the field name and type as needed

    def main(value: value_typeddict, indented: bool = False) -> str:
        indent = 2 if indented else None
        return json.dumps(value, indent=indent)
  original_code: |-
    import json
    from typing import TypedDict

    class value_typeddict(TypedDict):
        pass

    def main(value: value_typeddict, indented: bool = False) -> str:
        indent = 2 if indented else None
        return json.dumps(value, indent=indent)
  original_instructions: |-
    Convert JavaScript Object to JSON String in helper
  resource_type: |-
    value_typeddict
  resource_type_def: |-
    class value_typeddict(TypedDict):
        pass
- edit_instructions: |2

    Modify the script to send a message to the same channel confirming that the message with the given timestamp has been successfully deleted, or to report an error if the deletion was unsuccessful.
  id: |-
    hubedit_hub_18
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, timestamp: str):
        web = WebClient(token=slack_auth['token'])

        try:
            delete_response = web.chat_delete(
                channel=channel,
                ts=timestamp
            )
            confirmation_response = web.chat_postMessage(
                channel=channel,
                text=f"Message with timestamp {timestamp} has been successfully deleted."
            )
            return {'delete_response': delete_response, 'confirmation_response': confirmation_response}
        except SlackApiError as e:
            error_message = e.response['error']
            web.chat_postMessage(
                channel=channel,
                text=f"Failed to delete message with timestamp {timestamp}. Error: {error_message}"
            )
            return {'error': error_message}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, timestamp: str):
        web = WebClient(token=slack_auth['token'])

        try:
            response = web.chat_delete(
                channel=channel,
                ts=timestamp
            )
            return {'response': response}
        except SlackApiError as e:
            return {'error': e.response['error']}
  original_instructions: |-
    Delete Message in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter the records by a specific field value before returning the results.
  id: |-
    hubedit_hub_8
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from pyairtable import Table
    from pyairtable.formulas import match

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, field_name: str, field_value: str):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        formula = match({field_name: field_value})
        filtered_records = table.all(formula=formula)

        return {'results': filtered_records}
  original_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        result_list = table.all()

        return {'results': result_list}
  original_instructions: |-
    List Records in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add functionality to cache the response for a specific driveId, so that if the same driveId is requested again within a certain time frame, the cached response is returned instead of making a new request to the API.
  id: |-
    hubedit_hub_64
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    # Cache dictionary to store responses with their timestamps
    cache = {}

    # Cache expiration time in seconds
    CACHE_EXPIRATION = 300  # 5 minutes

    def main(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = False) -> str:
        GET_SHARED_DRIVE_URL = f'https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}'

        token = gdrive_auth["token"]

        # Check if the response is cached and not expired
        current_time = time.time()
        if driveId in cache and (current_time - cache[driveId]['timestamp']) < CACHE_EXPIRATION:
            return cache[driveId]['response']

        # If not cached or expired, make a new request
        response = requests.get(
            GET_SHARED_DRIVE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        # Cache the new response with the current timestamp
        cache[driveId] = {
            'response': response.text,
            'timestamp': current_time
        }

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = False) -> str:
        GET_SHARED_DRIVE_URL = f'https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}'

        token = gdrive_auth["token"]

        response = requests.get(
            GET_SHARED_DRIVE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Get Shared Drive in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing segment if it already exists instead of always creating a new one.
  id: |-
    hubedit_hub_210
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Optional, Dict, Any

    class MailchimpAuth(TypedDict):
        api_key: str
        server: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None and v != {}}

    def get_segment_id(auth: MailchimpAuth, list_id: str, segment_name: str) -> Optional[int]:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        response = requests.get(url, headers={
            'Authorization': f"Bearer {auth['api_key']}"
        })
        if response.ok:
            segments = response.json().get('segments', [])
            for segment in segments:
                if segment['name'] == segment_name:
                    return segment['id']
        return None

    def main(auth: MailchimpAuth, list_id: str, name: str, static_segment: Optional[List[str]] = None, options: Optional[Dict[str, Any]] = None) -> Any:
        segment_id = get_segment_id(auth, list_id, name)
        if segment_id:
            url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments/{segment_id}"
            method = requests.patch
        else:
            url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
            method = requests.post

        body = {
            'name': name,
            'static_segment': static_segment,
            'options': options,
        }

        cleaned_body = remove_empty_fields(body)
        response = method(url, headers={
            'Authorization': f"Bearer {auth['api_key']}"
        }, json=cleaned_body)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, List, Optional, Dict, Any

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None and v != {}}

    def main(auth: mailchimp, list_id: str, name: str, static_segment: Optional[List[str]] = None, options: Optional[Dict[str, Any]] = None) -> Any:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        body = {
            'name': name,
            'static_segment': static_segment,
            'options': options,
        }

        cleaned_body = remove_empty_fields(body)
        response = requests.post(url, headers={
            'Authorization': f"Bearer {auth['api_key']}"
        }, json=cleaned_body)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Create a Segment in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add functionality to send a new message if neither `message_id` nor `inline_message_id` is provided, instead of editing an existing message.
  id: |-
    hubedit_hub_235
  lang: |-
    python
  modified_code: |-
    from typing import Union, TypedDict, Optional
    from telebot import TeleBot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], message_id: Optional[int] = None, text: str, inline_message_id: Optional[str] = None):
        client = TeleBot(auth['token'])
        if message_id is not None:
            return client.edit_message_text(text, chat_id, message_id)
        elif inline_message_id is not None:
            return client.edit_message_text(text, inline_message_id=inline_message_id)
        else:
            return client.send_message(chat_id, text)
  original_code: |-
    from typing import Union, TypedDict
    from telebot import TeleBot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], message_id: int, text: str, inline_message_id: str = None):
        client = TeleBot(auth['token'])
        if inline_message_id:
            return client.edit_message_text(text, inline_message_id=inline_message_id)
        else:
            return client.edit_message_text(text, chat_id, message_id)
  original_instructions: |-
    Edit a Text Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to include a function that lists all campaigns before attempting to cancel a specific campaign, providing the user with an overview of available campaigns.
  id: |-
    hubedit_hub_204
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List

    class MailchimpAuth(TypedDict):
        api_key: str
        server: str

    def list_campaigns(auth: MailchimpAuth) -> List[dict]:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns"
        response = requests.get(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)

        return response.json().get('campaigns', [])

    def cancel_campaign(auth: MailchimpAuth, campaign_id: str) -> dict:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/cancel-send"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()

    def main(auth: MailchimpAuth, campaign_id: str):
        print("Listing all campaigns:")
        campaigns = list_campaigns(auth)
        for campaign in campaigns:
            print(f"ID: {campaign['id']}, Status: {campaign['status']}, Name: {campaign['settings']['title']}")

        print("\nAttempting to cancel campaign:")
        result = cancel_campaign(auth, campaign_id)
        print(f"Campaign {campaign_id} cancellation status: {result}")

    # Example usage:
    # auth = {'api_key': 'YOUR_API_KEY', 'server': 'YOUR_SERVER_PREFIX'}
    # campaign_id = 'YOUR_CAMPAIGN_ID'
    # main(auth, campaign_id)
  original_code: |-
    import requests
    from typing import TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/cancel-send"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Cancel a Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Modify the script to create a new customer instead of deleting an existing one, using the provided `stripe_con` token for authentication.
  id: |-
    hubedit_hub_128
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_data: dict):
        token = stripe_con["token"]
        stripe_module.api_key = token

        new_customer = stripe_module.Customer.create(**customer_data)
        return new_customer
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        deleted = stripe_module.Customer.delete(customer_id)
        return deleted
  original_instructions: |-
    Delete a Customer in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to delete all documents that match the filter criteria instead of just one.
  id: |-
    hubedit_hub_257
  lang: |-
    python
  modified_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        return coll.delete_many(filter)
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        return coll.delete_one(filter)
  original_instructions: |-
    Delete a Document in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Add functionality to send a direct message to each approver with a personalized thank you note after posting the approval message to the channel.
  id: |-
    hubedit_hub_180
  lang: |-
    python
  modified_code: |-
    import os
    from typing import TypedDict, List
    from slack_sdk import WebClient
    from urllib.parse import urljoin

    class slack(TypedDict):
        token: str

    def main(channel: str, slack: slack, approvers: List[str]):
        web = WebClient(slack['token'])
        wm_base_url = os.environ.get("WM_BASE_URL")
        wm_flow_job_id = os.environ.get("WM_FLOW_JOB_ID")
        job_url = urljoin(wm_base_url, f"/run/{wm_flow_job_id}")
        wm_flow_path = os.environ.get("WM_FLOW_PATH")
        wm_username = os.environ.get("WM_USERNAME")
        text = f"Flow job {job_url} ({wm_flow_path}) run by {wm_username} was approved by {', '.join(approvers)}"

        # Post the approval message to the channel
        web.chat_postMessage(
            channel=channel,
            text=text,
        )

        # Send a direct message to each approver
        for approver in approvers:
            user_id = web.users_lookupByEmail(email=approver)['user']['id']
            thank_you_note = f"Thank you {approver} for approving the job: {job_url}"
            web.chat_postMessage(
                channel=user_id,
                text=thank_you_note,
            )
  original_code: |-
    import os
    from typing import TypedDict, List
    from slack_sdk import WebClient
    from urllib.parse import urljoin

    class slack(TypedDict):
        token: str

    def main(channel: str, slack: slack, approvers: List[str]):
        web = WebClient(slack['token'])
        wm_base_url = os.environ.get("WM_BASE_URL")
        wm_flow_job_id = os.environ.get("WM_FLOW_JOB_ID")
        job_url = urljoin(wm_base_url, f"/run/{wm_flow_job_id}")
        wm_flow_path = os.environ.get("WM_FLOW_PATH")
        wm_username = os.environ.get("WM_USERNAME")
        text = f"Flow job {job_url} ({wm_flow_path}) run by {wm_username} was approved by {', '.join(approvers)}"

        web.chat_postMessage(
            channel=channel,
            text=text,
        )
  original_instructions: |-
    Send information about approved job to channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to send a custom text message to the `to_chat_id` instead of forwarding a message from `from_chat_id`.
  id: |-
    hubedit_hub_241
  lang: |-
    python
  modified_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, to_chat_id: str, text: str):
        client = TeleBot(auth['token'])
        return client.send_message(to_chat_id, text)
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, from_chat_id: str, to_chat_id: str, message_id: int):
        client = TeleBot(auth['token'])
        return client.forward_message(to_chat_id, from_chat_id, message_id)
  original_instructions: |-
    Forward a Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to filter jobs by their creation date, allowing the user to specify a date range for the jobs they want to retrieve.
  id: |-
    hubedit_hub_269
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    import requests
    from datetime import datetime

    class job_service(TypedDict):
        workspace: str
        suspended: bool
        per_page: int
        script_path_exact: Optional[str]
        created_after: Optional[str]
        created_before: Optional[str]

    def get_workspace() -> str:
        return "your_workspace_here"

    def list_queue(params: job_service):
        response = requests.get("https://api.windmill.example.com/jobs", params=params)
        return response.json()

    def main(
        script_path_exact: Optional[str] = None,
        only_suspended_jobs: bool = False,
        created_after: Optional[datetime] = None,
        created_before: Optional[datetime] = None
    ):
        params = {
            "workspace": get_workspace(),
            "suspended": only_suspended_jobs,
            "per_page": 50,
            "script_path_exact": script_path_exact,
            "created_after": created_after.isoformat() if created_after else None,
            "created_before": created_before.isoformat() if created_before else None,
        }
        return list_queue(params)
  original_code: |-
    from typing import TypedDict, Optional
    import requests

    class job_service(TypedDict):
        workspace: str
        suspended: bool
        per_page: int
        script_path_exact: Optional[str]

    def get_workspace() -> str:
        # Assuming get_workspace is a function that retrieves the current workspace
        # Replace with actual implementation
        return "your_workspace_here"

    def list_queue(params: job_service):
        # Assuming the Windmill API has a similar endpoint in Python
        # Replace with actual API endpoint and API key if needed
        response = requests.get("https://api.windmill.example.com/jobs", params=params)
        return response.json()

    def main(script_path_exact: Optional[str] = None, only_suspended_jobs: bool = False):
        return list_queue({
            "workspace": get_workspace(),
            "suspended": only_suspended_jobs,
            "per_page": 50,
            "script_path_exact": script_path_exact,
        })
  original_instructions: |-
    List Queued Jobs in windmill
  resource_type: |-
    job_service
  resource_type_def: |-
    class job_service(TypedDict):
        workspace: str
        suspended: bool
        per_page: int
        script_path_exact: Optional[str]
- edit_instructions: |2

    Add error handling to check the response status code and raise an exception if the API call fails. Also, include a caching mechanism to store and reuse the API response for a certain duration to reduce the number of API calls.
  id: |-
    hubedit_hub_322
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import TypedDict

    class currencyapi(TypedDict):
        apiKey: str

    # Cache dictionary to store API responses
    cache = {}

    def get_from_cache(base_currency: str, currencies: str):
        # Create a unique key for the cache based on the base currency and target currencies
        cache_key = f"{base_currency}_{currencies}"
        # Check if the data is in the cache and not expired
        if cache_key in cache and (time.time() - cache[cache_key]['timestamp']) < 300:  # 300 seconds (5 minutes) cache duration
            return cache[cache_key]['data']
        return None

    def set_cache(base_currency: str, currencies: str, data):
        cache_key = f"{base_currency}_{currencies}"
        cache[cache_key] = {
            'data': data,
            'timestamp': time.time()
        }

    def main(currency_api_resource: currencyapi, base_currency: str, currencies: str):
        # Check if the data is already in the cache
        cached_data = get_from_cache(base_currency, currencies)
        if cached_data:
            return cached_data

        params = {
            'base_currency': base_currency,
            'currencies': currencies,
        }
        headers = {
            'apikey': currency_api_resource['apiKey'],
        }
        response = requests.get(
            'https://api.currencyapi.com/v3/latest',
            params=params,
            headers=headers
        )

        # Check if the API call was successful
        if response.status_code != 200:
            raise Exception(f"API call failed with status code: {response.status_code}")

        data = response.json()
        currency = data.get('data')

        # Save the data to the cache
        set_cache(base_currency, currencies, currency)

        return currency
  original_code: |-
    import requests
    from typing import TypedDict

    class currencyapi(TypedDict):
        apiKey: str

    def main(currency_api_resource: currencyapi, base_currency: str, currencies: str):
        params = {
            'base_currency': base_currency,
            'currencies': currencies,
        }
        headers = {
            'apikey': currency_api_resource['apiKey'],
        }
        response = requests.get(
            'https://api.currencyapi.com/v3/latest',
            params=params,
            headers=headers
        )
        data = response.json()
        currency = data.get('data')
        return currency
  original_instructions: |-
    Latest exchange rate from CurrencyApi.com in currencyapi
  resource_type: |-
    currencyapi
  resource_type_def: |-
    class currencyapi(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add error handling to manage the response from the Discord webhook, such as checking if the request was successful or if it failed due to a client or server error, and print an appropriate message to the console.
  id: |-
    hubedit_hub_77
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, message: str):
        payload = {'content': message}
        try:
            response = requests.post(discord_webhook['webhook_url'], json=payload)
            response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.exceptions.HTTPError as http_err:
            print(f"HTTP error occurred: {http_err}")  # Python 3.6+
        except requests.exceptions.ConnectionError as conn_err:
            print(f"Error connecting: {conn_err}")
        except requests.exceptions.Timeout as timeout_err:
            print(f"Timeout error: {timeout_err}")
        except requests.exceptions.RequestException as req_err:
            print(f"An error occurred: {req_err}")
        else:
            if response.status_code == 204:
                print("Message sent successfully, no content returned.")
            else:
                print("Message sent successfully.")
        return response
  original_code: |-
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, message: str):
        payload = {'content': message}
        response = requests.post(discord_webhook['webhook_url'], json=payload)
        return response
  original_instructions: |-
    Send a message to discord using webhook in discord
  resource_type: |-
    discordwebhook
  resource_type_def: |-
    class discordwebhook(TypedDict):
        webhook_url: str
- edit_instructions: |2

    Add functionality to update a specific cell in the worksheet with a new value provided as an additional argument to the main function.
  id: |-
    hubedit_hub_53
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, worksheet_name: str, cell: str, new_value: str):
        token = gsheets_auth["token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{worksheet_name}"
        UPDATE_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{worksheet_name}!{cell}?valueInputOption=USER_ENTERED"

        # Update the specific cell with the new value
        data = {
            "range": f"{worksheet_name}!{cell}",
            "values": [[new_value]]
        }

        response = requests.put(
            UPDATE_VALUES_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
            json=data
        )

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, worksheet_name: str):
        token = gsheets_auth["token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{worksheet_name}"

        response = requests.get(
            GET_VALUES_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Get Values in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to the script to log the response of the `update_document` operation to a file with a timestamp for auditing purposes.
  id: |-
    hubedit_hub_337
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional, Dict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases
    from datetime import datetime
    import json

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_id: str,
        document_data: Optional[Dict[str, any]] = None,
        document_permissions: Optional[List[str]] = None
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        response = db.update_document(
            database_id,
            collection_id,
            document_id,
            document_data,
            document_permissions
        )

        # Log the response with a timestamp
        log_response(response)

        return response

    def log_response(response: Dict[str, any]) -> None:
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        log_filename = f"update_document_log_{timestamp}.txt"
        with open(log_filename, 'w') as log_file:
            log_file.write(json.dumps(response, indent=4))

    # Example usage:
    # main(auth_config, 'database_id', 'collection_id', 'document_id', {'name': 'John Doe'}, ['role:member'])
  original_code: |-
    from typing import TypedDict, Optional, Dict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_id: str,
        document_data: Optional[Dict[str, any]] = None,
        document_permissions: Optional[List[str]] = None
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        response = db.update_document(
            database_id,
            collection_id,
            document_id,
            document_data,
            document_permissions
        )

        return response
  original_instructions: |-
    Update Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add functionality to attach files to the email, allowing the user to send documents, images, or other file types as attachments.
  id: |-
    hubedit_hub_106
  lang: |-
    python
  modified_code: |-
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    from email.mime.base import MIMEBase
    from email import encoders
    from typing import TypedDict, List

    class smtp(TypedDict):
        host: str
        port: int
        user: str
        password: str

    def main(smtp_res: smtp, to_email: str, from_email: str, subject: str, content: str, attachments: List[str] = []):
        message = MIMEMultipart()
        message['Subject'] = subject
        message['From'] = from_email
        message['To'] = to_email
        message.attach(MIMEText(content, 'plain'))

        for file_path in attachments:
            with open(file_path, 'rb') as attachment:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(attachment.read())
                encoders.encode_base64(part)
                part.add_header(
                    'Content-Disposition',
                    f'attachment; filename={file_path.split("/")[-1]}',
                )
                message.attach(part)

        with smtplib.SMTP_SSL(smtp_res['host'], smtp_res['port']) as client:
            client.login(smtp_res['user'], smtp_res['password'])
            client.sendmail(from_email, to_email, message.as_string())

        return f"Email sent from {from_email} to {to_email} with {len(attachments)} attachment(s)"
  original_code: |-
    import smtplib
    from email.mime.text import MIMEText
    from typing import TypedDict

    class smtp(TypedDict):
        host: str
        port: int
        user: str
        password: str

    def main(smtp_res: smtp, to_email: str, from_email: str, subject: str, content: str):
        message = MIMEText(content)
        message['Subject'] = subject
        message['From'] = from_email
        message['To'] = to_email

        with smtplib.SMTP_SSL(smtp_res['host'], smtp_res['port']) as client:
            client.login(smtp_res['user'], smtp_res['password'])
            client.sendmail(from_email, to_email, message.as_string())

        return f"Email sent from {from_email} to {to_email}"
  original_instructions: |-
    Send Email in smtp
  resource_type: |-
    smtp
  resource_type_def: |-
    class smtp(TypedDict):
        host: str
        port: int
        user: str
        password: str
- edit_instructions: |2

    Add a timeout parameter to the `requests.get` call to limit how long the script will wait for a response from the server.
  id: |-
    hubedit_hub_199
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        status: int
        statusText: str

    def main(endpoint: str) -> http:
        try:
            res = requests.get(endpoint, timeout=10)  # Added timeout parameter
            return {'status': res.status_code, 'statusText': res.reason}
        except Exception as e:
            return {'status': -1, 'statusText': str(e)}
  original_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        status: int
        statusText: str

    def main(endpoint: str) -> http:
        try:
            res = requests.get(endpoint)
            return {'status': res.status_code, 'statusText': res.reason}
        except Exception as e:
            return {'status': -1, 'statusText': str(e)}
  original_instructions: |-
    Get an endpoint status and statusText in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        status: int
        statusText: str
- edit_instructions: |2

    Modify the script to cache the response for a given query, so that if the same query is made again within a certain time frame, the cached result is returned instead of making a new request to the SendGrid API.
  id: |-
    hubedit_hub_221
  lang: |-
    python
  modified_code: |-
    import json
    import requests
    import time
    from typing import TypedDict

    class sendgrid(TypedDict):
        token: str

    # Cache dictionary to store the responses
    cache = {}

    # Cache expiration time in seconds
    CACHE_EXPIRATION = 300  # 5 minutes

    def main(api_token: sendgrid, query: str):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }
        body = json.dumps({"query": query})
        url = "https://api.sendgrid.com/v3/marketing/contacts/search"

        # Check if the query is in cache and not expired
        current_time = time.time()
        if query in cache and current_time - cache[query]['timestamp'] < CACHE_EXPIRATION:
            return cache[query]['response']

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()
            # Cache the response with a timestamp
            cache[query] = {
                'response': response.json(),
                'timestamp': current_time
            }
            return cache[query]['response']
        except requests.exceptions.HTTPError as http_err:
            raise Exception(json.dumps({
                "status_code": http_err.response.status_code,
                "body": http_err.response.json()
            }))
        except Exception as err:
            raise Exception(str(err))
  original_code: |-
    import json
    import requests
    from typing import TypedDict

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, query: str):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }
        body = json.dumps({"query": query})
        url = "https://api.sendgrid.com/v3/marketing/contacts/search"

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as http_err:
            raise Exception(json.dumps({
                "status_code": http_err.response.status_code,
                "body": http_err.response.json()
            }))
        except Exception as err:
            raise Exception(str(err))
  original_instructions: |-
    Search Contacts in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter documents based on a specific field value that is passed as an additional parameter to the main function.
  id: |-
    hubedit_hub_262
  lang: |-
    python
  modified_code: |-
    from pymongo import MongoClient
    from bson.objectid import ObjectId
    import time

    # Define the TypedDict for MongoDB authentication
    from typing_extensions import TypedDict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    # Replace getState and setState with a simple file-based approach for demonstration purposes
    def get_state():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def set_state(state):
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, field: str, value):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        documents = client[database][collection]
        last_check = get_state()
        set_state(int(time.time()))
        id = ObjectId.from_datetime(last_check)
        query = { '_id': { '$gt': id }, field: value }
        return list(documents.find(query))

    # Example usage:
    # result = main(
    #     auth={'endpoint': 'your_endpoint', 'api_key': 'your_api_key'},
    #     data_source='Cluster0',
    #     database='your_database',
    #     collection='your_collection',
    #     field='your_field',
    #     value='your_value'
    # )
    # print(result)
  original_code: |-
    from pymongo import MongoClient
    from bson.objectid import ObjectId
    import time

    # Define the TypedDict for MongoDB authentication
    from typing_extensions import TypedDict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    # Replace getState and setState with a simple file-based approach for demonstration purposes
    def get_state():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def set_state(state):
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def main(auth: mongodbrest, data_source: str, database: str, collection: str):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        documents = client[database][collection]
        last_check = get_state()
        set_state(int(time.time()))
        id = ObjectId.from_datetime(last_check)
        return list(documents.find({ '_id': { '$gt': id } }))

    # Example usage:
    # result = main(
    #     auth={'endpoint': 'your_endpoint', 'api_key': 'your_api_key'},
    #     data_source='Cluster0',
    #     database='your_database',
    #     collection='your_collection'
    # )
    # print(result)
  original_instructions: |-
    Get recently inserted documents in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Modify the script to retrieve the content of a specific block instead of appending children to it by using the `client.blocks.retrieve` method with the `block_id`.
  id: |-
    hubedit_hub_355
  lang: |-
    python
  modified_code: |-
    from notion_client import Client
    from typing import TypedDict

    class NotionAuth(TypedDict):
        token: str

    def main(auth: NotionAuth, block_id: str):
        client = Client(auth=auth['token'])
        return client.blocks.retrieve(block_id=block_id)
  original_code: |-
    from notion_client import Client
    from typing import List, TypedDict

    class notion(TypedDict):
        token: str

    def main(auth: notion, block_id: str, children: List[dict] = []):
        client = Client(auth=auth['token'])
        return client.blocks.children.append(block_id=block_id, children=children)
  original_instructions: |-
    Append Block Children in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to attach a file to the email being sent.
  id: |-
    hubedit_hub_218
  lang: |-
    python
  modified_code: |-
    import sendgrid
    from sendgrid.helpers.mail import Mail, Attachment, FileContent, FileName, FileType, Disposition
    from typing import TypedDict, Optional
    import base64

    class sendgrid_type(TypedDict):
        token: str

    def main(api_token: sendgrid_type, email: str, source: Optional[str] = None, file_path: Optional[str] = None):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        message = Mail(from_email=source, to_emails=email)

        if file_path:
            with open(file_path, 'rb') as f:
                data = f.read()
                f.close()
            encoded_file = base64.b64encode(data).decode()
            attachment = Attachment()
            attachment.file_content = FileContent(encoded_file)
            attachment.file_type = FileType('application/pdf')  # Assuming the file is a PDF, change accordingly
            attachment.file_name = FileName(file_path.split('/')[-1])
            attachment.disposition = Disposition('attachment')
            message.attachment = attachment

        try:
            response = sg.client.mail.send.post(request_body=message.get())
            return response.body
        except Exception as error:
            raise Exception("\n" + str(error))
  original_code: |-
    import sendgrid
    from sendgrid.helpers.mail import Mail
    from typing import TypedDict, Optional

    class sendgrid_type(TypedDict):
        token: str

    def main(api_token: sendgrid_type, email: str, source: Optional[str] = None):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        data = {
            "email": email
        }
        if source:
            data["source"] = source

        try:
            response = sg.client.mail.send.post(request_body=Mail(from_email=source, to_emails=email).get())
            return response.body
        except Exception as error:
            raise Exception("\n" + str(error))
  original_instructions: |-
    Validate Email in sendgrid
  resource_type: |-
    sendgrid_type
  resource_type_def: |-
    class sendgrid_type(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to delete a document from the Firestore database by providing an additional parameter that, when set to true, will trigger the deletion of the specified document instead of setting or updating it.
  id: |-
    hubedit_hub_359
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Dict, List, Optional
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        document_path: List[str],
        document: Optional[Dict[str, any]] = None,
        merge: Optional[bool] = None,
        mergeFields: Optional[List[str]] = None,
        delete: Optional[bool] = False
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        if delete:
            doc_ref.delete()
        else:
            if merge is not None:
                doc_ref.set(document, merge=merge)
            elif mergeFields is not None:
                doc_ref.set(document, merge_fields=mergeFields)
            else:
                doc_ref.set(document)
  original_code: |-
    from typing import TypedDict, Dict, List, Optional
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        document_path: List[str],
        document: Dict[str, any],
        merge: Optional[bool] = None,
        mergeFields: Optional[List[str]] = None
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        if merge is not None:
            doc_ref.set(document, merge=merge)
        elif mergeFields is not None:
            doc_ref.set(document, merge_fields=mergeFields)
        else:
            doc_ref.set(document)
  original_instructions: |-
    Set Document in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- edit_instructions: |2

    Modify the script to insert a new document into the specified collection instead of deleting documents.
  id: |-
    hubedit_hub_258
  lang: |-
    python
  modified_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        result = coll.insert_one(document)
        return result
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        result = coll.delete_many(filter)
        return result
  original_instructions: |-
    Delete Many Documents in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Add error handling to manage the response from the Stripe API, checking for HTTP status codes that indicate failure (e.g., 400, 401, 500) and raise a custom exception or return a meaningful error message.
  id: |-
    hubedit_hub_120
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    class StripeError(Exception):
        """Custom exception for Stripe API errors."""
        def __init__(self, message, status_code):
            super().__init__(message)
            self.status_code = status_code

    def main(stripe_con: stripe):
        STRIPE_CREATE_CUSTOMER_URL = 'https://api.stripe.com/v1/customers'
        token = stripe_con['token']

        try:
            response = requests.post(
                STRIPE_CREATE_CUSTOMER_URL,
                headers={
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json',
                }
            )
            response.raise_for_status()
        except requests.exceptions.HTTPError as http_err:
            # Handle specific HTTP errors if needed, e.g., 400, 401, 500
            error_json = response.json()
            error_message = error_json.get('error', {}).get('message', 'Unknown error')
            raise StripeError(f'Stripe API error: {error_message}', response.status_code) from http_err
        except requests.exceptions.RequestException as e:
            # Handle other request-related errors (e.g., connection error)
            raise StripeError('A network error occurred', None) from e

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe):
        STRIPE_CREATE_CUSTOMER_URL = 'https://api.stripe.com/v1/customers'
        token = stripe_con['token']

        response = requests.post(
            STRIPE_CREATE_CUSTOMER_URL,
            headers={
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json',
            }
        )

        return response.json()
  original_instructions: |-
    Create a Customer in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to parse the XML response from the Nextcloud API and return a dictionary with user details such as email, display name, and quota instead of the raw XML text.
  id: |-
    hubedit_hub_164
  lang: |-
    python
  modified_code: |-
    import base64
    import requests
    import xml.etree.ElementTree as ET
    from typing import TypedDict

    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str

    def main(nextcloud_res: nextcloud, userId: str) -> dict:
        url = f"{nextcloud_res['baseUrl']}/ocs/v1.php/cloud/users/{requests.utils.quote(userId)}"
        auth = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['password']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {auth}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")

        # Parse the XML response
        root = ET.fromstring(resp.content)
        ns = {'ocs': 'http://open-collaboration-services.org/ns'}

        # Extract user details
        user_data = {}
        user_data['email'] = root.find('.//ocs:data/ocs:email', ns).text
        user_data['displayname'] = root.find('.//ocs:data/ocs:displayname', ns).text
        quota = root.find('.//ocs:data/ocs:quota', ns)
        user_data['quota'] = {
            'free': quota.find('ocs:free', ns).text,
            'used': quota.find('ocs:used', ns).text,
            'total': quota.find('ocs:total', ns).text,
            'relative': quota.find('ocs:relative', ns).text,
            'quota': quota.find('ocs:quota', ns).text
        }

        return user_data
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str

    def main(nextcloud_res: nextcloud, userId: str) -> str:
        url = f"{nextcloud_res['baseUrl']}/ocs/v1.php/cloud/users/{requests.utils.quote(userId)}"
        auth = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['password']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {auth}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_instructions: |-
    Get user metadata in ocs
  resource_type: |-
    nextcloud
  resource_type_def: |-
    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str
- edit_instructions: |2

    Add a feature to check the balance of the Stripe account before attempting to create a payout, and raise an exception if the balance is insufficient.
  id: |-
    hubedit_hub_124
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, amount: int, currency: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        # Check the balance of the Stripe account
        balance = stripe_module.Balance.retrieve()
        # Assuming we are only interested in the currency of the payout
        balance_amount = next((item for item in balance.available if item.currency == currency.lower()), None)
        if balance_amount is None or balance_amount.amount < amount:
            raise Exception(f"Insufficient funds for a payout of {amount} in {currency}")

        payout = stripe_module.Payout.create(
            amount=amount,
            currency=currency,
        )

        return payout
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, amount: int, currency: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        payout = stripe_module.Payout.create(
            amount=amount,
            currency=currency,
        )

        return payout
  original_instructions: |-
    Create a Payout in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing document in the Firestore collection by providing the document ID along with the new data to be updated.
  id: |-
    hubedit_hub_358
  lang: |-
    python
  modified_code: |-
    def update_document(auth: firebase, collection_id: str, document_id: str, new_data: Dict[str, any]):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred, name=f"app_{collection_id}_{document_id}", options=None)
        store = firestore.client(app)

        doc_ref = store.collection(collection_id).document(document_id)
        doc_ref.update(new_data)

        return document_id
  original_code: |-
    from typing import TypedDict, Dict
    from firebase_admin import credentials, firestore, initialize_app

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document: Dict[str, any]):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        store = firestore.client(app)

        col_ref = store.collection(collection_id)
        res = col_ref.add(document)

        return res[1].id
  original_instructions: |-
    Create Document in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- edit_instructions: |2

    Add functionality to update an existing contact in the list by making a PUT request to the SendGrid API with the contact's details in the request body.
  id: |-
    hubedit_hub_224
  lang: |-
    python
  modified_code: |-
    import json
    import requests
    from typing import TypedDict, Optional, Dict

    class SendgridConfig(TypedDict):
        token: str

    def update_contact(api_token: SendgridConfig, list_id: str, contact_id: str, contact_data: Dict[str, str]):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }

        url = f"https://api.sendgrid.com/v3/marketing/contacts"

        # Prepare the payload with the contact's details
        payload = {
            "list_ids": [list_id],
            "contacts": [
                {
                    "id": contact_id,
                    **contact_data
                }
            ]
        }

        try:
            response = requests.put(url, headers=headers, json=payload)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + json.dumps(error.response.json() if error.response else str(error)))
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, list_id: str, contact_sample: Optional[bool] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}"
        }
        params = {}
        if contact_sample is not None:
            params['contact_sample'] = contact_sample

        url = f"https://api.sendgrid.com/v3/marketing/lists/{list_id}"

        try:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + json.dumps(error.response.json() if error.response else str(error)))
  original_instructions: |-
    Get A Contact List in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to allow sending an email through the SendGrid API instead of just checking the suppression/bounces for an email address.
  id: |-
    hubedit_hub_217
  lang: |-
    python
  modified_code: |-
    api_config = {"token": "your_sendgrid_api_token"}
    send_email(api_config, email_data)
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, email: str, on_behalf_of: Optional[str] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Accept": "application/json"
        }
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        url = f"https://api.sendgrid.com/v3/suppression/bounces/{email}"

        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + json.dumps(response.json()))
  original_instructions: |-
    Get A Bounce in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter the bounces by email address by including an additional optional parameter `email` and incorporating it into the `params` dictionary if provided.
  id: |-
    hubedit_hub_216
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(
        api_token: sendgrid,
        on_behalf_of: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        email: Optional[str] = None,  # Added email parameter
    ):
        headers = {"Authorization": f"Bearer {api_token['token']}", "Accept": "application/json"}
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        params = {
            "start_time": start_time,
            "end_time": end_time,
            "limit": limit,
            "offset": offset,
            "email": email,  # Added email to params
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        url = "https://api.sendgrid.com/v3/suppression/bounces"
        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + response.text)
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(
        api_token: sendgrid,
        on_behalf_of: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
    ):
        headers = {"Authorization": f"Bearer {api_token['token']}", "Accept": "application/json"}
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        params = {
            "start_time": start_time,
            "end_time": end_time,
            "limit": limit,
            "offset": offset,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        url = "https://api.sendgrid.com/v3/suppression/bounces"
        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + response.text)
  original_instructions: |-
    Get All Bounces in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to remove a star from an item instead of adding it by using the `stars_remove` method of the `WebClient` instead of `stars_add`.
  id: |-
    hubedit_hub_22
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(
        slack_auth: slack,
        channel: str = None,  # Channel to remove star from, or channel where the message to remove star from was posted (used with timestamp)
        timestamp: str = None,  # Timestamp of the message to remove star from
        file: str = None,  # File to remove star from
    ):
        web = WebClient(token=slack_auth['token'])

        response = web.stars_remove(
            channel=channel,
            timestamp=timestamp,
            file=file,
        )

        return {'response': response}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(
        slack_auth: slack,
        channel: str = None,  # Channel to add star to, or channel where the message to add star to was posted (used with timestamp)
        timestamp: str = None,  # Timestamp of the message to add star to
        file: str = None,  # File to add star to
    ):
        web = WebClient(token=slack_auth['token'])

        response = web.stars_add(
            channel=channel,
            timestamp=timestamp,
            file=file,
        )

        return {'response': response}
  original_instructions: |-
    Add Star in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to save the response body to a local file instead of returning it.
  id: |-
    hubedit_hub_220
  lang: |-
    python
  modified_code: |-
    import sendgrid
    from typing import TypedDict
    import json

    class sendgrid_typed(TypedDict):
        token: str

    def main(api_token: sendgrid_typed, job_id: str):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        request_url = f"/v3/marketing/contacts/imports/{job_id}"

        try:
            response = sg.client.request(method='GET', url=request_url)
            with open('response_body.json', 'w') as file:
                file.write(response.body.decode('utf-8'))
        except Exception as error:
            raise Exception("\n" + json.dumps(getattr(error, 'body', str(error))))
  original_code: |-
    import sendgrid
    from typing import TypedDict
    import json

    class sendgrid_typed(TypedDict):
        token: str

    def main(api_token: sendgrid_typed, job_id: str):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        request_url = f"/v3/marketing/contacts/imports/{job_id}"

        try:
            response = sg.client.request(method='GET', url=request_url)
            return response.body
        except Exception as error:
            raise Exception("\n" + json.dumps(getattr(error, 'body', str(error))))
  original_instructions: |-
    Get Contacts Job Status in sendgrid
  resource_type: |-
    sendgrid_typed
  resource_type_def: |-
    class sendgrid_typed(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to send a caption with the photo by accepting an additional optional parameter `caption` and including it in the `data` dictionary before making the request.
  id: |-
    hubedit_hub_236
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Union, Optional
    import requests

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], photo: str, caption: Optional[str] = None, reply_to_message_id: Optional[int] = None):
        token = auth['token']
        method = 'sendPhoto'
        url = f"https://api.telegram.org/bot{token}/{method}"
        data = {
            'chat_id': chat_id,
            'photo': photo,
            'caption': caption,
            'reply_to_message_id': reply_to_message_id
        }
        # Remove None values to avoid sending them in the request
        data = {k: v for k, v in data.items() if v is not None}
        response = requests.post(url, data=data)
        return response.json()
  original_code: |-
    from typing import TypedDict, Union, Optional
    import requests

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], photo: str, reply_to_message_id: Optional[int] = None):
        token = auth['token']
        method = 'sendPhoto'
        url = f"https://api.telegram.org/bot{token}/{method}"
        data = {
            'chat_id': chat_id,
            'photo': photo,
            'reply_to_message_id': reply_to_message_id
        }
        response = requests.post(url, data=data)
        return response.json()
  original_instructions: |-
    Send a Photo in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter and return only the worksheets whose titles contain a specific keyword passed as an additional argument to the main function.
  id: |-
    hubedit_hub_68
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, keyword: str) -> List[dict]:
        token = gsheets_auth["token"]

        GET_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}?&fields=sheets.properties'

        response = requests.get(GET_WORKSHEET_URL, headers={
            'Authorization': 'Bearer ' + token,
            'Content-Type': 'application/json',
        })
        text = response.json()

        filtered_list = []
        for i in text["sheets"]:
            title = i["properties"]["title"]
            if keyword.lower() in title.lower():
                filtered_list.append({
                    'sheetId': i["properties"]["sheetId"],
                    'title': title,
                })

        return filtered_list
  original_code: |-
    import requests
    from typing import TypedDict, List

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str) -> List[dict]:
        token = gsheets_auth["token"]

        GET_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}?&fields=sheets.properties'

        response = requests.get(GET_WORKSHEET_URL, headers={
            'Authorization': 'Bearer ' + token,
            'Content-Type': 'application/json',
        })
        text = response.json()

        list = []
        for i in text["sheets"]:
            list.append({
                'sheetId': i["properties"]["sheetId"],
                'title': i["properties"]["title"],
            })

        return list
  original_instructions: |-
    List Worksheets in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to send a custom text message to the specified chat_id instead of getting the chat members count.
  id: |-
    hubedit_hub_242
  lang: |-
    python
  modified_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message: str):
        client = TeleBot(auth['token'])
        client.send_message(chat_id, message)
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str):
        client = TeleBot(auth['token'])
        return client.get_chat_members_count(chat_id)
  original_instructions: |-
    Get the Number of Members in a Chat in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to attach files to the email by encoding attachments in base64 and including them in the MIME message.
  id: |-
    hubedit_hub_194
  lang: |-
    python
  modified_code: |-
    import base64
    import json
    import requests
    from typing import TypedDict
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email.mime.base import MIMEBase
    from email import encoders

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, to_email: str, subject: str, message: str, attachments: list = [], user_id: str = "me"):
        token = gmail_auth["token"]
        if not token:
            raise ValueError("""
            No authentication token was found.
            Go to "https://app.windmill.dev/resources?connect_app=gmail" to connect gmail,
            then select your token from the dropdown in the arguments window.
            (Click "Refresh" if you don't see your resource in the list.)\n""")

        # Create a multipart message
        msg = MIMEMultipart()
        msg['From'] = user_id
        msg['To'] = to_email
        msg['Subject'] = subject

        # Attach the message body
        msg.attach(MIMEText(message, 'plain'))

        # Attach any files
        for attachment in attachments:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(open(attachment, 'rb').read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f'attachment; filename="{attachment}"')
            msg.attach(part)

        # Encode the entire message in base64
        raw_message = base64.urlsafe_b64encode(msg.as_bytes()).decode("utf-8")
        body = json.dumps({
            "raw": raw_message
        })
        SEND_URL = f"https://gmail.googleapis.com/gmail/v1/users/{user_id}/messages/send"

        response = requests.post(SEND_URL, headers={"Authorization": f"Bearer {token}"}, data=body)
        result = handle_send_email_result(response.json(), to_email)
        return result

    def handle_send_email_result(result: dict, to_email: str):
        if "error" in result:
            raise ValueError({ "wm_to_email": to_email, **result })

        return result
  original_code: |-
    import base64
    import json
    import requests
    from typing import TypedDict

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, to_email: str, subject: str, message: str, user_id: str = "me"):
        token = gmail_auth["token"]
        if not token:
            raise ValueError("""
            No authentication token was found.
            Go to "https://app.windmill.dev/resources?connect_app=gmail" to connect gmail,
            then select your token from the dropdown in the arguments window.
            (Click "Refresh" if you don't see your resource in the list.)\n""")

        text = f"From: <{user_id}>\nTo: <{to_email}>\nSubject: {subject}\n\n{message}"
        email = base64.urlsafe_b64encode(text.encode("utf-8")).decode("utf-8")
        body = json.dumps({
            "raw": email
        })
        SEND_URL = f"https://gmail.googleapis.com/gmail/v1/users/{user_id}/messages/send"

        response = requests.post(SEND_URL, headers={"Authorization": f"Bearer {token}"}, data=body)
        result = handle_send_email_result(response.json(), to_email)
        return result

    def handle_send_email_result(result: dict, to_email: str):
        if "error" in result:
            raise ValueError({ "wm_to_email": to_email, **result })

        return result
  original_instructions: |2-
     Send Email in gmail
  resource_type: |-
    gmail
  resource_type_def: |-
    class gmail(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to encrypt the client data using the private key before signing it, adding an additional layer of security to the license key generation process.
  id: |-
    hubedit_hub_278
  lang: |-
    python
  modified_code: |-
    import base64
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives.asymmetric import rsa
    from typing import TypedDict
    import os

    class client(TypedDict):
        client: str

    def main(client: str) -> str:
        encoded = client.encode('utf-8')

        # Replace this with the actual way you retrieve your private key
        private_key_pem = os.environ.get("YOUR_PRIVATE_KEY_PEM")
        if private_key_pem is None:
            raise ValueError("Private key not found")

        private_key = import_private_key(private_key_pem)

        # Encrypt the data using the private key
        encrypted_data = private_key.private_numbers().public_numbers.encrypt(
            encoded,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        # Sign the encrypted data
        signature = private_key.sign(
            encrypted_data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

        # Combine the encrypted data and signature to create a license key
        license_key = f"{base64.b64encode(encrypted_data).decode('utf-8')}.{base64.b64encode(signature).decode('utf-8')}"

        return license_key

    def import_private_key(pem: str):
        private_key = load_pem_private_key(
            pem.encode('utf-8'),
            password=None,
            backend=default_backend()
        )
        return private_key
  original_code: |-
    import base64
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.backends import default_backend
    from typing import TypedDict
    import os

    class client(TypedDict):
        client: str

    def main(client: str) -> str:
        encoded = client.encode('utf-8')

        # Replace this with the actual way you retrieve your private key
        private_key_pem = os.environ.get("YOUR_PRIVATE_KEY_PEM")
        if private_key_pem is None:
            raise ValueError("Private key not found")

        private_key = import_private_key(private_key_pem)

        signature = private_key.sign(
            encoded,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=32
            ),
            hashes.SHA256()
        )

        # Combine the encoded data and signature to create a license key
        license_key = f"{base64.b64encode(encoded).decode('utf-8')}.{base64.b64encode(signature).decode('utf-8')}"

        return license_key

    def import_private_key(pem: str):
        private_key = load_pem_private_key(
            pem.encode('utf-8'),
            password=None,
            backend=default_backend()
        )
        return private_key
  original_instructions: |-
    Generate a license key using RSA PSS for a customer in helper
  resource_type: |-
    client
  resource_type_def: |-
    class client(TypedDict):
        client: str
- edit_instructions: |2

    Add functionality to send an embedded message to Discord with additional fields such as timestamp, color, and footer to make the message more informative and visually appealing.
  id: |-
    hubedit_hub_291
  lang: |-
    python
  modified_code: |-
    import os
    import requests
    from datetime import datetime
    from typing import TypedDict

    class DiscordWebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: DiscordWebhook, message: str, name: str):
        flow_id = os.environ.get("WM_FLOW_JOB_ID")
        base_url = os.environ.get('WM_BASE_URL')
        workspace = os.environ.get('WM_WORKSPACE')
        formatted_message = f"Flow [{flow_id}]({base_url}/run/{flow_id}?workspace={workspace}) had an error:\n{name}: {message}"

        # Create the embed object with additional fields
        embed = {
            "title": "Workflow Error Notification",
            "description": formatted_message,
            "color": 0xFF0000,  # Red color
            "timestamp": datetime.utcnow().isoformat(),  # ISO8601 timestamp
            "footer": {
                "text": "Workflow Manager",
                "icon_url": "https://example.com/icon.png"  # Replace with your icon URL if needed
            }
        }

        # Send the message with the embed
        response = requests.post(discord_webhook['webhook_url'], json={"embeds": [embed]})
        return response
  original_code: |-
    import os
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, message: str, name: str):
        flow_id = os.environ.get("WM_FLOW_JOB_ID")
        message = f"Flow [{flow_id}]({os.environ.get('WM_BASE_URL')}/run/{flow_id}?workspace={os.environ.get('WM_WORKSPACE')}) had an error:\n{name}: {message}"
        response = requests.post(discord_webhook['webhook_url'], json={"content": message})
        return response
  original_instructions: |-
    Send the error to discord in discord
  resource_type: |-
    discordwebhook
  resource_type_def: |-
    class discordwebhook(TypedDict):
        webhook_url: str
- edit_instructions: |2

    Add error handling to check the response status code and raise an exception if the request was unsuccessful. Optionally, include logging to record successful and unsuccessful requests.
  id: |-
    hubedit_hub_316
  lang: |-
    python
  modified_code: |-
    import requests
    import logging
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def main(gh_auth: github, username: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        response = requests.get(f"https://api.github.com/users/{username}", headers=headers)

        if response.ok:
            logging.info(f"Successfully fetched data for user: {username}")
            return response.json()
        else:
            logging.error(f"Failed to fetch data for user: {username}, Status code: {response.status_code}, Response: {response.text}")
            response.raise_for_status()
  original_code: |-
    import requests
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def main(gh_auth: github, username: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        response = requests.get(f"https://api.github.com/users/{username}", headers=headers)
        return response.json()
  original_instructions: |-
    Get a user in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to write data to a specific cell or range within the spreadsheet by modifying the script to use the Google Sheets API method for updating spreadsheet values.
  id: |-
    hubedit_hub_51
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List

    class gsheets(TypedDict):
        token: str

    def update_cell(gsheets_auth: gsheets, spreadsheetId: str, range: str, values: List[List[str]]):
        token = gsheets_auth["token"]
        UPDATE_SPREADSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{range}:batchUpdate'

        data = {
            "valueInputOption": "USER_ENTERED",
            "data": [
                {
                    "range": range,
                    "values": values
                }
            ],
            "includeValuesInResponse": True
        }

        response = requests.post(
            UPDATE_SPREADSHEET_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            },
            json=data
        )

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str):
        token = gsheets_auth["token"]
        GET_SPREADSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}'

        response = requests.get(
            GET_SPREADSHEET_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        return response.json()
  original_instructions: |-
    Get Spreadsheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update documents in the collection based on a given update query and criteria.
  id: |-
    hubedit_hub_256
  lang: |-
    python
  modified_code: |-
    def update_documents(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Dict[str, Any],
        update: Dict[str, Any],
        upsert: Optional[bool] = False,
        multi: Optional[bool] = False
    ) -> Dict[str, Any]:
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]

        if multi:
            result = coll.update_many(filter, update, upsert=upsert)
        else:
            result = coll.update_one(filter, update, upsert=upsert)

        return {
            'matched_count': result.matched_count,
            'modified_count': result.modified_count,
            'upserted_id': result.upserted_id
        }
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Optional, Dict, Any

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Optional[Dict[str, Any]] = None,
        projection: Optional[Dict[str, int]] = None,
        sort: Optional[Dict[str, int]] = None,
        limit: Optional[int] = None,
        skip: Optional[int] = None,
    ):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        options = remove_empty_fields({'projection': projection, 'sort': sort, 'limit': limit, 'skip': skip})
        return list(coll.find(filter, **options))
  original_instructions: |-
    Search Documents in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Add functionality to save the response data to a CSV file, including an option to specify the file path where the CSV should be saved.
  id: |-
    hubedit_hub_211
  lang: |-
    python
  modified_code: |-
    import csv

    # ... (rest of the existing code)

    def main(
        # ... (rest of the existing parameters)
        save_to_csv: Optional[bool] = False,
        csv_file_path: Optional[str] = 'mailchimp_data.csv',
    ):
        # ... (rest of the existing code)

        data = response.json()

        if save_to_csv:
            with open(csv_file_path, mode='w', newline='', encoding='utf-8') as file:
                writer = csv.writer(file)
                if data.get('segments'):
                    # Assuming 'segments' is the key where the data list is stored
                    headers = data['segments'][0].keys() if data['segments'] else []
                    writer.writerow(headers)
                    for segment in data['segments']:
                        writer.writerow(segment.values())

        return data
  original_code: |-
    import requests
    from typing import List, Optional, TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        type: Optional[str] = None,
        since_created_at: Optional[str] = None,
        before_created_at: Optional[str] = None,
        since_updated_at: Optional[str] = None,
        before_updated_at: Optional[str] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'type': type,
            'since_created_at': since_created_at,
            'before_created_at': before_created_at,
            'since_updated_at': since_updated_at,
            'before_updated_at': before_updated_at,
            'include_cleaned': include_cleaned,
            'include_transactional': include_transactional,
            'include_unsubscribed': include_unsubscribed,
        }
        # Remove None values
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Search Segments in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add functionality to cache the response data to reduce the number of API calls if the same request is made within a certain time frame.
  id: |-
    hubedit_hub_200
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import List, TypedDict, Optional
    from functools import lru_cache

    class mailchimp(TypedDict):
        api_key: str
        server: str

    # Define a cache decorator with a timeout
    def cache_with_timeout(timeout: int):
        def decorator(func):
            cached_func = lru_cache(maxsize=None)(func)
            last_time_called = {'time': None}

            def wrapper(*args, **kwargs):
                nonlocal last_time_called
                current_time = time.time()
                if last_time_called['time'] is None or current_time - last_time_called['time'] > timeout:
                    cached_func.cache_clear()
                    last_time_called['time'] = current_time
                return cached_func(*args, **kwargs)
            return wrapper
        return decorator

    @cache_with_timeout(timeout=300)  # Cache timeout set to 5 minutes (300 seconds)
    def get_campaign_data(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}?"
        if fields and not exclude_fields:
            url += f"fields={','.join(fields)}"
        if exclude_fields:
            url += f"{'&' if fields else ''}exclude_fields={','.join(exclude_fields)}"

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        return get_campaign_data(auth, campaign_id, fields, exclude_fields)
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}?"
        if fields and not exclude_fields:
            url += f"fields={','.join(fields)}"
        if exclude_fields:
            url += f"{'&' if fields else ''}exclude_fields={','.join(exclude_fields)}"

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Get Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add functionality to save the response data to a local JSON file, allowing the user to keep a record of the retrieved segment data.
  id: |-
    hubedit_hub_212
  lang: |-
    python
  modified_code: |-
    import requests
    import json
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        segment_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
        save_to_file: Optional[bool] = False,
        file_name: Optional[str] = 'segment_data.json'
    ):
        base_url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments/{segment_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_cleaned': str(include_cleaned).lower() if include_cleaned is not None else None,
            'include_transactional': str(include_transactional).lower() if include_transactional is not None else None,
            'include_unsubscribed': str(include_unsubscribed).lower() if include_unsubscribed is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        data = response.json()

        if save_to_file:
            with open(file_name, 'w') as f:
                json.dump(data, f, indent=4)

        return data
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        segment_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
    ):
        base_url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments/{segment_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_cleaned': str(include_cleaned).lower() if include_cleaned is not None else None,
            'include_transactional': str(include_transactional).lower() if include_transactional is not None else None,
            'include_unsubscribed': str(include_unsubscribed).lower() if include_unsubscribed is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Get Segment in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add a feature to update an existing document in the database if the 'id' parameter is provided, instead of always creating a new document.
  id: |-
    hubedit_hub_326
  lang: |-
    python
  modified_code: |-
    def main(auth: appwrite, name: str, id: Optional[str] = None):
        client = Client() \
            .set_endpoint(auth['endpoint']) \
            .set_project(auth['project']) \
            .set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        if id:
            # Update an existing document
            return db.update_document(database_id='default', collection_id='unique_collection_id', document_id=id, data={'name': name})
        else:
            # Create a new document with a unique ID
            unique_id = 'unique()'  # Replace 'unique()' with actual unique ID generation logic
            return db.create_document(database_id='default', collection_id='unique_collection_id', document_id=unique_id, data={'name': name})
  original_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, name: str, id: Optional[str] = None):
        client = Client() \
            .set_endpoint(auth['endpoint']) \
            .set_project(auth['project']) \
            .set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        unique_id = id or 'unique()'  # Replace 'unique()' with actual unique ID generation logic
        return db.create_document(database_id='default', collection_id='unique_collection_id', document_id=unique_id, data={'name': name})
  original_instructions: |-
    Create Database in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Add functionality to create a new document in the specified collection with data provided as an argument to the main function.
  id: |-
    hubedit_hub_335
  lang: |-
    python
  modified_code: |-
    def main(auth: appwrite, database_id: str, collection_id: str, data: dict, queries: List[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        # Create a new document in the specified collection
        new_document = db.create_document(database_id, collection_id, data)

        # If queries are provided, list documents according to the queries
        if queries:
            result = db.list_documents(database_id, collection_id, queries=queries)
        else:
            result = new_document  # Return the newly created document if no queries are provided

        return result
  original_code: |-
    from typing import TypedDict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, queries: List[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        result = db.list_documents(database_id, collection_id, queries=queries)
        return result
  original_instructions: |-
    List Documents in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- edit_instructions: |2

    Modify the script to cache the response of the `get_resume_urls` function to avoid repeated calls to the API for the same `approver` parameter within a certain time frame.
  id: |-
    hubedit_hub_172
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional
    from functools import lru_cache
    from datetime import datetime, timedelta

    class windmill(TypedDict):
        approvalPage: str

    # Create a decorator to cache results for a certain time frame
    def timed_lru_cache(seconds: int, maxsize: int = 128):
        def wrapper_cache(func):
            func = lru_cache(maxsize=maxsize)(func)
            func.lifetime = timedelta(seconds=seconds)
            func.expiration = datetime.utcnow() + func.lifetime

            def wrapped_func(*args, **kwargs):
                if datetime.utcnow() >= func.expiration:
                    func.cache_clear()
                    func.expiration = datetime.utcnow() + func.lifetime
                return func(*args, **kwargs)

            return wrapped_func
        return wrapper_cache

    @timed_lru_cache(seconds=300)  # Cache results for 5 minutes
    def get_resume_urls(approver: Optional[str] = None) -> windmill:
        # Assuming there's an equivalent API endpoint to get resume URLs
        # Replace 'http://api.example.com/getResumeUrls' with the actual API endpoint
        response = requests.get('http://api.example.com/getResumeUrls', params={'approver': approver})
        response.raise_for_status()
        return response.json()

    def main(approver: Optional[str] = None) -> windmill:
        endpoints = get_resume_urls(approver)
        print(f"Approval page at {endpoints['approvalPage']}")
        return endpoints
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class windmill(TypedDict):
        approvalPage: str

    def get_resume_urls(approver: Optional[str] = None) -> windmill:
        # Assuming there's an equivalent API endpoint to get resume URLs
        # Replace 'http://api.example.com/getResumeUrls' with the actual API endpoint
        response = requests.get('http://api.example.com/getResumeUrls', params={'approver': approver})
        response.raise_for_status()
        return response.json()

    def main(approver: Optional[str] = None) -> windmill:
        endpoints = get_resume_urls(approver)
        print(f"Approval page at {endpoints['approvalPage']}")
        return endpoints
  original_instructions: |-
    Return resume and cancel endpoints in windmill
  resource_type: |-
    windmill
  resource_type_def: |-
    class windmill(TypedDict):
        approvalPage: str
- edit_instructions: |2

    Add error handling to check the response status code and raise an exception with a custom message if the request fails.
  id: |-
    hubedit_hub_312
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional, Dict, Any

    class github(TypedDict):
        token: str

    def main(
        gh_auth: github,
        owner: str,
        repo: str,
        workflow_id: str,
        ref: str,
        inputs: Optional[Dict[str, Any]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        payload = {
            "ref": ref,
            "inputs": inputs or {},
        }
        response = requests.post(url, headers=headers, json=payload)

        if response.status_code != 204:
            raise Exception(f"Failed to trigger workflow: {response.status_code} - {response.text}")

        return response
  original_code: |-
    import requests
    from typing import TypedDict, Optional, Dict, Any

    class github(TypedDict):
        token: str

    def main(
        gh_auth: github,
        owner: str,
        repo: str,
        workflow_id: str,
        ref: str,
        inputs: Optional[Dict[str, Any]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        payload = {
            "ref": ref,
            "inputs": inputs or {},
        }
        response = requests.post(url, headers=headers, json=payload)
        return response
  original_instructions: |-
    Dispatch Workflow Run in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter items by a specific type, such as 'story' or 'comment', by adding a type check in the loop that processes items.
  id: |-
    hubedit_hub_88
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import List, TypedDict

    class hackernews(TypedDict):
        text: str
        type: str

    MAX_LOOKBACK = 100

    def get_state():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read().strip())
        except FileNotFoundError:
            return None

    def set_state(state):
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def get_max_item():
        res = requests.get("https://hacker-news.firebaseio.com/v0/maxitem.json")
        return int(res.text)

    def get_item(id: int) -> hackernews:
        res = requests.get(f"https://hacker-news.firebaseio.com/v0/item/{id}.json")
        return res.json()

    def main(mentions: List[str], item_type: str):
        last_state = get_state()
        max_item = get_max_item()

        if last_state is None:
            last_state = max_item - MAX_LOOKBACK
        max_item = min(max_item, last_state + MAX_LOOKBACK)

        items = []
        for i in range(last_state, max_item):
            item = get_item(i)
            if item.get('type') == item_type:
                if any(mention.strip().lower() in (item.get('text') or '').lower() for mention in mentions):
                    items.append(item)

        set_state(max_item)

        return items
  original_code: |-
    import requests
    from typing import List, TypedDict

    class hackernews(TypedDict):
        text: str

    MAX_LOOKBACK = 100

    def get_state():
        # Replace with actual state retrieval logic
        # For example, reading from a file or a database
        try:
            with open('state.txt', 'r') as file:
                return int(file.read().strip())
        except FileNotFoundError:
            return None

    def set_state(state):
        # Replace with actual state saving logic
        # For example, writing to a file or a database
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def get_max_item():
        res = requests.get("https://hacker-news.firebaseio.com/v0/maxitem.json")
        return int(res.text)

    def get_item(id: int) -> hackernews:
        res = requests.get(f"https://hacker-news.firebaseio.com/v0/item/{id}.json")
        return res.json()

    def main(mentions: List[str]):
        last_state = get_state()
        max_item = get_max_item()

        if last_state is None:
            last_state = max_item - MAX_LOOKBACK
        max_item = min(max_item, last_state + MAX_LOOKBACK)

        items = []
        for i in range(last_state, max_item):
            item = get_item(i)
            if any(mention.strip().lower() in (item.get('text') or '').lower() for mention in mentions):
                items.append(item)

        set_state(max_item)

        return items
  original_instructions: |-
    Trigger everytime a new item text on HackerNews match at least one mention in hackernews
  resource_type: |-
    hackernews
  resource_type_def: |-
    class hackernews(TypedDict):
        text: str
- edit_instructions: |2

    Modify the script to include error handling that catches any exceptions raised by the Stripe API during the refund creation process and logs the error message.
  id: |-
    hubedit_hub_125
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict
    import logging

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, charge_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        try:
            refund = stripe_module.Refund.create(
                charge=charge_id
            )
            return refund
        except stripe_module.error.StripeError as e:
            logging.error(f"Stripe API error occurred: {e.user_message}")
            return None
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, charge_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        refund = stripe_module.Refund.create(
            charge=charge_id
        )

        return refund
  original_instructions: |-
    Create a Refund in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to cache the response for a given room_id, type, and state_key combination to reduce the number of requests to the server and improve performance.
  id: |-
    hubedit_hub_159
  lang: |-
    python
  modified_code: |-
    import urllib.parse
    import requests
    from typing import TypedDict, Optional
    from functools import lru_cache

    class matrix(TypedDict):
        baseUrl: str
        token: str

    @lru_cache(maxsize=128)
    def get_room_state(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{urllib.parse.quote(room_id)}/state/{urllib.parse.quote(type)}/"
        if state_key:
            url += urllib.parse.quote(state_key)
        resp = requests.get(url, headers={
            'Authorization': f"Bearer {matrix_res['token']}",
        })
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return resp.json()

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None):
        return {
            'content': get_room_state(matrix_res, room_id, type, state_key),
        }
  original_code: |-
    import urllib.parse
    import requests
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{urllib.parse.quote(room_id)}/state/{urllib.parse.quote(type)}/"
        if state_key:
            url += urllib.parse.quote(state_key)
        resp = requests.get(url, headers={
            'Authorization': f"Bearer {matrix_res['token']}",
        })
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return {
            'content': resp.json(),
        }
  original_instructions: |-
    Get room state by type and state_key in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add functionality to log the response status and message to a file after the delete request is made.
  id: |-
    hubedit_hub_44
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict
    import logging

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, eventId: str):
        sendUpdates = "all"
        DELETE_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?sendUpdates={sendUpdates}"
        token = gcal_auth["token"]

        response = requests.delete(
            DELETE_EVENT_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        # Set up logging to file
        logging.basicConfig(filename='delete_event_log.txt', level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

        # Log the response status and message
        if response.ok:
            logging.info(f"Event with ID {eventId} deleted successfully. Status Code: {response.status_code}")
        else:
            logging.error(f"Failed to delete event with ID {eventId}. Status Code: {response.status_code}, Response: {response.text}")

        return response
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, eventId: str):
        sendUpdates = "all"
        DELETE_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?sendUpdates={sendUpdates}"
        token = gcal_auth["token"]

        response = requests.delete(
            DELETE_EVENT_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response
  original_instructions: |-
    Delete Event in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to check the campaign status before attempting to send it, and only proceed with sending if the campaign is in a 'ready' state.
  id: |-
    hubedit_hub_203
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class MailchimpAuth(TypedDict):
        api_key: str
        server: str

    def check_campaign_status(auth: MailchimpAuth, campaign_id: str) -> str:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}"
        response = requests.get(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)

        campaign_data = response.json()
        return campaign_data.get('status')

    def main(auth: MailchimpAuth, campaign_id: str):
        # Check the campaign status before sending
        status = check_campaign_status(auth, campaign_id)
        if status != 'ready':
            raise Exception(f"Campaign status is '{status}', not 'ready'.")

        # Proceed with sending if the campaign is 'ready'
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/send"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/send"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Send a Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add error handling to manage the case where the request to the URL fails or returns an unexpected status code.
  id: |-
    hubedit_hub_167
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Any, Optional

    class appdata(TypedDict, total=False):
        apps: List[Any]
        error: str

    def main() -> appdata:
        url = "https://hub.windmill.dev/searchAppData"
        try:
            response = requests.get(url)
            response.raise_for_status()  # This will raise an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.RequestException as e:  # This block will handle any requests-related issues, like network problems or timeout
            return {"error": str(e)}
        except Exception as e:  # This block will handle any other exceptions that are not related to requests
            return {"error": f"An unexpected error occurred: {str(e)}"}

        try:
            return response.json()
        except ValueError:  # This block will handle JSON decoding errors
            return {"error": "Invalid JSON received"}
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class appdata(TypedDict):
        apps: List[Any]

    def main() -> appdata:
        url = "https://hub.windmill.dev/searchAppData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List Apps in windmillhub
  resource_type: |-
    appdata
  resource_type_def: |-
    class appdata(TypedDict):
        apps: List[Any]
- edit_instructions: |2

    Modify the script to send a message to the specified channel instead of leaving it.
  id: |-
    hubedit_hub_23
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, message: str):
        web = WebClient(token=slack_auth['token'])

        response = web.chat_postMessage(
            channel=channel,
            text=message
        )

        return {'response': response}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_leave(
            channel=channel
        )

        return {'response': response}
  original_instructions: |-
    Leave Channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing contact if the email address provided matches an existing record in the HubSpot CRM, instead of always creating a new contact.
  id: |-
    hubedit_hub_226
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.contacts import SimplePublicObjectInput, ApiException

    class hubspot(TypedDict):
        token: str

    def remove_object_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None and v != ''}

    def main(auth: hubspot, company: Optional[str] = None, email: Optional[str] = None,
             firstname: Optional[str] = None, lastname: Optional[str] = None,
             phone: Optional[str] = None, website: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'company': company,
            'email': email,
            'firstname': firstname,
            'lastname': lastname,
            'phone': phone,
            'website': website,
        })

        if email:
            # Search for contact by email to determine if it exists
            try:
                search_results = client.crm.contacts.search_api.do_search(
                    filter_groups=[
                        {
                            "filters": [
                                {
                                    "value": email,
                                    "propertyName": "email",
                                    "operator": "EQ"
                                }
                            ]
                        }
                    ],
                    properties=["email"]
                )
                contacts = search_results.results
                if contacts:
                    contact_id = contacts[0].id
                    # Update existing contact
                    return client.crm.contacts.basic_api.update(
                        contact_id=contact_id,
                        simple_public_object_input=SimplePublicObjectInput(properties=properties)
                    )
            except ApiException as e:
                if e.status != 404:  # If the error is not a 'Not Found' error, raise it
                    raise

        # If no email provided or contact does not exist, create a new contact
        try:
            return client.crm.contacts.basic_api.create(SimplePublicObjectInput(properties=properties))
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  original_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.contacts import SimplePublicObjectInput

    class hubspot(TypedDict):
        token: str

    def remove_object_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None and v != ''}

    def main(auth: hubspot, company: Optional[str] = None, email: Optional[str] = None,
             firstname: Optional[str] = None, lastname: Optional[str] = None,
             phone: Optional[str] = None, website: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'company': company,
            'email': email,
            'firstname': firstname,
            'lastname': lastname,
            'phone': phone,
            'website': website,
        })
        try:
            return client.crm.contacts.basic_api.create(SimplePublicObjectInput(properties=properties))
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  original_instructions: |-
    Create Contact in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to attach an image to the message by modifying the `main` function to accept an optional `image_url` parameter and use the `files_upload` method from the `WebClient` to upload the image to the channel along with the text message.
  id: |-
    hubedit_hub_72
  lang: |-
    python
  modified_code: |-
    from slack_sdk import WebClient
    from typing import TypedDict, Optional

    class SlackConfig(TypedDict):
        token: str

    def main(text: str, channel: str, slack: SlackConfig, image_url: Optional[str] = None):
        web = WebClient(token=slack['token'])

        # Post the text message to the channel
        response = web.chat_postMessage(channel=channel, text=text)

        # If an image URL is provided, upload the image to the channel
        if image_url:
            # Retrieve the timestamp of the message to attach the image to
            ts = response['ts']

            # Upload the image to the channel and attach it to the message
            web.files_upload(channels=channel, file=image_url, initial_comment=text, thread_ts=ts)

    # Example usage:
    # main(text="Hello, world!", channel="#general", slack={"token": "xoxb-your-token"}, image_url="http://example.com/image.png")
  original_code: |-
    from slack_sdk import WebClient
    from typing import TypedDict

    class slack(TypedDict):
        token: str

    def main(text: str, channel: str, slack: slack):
        web = WebClient(token=slack['token'])
        web.chat_postMessage(channel=channel, text=text)
  original_instructions: |-
    Send Message to Channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter the balance transactions by a specific date range before returning them.
  id: |-
    hubedit_hub_126
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict
    from datetime import datetime

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: int, start_date: datetime, end_date: datetime):
        token = stripe_con["token"]
        stripe_module.api_key = token

        balance_transactions = stripe_module.BalanceTransaction.list(
            limit=limit,
            created={
                'gte': int(start_date.timestamp()),
                'lte': int(end_date.timestamp())
            }
        )

        return balance_transactions
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: int):
        token = stripe_con["token"]
        stripe_module.api_key = token

        balance_transactions = stripe_module.BalanceTransaction.list(limit=limit)

        return balance_transactions
  original_instructions: |-
    List Balance History in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to also update the subscription's metadata with a timestamp and the quantity whenever a usage record is created.
  id: |-
    hubedit_hub_127
  lang: |-
    python
  modified_code: |-
    import stripe
    import time
    from typing import TypedDict

    class stripe_config(TypedDict):
        token: str

    def main(sk: stripe_config, subscriptionId: str, quantity: int):
        client = stripe.StripeClient(sk['token'])
        stripe.api_version = "2022-11-15"

        # Create a usage record
        usage_record = client.SubscriptionItem.create_usage_record(subscriptionId, {
            'quantity': quantity,
        })

        # Prepare metadata with timestamp and quantity
        metadata = {
            'last_usage_timestamp': str(int(time.time())),
            'last_usage_quantity': str(quantity)
        }

        # Update the subscription with the new metadata
        subscription = client.Subscriptions.update(subscriptionId, metadata=metadata)

        return usage_record
  original_code: |-
    import stripe
    from typing import TypedDict

    class stripe_config(TypedDict):
        token: str

    def main(sk: stripe_config, subscriptionId: str, quantity: int):
        client = stripe.StripeClient(sk['token'])
        stripe.api_version = "2022-11-15"

        return client.SubscriptionItem.create_usage_record(subscriptionId, {
            'quantity': quantity,
        })
  original_instructions: |-
    Create Usage Record in stripe
  resource_type: |-
    stripe_config
  resource_type_def: |-
    class stripe_config(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to the main function to catch any exceptions that may occur during the HTTP request, such as connection errors or timeouts, and return an appropriate error message.
  id: |-
    hubedit_hub_373
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Any

    class msteamswebhook(TypedDict):
        webhook_url: str

    def main(ms_teams_webhook: msteamswebhook, message_card: Any) -> Any:
        try:
            webhook_url = ms_teams_webhook['webhook_url']
            response = requests.post(webhook_url, json=message_card)
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
            return response.json()
        except requests.exceptions.HTTPError as http_err:
            return {'error': f'HTTP error occurred: {http_err}'}
        except requests.exceptions.ConnectionError as conn_err:
            return {'error': f'Connection error occurred: {conn_err}'}
        except requests.exceptions.Timeout as timeout_err:
            return {'error': f'Timeout error occurred: {timeout_err}'}
        except requests.exceptions.RequestException as req_err:
            return {'error': f'An error occurred during the request: {req_err}'}
        except Exception as e:
            return {'error': f'An unexpected error occurred: {e}'}
  original_code: |-
    import requests
    from typing import TypedDict, Any

    class msteamswebhook(TypedDict):
        webhook_url: str

    def main(ms_teams_webhook: msteamswebhook, message_card: Any) -> Any:
        webhook_url = ms_teams_webhook['webhook_url']
        response = requests.post(webhook_url, json=message_card)
        return response.json()

    example_card = {
        "@type": "MessageCard",
        "@context": "https://schema.org/extensions",
        "summary": "This is a test summary",
        "themeColor": "0078D7",
        "title": "This is a test title",
        "sections": [
            {
                "activityTitle": "Windmill Webhook",
                "activitySubtitle": "2023-05-25 17:57:55",
                "activityImage": "https://connectorsdemo.azurewebsites.net/images/MSC12_Oscar_002.jpg",
                "text": "This is a test text",
            },
        ],
    }
  original_instructions: |-
    Send a message to MS Teams channel via webhook in msteams
  resource_type: |-
    msteamswebhook
  resource_type_def: |-
    class msteamswebhook(TypedDict):
        webhook_url: str
- edit_instructions: |2

    Add functionality to check the response status code and raise an exception with a custom error message if the API call fails.
  id: |-
    hubedit_hub_47
  lang: |-
    python
  modified_code: |2-
        response = requests.put(UPDATE_EVENT_ATTENDEES_URL, json=body, headers=headers)

        if response.status_code != 200:
            raise Exception(f"API call failed with status code {response.status_code}: {response.text}")

        result = response.json()

        return result
  original_code: |-
    import requests
    from typing import TypedDict, List, Dict

    class gcal(TypedDict):
        token: str

    def main(
        gcal_auth: gcal,
        calendarId: str,
        eventId: str,
        attendees: List[Dict],
    ):
        alwaysIncludeEmail = True
        sendUpdates = "all"
        supportsAttachments = True
        UPDATE_EVENT_ATTENDEES_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?alwaysIncludeEmail={alwaysIncludeEmail}&sendUpdates={sendUpdates}&supportsAttachments={supportsAttachments}"

        token = gcal_auth["token"]

        body = {
            "attendees": attendees,
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = requests.put(UPDATE_EVENT_ATTENDEES_URL, json=body, headers=headers)

        result = response.json()

        return result
  original_instructions: |-
    Update Attendees of an Event in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to log the response status code and the response content to a file for debugging purposes whenever a request is made.
  id: |-
    hubedit_hub_283
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Union, List, Dict, Any, Optional
    import requests
    import logging

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        # This function should handle the token refresh logic and retry the action if the token is expired.
        # Since the original TypeScript function is from an external library, we'll need to implement
        # the logic ourselves or use a similar library in Python. For simplicity, we'll assume the token
        # is always valid in this example.
        return action()

    def log_response(response: requests.Response):
        with open('request_log.txt', 'a') as log_file:
            log_file.write(f"Status Code: {response.status_code}\n")
            log_file.write(f"Content: {response.content}\n\n")

    def main(
        auth: supabase,
        table: str,
        values: Union[Dict[str, Any], List[Dict[str, Any]]],
        return_inserted: bool = False,
        token: Optional[Dict[str, str]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            url = f"{auth['url']}/{table}"
            params = {'return': 'representation' if return_inserted else None, 'count': count}
            response = requests.post(url, json=values, headers=headers, params=params)
            log_response(response)  # Log the response
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  original_code: |-
    from typing import TypedDict, Union, List, Dict, Any, Optional
    import requests

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        # This function should handle the token refresh logic and retry the action if the token is expired.
        # Since the original TypeScript function is from an external library, we'll need to implement
        # the logic ourselves or use a similar library in Python. For simplicity, we'll assume the token
        # is always valid in this example.
        return action()

    def main(
        auth: supabase,
        table: str,
        values: Union[Dict[str, Any], List[Dict[str, Any]]],
        return_inserted: bool = False,
        token: Optional[Dict[str, str]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            url = f"{auth['url']}/{table}"
            params = {'return': 'representation' if return_inserted else None, 'count': count}
            response = requests.post(url, json=values, headers=headers, params=params)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  original_instructions: |-
    Insert data in supabase
  resource_type: |-
    supabase
  resource_type_def: |-
    class supabase(TypedDict):
        url: str
        key: str
- edit_instructions: |2

    Modify the script to update the status of a campaign to 'paused' instead of deleting it.
  id: |-
    hubedit_hub_202
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class MailchimpAuth(TypedDict):
        api_key: str
        server: str

    def main(auth: MailchimpAuth, campaign_id: str) -> str:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/pause"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })
        if not response.ok:
            raise Exception(response.text)
        return f"Successfully paused campaign with ID '{campaign_id}'"
  original_code: |-
    import requests
    from typing import TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str) -> str:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}"
        response = requests.delete(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })
        if not response.ok:
            raise Exception(response.text)
        return f"Successfully deleted campaign with ID '{campaign_id}'"
  original_instructions: |-
    Delete Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Modify the script to update a specific document with new data instead of deleting it. The new data should be passed as an additional parameter to the main function.
  id: |-
    hubedit_hub_360
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document_path: str, new_data: dict):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['apiKey'],
            "private_key": auth['appId'],
            "client_email": f"firebase-adminsdk@{auth['projectId']}.iam.gserviceaccount.com",
            "client_id": auth['messagingSenderId'],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": f"https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk%40{auth['projectId']}.iam.gserviceaccount.com"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(document_path)
        doc_ref.update(new_data)
  original_code: |-
    from typing import TypedDict
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document_path: list):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['apiKey'],
            "private_key": auth['appId'],
            "client_email": f"firebase-adminsdk@{auth['projectId']}.iam.gserviceaccount.com",
            "client_id": auth['messagingSenderId'],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": f"https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk%40{auth['projectId']}.iam.gserviceaccount.com"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        doc_ref.delete()
  original_instructions: |-
    Delete Document in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- edit_instructions: |2

    Add functionality to filter the returned S3 objects by a specific file extension, such as ".txt" or ".jpg".
  id: |-
    hubedit_hub_107
  lang: |-
    python
  modified_code: |-
    def main(s3_config: s3, prefix: Optional[str] = None, bucket_name: Optional[str] = None, max_results: Optional[int] = None, page_size: Optional[int] = None, file_extension: Optional[str] = None) -> List[dict]:
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            endpoint_url=s3_config['endPoint'],
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        options = remove_empty_fields({
            'Prefix': prefix,
            'Bucket': bucket_name or s3_config['bucket'],
            'MaxKeys': max_results,
            'PageSize': page_size,
        })

        paginator = s3_client.get_paginator('list_objects_v2')
        page_iterator = paginator.paginate(**options)

        result = []
        try:
            for page in page_iterator:
                for obj in page.get('Contents', []):
                    if file_extension and obj['Key'].endswith(file_extension):
                        result.append(obj)
                    elif not file_extension:
                        result.append(obj)
        except NoCredentialsError:
            print("Credentials not available")

        return result
  original_code: |-
    from typing import TypedDict, Optional, List
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(s3_config: s3, prefix: Optional[str] = None, bucket_name: Optional[str] = None, max_results: Optional[int] = None, page_size: Optional[int] = None) -> List[dict]:
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            endpoint_url=s3_config['endPoint'],
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        options = remove_empty_fields({
            'Prefix': prefix,
            'Bucket': bucket_name or s3_config['bucket'],
            'MaxKeys': max_results,
            'PageSize': page_size,
        })

        paginator = s3_client.get_paginator('list_objects_v2')
        page_iterator = paginator.paginate(**options)

        result = []
        try:
            for page in page_iterator:
                result.extend(page.get('Contents', []))
        except NoCredentialsError:
            print("Credentials not available")

        return result
  original_instructions: |-
    List objects in a bucket in s3
  resource_type: |-
    s3
  resource_type_def: |-
    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str
- edit_instructions: |2

    Add functionality to handle file attachments by modifying the `main` function to accept a file path, read the file, and send it as a "m.file" message type to the Matrix room.
  id: |-
    hubedit_hub_95
  lang: |-
    python
  modified_code: |-
    import requests
    import random
    import json
    import mimetypes
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def resolveRoomAlias(matrix_res: matrix, room: str) -> str:
        if room.startswith("!"):
            return room
        resp = requests.get(
            f"{matrix_res['baseUrl']}/_matrix/client/v3/directory/room/{requests.utils.quote(room)}",
            headers={
                "Accept": "application/json",
                **({"Authorization": f"Bearer {matrix_res['token']}"} if matrix_res['token'] else {}),
            },
        )
        if not resp.ok:
            raise Exception(f"Failed to resolve room alias: Error HTTP{resp.status_code}")
        roomId = resp.json().get("room_id")
        if not isinstance(roomId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide room_id for this alias.")
        return roomId

    def uploadContent(matrix_res: matrix, file_path: str) -> str:
        content_type, _ = mimetypes.guess_type(file_path)
        if not content_type:
            content_type = "application/octet-stream"
        with open(file_path, 'rb') as file:
            resp = requests.post(
                f"{matrix_res['baseUrl']}/_matrix/media/v3/upload",
                headers={
                    "Authorization": f"Bearer {matrix_res['token']}",
                    "Content-Type": content_type,
                },
                data=file
            )
        if not resp.ok:
            raise Exception(f"Failed to upload content: Error HTTP{resp.status_code}")
        content_uri = resp.json().get("content_uri")
        if not isinstance(content_uri, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide content_uri for this upload.")
        return content_uri

    def main(matrix_res: matrix, room: str, body: str, file_path: str = None) -> str:
        if not matrix_res['token']:
            raise Exception("Sending a message requires an access token.")
        roomId = resolveRoomAlias(matrix_res, room)
        txnId = str(random.random())

        if file_path:
            content_uri = uploadContent(matrix_res, file_path)
            file_info = {
                "body": body,  # Use the body as the filename
                "msgtype": "m.file",
                "url": content_uri,
                "info": {
                    "mimetype": mimetypes.guess_type(file_path)[0] or "application/octet-stream",
                    "size": os.path.getsize(file_path),
                }
            }
        else:
            file_info = {
                "body": body,
                "msgtype": "m.text",
            }

        resp = requests.put(
            f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/send/m.room.message/{txnId}",
            headers={
                "Accept": "application/json",
                "Authorization": f"Bearer {matrix_res['token']}",
                "Content-Type": "application/json",
            },
            data=json.dumps(file_info),
        )
        if not resp.ok:
            raise Exception(f"Failed to send message: Error HTTP{resp.status_code}")
        eventId = resp.json().get("event_id")
        if not isinstance(eventId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide event_id for this message.")
        return eventId
  original_code: |-
    import requests
    import random
    import json
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def resolveRoomAlias(matrix_res: matrix, room: str) -> str:
        if room.startswith("!"):
            return room
        resp = requests.get(
            f"{matrix_res['baseUrl']}/_matrix/client/v3/directory/room/{requests.utils.quote(room)}",
            headers={
                "Accept": "application/json",
                **({"Authorization": f"Bearer {matrix_res['token']}"} if matrix_res['token'] else {}),
            },
        )
        if not resp.ok:
            raise Exception(f"Failed to resolve room alias: Error HTTP{resp.status_code}")
        roomId = resp.json().get("room_id")
        if not isinstance(roomId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide room_id for this alias.")
        return roomId

    def main(matrix_res: matrix, room: str, body: str) -> str:
        if not matrix_res['token']:
            raise Exception("Sending a message requires an access token.")
        roomId = resolveRoomAlias(matrix_res, room)
        txnId = str(random.random())
        resp = requests.put(
            f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/send/m.room.message/{txnId}",
            headers={
                "Accept": "application/json",
                "Authorization": f"Bearer {matrix_res['token']}",
                "Content-Type": "application/json",
            },
            data=json.dumps({
                "body": body,
                "msgtype": "m.text",
            }),
        )
        if not resp.ok:
            raise Exception(f"Failed to send message: Error HTTP{resp.status_code}")
        eventId = resp.json().get("event_id")
        if not isinstance(eventId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide event_id for this message.")
        return eventId
  original_instructions: |-
    Post an unencrypted message in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add functionality to filter the lists by a specific member's status, such as subscribed, unsubscribed, cleaned, or pending.
  id: |-
    hubedit_hub_207
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        sort_dir: Optional[str] = None,
        before_date_created: Optional[str] = None,
        since_date_created: Optional[str] = None,
        before_campaign_last_sent: Optional[str] = None,
        since_campaign_last_sent: Optional[str] = None,
        email: Optional[str] = None,
        sort_field: Optional[str] = None,
        has_ecommerce_store: Optional[bool] = None,
        include_total_contacts: Optional[bool] = None,
        member_status: Optional[str] = None,  # Added parameter for member status
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'sort_dir': sort_dir,
            'before_date_created': before_date_created,
            'since_date_created': since_date_created,
            'before_campaign_last_sent': before_campaign_last_sent,
            'since_campaign_last_sent': since_campaign_last_sent,
            'email': email,
            'sort_field': sort_field,
            'has_ecommerce_store': has_ecommerce_store,
            'include_total_contacts': include_total_contacts,
            'member_status': member_status,  # Added member status to the params
        }
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, List, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        sort_dir: Optional[str] = None,
        before_date_created: Optional[str] = None,
        since_date_created: Optional[str] = None,
        before_campaign_last_sent: Optional[str] = None,
        since_campaign_last_sent: Optional[str] = None,
        email: Optional[str] = None,
        sort_field: Optional[str] = None,
        has_ecommerce_store: Optional[bool] = None,
        include_total_contacts: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'sort_dir': sort_dir,
            'before_date_created': before_date_created,
            'since_date_created': since_date_created,
            'before_campaign_last_sent': before_campaign_last_sent,
            'since_campaign_last_sent': since_campaign_last_sent,
            'email': email,
            'sort_field': sort_field,
            'has_ecommerce_store': has_ecommerce_store,
            'include_total_contacts': include_total_contacts,
        }
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Search Lists in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Modify the script to send a custom text message to the specified chat_id instead of exporting a chat invite link.
  id: |-
    hubedit_hub_237
  lang: |-
    python
  modified_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message: str):
        client = TeleBot(auth['token'])
        client.send_message(chat_id, message)
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str):
        client = TeleBot(auth['token'])
        return client.export_chat_invite_link(chat_id)
  original_instructions: |-
    Create Chat Invite Link in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to perform an update operation on a record instead of a delete operation by sending a PATCH request with the updated field values in the request body.
  id: |-
    hubedit_hub_1023
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import requests

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, recordId: str, fields: dict):
        api_key = at_con['apiKey']
        base_id = at_table['baseId']
        table_name = at_table['tableName']
        endpoint = f"https://api.airtable.com/v0/{base_id}/{table_name}/{recordId}"

        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

        data = {
            "fields": fields
        }

        response = requests.patch(endpoint, headers=headers, json=data)
        return response.json()
  original_code: |-
    from typing import TypedDict
    import requests

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, recordId: str):
        api_key = at_con['apiKey']
        base_id = at_table['baseId']
        table_name = at_table['tableName']
        endpoint = f"https://api.airtable.com/v0/{base_id}/{table_name}/{recordId}"

        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

        response = requests.delete(endpoint, headers=headers)
        return response.json()
  original_instructions: |-
    Delete Record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add a feature to update an existing index by sending a PUT request to the appropriate endpoint with the modified index parameters.
  id: |-
    hubedit_hub_343
  lang: |-
    python
  modified_code: |-
    def update_index(
        auth: pinecone,
        index_name: str,
        dimension: Optional[int] = None,
        metric: Optional[str] = None,
        pods: Optional[int] = None,
        replicas: Optional[int] = None,
        pod_type: Optional[str] = None,
        pod_size: Optional[str] = None,
        metadata_config: Optional[Dict[str, str]] = None,
        source_collection: Optional[int] = None,
    ):
        headers = {
            'Api-Key': auth['apiKey'],
            'Content-Type': 'application/json'
        }
        base_url = f"https://{auth['environment']}.pinecone.io"

        pod_type_size = f"{pod_type}.{pod_size or 'x1'}" if pod_type else None
        update_request = remove_object_empty_fields({
            'dimension': dimension,
            'metric': metric,
            'pods': pods,
            'replicas': replicas,
            'pod_type': pod_type_size,
            'metadata_config': metadata_config,
            'source_collection': source_collection,
        })

        response = requests.put(
            f"{base_url}/indexes/{index_name}",
            headers=headers,
            json=update_request
        )

        return response.json()
  original_code: |-
    from typing import TypedDict, Optional, Dict
    import requests

    class pinecone(TypedDict):
        apiKey: str
        environment: str

    def remove_object_empty_fields(d: Dict) -> Dict:
        return {k: v for k, v in d.items() if v is not None and v != ""}

    def main(
        auth: pinecone,
        name: str,
        dimension: int,
        metric: Optional[str] = None,
        pods: Optional[int] = None,
        replicas: Optional[int] = None,
        pod_type: Optional[str] = None,
        pod_size: Optional[str] = None,
        metadata_config: Optional[Dict[str, str]] = None,
        source_collection: Optional[int] = None,
    ):
        headers = {
            'Api-Key': auth['apiKey'],
            'Content-Type': 'application/json'
        }
        base_url = f"https://{auth['environment']}.pinecone.io"

        pod_type_size = f"{pod_type}.{pod_size or 'x1'}" if pod_type else None
        create_request = remove_object_empty_fields({
            'name': name,
            'dimension': dimension,
            'metric': metric,
            'pods': pods,
            'replicas': replicas,
            'pod_type': pod_type_size,
            'metadata_config': metadata_config,
            'source_collection': source_collection,
        })

        response = requests.post(
            f"{base_url}/indexes",
            headers=headers,
            json=create_request
        )

        return response.json()
  original_instructions: |-
    Create Index in pinecone
  resource_type: |-
    pinecone
  resource_type_def: |-
    class pinecone(TypedDict):
        apiKey: str
        environment: str
- edit_instructions: |2

    Add functionality to send an email notification to the customer with the details of the created invoice item after it is successfully created.
  id: |-
    hubedit_hub_121
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart

    class stripe(TypedDict):
        token: str

    def send_email(customer_email: str, invoice_item_details: str):
        # Configure your email server and sender details
        smtp_server = 'smtp.example.com'
        smtp_port = 587
        sender_email = 'your-email@example.com'
        sender_password = 'your-email-password'

        # Create the email message
        message = MIMEMultipart()
        message['From'] = sender_email
        message['To'] = customer_email
        message['Subject'] = 'Invoice Item Created'

        # Email body
        body = f'An invoice item has been created with the following details:\n\n{invoice_item_details}'
        message.attach(MIMEText(body, 'plain'))

        # Connect to the email server and send the email
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, customer_email, message.as_string())
        server.quit()

    def main(stripe_con: stripe, customer_id: str, price_id: str, customer_email: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        # Assuming the invoice item has a string representation with all details
        invoice_item_details = str(invoice_item)

        # Send an email notification to the customer
        send_email(customer_email, invoice_item_details)

        return invoice_item
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        return invoice_item
  original_instructions: |-
    Create Invoice in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter the returned calendar list by a specific calendar title, requiring an additional parameter for the calendar title to filter by.
  id: |-
    hubedit_hub_40
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Optional

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendar_title_filter: str) -> Optional[dict]:
        CALENDAR_LIST_URL = "https://www.googleapis.com/calendar/v3/users/me/calendarList"

        token = gcal_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = requests.get(CALENDAR_LIST_URL, headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP errors

        calendars = response.json().get('items', [])
        filtered_calendars = [calendar for calendar in calendars if calendar.get('summary') == calendar_title_filter]

        return filtered_calendars[0] if filtered_calendars else None
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal):
        CALENDAR_LIST_URL = "https://www.googleapis.com/calendar/v3/users/me/calendarList"

        token = gcal_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = requests.get(CALENDAR_LIST_URL, headers=headers)

        result = response.json()

        return result
  original_instructions: |-
    Get Calendar List in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter the watched changes by file type, allowing the user to specify which types of files (e.g., documents, spreadsheets, images) should trigger notifications.
  id: |-
    hubedit_hub_39
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Any, List

    class gdrive(TypedDict):
        token: str

    def main(
        gdrive_auth: gdrive,
        drive_id: str,
        webhook_address: str,
        channelId: Any,
        file_types: List[str],  # Added parameter to specify file types
    ):
        SUPPORT_ALL_DRIVES = True
        SUPPORT_TEAM_DRIVES = True
        INCLUDE_ITEMS_FROM_ALL_DRIVES = True
        MIME_TYPES = ','.join([f"'{file_type}'" for file_type in file_types])  # MIME types filter
        START_PAGE_URL = f"https://www.googleapis.com/drive/v3/changes/startPageToken/?driveId={drive_id}&supportsAllDrives={SUPPORT_ALL_DRIVES}"

        token = gdrive_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response_sp = requests.get(START_PAGE_URL, headers=headers)
        start_page_result = response_sp.json()
        START_PAGE_TOKEN = start_page_result["startPageToken"]

        WATCH_URL = f"https://www.googleapis.com/drive/v3/changes/watch/?pageToken={START_PAGE_TOKEN}&supportsAllDrives={SUPPORT_ALL_DRIVES}&supportsTeamDrives={SUPPORT_TEAM_DRIVES}&includeItemsFromAllDrives={INCLUDE_ITEMS_FROM_ALL_DRIVES}"

        requestBody = {
            "kind": "api#channel",
            "type": "webhook",
            "address": webhook_address,
            "id": channelId,
            "payload": True,  # To receive notifications with the change details
        }

        # Add the mimeType filter to the requestBody if file_types are specified
        if MIME_TYPES:
            requestBody['mimeType'] = MIME_TYPES

        response = requests.post(WATCH_URL, json=requestBody, headers=headers)
        message = response.json()

        return message
  original_code: |-
    import requests
    from typing import TypedDict, Any

    class gdrive(TypedDict):
        token: str

    def main(
        gdrive_auth: gdrive,
        drive_id: str,
        webhook_address: str,
        channelId: Any,
    ):
        SUPPORT_ALL_DRIVES = True
        SUPPORT_TEAM_DRIVES = True
        INCLUDE_ITEMS_FROM_ALL_DRIVES = True
        START_PAGE_URL = f"https://www.googleapis.com/drive/v3/changes/startPageToken/?driveId={drive_id}&supportsAllDrives={SUPPORT_ALL_DRIVES}"

        token = gdrive_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response_sp = requests.get(START_PAGE_URL, headers=headers)
        start_page_result = response_sp.json()
        START_PAGE_TOKEN = start_page_result["startPageToken"]

        WATCH_URL = f"https://www.googleapis.com/drive/v3/changes/watch/?pageToken={START_PAGE_TOKEN}&supportsAllDrives={SUPPORT_ALL_DRIVES}&supportsTeamDrives={SUPPORT_TEAM_DRIVES}&includeItemsFromAllDrives={INCLUDE_ITEMS_FROM_ALL_DRIVES}"

        requestBody = {
            "kind": "api#channel",
            "type": "webhook",
            "address": webhook_address,
            "id": channelId,
        }

        response = requests.post(WATCH_URL, json=requestBody, headers=headers)
        message = response.json()

        return message
  original_instructions: |-
    Subscribe to Watch Changes in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter the changes by a specific file type, such as only retrieving changes related to documents with a '.txt' extension.
  id: |-
    hubedit_hub_38
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Dict

    class gdrive(TypedDict):
        token: str

    def get_internal_state():
        # Placeholder for getting internal state, replace with actual implementation
        return None

    def set_internal_state(new_start_page_token):
        # Placeholder for setting internal state, replace with actual implementation
        pass

    def filter_changes_by_file_type(changes: List[Dict], file_extension: str) -> List[Dict]:
        filtered_changes = []
        for change in changes:
            if 'file' in change and change['file'].get('mimeType') == f'application/{file_extension}':
                filtered_changes.append(change)
        return filtered_changes

    def main(gdrive_auth: gdrive, file_extension: str = 'vnd.google-apps.document'):
        START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken"

        last_start_page_token = get_internal_state()

        token = gdrive_auth["token"]

        if last_start_page_token is None:
            response_sp = requests.get(START_PAGE_URL, headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            })
            start_page_result = response_sp.json()

            last_start_page_token = start_page_result["startPageToken"]

        CHECK_CHANGES_URL = f"https://www.googleapis.com/drive/v3/changes?pageToken={last_start_page_token}"

        changes_response = requests.get(CHECK_CHANGES_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        result_changes = changes_response.json()

        set_internal_state(result_changes["newStartPageToken"])

        filtered_changes = filter_changes_by_file_type(result_changes["changes"], file_extension)

        return filtered_changes
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def get_internal_state():
        # Placeholder for getting internal state, replace with actual implementation
        return None

    def set_internal_state(new_start_page_token):
        # Placeholder for setting internal state, replace with actual implementation
        pass

    def main(gdrive_auth: gdrive):
        START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken/"

        last_start_page_token = get_internal_state()

        token = gdrive_auth["token"]

        if last_start_page_token is None:
            START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken"

            response_sp = requests.get(START_PAGE_URL, headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            })
            start_page_result = response_sp.json()

            last_start_page_token = start_page_result["startPageToken"]

        CHECK_CHANGES_URL = f"https://www.googleapis.com/drive/v3/changes/?pageToken={last_start_page_token}"

        changes_response = requests.get(CHECK_CHANGES_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        result_changes = changes_response.json()

        set_internal_state(result_changes["newStartPageToken"])

        return result_changes["changes"]
  original_instructions: |-
    Get Changes in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to include a JSON payload in the POST request that specifies the properties of the new spreadsheet, such as its title.
  id: |-
    hubedit_hub_36
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets):
        CREATE_URL = "https://sheets.googleapis.com/v4/spreadsheets"

        token = gsheets_auth["token"]

        # Define the JSON payload with the properties of the new spreadsheet
        json_payload = {
            "properties": {
                "title": "New Spreadsheet Title"
            }
        }

        response = requests.post(
            CREATE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
            json=json_payload  # Include the JSON payload in the POST request
        )

        result = response.json()

        return {"result": result}
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets):
        CREATE_URL = "https://sheets.googleapis.com/v4/spreadsheets"

        token = gsheets_auth["token"]

        response = requests.post(
            CREATE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return {"result": result}
  original_instructions: |-
    Create Spreadsheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to send a message to the specified channel after joining it, using the `chat_postMessage` method of the `WebClient`.
  id: |-
    hubedit_hub_20
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, message: str):
        web = WebClient(token=slack_auth['token'])

        # Join the channel
        web.conversations_join(channel=channel)

        # Send a message to the channel
        response = web.chat_postMessage(
            channel=channel,
            text=message
        )

        return {'response': response}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_join(
            channel=channel
        )

        return {'response': response}
  original_instructions: |-
    Join Channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the Stripe API, such as checking the status code of the response and raising an exception if the capture fails.
  id: |-
    hubedit_hub_118
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: str):
        STRIPE_CAPTURE_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/capture'

        token = stripe_con["token"]

        try:
            response = requests.post(
                STRIPE_CAPTURE_PAYMENT_URL,
                headers={
                    "Authorization": "Bearer " + token,
                    "Content-Type": "application/json",
                },
            )
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

            # Assuming a successful response includes a JSON body with a "status" key that could be "succeeded"
            json_response = response.json()
            if json_response.get('status') != 'succeeded':
                raise Exception(f"Payment capture failed with status: {json_response.get('status')}")

            return json_response

        except requests.exceptions.HTTPError as http_err:
            # Specific handling for HTTP errors (e.g., connection errors, timeout, etc.)
            raise Exception(f"HTTP error occurred: {http_err}") from http_err
        except requests.exceptions.RequestException as err:
            # Handle any request-related exceptions that are not covered by HTTPError
            raise Exception(f"Error occurred during request: {err}") from err
        except Exception as e:
            # Handle other exceptions such as a KeyError if 'status' is not in the response
            raise Exception(f"An error occurred: {e}") from e
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: str):
        STRIPE_CAPTURE_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/capture'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_CAPTURE_PAYMENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Capture a Payment Intent in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to also create a charge for the customer using the Stripe API after modifying the customer's metadata.
  id: |-
    hubedit_hub_131
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, order_id: str, amount: int, currency: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        # Modify the customer's metadata
        customer = stripe_module.Customer.modify(customer_id, metadata={'order_id': order_id})

        # Create a charge for the customer
        charge = stripe_module.Charge.create(
            customer=customer_id,
            amount=amount,
            currency=currency,
            description=f"Charge for order {order_id}"
        )

        return charge
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, order_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        customer = stripe_module.Customer.modify(customer_id, metadata={'order_id': order_id})

        return customer
  original_instructions: |-
    Update a Customer in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to check if the user is already in the room before attempting to invite them, and if they are, print a message indicating that the user is already a member of the room.
  id: |-
    hubedit_hub_104
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def is_user_in_room(matrix_res: matrix, room_id: str, user_id: str) -> bool:
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/joined_members"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
        }

        resp = requests.get(url, headers=headers)
        if resp.ok:
            members = resp.json().get('joined', {})
            return user_id in members
        else:
            raise ValueError(f"Failed to check members: Error HTTP{resp.status_code}")

    def main(matrix_res: matrix, room_id: str, user_id: str, reason: str = ""):
        if not matrix_res['token']:
            raise ValueError("Inviting a user requires an access token.")

        if is_user_in_room(matrix_res, room_id, user_id):
            print(f"User {user_id} is already a member of the room.")
            return

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/invite"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        payload = {
            "user_id": user_id,
            **({"reason": reason} if reason else {}),
        }

        resp = requests.post(url, headers=headers, json=payload)

        if not resp.ok:
            raise ValueError(f"Failed to invite: Error HTTP{resp.status_code}")
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, user_id: str, reason: str = ""):
        if not matrix_res['token']:
            raise ValueError("Inviting a user requires an access token.")

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/invite"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        payload = {
            "user_id": user_id,
            **({"reason": reason} if reason else {}),
        }

        resp = requests.post(url, headers=headers, json=payload)

        if not resp.ok:
            raise ValueError(f"Failed to invite: Error HTTP{resp.status_code}")
  original_instructions: |-
    Invite user to a room in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |-
    Add a feature to cache the response for a certain duration to avoid hitting the GitHub API rate limits for frequently requested resources.
  id: |-
    hubedit_hub_345
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import TypedDict, Optional
    from functools import lru_cache

    class github(TypedDict):
        token: str

    # Define a decorator to cache responses
    def cache_response(duration: int):
        def decorator(func):
            cached_responses = {}
            @lru_cache(maxsize=None)
            def wrapper(*args, **kwargs):
                nonlocal cached_responses
                cache_key = (args, frozenset(kwargs.items()))
                current_time = time.time()
                if cache_key in cached_responses:
                    cached_data, timestamp = cached_responses[cache_key]
                    if current_time - timestamp < duration:
                        return cached_data
                response = func(*args, **kwargs)
                cached_responses[cache_key] = (response, current_time)
                return response
            return wrapper
        return decorator

    @cache_response(duration=60)  # Cache duration set to 60 seconds
    def main(gh_auth: github, owner: str, repo: str, path: Optional[str] = None, ref: Optional[str] = None, result_format: str = "github_object"):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": f"application/vnd.github.{ 'vnd.github+json' if result_format == 'json' else 'vnd.github.object' }"
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path or ''}"
        if ref:
            url += f"?ref={ref}"

        response = requests.get(url, headers=headers)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str, path: Optional[str] = None, ref: Optional[str] = None, result_format: str = "github_object"):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": f"application/vnd.github.{ 'vnd.github+json' if result_format == 'json' else 'vnd.github.object' }"
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path or ''}"
        if ref:
            url += f"?ref={ref}"

        response = requests.get(url, headers=headers)
        return response.json()
  original_instructions: |-
    Get Repo Content in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to update an existing document in the collection based on a given query instead of inserting a new one.
  id: |-
    hubedit_hub_259
  lang: |-
    python
  modified_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, query: Dict[str, Any], update: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[data_source][database]
        documents = db[collection]
        return documents.update_one(query, update)
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[data_source][database]
        documents = db[collection]
        return documents.insert_one(document)
  original_instructions: |-
    Create New Document in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- edit_instructions: |2

    Add functionality to handle database connection errors and query execution errors by wrapping the connection and cursor execution in a try-except block, and log the errors to a file.
  id: |-
    hubedit_hub_82
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import psycopg2
    import logging

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    # Configure logging
    logging.basicConfig(filename='db_errors.log', level=logging.ERROR,
                        format='%(asctime)s:%(levelname)s:%(message)s')

    def main(db: postgresql, query: str = "SELECT * FROM demo;"):
        if not query:
            raise ValueError("Query must not be empty.")

        try:
            connection = psycopg2.connect(
                host=db['host'],
                port=db['port'],
                user=db['user'],
                dbname=db['dbname'],
                sslmode=db['sslmode'],
                password=db['password']
            )

            with connection.cursor() as cursor:
                cursor.execute(query)
                rows = cursor.fetchall()
            connection.close()
            return rows

        except psycopg2.OperationalError as e:
            logging.error(f"Database connection failed: {e}")
            raise e
        except psycopg2.Error as e:
            logging.error(f"Query execution failed: {e}")
            if connection:
                connection.close()
            raise e
  original_code: |-
    from typing import TypedDict
    import psycopg2

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    def main(db: postgresql, query: str = "SELECT * FROM demo;"):
        if not query:
            raise ValueError("Query must not be empty.")

        connection = psycopg2.connect(
            host=db['host'],
            port=db['port'],
            user=db['user'],
            dbname=db['dbname'],
            sslmode=db['sslmode'],
            password=db['password']
        )

        with connection.cursor() as cursor:
            cursor.execute(query)
            rows = cursor.fetchall()

        connection.close()
        return rows
  original_instructions: |-
    Execute Query and return results in postgresql
  resource_type: |-
    postgresql
  resource_type_def: |-
    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str
- edit_instructions: |2

    Add error handling to check if the request was successful before returning the JSON data, and if not, return an appropriate error message.
  id: |-
    hubedit_hub_169
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Any, Union

    class FlowData(TypedDict):
        flows: List[Any]

    class ErrorMessage(TypedDict):
        error: str

    def main() -> Union[FlowData, ErrorMessage]:
        url = "https://hub.windmill.dev/searchFlowData"
        try:
            response = requests.get(url)
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.RequestException as e:
            return {"error": str(e)}

        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class flowdata(TypedDict):
        flows: List[Any]

    def main() -> flowdata:
        url = "https://hub.windmill.dev/searchFlowData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List Flows in windmillhub
  resource_type: |-
    flowdata
  resource_type_def: |-
    class flowdata(TypedDict):
        flows: List[Any]
- edit_instructions: |2

    Add functionality to the script to log the response status code and message to a file for auditing purposes whenever the `main` function is called.
  id: |-
    hubedit_hub_63
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict
    import logging

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = True):
        UPDATE_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}"

        token = gdrive_auth["token"]

        body = {
            "name": "Update Drive Test",
            "restrictions": {
                "adminManagedRestrictions": False,
                "copyRequiresWriterPermission": False,
                "domainUsersOnly": False,
                "driveMembersOnly": False,
            },
            "colorRgb": "#ff0000",
        }
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }
        response = requests.patch(UPDATE_SHARED_DRIVE_URL, json=body, headers=headers)

        # Log the response status code and message
        log_response(response)

        return response.text

    def log_response(response):
        # Configure logging
        logging.basicConfig(filename='gdrive_audit.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

        # Log the status code and response message
        logging.info(f"Status Code: {response.status_code}, Response Message: {response.text}")
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = True):
        UPDATE_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}"

        token = gdrive_auth["token"]

        body = {
            "name": "Update Drive Test",
            "restrictions": {
                "adminManagedRestrictions": False,
                "copyRequiresWriterPermission": False,
                "domainUsersOnly": False,
                "driveMembersOnly": False,
            },
            "colorRgb": "#ff0000",
        }
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }
        response = requests.patch(UPDATE_SHARED_DRIVE_URL, json=body, headers=headers)

        return response.text
  original_instructions: |-
    Update Shared Drive in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to send an email notification to the customer after creating the invoice item, using a hypothetical email service.
  id: |-
    hubedit_hub_122
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def send_email_notification(customer_email: str):
        # Hypothetical email service code
        # This is a placeholder for actual email sending logic
        print(f"Sending email notification to {customer_email}...")

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        # Retrieve the customer's email address from the Stripe API
        customer = stripe_module.Customer.retrieve(customer_id)
        customer_email = customer.get('email')

        # Send an email notification to the customer
        if customer_email:
            send_email_notification(customer_email)

        return invoice_item
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        return invoice_item
  original_instructions: |-
    Create Invoice Line Item in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing list instead of always creating a new one by checking if the list already exists and performing an HTTP PUT request to update it.
  id: |-
    hubedit_hub_209
  lang: |-
    python
  modified_code: |-
    def get_list_id_by_name(auth: mailchimp, list_name: str) -> Optional[str]:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        headers = {
            "Authorization": f"Bearer {auth['api_key']}",
            "Content-Type": "application/json",
        }
        params = {
            "fields": "lists.name,lists.id",
            "count": 1000  # Adjust the count as needed
        }
        response = requests.get(url, headers=headers, params=params)
        if response.ok:
            lists = response.json().get('lists', [])
            for lst in lists:
                if lst['name'] == list_name:
                    return lst['id']
        return None

    def main(
        # ... [rest of the parameters] ...
    ):
        # ... [rest of the main function code] ...

        list_id = get_list_id_by_name(auth, name)
        if list_id:
            # Update existing list
            url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}"
            response = requests.put(url, headers=headers, data=json.dumps(cleaned_body))
        else:
            # Create new list
            response = requests.post(url, headers=headers, data=json.dumps(cleaned_body))

        # ... [rest of the main function code] ...
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def remove_object_empty_fields(d):
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: mailchimp,
        name: str,
        permission_reminder: str,
        campaign_from_name: str,
        campaign_from_email: str,
        campaign_subject: str,
        campaign_language: str,
        email_type_option: bool,
        contact_company: str,
        contact_country: str,
        contact_city: str,
        contact_address1: str,
        contact_address2: Optional[str] = None,
        contact_state: Optional[str] = None,
        contact_zip: Optional[str] = None,
        contact_phone: Optional[str] = None,
        notify_on_subscribe: Optional[str] = None,
        notify_on_unsubscribe: Optional[str] = None,
        use_archive_bar: Optional[bool] = None,
        double_optin: Optional[bool] = None,
        marketing_permissions: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        body = {
            "name": name,
            "contact": {
                "company": contact_company,
                "country": contact_country,
                "city": contact_city,
                "address1": contact_address1,
                "address2": contact_address2,
                "state": contact_state,
                "zip": contact_zip,
                "phone": contact_phone,
            },
            "permission_reminder": permission_reminder,
            "campaign_defaults": {
                "from_name": campaign_from_name,
                "from_email": campaign_from_email,
                "subject": campaign_subject,
                "language": campaign_language,
            },
            "email_type_option": email_type_option,
            "use_archive_bar": use_archive_bar,
            "notify_on_subscribe": notify_on_subscribe,
            "notify_on_unsubscribe": notify_on_unsubscribe,
            "double_optin": double_optin,
            "marketing_permissions": marketing_permissions,
        }

        cleaned_body = remove_object_empty_fields(body)
        headers = {
            "Authorization": f"Bearer {auth['api_key']}",
            "Content-Type": "application/json",
        }

        response = requests.post(url, headers=headers, data=json.dumps(cleaned_body))

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Create List in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |2

    Add functionality to create a new event in the specified calendar by sending a POST request with the event details in the request body.
  id: |-
    hubedit_hub_41
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Dict

    class gcal(TypedDict):
        token: str

    def create_event(gcal_auth: gcal, calendarId: str, event_details: Dict):
        CALENDAR_EVENTS_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events'

        token = gcal_auth["token"]

        response = requests.post(
            CALENDAR_EVENTS_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
            json=event_details,
        )

        result = response.json()

        return result
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str):
        CALENDAR_LIST_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}'

        token = gcal_auth["token"]

        response = requests.get(
            CALENDAR_LIST_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return result
  original_instructions: |-
    Get Calendar Metadata in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- edit_instructions: |2

    Add a new function that parses the JSON response from the capabilities endpoint and extracts a specific capability, such as 'files_sharing', to check if it is enabled or not.
  id: |-
    hubedit_hub_162
  lang: |-
    python
  modified_code: |-
    import json

    def check_capability_enabled(response_text: str, capability_key: str) -> bool:
        data = json.loads(response_text)
        capabilities = data.get('ocs', {}).get('data', {}).get('capabilities', {})
        capability = capabilities.get(capability_key, {})
        return capability.get('enabled', False)
  original_code: |-
    import requests
    from typing import TypedDict

    class ocs(TypedDict):
        pass

    def main(base_url: str) -> str:
        resp = requests.get(f"{base_url}/ocs/v1.php/cloud/capabilities", headers={"OCS-APIRequest": "true"})
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_instructions: |-
    Get API capabilities in ocs
  resource_type: |-
    ocs
  resource_type_def: |-
    class ocs(TypedDict):
        pass
- edit_instructions: |2

    Modify the script to create a new index instead of deleting an existing one, using the same `index_name` and `namespace` parameters.
  id: |-
    hubedit_hub_346
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from pinecone import PineconeClient

    class pinecone(TypedDict):
        apiKey: str
        environment: str

    def main(auth: pinecone, index_name: str, namespace: Optional[str] = None):
        client = PineconeClient(api_key=auth['apiKey'], environment=auth['environment'])
        index = client.create_index(name=index_name, dimension=128, namespace=namespace)  # Assuming a dimension of 128 for the vector space

        return index
  original_code: |-
    from typing import TypedDict, Optional
    from pinecone import PineconeClient

    class pinecone(TypedDict):
        apiKey: str
        environment: str

    def main(auth: pinecone, index_name: str, namespace: Optional[str] = None):
        client = PineconeClient(api_key=auth['apiKey'], environment=auth['environment'])
        index = client.index(index_name)

        return index.delete(delete_all=True, namespace=namespace)
  original_instructions: |-
    Delete All Vectors in pinecone
  resource_type: |-
    pinecone
  resource_type_def: |-
    class pinecone(TypedDict):
        apiKey: str
        environment: str
- edit_instructions: |2

    Add error handling to check the response status code and raise an exception with a custom message if the request fails.
  id: |-
    hubedit_hub_50
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, sheet_id: str, spreadsheet_id_1: str, spreadsheet_id_2: str):
        token = gsheets_auth["token"]

        COPY_TO_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id_1}/sheets/{sheet_id}:copyTo"

        req = {
            "destinationSpreadsheetId": spreadsheet_id_2,
        }

        response = requests.post(
            COPY_TO_URL,
            json=req,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        if response.status_code != 200:
            raise Exception(f"Request failed with status code {response.status_code}: {response.text}")

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, sheet_id: str, spreadsheet_id_1: str, spreadsheet_id_2: str):
        token = gsheets_auth["token"]

        COPY_TO_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id_1}/sheets/{sheet_id}:copyTo"

        req = {
            "destinationSpreadsheetId": spreadsheet_id_2,
        }

        response = requests.post(
            COPY_TO_URL,
            json=req,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Copy Worksheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to paginate through the results by accepting a 'count' parameter for the number of records to return per page and an 'offset' parameter to specify the starting point for the return data.
  id: |-
    hubedit_hub_208
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class MailchimpAuth(TypedDict):
        api_key: str
        server: str

    def main(
        auth: MailchimpAuth,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_total_contacts: Optional[bool] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_total_contacts': str(include_total_contacts).lower() if include_total_contacts is not None else None,
            'count': count,
            'offset': offset,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}
        response = requests.get(url, headers={'Authorization': f'Bearer {auth["api_key"]}'}, params=params)

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_total_contacts: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_total_contacts': str(include_total_contacts).lower() if include_total_contacts is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}
        response = requests.get(url, headers={'Authorization': f'Bearer {auth["api_key"]}'}, params=params)

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Get List in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- edit_instructions: |-
    Add functionality to parse and include optional parameters such as 'parse_mode' for formatting the message text, 'disable_web_page_preview' to disable link previews, and 'disable_notification' to send the message silently without a notification.
  id: |-
    hubedit_hub_234
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Union, Optional
    import requests

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], text: str, reply_to_message_id: int = None,
             parse_mode: Optional[str] = None, disable_web_page_preview: Optional[bool] = None,
             disable_notification: Optional[bool] = None):
        token = auth['token']
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        payload = {
            'chat_id': chat_id,
            'text': text,
            'reply_to_message_id': reply_to_message_id,
            'parse_mode': parse_mode,
            'disable_web_page_preview': disable_web_page_preview,
            'disable_notification': disable_notification
        }
        # Remove None values from the payload
        payload = {k: v for k, v in payload.items() if v is not None}
        response = requests.post(url, data=payload)
        return response.json()
  original_code: |-
    from typing import TypedDict, Union
    import requests

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], text: str, reply_to_message_id: int = None):
        token = auth['token']
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        payload = {
            'chat_id': chat_id,
            'text': text,
            'reply_to_message_id': reply_to_message_id
        }
        response = requests.post(url, data=payload)
        return response.json()
  original_instructions: |-
    Send a Text Message or Reply in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the Stripe API, such as checking the status code of the response and raising an exception if the request was unsuccessful.
  id: |-
    hubedit_hub_116
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, payout_id: str):
        STRIPE_REVERSE_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{payout_id}/reverse'

        token = stripe_con["token"]

        try:
            response = requests.post(
                STRIPE_REVERSE_PAYOUT_URL,
                headers={
                    "Authorization": "Bearer " + token,
                    "Content-Type": "application/json",
                },
            )
            response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
        except requests.exceptions.HTTPError as http_err:
            # Handle specific HTTP errors (e.g., 400 Bad Request, 401 Unauthorized, etc.)
            print(f"HTTP error occurred: {http_err}")
            raise
        except requests.exceptions.RequestException as err:
            # Handle other possible errors (e.g., network issues)
            print(f"An error occurred: {err}")
            raise
        else:
            # If no exceptions were raised, return the JSON response
            return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, payout_id: str):
        STRIPE_REVERSE_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{payout_id}/reverse'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_REVERSE_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Cancel Or Reverse a Payout in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage exceptions that may occur when connecting to the database or executing the query, and log the errors to a file.
  id: |-
    hubedit_hub_28
  lang: |-
    python
  modified_code: |-
    import mysql.connector
    from typing import TypedDict
    import logging

    class mysql(TypedDict):
        host: str
        port: int
        user: str
        database: str
        password: str
        ssl: bool

    # Configure logging
    logging.basicConfig(filename='mysql_errors.log', level=logging.ERROR,
                        format='%(asctime)s:%(levelname)s:%(message)s')

    def main(mysql_conn: mysql, query: str):
        try:
            mysql_conn['db'] = mysql_conn['database']
            mysql_conn['hostname'] = mysql_conn['host']
            mysql_conn['username'] = mysql_conn['user']

            connection = mysql.connector.connect(
                host=mysql_conn['hostname'],
                user=mysql_conn['username'],
                password=mysql_conn['password'],
                database=mysql_conn['db'],
                port=mysql_conn['port'],
                ssl_disabled=not mysql_conn['ssl']
            )

            cursor = connection.cursor()
            try:
                cursor.execute(query)
                result = cursor.fetchall()
            except mysql.connector.Error as err:
                logging.error(f"Error executing query: {err}")
                result = []
            finally:
                cursor.close()
                connection.close()

        except mysql.connector.Error as err:
            logging.error(f"Error connecting to MySQL: {err}")
            result = []

        return result
  original_code: |-
    import mysql.connector
    from typing import TypedDict

    class mysql(TypedDict):
        host: str
        port: int
        user: str
        database: str
        password: str
        ssl: bool

    def main(mysql_conn: mysql, query: str):
        mysql_conn['db'] = mysql_conn['database']
        mysql_conn['hostname'] = mysql_conn['host']
        mysql_conn['username'] = mysql_conn['user']

        connection = mysql.connector.connect(
            host=mysql_conn['hostname'],
            user=mysql_conn['username'],
            password=mysql_conn['password'],
            database=mysql_conn['db'],
            port=mysql_conn['port'],
            ssl_disabled=not mysql_conn['ssl']
        )

        cursor = connection.cursor()
        cursor.execute(query)
        result = cursor.fetchall()
        cursor.close()
        connection.close()
        return result
  original_instructions: |-
    Execute Query in mysql
  resource_type: |-
    mysql
  resource_type_def: |-
    class mysql(TypedDict):
        host: str
        port: int
        user: str
        database: str
        password: str
        ssl: bool
- edit_instructions: |2

    Add functionality to send a welcome message to the user found by their email address using the Slack API.
  id: |-
    hubedit_hub_21
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class SlackConfig(TypedDict):
        token: str
        welcome_message: str

    def main(email: str, slack_config: SlackConfig):
        web = WebClient(token=slack_config['token'])

        try:
            # Look up the user by email
            lookup_response = web.users_lookupByEmail(email=email)
            user_id = lookup_response['user']['id']

            # Send a welcome message to the user
            message_response = web.chat_postMessage(
                channel=user_id,
                text=slack_config['welcome_message']
            )

            return {'response': message_response}
        except SlackApiError as e:
            # You can add more error handling here depending on the requirements
            return {'error': str(e)}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(email: str, slack: slack):
        web = WebClient(token=slack['token'])

        response = web.users_lookupByEmail(email=email)

        return {'response': response}
  original_instructions: |-
    Find User by Email in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to attach files to the email by modifying the 'Message' parameter to include an 'Attachments' key within the 'Body' dictionary.
  id: |-
    hubedit_hub_371
  lang: |-
    python
  modified_code: |-
    import base64

    # ... (rest of the imports and aws class definition)

    def main(
        to_addresses: List[str],
        html_data: str,
        text_data: str,
        subject: str,
        source: str,
        credentials: aws,
        attachments: List[dict] = None,  # Add an optional parameter for attachments
    ):
        # ... (rest of the existing code)

        # Modify the 'Message' parameter to include an 'Attachments' key
        if attachments:
            params['Message']['Body']['Attachments'] = []
            for attachment in attachments:
                with open(attachment['path'], 'rb') as f:
                    attachment_data = f.read()
                params['Message']['Body']['Attachments'].append({
                    'Filename': attachment['filename'],
                    'Data': base64.b64encode(attachment_data).decode('utf-8'),
                    'ContentType': attachment['content_type'],
                })

        # ... (rest of the existing code to create SES client and send email)
  original_code: |-
    import boto3
    from botocore.exceptions import ClientError
    from typing import TypedDict, List

    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str

    def main(
        to_addresses: List[str],
        html_data: str,
        text_data: str,
        subject: str,
        source: str,
        credentials: aws,
    ):
        params = {
            'Destination': {
                'ToAddresses': to_addresses,
            },
            'Message': {
                'Body': {
                    'Html': {
                        'Charset': "UTF-8",
                        'Data': html_data,
                    },
                    'Text': {
                        'Charset': "UTF-8",
                        'Data': text_data,
                    },
                },
                'Subject': {
                    'Charset': "UTF-8",
                    'Data': subject,
                },
            },
            'Source': source,
        }

        ses_client = boto3.client(
            'ses',
            aws_access_key_id=credentials['aws_access_key_id'],
            aws_secret_access_key=credentials['aws_secret_access_key'],
            region_name=credentials['region_name'],
        )

        try:
            response = ses_client.send_email(**params)
            return response
        except ClientError as e:
            return e.response['Error']
  original_instructions: |-
    send an email with aws ses  in aws-ses
  resource_type: |-
    aws
  resource_type_def: |-
    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str
- edit_instructions: |2

    Add functionality to attach an image to the LinkedIn post by modifying the `specificContent` dictionary to include the necessary fields for media upload and update the `shareMediaCategory` to "IMAGE".
  id: |-
    hubedit_hub_243
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Literal

    class linkedin(TypedDict):
        token: str

    def main(auth: linkedin, content: str, visibility: Literal["PUBLIC", "CONNECTIONS"] = "PUBLIC", image_url: str = None):
        entityResponse = requests.get("https://api.linkedin.com/v2/me", headers={"Authorization": "Bearer " + auth['token']})
        entityId = entityResponse.json()['id']

        url = "https://api.linkedin.com/v2/ugcPosts"
        specificContent = {
            "com.linkedin.ugc.ShareContent": {
                "shareCommentary": {
                    "text": content,
                },
                "shareMediaCategory": "NONE",
            },
        }

        if image_url:
            specificContent["com.linkedin.ugc.ShareContent"]["shareMediaCategory"] = "IMAGE"
            specificContent["com.linkedin.ugc.ShareContent"]["media"] = [
                {
                    "status": "READY",
                    "description": {
                        "text": content,
                    },
                    "media": image_url,
                    "title": {
                        "text": content,
                    },
                }
            ]

        body = {
            "author": f"urn:li:person:{entityId}",
            "lifecycleState": "PUBLISHED",
            "specificContent": specificContent,
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": visibility,
            },
        }
        response = requests.post(url, json=body, headers={
            "Authorization": "Bearer " + auth['token'],
            "X-Restli-Protocol-Version": "2.0.0",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Literal

    class linkedin(TypedDict):
        token: str

    def main(auth: linkedin, content: str, visibility: Literal["PUBLIC", "CONNECTIONS"] = "PUBLIC"):
        entityResponse = requests.get("https://api.linkedin.com/v2/me", headers={"Authorization": "Bearer " + auth['token']})
        entityId = entityResponse.json()['id']

        url = "https://api.linkedin.com/v2/ugcPosts"
        body = {
            "author": f"urn:li:person:{entityId}",
            "lifecycleState": "PUBLISHED",
            "specificContent": {
                "com.linkedin.ugc.ShareContent": {
                    "shareCommentary": {
                        "text": content,
                    },
                    "shareMediaCategory": "NONE",
                },
            },
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": visibility,
            },
        }
        response = requests.post(url, json=body, headers={
            "Authorization": "Bearer " + auth['token'],
            "X-Restli-Protocol-Version": "2.0.0",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Create a Simple Post (User) in linkedin
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to specify the body of the document by accepting an additional parameter and including it in the request body sent to the Google Docs API.
  id: |-
    hubedit_hub_54
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, title: str, content: str) -> str:
        token = gdocs_auth["token"]

        body = {
            "title": title,
            "body": {
                "content": [
                    {
                        "paragraph": {
                            "elements": [
                                {
                                    "textRun": {
                                        "content": content
                                    }
                                }
                            ]
                        }
                    }
                ]
            }
        }
        CREATE_DOC_URL = "https://docs.googleapis.com/v1/documents"

        response = requests.post(
            CREATE_DOC_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, title: str) -> str:
        token = gdocs_auth["token"]

        body = {
            "title": title,
        }
        CREATE_DOC_URL = "https://docs.googleapis.com/v1/documents"

        response = requests.post(
            CREATE_DOC_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Create a New Document in gdocs
  resource_type: |-
    gdocs
  resource_type_def: |-
    class gdocs(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to attach a screenshot or log file to the message when an error occurs, by using the `files_upload` method of the `WebClient`.
  id: |-
    hubedit_hub_293
  lang: |-
    python
  modified_code: |-
    import os
    from slack_sdk import WebClient
    from typing import TypedDict, Optional

    class slack(TypedDict):
        token: str

    def main(message: str, name: str, channel: str, slack_config: slack, file_path: Optional[str] = None):
        web = WebClient(token=slack_config['token'])
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        base_url = os.getenv("WM_BASE_URL")
        workspace = os.getenv("WM_WORKSPACE")
        text = f"Flow [{flow_id}]({base_url}/run/{flow_id}?workspace={workspace}) had an error:\n{name}: {message}"

        # Post the initial message
        response = web.chat_postMessage(channel=channel, text=text)
        ts = response['ts']  # Timestamp of the message to attach the file to

        # If a file path is provided, upload the file and attach it to the message
        if file_path:
            try:
                with open(file_path, 'rb') as file_content:
                    web.files_upload(
                        channels=channel,
                        file=file_content,
                        filename=os.path.basename(file_path),
                        initial_comment=f"Attached file for error in flow {flow_id}",
                        thread_ts=ts  # Attach the file to the same thread as the message
                    )
            except Exception as e:
                print(f"Failed to upload file: {e}")

        return {"message": message, "flow_id": flow_id}
  original_code: |-
    import os
    from slack_sdk import WebClient
    from typing import TypedDict

    class slack(TypedDict):
        token: str

    def main(message: str, name: str, channel: str, slack_config: slack):
        web = WebClient(token=slack_config['token'])
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        base_url = os.getenv("WM_BASE_URL")
        workspace = os.getenv("WM_WORKSPACE")
        text = f"Flow [{flow_id}]({base_url}/run/{flow_id}?workspace={workspace}) had an error:\n{name}: {message}"
        web.chat_postMessage(channel=channel, text=text)
        return {"message": message, "flow_id": flow_id}
  original_instructions: |-
    Send error to slack channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update a deal by adding a new function that takes the deal_id and a dictionary of properties to update, then uses the HubSpot client to update the deal with the provided properties.
  id: |-
    hubedit_hub_230
  lang: |-
    python
  modified_code: |-
    def update_deal(
        auth: hubspot,
        deal_id: str,
        properties_to_update: dict,
    ):
        client = HubSpot(api_key=auth['token'])

        try:
            # Prepare the data for update
            simple_public_object_input = {
                "properties": properties_to_update
            }

            # Perform the update operation
            return client.crm.deals.basic_api.update(
                deal_id,
                simple_public_object_input
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")
  original_code: |-
    from typing import List, Optional, TypedDict
    from hubspot import HubSpot

    class hubspot(TypedDict):
        token: str

    def main(
        auth: hubspot,
        deal_id: str,
        properties: Optional[List[str]] = None,
        properties_with_history: Optional[List[str]] = None,
        associations: Optional[List[str]] = None,
        archived: Optional[bool] = None,
        id_property: Optional[str] = None,
    ):
        client = HubSpot(api_key=auth['token'])

        try:
            return client.crm.deals.basic_api.get_by_id(
                deal_id,
                get_prop(properties),
                get_prop(properties_with_history),
                get_prop(associations),
                archived,
                id_property,
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")

    def get_prop(prop: Optional[List[str]]):
        return prop if prop and isinstance(prop, list) and len(prop) > 0 else None
  original_instructions: |-
    Get Deal in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to allow changing the topic of the room by adding a new function that takes the room_id and the new topic as arguments, constructs the appropriate API endpoint, and sends a PUT request with the new topic data.
  id: |-
    hubedit_hub_286
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def set_room_name(matrix_res: matrix, room_id: str, name: str = ""):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.name/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        response = requests.put(url, headers=headers, json={"name": name})
        if not response.ok:
            raise Exception(f"Failed to set room name: Error HTTP{response.status_code}")
        return response.json()

    def set_room_topic(matrix_res: matrix, room_id: str, topic: str = ""):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.topic/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        response = requests.put(url, headers=headers, json={"topic": topic})
        if not response.ok:
            raise Exception(f"Failed to set room topic: Error HTTP{response.status_code}")
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, name: str = ""):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.name/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        response = requests.put(url, headers=headers, json={"name": name})
        if not response.ok:
            raise Exception(f"Failed to set room name: Error HTTP{response.status_code}")
        return response.json()
  original_instructions: |-
    Set room name in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add functionality to attach a PDF file to the email, by modifying the `get_email_body` function to encode the PDF file in base64 and include it in the MIME email body.
  id: |-
    hubedit_hub_178
  lang: |-
    python
  modified_code: |-
    import base64
    import json
    import os
    import requests
    from typing import List, TypedDict, Dict
    from email.mime.base import MIMEBase
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email import encoders

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, approver_emails: List[str], subject: str = "Resume Windmill flow", attachment_path: str = None):
        throw_on_invalid_approvers(approver_emails)

        token = gmail_auth["token"]
        results = []
        for to_email in approver_emails:
            results.append(send_email(token, to_email, subject, attachment_path))

        return results

    def send_email(gmail_token: str, to_email: str, subject: str, attachment_path: str = None) -> Dict:
        email = get_email_body(to_email, subject, attachment_path)
        SEND_EMAIL_URL = "https://gmail.googleapis.com/gmail/v1/users/me/messages/send"
        body = {
            'raw': email
        }
        response = requests.post(SEND_EMAIL_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {gmail_token}',
            'Content-Type': 'application/json'
        })
        response_json = response.json()

        return handle_send_email_result(response_json, to_email)

    def get_email_body(to_email: str, subject: str, attachment_path: str = None) -> str:
        approval_page = get_resume_urls(to_email)
        message = f"There is a Windmill flow at {os.getenv('WM_FLOW_PATH')} run by {os.getenv('WM_USERNAME')} waiting for your approval to resume.\n\nIn order to resume or cancel the flow go to {approval_page}"

        # Create a multipart message
        msg = MIMEMultipart()
        msg['From'] = 'me'
        msg['To'] = to_email
        msg['Subject'] = subject

        # Attach the body text
        msg.attach(MIMEText(message, 'plain'))

        # Attach the PDF file
        if attachment_path:
            with open(attachment_path, 'rb') as attachment:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(attachment.read())
                encoders.encode_base64(part)
                part.add_header(
                    'Content-Disposition',
                    f'attachment; filename="{os.path.basename(attachment_path)}"',
                )
                msg.attach(part)

        # Encode the entire message in base64
        return base64.urlsafe_b64encode(msg.as_bytes()).decode()

    def throw_on_invalid_approvers(approvers: List[str]):
        if not isinstance(approvers, list) or len(approvers) == 0:
            raise ValueError("Expected at least one approver email")

    def handle_send_email_result(result: Dict, to_email: str) -> Dict:
        if "error" in result:
            result.update({"wm_to_email": to_email})
            raise ValueError(result)

        return result

    def get_resume_urls(to_email: str) -> str:
        # Placeholder for the actual implementation of get_resume_urls
        # In the original TypeScript code, this function is imported from an external module
        # Here, we'll just return a dummy URL for demonstration purposes
        return f"https://example.com/approval?email={to_email}"
  original_code: |-
    import base64
    import json
    import os
    import requests
    from typing import List, TypedDict, Dict

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, approver_emails: List[str], subject: str = "Resume Windmill flow"):
        throw_on_invalid_approvers(approver_emails)

        token = gmail_auth["token"]
        results = []
        for to_email in approver_emails:
            results.append(send_email(token, to_email, subject))

        return results

    def send_email(gmail_token: str, to_email: str, subject: str) -> Dict:
        email = get_email_body(to_email, subject)
        SEND_EMAIL_URL = "https://gmail.googleapis.com/gmail/v1/users/me/messages/send"
        body = {
            'raw': email
        }
        response = requests.post(SEND_EMAIL_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {gmail_token}',
            'Content-Type': 'application/json'
        })
        response_json = response.json()

        return handle_send_email_result(response_json, to_email)

    def get_email_body(to_email: str, subject: str) -> str:
        approval_page = get_resume_urls(to_email)
        message = f"There is a Windmill flow at {os.getenv('WM_FLOW_PATH')} run by {os.getenv('WM_USERNAME')} waiting for your approval to resume.\n\nIn order to resume or cancel the flow go to {approval_page}"
        email_body = f"From: <me>\nTo: <{to_email}>\nSubject: {subject}\n\n {message}"

        return base64.urlsafe_b64encode(email_body.encode()).decode()

    def throw_on_invalid_approvers(approvers: List[str]):
        if not isinstance(approvers, list) or len(approvers) == 0:
            raise ValueError("Expected at least one approver email")

    def handle_send_email_result(result: Dict, to_email: str) -> Dict:
        if "error" in result:
            result.update({"wm_to_email": to_email})
            raise ValueError(result)

        return result

    def get_resume_urls(to_email: str) -> str:
        # Placeholder for the actual implementation of get_resume_urls
        # In the original TypeScript code, this function is imported from an external module
        # Here, we'll just return a dummy URL for demonstration purposes
        return f"https://example.com/approval?email={to_email}"
  original_instructions: |-
    Suspend/resume a flow by sending approval URL via email in gmail
  resource_type: |-
    gmail
  resource_type_def: |-
    class gmail(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to filter the customers by those with an active subscription and return only their email addresses and subscription status.
  id: |-
    hubedit_hub_129
  lang: |-
    python
  modified_code: |-
    import stripe as stripe_module
    from typing import TypedDict, List, Dict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: int) -> List[Dict[str, str]]:
        token = stripe_con["token"]
        stripe_module.api_key = token

        customers = stripe_module.Customer.list(limit=limit)
        active_customers = []

        for customer in customers.auto_paging_iter():
            subscriptions = customer.subscriptions.data if customer.subscriptions else []
            for subscription in subscriptions:
                if subscription.status == 'active':
                    active_customers.append({
                        'email': customer.email,
                        'subscription_status': subscription.status
                    })
                    break  # Assuming we only care about the first active subscription

        return active_customers
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: int):
        token = stripe_con["token"]
        stripe_module.api_key = token

        customers = stripe_module.Customer.list(limit=limit)
        return customers
  original_instructions: |-
    List Customers in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to cache the response for a given documentId, so that if the same documentId is requested again within a certain time frame, the cached response is returned instead of making a new request to the API.
  id: |-
    hubedit_hub_55
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    # Define a cache dictionary to store the responses
    cache = {}

    # Define a cache expiration time in seconds
    CACHE_EXPIRATION_TIME = 300  # 5 minutes

    def get_cached_response(documentId: str):
        current_time = time.time()
        if documentId in cache:
            cached_response, timestamp = cache[documentId]
            # Check if the cached response is still valid
            if current_time - timestamp < CACHE_EXPIRATION_TIME:
                return cached_response
            else:
                # Cache has expired for this documentId
                del cache[documentId]
        return None

    def cache_response(documentId: str, response_text: str):
        current_time = time.time()
        cache[documentId] = (response_text, current_time)

    def main(gdocs_auth: gdocs, documentId: str):
        token = gdocs_auth["token"]
        GET_DOC_URL = f'https://docs.googleapis.com/v1/documents/{documentId}'

        # Check if the response is already cached
        cached_response = get_cached_response(documentId)
        if cached_response is not None:
            return cached_response

        response = requests.get(
            GET_DOC_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        # Cache the new response
        cache_response(documentId, response.text)

        return response.text
  original_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, documentId: str):
        token = gdocs_auth["token"]
        GET_DOC_URL = f'https://docs.googleapis.com/v1/documents/{documentId}'

        response = requests.get(
            GET_DOC_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        return response.text
  original_instructions: |-
    Get Document in gdocs
  resource_type: |-
    gdocs
  resource_type_def: |-
    class gdocs(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage the response from the Stripe API, such as checking the status code of the response and raising an exception if the request was unsuccessful.
  id: |-
    hubedit_hub_119
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: str):
        STRIPE_CONFIRM_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/confirm'

        token = stripe_con["token"]

        try:
            response = requests.post(STRIPE_CONFIRM_PAYMENT_URL, headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            })

            # Check if the request was successful
            response.raise_for_status()

        except requests.exceptions.HTTPError as http_err:
            # Handle HTTP errors that are not 2xx
            print(f'HTTP error occurred: {http_err}')
            raise
        except Exception as err:
            # Handle other possible errors
            print(f'An error occurred: {err}')
            raise
        else:
            # Return the JSON response if the request was successful
            return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: str):
        STRIPE_CONFIRM_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/confirm'

        token = stripe_con["token"]

        response = requests.post(STRIPE_CONFIRM_PAYMENT_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        return response.json()
  original_instructions: |-
    Confirm a Payment Intent in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to check the response status code and raise an exception if the request was unsuccessful. Include a specific message for common HTTP errors such as 400 (Bad Request) and 401 (Unauthorized).
  id: |-
    hubedit_hub_48
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str, mimeType: str):
        DOWNLOAD_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/export?mimeType={mimeType}"

        token = gdrive_auth["token"]

        response = requests.get(
            DOWNLOAD_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        if response.status_code == 400:
            raise Exception("Bad Request: The server could not understand the request due to invalid syntax.")
        elif response.status_code == 401:
            raise Exception("Unauthorized: The request has not been applied because it lacks valid authentication credentials for the target resource.")
        elif response.status_code != 200:
            raise Exception(f"An error occurred: HTTP status code {response.status_code}")

        result = response.json()

        return result
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str, mimeType: str):
        DOWNLOAD_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/export?mimeType={mimeType}"

        token = gdrive_auth["token"]

        response = requests.get(
            DOWNLOAD_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return result
  original_instructions: |-
    Download Files (Google Docs, Sheets, Slides) in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- edit_instructions: |2

    Add error handling to manage situations where the requests.get call fails due to network issues or an invalid IP address, and return a meaningful error message in the response.
  id: |-
    hubedit_hub_393
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Optional

    class ipinfo(TypedDict):
        token: str

    def main(ipinfo: Optional[ipinfo] = None, ip: Optional[str] = None) -> dict:
        token = ipinfo['token'] if ipinfo and 'token' in ipinfo else ''
        url = f'https://ipinfo.io{"/" + ip if ip else ""}/json?token={token}'

        try:
            ipAddressInformation = requests.get(url)
            ipAddressInformation.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code
            return {
                'status': ipAddressInformation.status_code,
                'payload': ipAddressInformation.json(),
            }
        except requests.exceptions.HTTPError as http_err:
            # Specific error handling for HTTP errors (e.g., 404 Not Found, 403 Forbidden)
            return {
                'status': ipAddressInformation.status_code if ipAddressInformation else 500,
                'error': f'HTTP error occurred: {http_err}',
            }
        except requests.exceptions.ConnectionError:
            # Specific error handling for network-related errors
            return {
                'status': 503,
                'error': 'Network error: Unable to connect to the server',
            }
        except requests.exceptions.Timeout:
            # Specific error handling for request timeouts
            return {
                'status': 408,
                'error': 'Timeout error: The request timed out',
            }
        except requests.exceptions.RequestException as e:
            # General error handling for any other request-related errors
            return {
                'status': 500,
                'error': f'An error occurred while handling your request: {e}',
            }
        except Exception as e:
            # General error handling for any other errors
            return {
                'status': 500,
                'error': f'An unexpected error occurred: {e}',
            }
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class ipinfo(TypedDict):
        token: str

    def main(ipinfo: Optional[ipinfo] = None, ip: Optional[str] = None) -> dict:
        token = ipinfo['token'] if ipinfo and 'token' in ipinfo else ''
        url = f'https://ipinfo.io{"/" + ip if ip else ""}/json?token={token}'
        ipAddressInformation = requests.get(url)

        return {
            'status': ipAddressInformation.status_code,
            'payload': ipAddressInformation.json(),
        }
  original_instructions: |-
    Get IP address insights from IPinfo - geolocation, privacy detection, company and more in ipinfo
  resource_type: |-
    ipinfo
  resource_type_def: |-
    class ipinfo(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to send a message to the specified channel instead of retrieving the conversation history.
  id: |-
    hubedit_hub_19
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, message: str):
        web = WebClient(token=slack_auth['token'])

        response = web.chat_postMessage(channel=channel, text=message)

        return {'response': response}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_history(channel=channel)

        return {'response': response}
  original_instructions: |-
    List Conversation History in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to the script to also change the room name along with the topic by making an additional API call to the appropriate endpoint for setting the room name.
  id: |-
    hubedit_hub_287
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, topic: str = "", name: str = ""):
        # Function to set room topic
        def set_room_topic():
            topic_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.topic/"
            headers = {
                "Authorization": f"Bearer {matrix_res['token']}",
                "Content-Type": "application/json",
            }
            body = {
                "topic": topic,
            }
            resp = requests.put(topic_url, headers=headers, json=body)
            if not resp.ok:
                raise Exception(f"Failed to set room topic: Error HTTP{resp.status_code}")

        # Function to set room name
        def set_room_name():
            name_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.name/"
            headers = {
                "Authorization": f"Bearer {matrix_res['token']}",
                "Content-Type": "application/json",
            }
            body = {
                "name": name,
            }
            resp = requests.put(name_url, headers=headers, json=body)
            if not resp.ok:
                raise Exception(f"Failed to set room name: Error HTTP{resp.status_code}")

        # Set room topic if provided
        if topic:
            set_room_topic()

        # Set room name if provided
        if name:
            set_room_name()

        # Return a success message
        return {"message": "Room details updated successfully."}
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, topic: str = ""):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.topic/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        body = {
            "topic": topic,
        }
        resp = requests.put(url, headers=headers, json=body)
        if not resp.ok:
            raise Exception(f"Failed to set room topic: Error HTTP{resp.status_code}")
        return resp.json()
  original_instructions: |-
    Set room topic in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |-
    Add a feature to automatically retry the request if it fails due to a network error or a 5xx server error, with a maximum number of retries and a delay between retries.
  id: |-
    hubedit_hub_100
  lang: |-
    python
  modified_code: |-
    import requests
    import time
    from typing import TypedDict, Optional
    from requests.exceptions import RequestException

    class mastodon(TypedDict, total=False):
        sensitive: bool
        status: str
        visibility: str
        in_reply_to_id: str
        spoiler_text: str
        language: str

    def main(
        base_url: str,
        access_token: str,
        status: str,
        in_reply_to_id: Optional[str] = None,
        sensitive: bool = False,
        spoiler_text: Optional[str] = None,
        visibility: str = "public",
        language: Optional[str] = None,
        max_retries: int = 3,
        retry_delay: int = 5  # in seconds
    ) -> mastodon:
        payload = {
            "sensitive": sensitive,
            "status": status,
            "visibility": visibility
        }
        if in_reply_to_id:
            payload["in_reply_to_id"] = in_reply_to_id
        if spoiler_text:
            payload["spoiler_text"] = spoiler_text
        if language:
            payload["language"] = language

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        for attempt in range(max_retries):
            try:
                resp = requests.post(f"{base_url}/api/v1/statuses", headers=headers, json=payload)
                if resp.ok:
                    return resp.json()
                elif not (500 <= resp.status_code < 600):
                    # If the error is not a 5xx server error, raise an exception
                    raise Exception(f"Failed to post status: Error HTTP{resp.status_code}")
            except RequestException as e:
                # Log the exception here if needed
                print(f"Request failed: {e}, attempt {attempt + 1} of {max_retries}")
            time.sleep(retry_delay)

        raise Exception("Max retries exceeded")
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class mastodon(TypedDict, total=False):
        sensitive: bool
        status: str
        visibility: str
        in_reply_to_id: str
        spoiler_text: str
        language: str

    def main(
        base_url: str,
        access_token: str,
        status: str,
        in_reply_to_id: Optional[str] = None,
        sensitive: bool = False,
        spoiler_text: Optional[str] = None,
        visibility: str = "public",
        language: Optional[str] = None
    ) -> mastodon:
        payload = {
            "sensitive": sensitive,
            "status": status,
            "visibility": visibility
        }
        if in_reply_to_id:
            payload["in_reply_to_id"] = in_reply_to_id
        if spoiler_text:
            payload["spoiler_text"] = spoiler_text
        if language:
            payload["language"] = language

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        resp = requests.post(f"{base_url}/api/v1/statuses", headers=headers, json=payload)

        if not resp.ok:
            raise Exception(f"Failed to post status: Error HTTP{resp.status_code}")

        return resp.json()
  original_instructions: |-
    Post status in mastodon
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to create a new charge on a customer's card instead of retrieving an invoice item.
  id: |-
    hubedit_hub_123
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import stripe as stripe_module

    class StripeConfig(TypedDict):
        token: str

    def main(stripe_con: StripeConfig, customer_id: str, amount: int, currency: str, description: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        charge = stripe_module.Charge.create(
            customer=customer_id,
            amount=amount,
            currency=currency,
            description=description
        )

        return charge
  original_code: |-
    from typing import TypedDict
    import stripe as stripe_module

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, invoice_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.retrieve(invoice_id)

        return invoice_item
  original_instructions: |-
    Retrieve Invoice Line Item in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to update an existing deal by accepting a deal ID as an optional parameter and using the deals API update method if the ID is provided.
  id: |-
    hubedit_hub_229
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.deals import SimplePublicObjectInput

    class hubspot(TypedDict):
        token: str

    def remove_object_empty_fields(properties: dict) -> dict:
        return {k: v for k, v in properties.items() if v is not None and v != ''}

    def main(auth: hubspot, deal_id: Optional[str] = None, amount: Optional[str] = None,
             closedate: Optional[str] = None, dealname: Optional[str] = None,
             dealstage: Optional[str] = None, hubspot_owner_id: Optional[str] = None,
             pipeline: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'amount': amount,
            'closedate': closedate,
            'dealname': dealname,
            'dealstage': dealstage,
            'hubspot_owner_id': hubspot_owner_id,
            'pipeline': pipeline,
        })
        try:
            simple_public_object_input = SimplePublicObjectInput(properties=properties)
            if deal_id:
                return client.crm.deals.basic_api.update(deal_id=deal_id, simple_public_object_input=simple_public_object_input)
            else:
                return client.crm.deals.basic_api.create(simple_public_object_input=simple_public_object_input)
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  original_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.deals import SimplePublicObjectInput

    class hubspot(TypedDict):
        token: str

    def remove_object_empty_fields(properties: dict) -> dict:
        return {k: v for k, v in properties.items() if v is not None and v != ''}

    def main(auth: hubspot, amount: Optional[str] = None, closedate: Optional[str] = None,
             dealname: Optional[str] = None, dealstage: Optional[str] = None,
             hubspot_owner_id: Optional[str] = None, pipeline: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'amount': amount,
            'closedate': closedate,
            'dealname': dealname,
            'dealstage': dealstage,
            'hubspot_owner_id': hubspot_owner_id,
            'pipeline': pipeline,
        })
        try:
            simple_public_object_input = SimplePublicObjectInput(properties=properties)
            return client.crm.deals.basic_api.create(simple_public_object_input=simple_public_object_input)
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  original_instructions: |-
    Create Deal in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to fetch and return the list of open issues for the specified repository instead of the stargazers count.
  id: |-
    hubedit_hub_314
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str) -> List[dict]:
        headers = {
            'Authorization': f'token {gh_auth["token"]}',
            'Accept': 'application/vnd.github.v3+json',
        }
        response = requests.get(f'https://api.github.com/repos/{owner}/{repo}/issues?state=open', headers=headers)
        response.raise_for_status()
        issues_data = response.json()
        return issues_data
  original_code: |-
    import requests
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str):
        headers = {
            'Authorization': f'token {gh_auth["token"]}',
            'X-GitHub-Api-Version': '2022-11-28',
            'Accept': 'application/vnd.github+json',
        }
        response = requests.get(f'https://api.github.com/repos/{owner}/{repo}', headers=headers)
        response.raise_for_status()
        repository_data = response.json()
        return repository_data.get('stargazers_count')
  original_instructions: |-
    Get Repo Star Count in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter commits by a specific author by including an additional query parameter in the request URL.
  id: |-
    hubedit_hub_165
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: str, author: str = None):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/repository/commits"
        headers = {
            'Authorization': f"Bearer {glab['token']}",
            'Content-Type': 'application/json',
        }
        params = {}
        if author:
            params['author'] = author
        response = requests.get(url, headers=headers, params=params)
        return response.json()
  original_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: str):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/repository/commits"
        response = requests.get(url, headers={
            'Authorization': f"Bearer: {glab['token']}",
            'Content-Type': 'application/json',
        })
        return response.json()
  original_instructions: |-
    List Commits in gitlab
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add functionality to filter the events by time range, allowing the user to specify a minimum and maximum date-time to retrieve events only within that period.
  id: |-
    hubedit_hub_43
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, timeMin: str, timeMax: str):
        LIST_EVENTS_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events'

        token = gcal_auth["token"]

        params = {
            'timeMin': timeMin,
            'timeMax': timeMax,
            'singleEvents': True,
            'orderBy': 'startTime'
        }

        response = requests.get(LIST_EVENTS_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        }, params=params)

        result = response.json()

        return result
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str):
        LIST_EVENTS_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events'

        token = gcal_auth["token"]

        response = requests.get(LIST_EVENTS_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        result = response.json()

        return result
  original_instructions: |-
    List Events in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to save the query results to a CSV file by introducing a new parameter `output_file` that specifies the file path. If `output_file` is provided, write the results to the specified CSV file.
  id: |-
    hubedit_hub_268
  lang: |-
    python
  modified_code: |-
    import csv

    # ... (rest of the existing imports and code)

    def main(
        auth: clickhouse,
        query: str,
        parse_into: str = "json",
        format: Optional[str] = None,
        clickhouse_settings: Optional[Dict[str, Any]] = None,
        query_params: Optional[Dict[str, Any]] = None,
        output_file: Optional[str] = None,  # New parameter for output file path
    ):
        client = Client(**remove_empty_fields(auth))

        params = remove_empty_fields({
            'query': query,
            'format': format,
            'settings': clickhouse_settings,
        })

        if query_params:
            params['params'] = query_params

        result = client.execute(**params)

        client.disconnect()

        if output_file:
            with open(output_file, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerows(result)

        if parse_into == "json":
            return result
        elif parse_into == "text":
            return str(result)
        else:
            raise ValueError(f"Unsupported parse_into value: {parse_into}")
  original_code: |-
    from typing import TypedDict, Optional, Dict, Any
    from clickhouse_driver import Client

    class clickhouse(TypedDict):
        host: str
        username: str
        password: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: clickhouse,
        query: str,
        parse_into: str = "json",
        format: Optional[str] = None,
        clickhouse_settings: Optional[Dict[str, Any]] = None,
        query_params: Optional[Dict[str, Any]] = None,
    ):
        client = Client(**remove_empty_fields(auth))

        params = remove_empty_fields({
            'query': query,
            'format': format,
            'settings': clickhouse_settings,
        })

        if query_params:
            params['params'] = query_params

        result = client.execute(**params)

        client.disconnect()

        if parse_into == "json":
            return result
        elif parse_into == "text":
            return str(result)
        else:
            raise ValueError(f"Unsupported parse_into value: {parse_into}")
  original_instructions: |-
    Run Query in clickhouse
  resource_type: |-
    clickhouse
  resource_type_def: |-
    class clickhouse(TypedDict):
        host: str
        username: str
        password: str
- edit_instructions: |2

    Modify the script to add a feature that allows the user to insert new rows into the spreadsheet at a specified index, with the option to provide data that will populate the new rows.
  id: |-
    hubedit_hub_69
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Optional

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: int,
        start_index: int,
        end_index: int,
        action: str,
        rowData: Optional[List[List[object]]] = None,
    ):
        token = gsheets_auth["token"]
        BATCH_UPDATE_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        if action == "delete":
            body = {
                "requests": [
                    {
                        "deleteDimension": {
                            "range": {
                                "sheetId": sheetId,
                                "dimension": "ROWS",
                                "startIndex": start_index,
                                "endIndex": end_index,
                            },
                        },
                    },
                ],
            }
        elif action == "insert":
            body = {
                "requests": [
                    {
                        "insertDimension": {
                            "range": {
                                "sheetId": sheetId,
                                "dimension": "ROWS",
                                "startIndex": start_index,
                                "endIndex": end_index,
                            },
                            "inheritFromBefore": False,
                        },
                    },
                ],
            }
            if rowData:
                body["requests"].append({
                    "updateCells": {
                        "rows": [{"values": [{"userEnteredValue": {"stringValue": str(cell)}} for cell in row]} for row in rowData],
                        "fields": "userEnteredValue",
                        "start": {
                            "sheetId": sheetId,
                            "rowIndex": start_index,
                            "columnIndex": 0,
                        },
                    },
                })

        response = requests.post(
            BATCH_UPDATE_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        if action == "delete":
            return "Rows deleted."
        elif action == "insert":
            return "Rows inserted."
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: int,
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        DELETE_ROWS_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "deleteDimension": {
                        "range": {
                            "sheetId": sheetId,
                            "dimension": "ROWS",
                            "startIndex": start_index,
                            "endIndex": end_index,
                        },
                    },
                },
            ],
        }
        response = requests.post(
            DELETE_ROWS_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return "Rows deleted."
  original_instructions: |-
    Clear Row in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to rejoin the room automatically after leaving, using a new endpoint to rejoin the room with the same `roomId`.
  id: |-
    hubedit_hub_96
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, roomId: str):
        if not matrix_res['token']:
            raise ValueError("Leaving and rejoining a room requires an access token.")

        leave_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/leave"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        leave_resp = requests.post(leave_url, headers=headers)

        if not leave_resp.ok:
            raise ValueError(f"Failed to leave room: Error HTTP{leave_resp.status_code}")

        # After leaving, try to rejoin the room
        rejoin_url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/join"
        rejoin_resp = requests.post(rejoin_url, headers=headers)

        if not rejoin_resp.ok:
            raise ValueError(f"Failed to rejoin room: Error HTTP{rejoin_resp.status_code}")
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, roomId: str):
        if not matrix_res['token']:
            raise ValueError("Leaving a room requires an access token.")

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/leave"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        resp = requests.post(url, headers=headers)

        if not resp.ok:
            raise ValueError(f"Failed to leave room: Error HTTP{resp.status_code}")
  original_instructions: |-
    Leave room in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- edit_instructions: |2

    Add error handling to catch exceptions from the Slack API call and return an error message if the update fails.
  id: |-
    hubedit_hub_15
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, purpose: str):
        web = WebClient(token=slack_auth['token'])

        try:
            web.conversations_setPurpose(
                channel=channel,
                purpose=purpose
            )
        except SlackApiError as e:
            return {"error": f"Failed to update channel purpose: {e.response['error']}"}

        return {"message": "Successfully updated channel purpose"}
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, purpose: str):
        web = WebClient(token=slack_auth['token'])

        web.conversations_setPurpose(
            channel=channel,
            purpose=purpose
        )

        return {"message": "Successfully updated channel purpose"}
  original_instructions: |-
    Set Channel Purpose in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to filter the records based on a given field and value when retrieving all records, instead of returning all records unfiltered.
  id: |-
    hubedit_hub_357
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    from pyairtable import Table
    from pyairtable.formulas import match

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: Optional[str] = None, filter_field: Optional[str] = None, filter_value: Optional[str] = None):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])

        if record_id:
            record = table.get(record_id)
            return {'result': record}
        else:
            if filter_field and filter_value:
                formula = match(filter_field, filter_value)
                records = table.all(formula=formula)
            else:
                records = table.all()
            return {'result': records}
  original_code: |-
    from typing import TypedDict, Optional
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: Optional[str] = None):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])

        if record_id:
            record = table.get(record_id)
            return {'result': record}
        else:
            records = table.all()
            return {'result': records}
  original_instructions: |-
    Get Record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- edit_instructions: |2

    Add a feature to log the response status and message to a file after the `set_schedule_enabled` function makes the HTTP request.
  id: |-
    hubedit_hub_114
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict
    import logging

    class scheduleapi(TypedDict):
        workspace_id: str
        schedule_path: str
        enabled: bool

    def create_conf() -> scheduleapi:
        return {
            "workspace_id": "your_workspace_id",
            "schedule_path": "",
            "enabled": False
        }

    def set_schedule_enabled(conf: scheduleapi, schedule_path: str, enabled: bool):
        api_url = f"https://api.example.com/workspaces/{conf['workspace_id']}/schedules/{schedule_path}"
        payload = {"enabled": enabled}
        response = requests.put(api_url, json=payload)

        # Log the response status and message to a file
        log_response(response)

        return response.json()

    def log_response(response):
        # Configure logging to write to a file
        logging.basicConfig(filename='api_responses.log', level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

        # Log the status code and response message
        logging.info(f"Status Code: {response.status_code}, Response: {response.text}")

    def main(schedule_path: str, enabled: bool):
        conf = create_conf()
        conf['schedule_path'] = schedule_path
        return set_schedule_enabled(conf, schedule_path, enabled)
  original_code: |-
    import requests
    from typing import TypedDict

    class scheduleapi(TypedDict):
        workspace_id: str
        schedule_path: str
        enabled: bool

    def create_conf() -> scheduleapi:
        # Assuming createConf initializes some configuration
        # Replace with actual initialization as needed
        return {
            "workspace_id": "your_workspace_id",  # Replace with actual workspace ID
            "schedule_path": "",
            "enabled": False
        }

    def set_schedule_enabled(conf: scheduleapi, schedule_path: str, enabled: bool):
        # Assuming setScheduleEnabled makes an HTTP request to an API
        # Replace with actual API endpoint and authentication as needed
        api_url = f"https://api.example.com/workspaces/{conf['workspace_id']}/schedules/{schedule_path}"
        payload = {"enabled": enabled}
        response = requests.put(api_url, json=payload)
        return response.json()

    def main(schedule_path: str, enabled: bool):
        conf = create_conf()
        conf['schedule_path'] = schedule_path
        return set_schedule_enabled(conf, schedule_path, enabled)
  original_instructions: |-
    Turn on/off a schedule in windmill
  resource_type: |-
    scheduleapi
  resource_type_def: |-
    class scheduleapi(TypedDict):
        workspace_id: str
        schedule_path: str
        enabled: bool
- edit_instructions: |2

    Add functionality to send a direct message to a specific user with the approval page link instead of posting it in a channel.
  id: |-
    hubedit_hub_273
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class SlackConfig(TypedDict):
        token: str

    def get_resume_urls(channel: str):
        # Assuming there is a similar API endpoint to get resume URLs
        response = requests.get(f"https://api.example.com/getResumeUrls/channel-{channel}")
        return response.json()

    def send_direct_message(slack_config: SlackConfig, user_id: str, text: str):
        web = WebClient(token=slack_config['token'])
        try:
            response = web.chat_postMessage(
                channel=user_id,
                text=text,
                as_user=True  # Send as the authenticated user
            )
            return response
        except SlackApiError as e:
            print(f"Error sending message: {e.response['error']}")

    def main(slack_config: SlackConfig, channel: str, user_id: str, text: str = "A flow is requesting an approval to be resumed"):
        resume_urls = get_resume_urls(channel)
        approval_page = resume_urls['approvalPage']
        message_text = f"{text} <{approval_page}|approval page>"

        # Send a direct message to the specified user with the approval page link
        response = send_direct_message(slack_config, user_id, message_text)
        return response
  original_code: |-
    import requests
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def get_resume_urls(channel: str):
        # Assuming there is a similar API endpoint to get resume URLs
        response = requests.get(f"https://api.example.com/getResumeUrls/channel-{channel}")
        return response.json()

    def main(slack_config: slack, channel: str, text: str = "A flow is requesting an approval to be resumed"):
        web = WebClient(token=slack_config['token'])

        resume_urls = get_resume_urls(channel)
        approval_page = resume_urls['approvalPage']
        response = web.chat_postMessage(
            channel=channel,
            text=f"{text} <{approval_page}|approval page>"
        )
        return response
  original_instructions: |-
    Ask channel for approval in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Modify the script to add contacts to the list instead of deleting them by changing the HTTP method from DELETE to POST and adjusting the payload to include the necessary contact data.
  id: |-
    hubedit_hub_225
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, List, Dict

    class SendGridConfig(TypedDict):
        token: str

    class ContactData(TypedDict):
        email: str
        first_name: str
        last_name: str

    def main(api_token: SendGridConfig, list_id: str, contacts: List[ContactData]):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }

        payload = {
            "list_ids": [list_id],
            "contacts": contacts
        }

        url = "https://api.sendgrid.com/v3/marketing/contacts"

        try:
            response = requests.post(url, headers=headers, json=payload)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + str(error.response.json() if error.response else error))
  original_code: |-
    import requests
    from typing import TypedDict, List

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, list_id: str, contact_ids: List[str]):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }

        contact_ids_str = ",".join(contact_ids) if contact_ids else ""
        url = f"https://api.sendgrid.com/v3/marketing/lists/{list_id}/contacts"
        params = {'contact_ids': contact_ids_str}

        try:
            response = requests.delete(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + str(error.response.json() if error.response else error))
  original_instructions: |-
    Remove Contact From List in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- edit_instructions: |2

    Add a feature to schedule the direct message to be sent at a later time by accepting an optional `post_at` parameter that represents a future timestamp.
  id: |-
    hubedit_hub_189
  lang: |-
    python
  modified_code: |-
    import requests
    from typing import TypedDict, Dict, Optional
    from email_validator import validate_email, EmailNotValidError

    class slack(TypedDict):
        token: str

    class UserData(TypedDict):
        id: str
        email: str
        real_name: str

    def main(user_email: str, text: str, slack_config: slack, post_at: Optional[int] = None):
        throw_on_invalid_email(user_email)

        client = WebClient(slack_config['token'])
        user_data = get_user_data(client, user_email)
        print(user_data)
        result = send_direct_message(text, client, user_data, post_at)

        return result

    def get_user_data(client: 'WebClient', email: str) -> UserData:
        try:
            response = client.users_lookup_by_email(email=email)

            user = response['user']
            return UserData(id=user['id'], email=email, real_name=user['real_name'])
        except Exception as err:
            return handle_api_response(email, err)

    def send_direct_message(text: str, client: 'WebClient', user_data: UserData, post_at: Optional[int] = None):
        if post_at:
            response = client.chat_schedule_message(channel=user_data['id'], text=text, post_at=post_at)
        else:
            response = client.chat_post_message(channel=user_data['id'], text=text)
        return {
            'ok': response['ok'],
            'ts': response.get('ts'),
            'channel': response['channel'],
            'email': user_data['email'],
            'scheduled_message_id': response.get('scheduled_message_id')
        }

    def throw_on_invalid_email(email: str):
        try:
            validate_email(email)
        except EmailNotValidError:
            raise ValueError("Expected user email")

    def handle_api_response(email: str, error: Exception):
        raise ValueError({'email': email, 'err_msg': str(error)})

    class WebClient:
        def __init__(self, token: str):
            self.token = token
            self.session = requests.Session()
            self.session.headers.update({'Authorization': f'Bearer {self.token}'})

        def users_lookup_by_email(self, email: str) -> Dict:
            url = 'https://slack.com/api/users.lookupByEmail'
            response = self.session.get(url, params={'email': email})
            return response.json()

        def chat_post_message(self, channel: str, text: str) -> Dict:
            url = 'https://slack.com/api/chat.postMessage'
            response = self.session.post(url, data={'channel': channel, 'text': text})
            return response.json()

        def chat_schedule_message(self, channel: str, text: str, post_at: int) -> Dict:
            url = 'https://slack.com/api/chat.scheduleMessage'
            response = self.session.post(url, data={'channel': channel, 'text': text, 'post_at': post_at})
            return response.json()
  original_code: |-
    import requests
    from typing import TypedDict, Dict
    from email_validator import validate_email, EmailNotValidError

    class slack(TypedDict):
        token: str

    class UserData(TypedDict):
        id: str
        email: str
        real_name: str

    def main(user_email: str, text: str, slack_config: slack):
        throw_on_invalid_email(user_email)

        client = WebClient(slack_config['token'])
        user_data = get_user_data(client, user_email)
        print(user_data)
        result = send_direct_message(text, client, user_data)

        return result

    def get_user_data(client: 'WebClient', email: str) -> UserData:
        try:
            response = client.users_lookup_by_email(email=email)

            user = response['user']
            return UserData(id=user['id'], email=email, real_name=user['real_name'])
        except Exception as err:
            return handle_api_response(email, err)

    def send_direct_message(text: str, client: 'WebClient', user_data: UserData):
        response = client.chat_post_message(channel=user_data['id'], text=text)
        return {
            'ok': response['ok'],
            'ts': response['ts'],
            'channel': response['channel'],
            'email': user_data['email']
        }

    def throw_on_invalid_email(email: str):
        try:
            validate_email(email)
        except EmailNotValidError:
            raise ValueError("Expected user email")

    def handle_api_response(email: str, error: Exception):
        raise ValueError({'email': email, 'err_msg': str(error)})

    class WebClient:
        def __init__(self, token: str):
            self.token = token
            self.session = requests.Session()
            self.session.headers.update({'Authorization': f'Bearer {self.token}'})

        def users_lookup_by_email(self, email: str) -> Dict:
            url = 'https://slack.com/api/users.lookupByEmail'
            response = self.session.get(url, params={'email': email})
            return response.json()

        def chat_post_message(self, channel: str, text: str) -> Dict:
            url = 'https://slack.com/api/chat.postMessage'
            response = self.session.post(url, data={'channel': channel, 'text': text})
            return response.json()
  original_instructions: |-
    Send direct message in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- edit_instructions: |2

    Add functionality to filter the results by a specific job status, such as 'running', 'completed', or 'failed', by including an additional parameter in the 'params' dictionary.
  id: |-
    hubedit_hub_270
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict, Optional
    import requests

    class wmill(TypedDict):
        workspace: str
        suspend: bool
        perPage: int
        scriptPathExact: Optional[str]
        status: Optional[str]  # Added status field

    def main(scriptPathExact: Optional[str] = None, status: Optional[str] = None):
        params = {
            'workspace': 'your_workspace_name',  # Replace with your actual workspace name
            'suspend': True,
            'perPage': 50,
            'scriptPathExact': scriptPathExact,
            'status': status,  # Added status to the params
        }
        response = requests.get('https://api.yourwindmillserver.com/listQueue', params=params)  # Replace with your actual Windmill server URL
        return response.json()
  original_code: |-
    from typing import TypedDict, Optional
    import requests

    class wmill(TypedDict):
        workspace: str
        suspend: bool
        perPage: int
        scriptPathExact: Optional[str]

    def main(scriptPathExact: Optional[str] = None):
        params = {
            'workspace': 'your_workspace_name',  # Replace with your actual workspace name
            'suspend': True,
            'perPage': 50,
            'scriptPathExact': scriptPathExact,
        }
        response = requests.get('https://api.yourwindmillserver.com/listQueue', params=params)  # Replace with your actual Windmill server URL
        return response.json()
  original_instructions: |-
    List Suspended Jobs in windmill
  resource_type: |-
    wmill
  resource_type_def: |-
    class wmill(TypedDict):
        workspace: str
        suspend: bool
        perPage: int
        scriptPathExact: Optional[str]
- edit_instructions: |2

    Modify the script to allow customization of the QR code's fill and back colors by adding parameters to the main function for these colors and using them when creating the image.
  id: |-
    hubedit_hub_87
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import qrcode
    from io import BytesIO
    import base64

    class qrcode_typeddict(TypedDict):
        qr_url: str

    def main(qr_url: str, fill_color: str = "black", back_color: str = "white") -> qrcode_typeddict:
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(qr_url)
        qr.make(fit=True)

        img = qr.make_image(fill_color=fill_color, back_color=back_color)
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")

        base64_image = f"data:image/png;base64,{img_str}"
        return {"qr_url": base64_image}
  original_code: |-
    from typing import TypedDict
    import qrcode
    from io import BytesIO
    import base64

    class qrcode_typeddict(TypedDict):
        qr_url: str

    def main(qr_url: str) -> qrcode_typeddict:
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(qr_url)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")

        base64_image = f"data:image/png;base64,{img_str}"
        return {"qr_url": base64_image}
  original_instructions: |-
    Generate QR Code in qrcode
  resource_type: |-
    qrcode_typeddict
  resource_type_def: |-
    class qrcode_typeddict(TypedDict):
        qr_url: str
- edit_instructions: |2

    Modify the script to save the embedding response to a JSON file with a filename based on the current timestamp.
  id: |-
    hubedit_hub_248
  lang: |-
    python
  modified_code: |-
    from typing import TypedDict
    import openai
    import json
    from datetime import datetime

    class openai_auth(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai_auth, prompt: str, model: str = "text-embedding-ada-002"):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Embedding.create(
            model=model,
            input=prompt
        )

        # Generate a filename based on the current timestamp
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        filename = f"embedding_{timestamp}.json"

        # Save the response to a JSON file
        with open(filename, 'w') as f:
            json.dump(response['data'], f)

        return response['data']
  original_code: |-
    from typing import TypedDict
    import openai

    class openai_auth(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai_auth, prompt: str, model: str = "text-embedding-ada-002"):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Embedding.create(
            model=model,
            input=prompt
        )
        return response['data']
  original_instructions: |-
    Create Embedding in openai
  resource_type: |-
    openai_auth
  resource_type_def: |-
    class openai_auth(TypedDict):
        api_key: str
        organization_id: str
- edit_instructions: |2

    Add a new function that validates the input data against the schema provided and only returns the record if it matches the schema, otherwise it raises an error.
  id: |-
    hubedit_hub_250
  lang: |-
    python
  modified_code: |-
    import jsonschema
    from jsonschema import validate
    from typing import Any, Dict

    def validate_record(record: Any, schema: Dict[str, Any]) -> None:
        try:
            validate(instance=record, schema=schema)
        except jsonschema.exceptions.ValidationError as e:
            raise ValueError(f"Record does not match the schema: {e.message}")

    def main(type: str, table: str, record: object, schema: str, old_record: object) -> record_type:
        # Assuming 'schema' is a JSON schema in string format, we need to convert it to a dictionary
        schema_dict = json.loads(schema)

        # Validate the record against the schema
        validate_record(record, schema_dict)

        print("type", type)
        print("table", table)
        print("record", record)
        print("schema", schema)
        print("old_record", old_record)

        return {
            "type": type,
            "table": table,
            "record": record,
            "schema": schema,
            "old_record": old_record,
        }
  original_code: |-
    from typing import TypedDict, Any

    class record_type(TypedDict):
        type: str
        table: str
        record: Any
        schema: str
        old_record: Any

    def main(type: str, table: str, record: object, schema: str, old_record: object) -> record_type:
        print("type", type)
        print("table", table)
        print("record", record)
        print("schema", schema)
        print("old_record", old_record)
        return {
            "type": type,
            "table": table,
            "record": record,
            "schema": schema,
            "old_record": old_record,
        }
  original_instructions: |-
    preview supabase event in supabase
  resource_type: |-
    record_type
  resource_type_def: |-
    class record_type(TypedDict):
        type: str
        table: str
        record: Any
        schema: str
        old_record: Any
- edit_instructions: |2

    Add a feature to send a direct message to the user who last modified the schedule or script, informing them about the recovery and providing a link to the error details.
  id: |-
    hubedit_hub_1031
  lang: |-
    deno
  modified_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string,
      is_flow: boolean,
      schedule_path: string,
      error: object,
      error_started_at: string,
      success_times: number,
      success_result: object,
      success_started_at: string,
      slack: Slack,
      channel: string,
      last_modified_by_user: string, // The user ID of the person who last modified the schedule or script
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      // Send a message to the channel
      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> recovered*${
                success_times > 1 ? (" " + success_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last failure at: ${
                    dayjs(error_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n${formatError(error)}`,
                },
              },
            ],
          },
          {
            color: "#00ff00",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last success at: ${
                    dayjs(success_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n\`\`\`\n${JSON.stringify(success_result, null, 2)}\n\`\`\``,
                },
              },
            ],
          },
        ],
      });

      // Send a direct message to the user who last modified the schedule or script
      await web.chat.postMessage({
        channel: last_modified_by_user,
        text: `The schedule or script you modified has recovered.`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> recovered*${
                success_times > 1 ? (" " + success_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `Last failure at: ${
                dayjs(error_started_at).format("DD.MM.YYYY HH:mm (Z)")
              }\n${formatError(error)}`,
            },
          },
        ],
      });
    }
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      error_started_at: string, // The start datetime of the latest job that failed
      success_times: number, // The number of times the schedule succeeded before calling the recovery handler.
      success_result: object, // The result of the latest successful job
      success_started_at: string, // The start datetime of the latest successful job
      slack: Slack,
      channel: string,
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> recovered*${
                success_times > 1 ? (" " + success_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last failure at: ${
                    dayjs(error_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n${formatError(error)}`,
                },
              },
            ],
          },
          {
            color: "#00ff00",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last success at: ${
                    dayjs(success_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n\`\`\`\n${success_result}\n\`\`\``,
                },
              },
            ],
          },
        ],
      });
    }
  original_instructions: |-
    Schedule recovery handler in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to upload a file to the specified S3 bucket instead of retrieving an object.
  id: |-
    hubedit_hub_392
  lang: |-
    deno
  modified_code: |-
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };

    export async function uploadFile(s3: S3, path: string, filePath: string) {
      const client = new S3Client(s3);
      const fileContent = await Deno.readFile(filePath);
      return client.putObject(path, fileContent, {
        contentType: "application/octet-stream", // You might want to set the appropriate content type for your file
      });
    }
  original_code: |
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, path: string) {
      return (await new S3Client(s3).getObject(path)).text();
    }
  original_instructions: |-
    Get object in bucket as text in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- edit_instructions: |2

    Modify the script to create a new index in the Pinecone database instead of describing an existing index.
  id: |-
    hubedit_hub_339
  lang: |-
    deno
  modified_code: |-
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(auth: Pinecone, index_name: string) {
      const client = new PineconeClient();
      await client.init(auth);
      return await client.createIndex({ indexName: index_name });
    }
  original_code: |
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(auth: Pinecone, index_name: string) {
      const client = new PineconeClient();
      await client.init(auth);
      return await client.describeIndex({ indexName: index_name });
    }
  original_instructions: |-
    Describe Index in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- edit_instructions: |2

    Add functionality to the script to also create a set of predefined attributes for the new collection after it is created.
  id: |-
    hubedit_hub_329
  lang: |-
    deno
  modified_code: |-
    import {
      Client,
      Databases,
      ID,
      Database,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param collection_id ID of the collection to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    type Attribute = {
      key: string;
      type: string;
      size?: number;
      required?: boolean;
      default?: any;
      array?: boolean;
    };

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      attributes: Attribute[],
      collection_id?: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      const collection = await db.createCollection(
        database_id,
        collection_id || ID.unique(),
        collection_name,
        collection_permissions,
        collection_document_security,
      );

      for (const attribute of attributes) {
        await db.createStringAttribute(
          database_id,
          collection.$id,
          attribute.key,
          attribute.size || 255,
          attribute.required || false,
          attribute.default,
          attribute.array || false,
        );
      }

      return collection;
    }
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param collection_id ID of the collection to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      collection_id?: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createCollection(
        database_id,
        collection_id || ID.unique(),
        collection_name,
        collection_permissions,
        collection_document_security,
      );
    }
  original_instructions: |-
    Create Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add functionality to send an email notification to a predefined list of recipients with the error details and recovery information whenever the `main` function is called.
  id: |-
    hubedit_hub_1028
  lang: |-
    deno
  modified_code: |-
    import { sendEmail } from './emailService'; // Assuming there's an emailService module to send emails

    const RECIPIENTS = ['admin@example.com', 'support@example.com']; // Predefined list of recipients

    export async function main(
      path: string,
      is_flow: boolean,
      schedule_path: string,
      error: object,
      error_started_at: string,
      success_times: number,
      success_result: object,
      success_started_at: string,
    ) {
      console.log(
        `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${error_started_at}:`, error);
      console.log(`Last success at ${success_started_at}:`, success_result);

      // Prepare the email content
      const emailSubject = `Recovery Notification for Schedule: ${schedule_path}`;
      const emailBody = `
        <h1>Recovery Details</h1>
        <p>Schedule <strong>${schedule_path}</strong> has recovered ${
        success_times > 1 ? (success_times + " times in a row") : "once"
      }.</p>
        <p><strong>${is_flow ? "Flow" : "Script"}:</strong> ${path}</p>
        <p><strong>Last failure at:</strong> ${error_started_at}</p>
        <pre>${JSON.stringify(error, null, 2)}</pre>
        <p><strong>Last success at:</strong> ${success_started_at}</p>
        <pre>${JSON.stringify(success_result, null, 2)}</pre>
      `;

      // Send the email notification
      try {
        await sendEmail(RECIPIENTS, emailSubject, emailBody);
        console.log('Email notification sent successfully.');
      } catch (emailError) {
        console.error('Failed to send email notification:', emailError);
      }

      return error;
    }
  original_code: |
    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      error_started_at: string, // The start datetime of the latest job that failed
      success_times: number, // The number of times the schedule succeeded before calling the recovery handler.
      success_result: object, // The result of the latest successful job
      success_started_at: string, // The start datetime of the latest successful job
    ) {
      console.log(
        `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${error_started_at}:`, error);
      console.log(`Last success at ${success_started_at}:`, success_result);
      return error;
    }
  original_instructions: |-
    Schedule recovery handler template in windmill
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a feature to log the generated signed URL to a file for record-keeping purposes before returning it.
  id: |-
    hubedit_hub_231
  lang: |-
    deno
  modified_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";
    import { writeTextFile } from "deno:fs";

    type Hubspot = {
      token: string;
    };

    export async function main(
      auth: Hubspot,
      file_id: string,
      size?: "" | "thumb" | "icon" | "medium" | "preview",
      expiration_seconds?: number,
      upscale?: boolean,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        const signedUrl = await client.files.filesApi.getSignedUrl(
          file_id,
          size || undefined,
          expiration_seconds || undefined,
          upscale || undefined,
        );

        // Log the generated signed URL to a file
        const logEntry = `Time: ${new Date().toISOString()}, File ID: ${file_id}, Signed URL: ${signedUrl}\n`;
        await writeTextFile("signed_url_log.txt", logEntry, { append: true });

        return signedUrl;
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      file_id: string,
      size?: "" | "thumb" | "icon" | "medium" | "preview",
      expiration_seconds?: number,
      upscale?: boolean,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.files.filesApi.getSignedUrl(
          file_id,
          size || undefined,
          expiration_seconds || undefined,
          upscale || undefined,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  original_instructions: |-
    Get File Public URL in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- edit_instructions: |2

    Add error handling to provide a more descriptive message if the fetch request fails or if the response status is not OK (status code 200).
  id: |-
    hubedit_hub_263
  lang: |-
    deno
  modified_code: |-
    export async function main(
      auth: Faunadb,
      query: string,
      variables?: Record<string, any>,
      operationName?: string,
    ) {
      const region = ["us", "eu"].includes(auth.region) ? auth.region : "";
      let response;
      try {
        response = await fetch(`https://graphql.${region}.fauna.com/graphql`, {
          method: "POST",
          headers: {
            Authorization: "Bearer " + auth.secret,
          },
          body: JSON.stringify({
            query,
            variables: variables || {},
            operationName: operationName || null,
          }),
        });
      } catch (error) {
        throw new Error(`Network error: ${error.message}`);
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`FaunaDB GraphQL API error: ${response.status} ${response.statusText} - ${errorText}`);
      }

      return await response.json();
    }
  original_code: |
    type Faunadb = {
      region: string;
      secret: string;
    };
    export async function main(
      auth: Faunadb,
      query: string,
      variables?: Record<string, any>,
      operationName?: string,
    ) {
      const region = ["us", "eu"].includes(auth.region) ? auth.region : "";
      const response = await fetch(`https://graphql.${region}.fauna.com/graphql`, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + auth.secret,
        },
        body: JSON.stringify({
          query,
          variables: variables || {},
          operationName: operationName || null,
        }),
      });
      return await response.json();
    }
  original_instructions: |-
    Execute GraphQL Query in faunadb
  resource_type: |-
    Faunadb
  resource_type_def: |-
    type Faunadb = {
      region: string;
      secret: string;
    }
- edit_instructions: |2

    Change the function to send a message to the specified chat_id instead of exporting the chat invite link.
  id: |-
    hubedit_hub_233
  lang: |-
    deno
  modified_code: |-
    import { Telegraf } from "npm:telegraf@4.11";

    type TelegramAuth = {
      token: string;
    };

    export async function main(auth: TelegramAuth, chat_id: string, message: string) {
      const bot = new Telegraf(auth.token);
      return await bot.telegram.sendMessage(chat_id, message);
    }
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(auth: Telegram, chat_id: string) {
      const client = new Telegram(auth.token);
      return await client.exportChatInviteLink(chat_id);
    }
  original_instructions: |-
    Export Chat Invite Link in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to cache the translations in a local file and check the cache before making a new request to the OpenAI API to avoid unnecessary API calls for previously translated texts.
  id: |-
    hubedit_hub_348
  lang: |-
    deno
  modified_code: "import { removeObjectEmptyFields } from \"https://deno.land/x/windmill_helpers@v1.1.1/mod.ts\"\
    ;\nimport {\n  Configuration,\n  CreateCompletionRequest,\n  OpenAIApi,\n} from\
    \ \"npm:openai@3.2.1\";\nimport { existsSync, readJson, writeJson } from \"https://deno.land/std/fs/mod.ts\"\
    ;\n\n/**\n * You can read about the parameters at\n * https://platform.openai.com/docs/api-reference/completions/create\n\
    \ *\n * @returns An object with the **lowercase** values of the `translate_to`\
    \ array as keys.\n *\n * *For example:*\n * ```\n *  { french: \"J'aime les pommes\"\
    , german: \"Ich liebe \xC4pfel\" }\n * ```\n */\ntype Openai = {\n  api_key: string;\n\
    \  organization_id: string;\n};\ntype CacheEntry = {\n  text: string;\n  translations:\
    \ Record<string, string>;\n};\nconst CACHE_FILE = './translation_cache.json';\n\
    \nexport async function main(\n  auth: Openai,\n  text: string,\n  translate_to:\
    \ string[] = [\"french\", \"german\"],\n  model: string = \"text-davinci-003\"\
    ,\n  max_tokens: number = 100,\n) {\n  // Load cache\n  let cache: CacheEntry[]\
    \ = [];\n  if (existsSync(CACHE_FILE)) {\n    cache = await readJson(CACHE_FILE)\
    \ as CacheEntry[];\n  }\n\n  // Check cache for existing translation\n  const\
    \ cacheKey = translate_to.map(l => l.toLowerCase()).sort().join('|');\n  const\
    \ cachedTranslation = cache.find(entry => entry.text === text && Object.keys(entry.translations).sort().join('|')\
    \ === cacheKey);\n\n  if (cachedTranslation) {\n    return cachedTranslation.translations;\n\
    \  }\n\n  const configuration = new Configuration({\n    apiKey: auth.api_key,\n\
    \    organization: auth.organization_id,\n  });\n  const openai = new OpenAIApi(configuration);\n\
    \n  const prompt = `Translate the text below into the languages found in this\
    \ array:\n[${translate_to.map((l) => l.trim().toLowerCase()).join(\", \")}]\n\
    Apply the following rules:\n  - return ONLY a valid JSON object\n  - the object\
    \ keys are strictly the languages in the array above\n  - the values are the corresponding\
    \ translations\n  - do NOT try to complete the original text\n\n${text}`;\n  console.log(prompt);\n\
    \  const request = removeObjectEmptyFields({\n    model,\n    prompt,\n    max_tokens,\n\
    \    temperature: 0.3,\n    top_p: 1.0,\n    frequency_penalty: 0.0,\n    presence_penalty:\
    \ 0.0,\n  }) as CreateCompletionRequest;\n  const { data } = await openai.createCompletion(request);\n\
    \  console.log(data?.choices[0]?.text);\n\n  const translations = JSON.parse(data?.choices[0]?.text.replaceAll('\"\
    ', '\"') ?? \"\");\n\n  // Update cache\n  cache.push({ text, translations });\n\
    \  await writeJson(CACHE_FILE, cache);\n\n  return translations;\n}"
  original_code: "import { removeObjectEmptyFields } from \"https://deno.land/x/windmill_helpers@v1.1.1/mod.ts\"\
    ;\nimport {\n  Configuration,\n  CreateCompletionRequest,\n  OpenAIApi,\n} from\
    \ \"npm:openai@3.2.1\";\n\n/**\n * You can read about the parameters at\n * https://platform.openai.com/docs/api-reference/completions/create\n\
    \ *\n * @returns An object with the **lowercase** values of the `translate_to`\
    \ array as keys.\n *\n * *For example:*\n * ```\n *  { french: \"J'aime les pommes\"\
    , german: \"Ich liebe \xC4pfel\" }\n * ```\n */\ntype Openai = {\n  api_key: string;\n\
    \  organization_id: string;\n};\nexport async function main(\n  auth: Openai,\n\
    \  text: string,\n  translate_to: string[] = [\"french\", \"german\"],\n  model:\
    \ string = \"text-davinci-003\",\n  max_tokens: number = 100,\n) {\n  const configuration\
    \ = new Configuration({\n    apiKey: auth.api_key,\n    organization: auth.organization_id,\n\
    \  });\n  const openai = new OpenAIApi(configuration);\n\n  const prompt = `Translate\
    \ the text below into the languages found in this array:\n[${translate_to.map((l)\
    \ => l.trim().toLowerCase()).join(\", \")}]\nApply the following rules:\n  - return\
    \ ONLY a valid JSON object\n  - the object keys are strictly the languages in\
    \ the array above\n  - the values are the corresponding translations\n  - do NOT\
    \ try to complete the original text\n\n${text}`;\n  console.log(prompt);\n  const\
    \ request = removeObjectEmptyFields({\n    model,\n    prompt,\n    max_tokens,\n\
    \    temperature: 0.3,\n    top_p: 1.0,\n    frequency_penalty: 0.0,\n    presence_penalty:\
    \ 0.0,\n  }) as CreateCompletionRequest;\n  const { data } = await openai.createCompletion(request);\n\
    \  console.log(data?.choices[0]?.text);\n\n  return JSON.parse(data?.choices[0]?.text.replaceAll('\"\
    ', '\"') ?? \"\");\n}\n"
  original_instructions: |-
    Create Translation in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- edit_instructions: |2

    Modify the script to filter the returned users by a specific email domain, only including users with email addresses that match the domain.
  id: |-
    hubedit_hub_349
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * @param start_cursor If supplied, only results starting after the cursor will be returned.
     * @param page_size The number of items in the response. Maximum is `100`.
     * @param email_domain The email domain to filter users by.
     *
     * Learn more at
     * https://developers.notion.com/reference/get-users
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      start_cursor?: string | undefined,
      page_size?: number | undefined,
      email_domain?: string | undefined,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        page_size,
        start_cursor,
      });

      const response = await client.users.list(args);
      if (email_domain) {
        response.results = response.results.filter(user => {
          return user.person?.email?.endsWith(`@${email_domain}`);
        });
      }
      return response;
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * @param start_cursor If supplied, only results starting after the cursor will be returned.
     *
     * @param page_size The number of items in the response. Maximum is `100`.
     *
     * Learn more at
     * https://developers.notion.com/reference/get-users
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      start_cursor?: string | undefined,
      page_size?: number | undefined,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        page_size,
        start_cursor,
      });
      return await client.users.list(args);
    }
  original_instructions: |-
    List Users in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- edit_instructions: |2

    Add an option to attach files to the email by accepting an array of objects containing file paths and their corresponding filenames, then modify the messageObject to include these attachments in the appropriate format for the SendGrid API.
  id: |-
    hubedit_hub_215
  lang: |-
    deno
  modified_code: |-
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";
    import { readFile } from "fs/promises";

    /**
     * @param is_message_html If `true` then the message will be sent and parsed as HTML,
     * otherwise it will be sent as plain text.
     */
    type Sendgrid = {
      token: string;
    };

    type Attachment = {
      path: string;
      filename: string;
    };

    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string[],
      subject: string,
      message: string,
      is_message_html: boolean,
      attachments?: Attachment[],
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, any> = {
        to,
        from,
        subject,
      };
      messageObject[is_message_html ? "html" : "text"] = message;

      if (attachments && attachments.length > 0) {
        const processedAttachments = await Promise.all(
          attachments.map(async (attachment) => {
            const content = await readFile(attachment.path, { encoding: 'base64' });
            return {
              content,
              filename: attachment.filename,
              type: 'application/octet-stream', // You might want to determine the type based on the file extension
              disposition: 'attachment',
              content_id: attachment.filename,
            };
          })
        );
        messageObject.attachments = processedAttachments;
      }

      try {
        return await sendgrid.send(messageObject, true);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_code: |
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";

    /**
     * @param is_message_html If `true` then the message will be sent and parsed as HTML,
     * otherwise it will be sent as plain text.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string[],
      subject: string,
      message: string,
      is_message_html: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, string | string[]> = {
        to,
        from,
        subject,
      };
      messageObject[is_message_html ? "html" : "text"] = message;

      try {
        return await sendgrid.send(messageObject, true);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Send Email Multiple Recipients in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- edit_instructions: |2

    Add error handling to provide a more informative response if the deletion fails, such as logging the error or returning a custom error message.
  id: |-
    hubedit_hub_49
  lang: |-
    deno
  modified_code: |-
    type Gdrive = {
      token: string;
    };

    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      try {
        const response = await fetch(DELETE_FILE_URL, {
          method: "DELETE",
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });

        if (!response.ok) {
          const errorBody = await response.text();
          throw new Error(`Failed to delete file: ${response.status} ${response.statusText} - ${errorBody}`);
        }

        return await response.text();
      } catch (error) {
        // Log the error or return a custom error message
        console.error("Error during file deletion:", error.message);
        return `Error during file deletion: ${error.message}`;
      }
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Delete File in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to retry the failed schedule automatically after a certain delay and report the retry attempt in the Slack message.
  id: |-
    hubedit_hub_1030
  lang: |-
    deno
  modified_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string,
      is_flow: boolean,
      schedule_path: string,
      error: object,
      started_at: string,
      failed_times: number,
      slack: Slack,
      channel: string,
      retryDelay: number = 5, // Delay in minutes before retrying the schedule
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      // Retry logic
      const retryTime = dayjs().add(retryDelay, 'minute').format("DD.MM.YYYY HH:mm (Z)");
      // Here you would add the logic to actually retry the schedule
      // For example, you could make an HTTP request to an endpoint that triggers the schedule

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        } and will be retried at ${retryTime}`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> failed*${
                failed_times > 1 ? (" " + failed_times + " times in a row") : ""
              } and will be retried at ${retryTime}:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            color: "#ff0000",
            "blocks": [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": `Last failure at: ${
                  dayjs(started_at).format("DD.MM.YYYY HH:mm (Z)")
                }\n${formatError(error)}`,
              },
            }],
          },
        ],
      });
    }
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      started_at: string, // The start datetime of the latest job that failed
      failed_times: number, // Minimum number of times the schedule failed before calling the error handler
      slack: Slack,
      channel: string,
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> failed*${
                failed_times > 1 ? (" " + failed_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            color: "#ff0000",
            "blocks": [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": `Last failure at: ${
                  dayjs(started_at).format("DD.MM.YYYY HH:mm (Z)")
                }\n${formatError(error)}`,
              },
            }],
          },
        ],
      });
    }
  original_instructions: |-
    Schedule error handler in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to create a new document in a specified collection within the database instead of retrieving a database's details.
  id: |-
    hubedit_hub_328
  lang: |-
    deno
  modified_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    type DocumentData = {
      [key: string]: any;
    };

    export async function createDocument(
      auth: Appwrite,
      databaseId: string,
      collectionId: string,
      data: DocumentData
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(databaseId, collectionId, 'unique()', data);
    }
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, id: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.get(id);
    }
  original_instructions: |-
    Get Database in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add a feature to log the response status and status text to the console before returning the response text.
  id: |-
    hubedit_hub_264
  lang: |-
    deno
  modified_code: |-
    export async function main(
      auth: Faunadb,
      schema: string,
      mode: "merge" | "replace" | "override" = "merge",
    ) {
      const region = ["us", "eu"].includes(auth.region) ? auth.region : "";
      const response = await fetch(
        `https://graphql.${region}.fauna.com/import?mode=${mode}`,
        {
          method: "POST",
          headers: {
            Authorization: "Bearer " + auth.secret,
          },
          body: schema,
        },
      );

      console.log(`Response Status: ${response.status} (${response.statusText})`);

      return await response.text();
    }
  original_code: |
    /**
     * Learn more at
     * https://docs.fauna.com/fauna/current/api/graphql/endpoints#import
     */
    type Faunadb = {
      region: string;
      secret: string;
    };
    export async function main(
      auth: Faunadb,
      schema: string,
      mode: "merge" | "replace" | "override" = "merge",
    ) {
      const region = ["us", "eu"].includes(auth.region) ? auth.region : "";
      const response = await fetch(
        `https://graphql.${region}.fauna.com/import?mode=${mode}`,
        {
          method: "POST",
          headers: {
            Authorization: "Bearer " + auth.secret,
          },
          body: schema,
        },
      );
      return await response.text();
    }
  original_instructions: |-
    Import GraphQL schema in faunadb
  resource_type: |-
    Faunadb
  resource_type_def: |-
    type Faunadb = {
      region: string;
      secret: string;
    }
- edit_instructions: |2

    Modify the script to filter and return only message updates that contain a specific keyword in the text.
  id: |-
    hubedit_hub_232
  lang: |-
    deno
  modified_code: |-
    import { Telegram } from "npm:telegraf@4.11";
    import { UpdateType } from "npm:telegraf@4.11/typings/telegram-types";

    /**
     * @param keyword The specific keyword to filter messages by.
     * @param limit Number of elements in the returned list.
     * Defaults to 100 and must be between 1-100.
     * @param offset Identifier of the first update to be returned.
     * @param allowed_updates The update types that should be received.
     * Read more about types at
     * https://core.telegram.org/bots/api#update
     */
    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      keyword: string,
      limit = 100,
      offset = 0,
      allowed_updates?: UpdateType[],
    ) {
      const client = new Telegram(auth.token);
      const updates = await client.getUpdates(
        offset,
        limit,
        allowed_updates || ['message'],
      );

      // Filter updates to only include messages with the specified keyword
      const filteredUpdates = updates.filter(update =>
        update.message?.text?.includes(keyword)
      );

      return filteredUpdates;
    }
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";
    import { UpdateType } from "npm:telegraf@4.11/typings/telegram-types";

    /**
     * @param limit Number of elements in the returned list.
     * Defaults to 100 and must be between 1-100.
     *
     * @param offset Identifier of the first update to be returned.
     *
     * @param allowed_updates The update types that should be received.
     * Read more about types at
     * https://core.telegram.org/bots/api#update
     */
    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      limit = 100,
      offset = 0,
      allowed_updates?: UpdateType[],
    ) {
      const client = new Telegram(auth.token);
      return await client.getUpdates(
        0,
        limit,
        offset,
        allowed_updates || undefined,
      );
    }
  original_instructions: |-
    List Chats in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter the results to include only resources with a specific tag, such as "education".
  id: |-
    hubedit_hub_168
  lang: |-
    deno
  modified_code: |-
    export async function main(tag: string = 'education') {
      const url = "https://hub.windmill.dev/searchResourceData";
      const response = await fetch(url);
      const data = await response.json();

      const filteredResources = data.resources.filter((resource: any) =>
        resource.tags && resource.tags.includes(tag)
      );

      return { resources: filteredResources };
    }
  original_code: "// Should return {resources: [{\u2026},\u2026]}\n\nexport async\
    \ function main() {\n  const url = \"https://hub.windmill.dev/searchResourceData\"\
    ;\n  const response = await fetch(url);\n  return await response.json();\n}\n"
  original_instructions: |-
    List Resource Types in windmillhub
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to filter the returned user list to include only users who are currently active on Slack.
  id: |-
    hubedit_hub_299
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import { SlackAPI } from "https://deno.land/x/deno_slack_api@1.6.0/mod.ts";

    type Slack = {
      token: string;
    };

    export async function main(auth: Slack, cursor?: string, limit?: number) {
      const client = SlackAPI(auth.token);
      const params = removeObjectEmptyFields({ cursor, limit });
      const response = await client.users.list(params);

      // Filter the user list to include only active users
      const activeUsers = response.members.filter(user => user.deleted === false && user.is_bot === false && user.presence === 'active');

      return activeUsers;
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import { SlackAPI } from "https://deno.land/x/deno_slack_api@1.6.0/mod.ts";

    /**
     * @param cursor Paginate the list of users by setting the cursor parameter
     * to a `next_cursor` attribute returned by a previous request's
     * `response_metadata`. Default value fetches the first "page" of the users.
     * Used in conjunction with `limit`.
     *
     * @param limit The maximum number of users to return. Fewer than the
     * requested number of users may be returned, even if the end of the result
     * list hasn't been reached.
     * Used in conjunction with `cursor`.
     */
    type Slack = {
      token: string;
    };
    export async function main(auth: Slack, cursor?: string, limit?: number) {
      const client = SlackAPI(auth.token);
      const params = removeObjectEmptyFields({ cursor, limit });
      return await client.users.list(params);
    }
  original_instructions: |-
    List Users in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to create a new user instead of deleting one, by using the `create` method from the `Users` class with appropriate user details.
  id: |-
    hubedit_hub_325
  lang: |-
    deno
  modified_code: |-
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    export async function main(auth: Appwrite, email: string, password: string, name?: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.create('unique()', email, password, name);
    }
  original_code: |
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, id: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.delete(id);
    }
  original_instructions: |-
    Delete User in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add functionality to save the response from the OpenAI API to a local file in JSON format.
  id: |-
    hubedit_hub_245
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.1.0";
    import { writeJson } from "https://deno.land/std/fs/mod.ts";

    /**
     * You can read about the parameters at
     * https://beta.openai.com/docs/api-reference/completions/create
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      model = "text-davinci-003",
      prompt?: string,
      suffix?: string,
      max_tokens?: number,
      temperature?: number,
      top_p?: number,
      n?: number,
      stream?: boolean,
      logprobs?: number,
      echo?: boolean,
      stop?: string,
      presence_penalty?: number,
      frequency_penalty?: number,
      best_of?: number,
      logit_bias?: object,
      outputFilePath?: string // Add an optional parameter for the output file path
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request = removeObjectEmptyFields({
        model,
        prompt,
        suffix,
        max_tokens,
        temperature,
        top_p,
        n,
        stream,
        logprobs,
        echo,
        stop,
        presence_penalty,
        frequency_penalty,
        best_of,
        logit_bias,
      }) as CreateCompletionRequest;
      const response = await openai.createCompletion(request);

      // Save the response to a local file in JSON format if outputFilePath is provided
      if (outputFilePath) {
        await writeJson(outputFilePath, response.data);
      }

      return response.data;
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.1.0";

    /**
     * You can read about the parameters at
     * https://beta.openai.com/docs/api-reference/completions/create
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      model = "text-davinci-003",
      prompt?: string,
      suffix?: string,
      max_tokens?: number,
      temperature?: number,
      top_p?: number,
      n?: number,
      stream?: boolean,
      logprobs?: number,
      echo?: boolean,
      stop?: string,
      presence_penalty?: number,
      frequency_penalty?: number,
      best_of?: number,
      logit_bias?: object,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request = removeObjectEmptyFields({
        model,
        prompt,
        suffix,
        max_tokens,
        temperature,
        top_p,
        n,
        stream,
        logprobs,
        echo,
        stop,
        presence_penalty,
        frequency_penalty,
        best_of,
        logit_bias,
      }) as CreateCompletionRequest;
      const response = await openai.createCompletion(request);
      return response.data;
    }
  original_instructions: |-
    Create Completion in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- edit_instructions: |2

    Modify the script to add a new feature that reads data from a specified range in the same sheet before deleting the columns, and logs the data to the console.
  id: |-
    hubedit_hub_70
  lang: |-
    deno
  modified_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
      start_index: number,
      end_index: number,
      readRange: string
    ) {
      const token = gsheets_auth["token"];

      // Read data from the specified range
      const READ_DATA_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${readRange}`;
      try {
        const readResponse = await fetch(READ_DATA_URL, {
          method: "GET",
          headers: {
            Authorization: "Bearer " + token,
          },
        });
        if (!readResponse.ok) {
          throw new Error(`Error reading data: ${readResponse.statusText}`);
        }
        const readData = await readResponse.json();
        console.log("Data from the specified range:", readData);
      } catch (error) {
        console.error("Failed to read data:", error);
        return "Failed to read data.";
      }

      // Delete columns from the specified range
      const DELETE_COLUMN_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;
      const body = {
        requests: [
          {
            deleteDimension: {
              range: {
                sheetId: sheetId,
                dimension: "COLUMNS",
                startIndex: start_index,
                endIndex: end_index,
              },
            },
          },
        ],
      };
      try {
        const deleteResponse = await fetch(DELETE_COLUMN_URL, {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });
        if (!deleteResponse.ok) {
          throw new Error(`Error deleting columns: ${deleteResponse.statusText}`);
        }
        await deleteResponse.json();
        return "Columns deleted.";
      } catch (error) {
        console.error("Failed to delete columns:", error);
        return "Failed to delete columns.";
      }
    }
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
      start_index: number,
      end_index: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_COLUMN_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteDimension: {
              range: {
                sheetId: sheetId,
                dimension: "COLUMNS",
                startIndex: start_index,
                endIndex: end_index,
              },
            },
          },
        ],
      };
      const response = await fetch(DELETE_COLUMN_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.json();

      return "Columns deleted.";
    }
  original_instructions: |-
    Clear Columns in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to the script to also create a new user in the SurrealDB database if the sign-in fails due to the user not existing.
  id: |-
    hubedit_hub_320
  lang: |-
    deno
  modified_code: |-
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    /**
     * @returns The authentication token or a message indicating user creation.
     */
    export async function main(
      url: string,
      user: string,
      password: string,
      namespace?: string,
      database?: string,
      scope?: string,
    ) {
      const client = new Surreal(url);

      try {
        // Attempt to sign in
        return await client.signin({
          user,
          pass: password,
          NS: namespace,
          DB: database,
          SC: scope,
        });
      } catch (error) {
        // Check if the error is due to the user not existing
        if (error.message.includes('user not found')) {
          // Create a new user
          await client.signup({
            user,
            pass: password,
            NS: namespace,
            DB: database,
            SC: scope,
          });
          // Sign in the newly created user
          return await client.signin({
            user,
            pass: password,
            NS: namespace,
            DB: database,
            SC: scope,
          });
        } else {
          // If the error is not due to the user not existing, rethrow it
          throw error;
        }
      }
    }
  original_code: |
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    /**
     * @returns The authenication token.
     */
    export async function main(
      url: string,
      user: string,
      password: string,
      namespace?: string,
      database?: string,
      scope?: string,
    ) {
      const client = new Surreal(url);
      return await client.signin({
        user,
        pass: password,
        NS: namespace,
        DB: database,
        SC: scope,
      });
    }
  original_instructions: |-
    Sign in in surrealdb
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Add error handling to the script to catch and log any network or HTTP errors that might occur during the fetch request.
  id: |-
    hubedit_hub_414
  lang: |-
    deno
  modified_code: |-
    export async function main(
      glab: Gitlab,
      projectId: number,
      releaseTag: string,
    ) {
      try {
        const url = `${glab.baseUrl}/api/v4/projects/${projectId}/releases/${releaseTag}`;
        const response = await fetch(`${url}`, {
          headers: { "PRIVATE-TOKEN": `${glab.token}` },
        });

        if (!response.ok) {
          const error = await response.text();
          console.error(`HTTP Error: ${response.status} ${response.statusText}`, error);
          throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
        }

        return await response.json();
      } catch (error) {
        console.error('Network error:', error);
        throw error;
      }
    }
  original_code: |
    type Gitlab = {
      baseUrl: string;
      token: string;
    };

    export async function main(
      glab: Gitlab,
      projectId: number,
      releaseTag: string,
    ) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/releases/${releaseTag}`;
      const response = await fetch(`${url}`, {
        headers: { "PRIVATE-TOKEN": `${glab.token}` },
      });
      return await response.json();
    }
  original_instructions: |-
    Get release in gitlab
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Add error handling to manage the response when the fetch request fails or the server returns an error status code. Log the error details for debugging purposes.
  id: |-
    hubedit_hub_112
  lang: |-
    deno
  modified_code: |-
    import type { Sql } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      token: string,
      account_id: string,
      database: string,
      schema: string,
      sql: Sql,
    ) {
      const POST_URL = `https://${account_id}.snowflakecomputing.com/api/statements`;

      const body = {
        statement: `${sql}`,
        timeout: 60,
        database: `${database}`,
        schema: `${schema}`,
      };

      try {
        const response = await fetch(POST_URL, {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });

        if (!response.ok) {
          // Response is not OK, log the status and statusText for debugging
          console.error(`Error: ${response.status} ${response.statusText}`);
          // You can also log the response body for more details if needed
          const errorBody = await response.text();
          console.error(`Error Body: ${errorBody}`);
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        // Log the error and rethrow or handle it as needed
        console.error('Fetch error:', error.message);
        throw error; // Rethrow the error if you want the caller to handle it
      }
    }
  original_code: |
    import type { Sql } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      token: string,
      account_id: string,
      database: string,
      schema: string,
      sql: Sql,
    ) {
      const POST_URL = `https://${account_id}.snowflakecomputing.com/api/statements`;

      const body = {
        statement: `${sql}`,
        timeout: 60,
        database: `${database}`,
        schema: `${schema}`,
      };

      const response = await fetch(POST_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Execute Query & Return Results in snowflake
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to verify a given password against the hashed password to confirm if they match or not.
  id: |-
    hubedit_hub_85
  lang: |-
    deno
  modified_code: |-
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string, salt_num: number) {
      const salt = await bcrypt.genSalt(salt_num);
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }

    export async function verifyPassword(password: string, hash_pass: string): Promise<boolean> {
      return await bcrypt.compare(password, hash_pass);
    }
  original_code: |
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string, salt_num: number) {
      const salt = await bcrypt.genSalt(salt_num);
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }
  original_instructions: |-
    Hash Password with Manual Salt in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to validate the `newRecord` object against a predefined schema before attempting to update the record in Airtable, and throw an error if the validation fails.
  id: |-
    hubedit_hub_1022
  lang: |-
    deno
  modified_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };
    type AirtableTable = {
      baseId: string;
      tableName: string;
    };

    // Define the schema for the newRecord object
    type RecordSchema = {
      [key: string]: string | number | boolean;
    };

    // Function to validate the newRecord against the schema
    function validateRecord(newRecord: object, schema: RecordSchema): boolean {
      for (const key in schema) {
        if (!(key in newRecord)) {
          throw new Error(`Validation failed: Missing property '${key}' in newRecord.`);
        }
        const expectedType = typeof schema[key];
        const actualType = typeof (newRecord as any)[key];
        if (actualType !== expectedType) {
          throw new Error(`Validation failed: Property '${key}' should be of type '${expectedType}', but got '${actualType}'.`);
        }
      }
      return true;
    }

    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordId: string,
      newRecord: object,
      schema: RecordSchema,
    ) {
      // Validate the newRecord object
      if (!validateRecord(newRecord, schema)) {
        throw new Error('Record validation failed.');
      }

      const airtable = new Airtable({...atCon, ...atTable});

      const updateSingleRecord = await airtable.update(recordId, newRecord);

      return updateSingleRecord;
    }
  original_code: |
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };
    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordId: string,
      newRecord: object,
    ) {
      const airtable = new Airtable({...atCon, ...atTable});

      const updateSingleRecord = await airtable.update(recordId, newRecord);

      return updateSingleRecord;
    }
  original_instructions: |-
    Update record in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- edit_instructions: |2

    Add an option to specify the style of the generated images, such as photorealistic, oil painting, or pencil sketch, and pass this style preference to the OpenAI createImage API call.
  id: |-
    hubedit_hub_244
  lang: |-
    deno
  modified_code: |-
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";

    /**
     * @param prompt The maximum length is 1000 characters.
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      number_of_images:
        | "1"
        | "2"
        | "3"
        | "4"
        | "5"
        | "6"
        | "7"
        | "8"
        | "9"
        | "10" = "1",
      size: "256x256" | "512x512" | "1024x1024" = "1024x1024",
      response_format: "url" | "b64_json" = "url",
      style: "photorealistic" | "oil painting" | "pencil sketch" = "photorealistic",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createImage({
        prompt: `${prompt}, ${style} style`,
        n: +number_of_images,
        size,
        response_format,
      });
      return response.data.data;
    }
  original_code: |
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";

    /**
     * @param prompt The maximum length is 1000 characters.
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      number_of_images:
        | "1"
        | "2"
        | "3"
        | "4"
        | "5"
        | "6"
        | "7"
        | "8"
        | "9"
        | "10" = "1",
      size: "256x256" | "512x512" | "1024x1024" = "1024x1024",
      response_format: "url" | "b64_json" = "url",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createImage({
        prompt,
        n: +number_of_images,
        size,
        response_format,
      });
      return response.data.data;
    }
  original_instructions: |-
    Generate Image in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- edit_instructions: |2

    Add functionality to filter the search results by a specific Notion page type, such as databases or pages, by including a 'type' parameter in the search arguments.
  id: |-
    hubedit_hub_353
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/post-search
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      query?: string,
      filter?: { property: string; value: string },
      sort?: { timestamp: string; direction: string },
      start_cursor?: string,
      page_size?: number,
      type?: 'database' | 'page', // Add a 'type' parameter to filter by page type
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        query,
        filter: {
          ...filter,
          ...(type ? { property: 'object', value: type } : {}), // Include the 'type' in the filter if provided
        },
        sort,
        start_cursor,
        page_size,
      });
      return await client.search(args);
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/post-search
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      query?: string,
      filter?: { property: string; value: string },
      sort?: { timestamp: string; direction: string },
      start_cursor?: string,
      page_size?: number,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        query,
        filter,
        sort,
        start_cursor,
        page_size,
      });
      return await client.search(args);
    }
  original_instructions: |-
    Search by Title in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to log the timestamp of the user's login attempt, successful or not, to a separate log file or database table.
  id: |-
    hubedit_hub_310
  lang: |-
    deno
  modified_code: |-
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2.10.0";
    import { writeLog } from "./log_utils.ts"; // Assume this is a utility module for logging

    type Supabase = {
      url: string;
      key: string;
    };

    export async function main(auth: Supabase, email: string, password: string) {
      const client = createClient(auth.url, auth.key);
      const { data, error } = await client.auth.signInWithPassword({
        email,
        password,
      });

      // Log the timestamp and email of the login attempt
      const timestamp = new Date().toISOString();
      const logEntry = {
        timestamp,
        email,
        success: !error,
        errorMessage: error?.message,
      };
      await writeLog(logEntry); // This function should handle writing to a log file or database table

      if (error) {
        return {
          access_token: undefined,
          refresh_token: undefined,
          error: error.message,
        };
      }
      return {
        access_token: data?.session?.access_token,
        refresh_token: data?.session?.refresh_token,
        error: undefined,
      };
    }
  original_code: |
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2.10.0";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(auth: Supabase, email: string, password: string) {
      const client = createClient(auth.url, auth.key);
      const { data, error } = await client.auth.signInWithPassword({
        email,
        password,
      });
      if (error) {
        return {
          access_token: undefined,
          refresh_token: undefined,
          error: error.message,
        };
      }
      return {
        access_token: data?.session?.access_token,
        refresh_token: data?.session?.refresh_token,
        error: undefined,
      };
    }
  original_instructions: |-
    Authenticate with email and password in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- edit_instructions: |2

    Modify the script to filter the returned block children by a specific type, such as only returning "paragraph" or "heading" blocks.
  id: |-
    hubedit_hub_354
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/get-block-children
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      block_id: string,
      start_cursor?: string,
      page_size?: number,
      typeFilter: string = 'paragraph', // Add a parameter to specify the type of block to filter
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        block_id,
        start_cursor,
        page_size,
      });

      // Fetch the block children from Notion
      const response = await client.blocks.children.list(args);

      // Filter the results to include only blocks of the specified type
      const filteredBlocks = response.results.filter(block => block.type === typeFilter);

      // Return the filtered blocks
      return filteredBlocks;
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/get-block-children
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      block_id: string,
      start_cursor?: string,
      page_size?: number,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        block_id,
        start_cursor,
        page_size,
      });
      return await client.blocks.children.list(args);
    }
  original_instructions: |-
    Retrieve Block Children in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to write data to the spreadsheet by changing the method to "POST" and including a request body with the data to be written.
  id: |-
    hubedit_hub_52
  lang: |-
    deno
  modified_code: |-
    type Gsheets = {
      token: string;
    };

    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      range: string,
      values: any[][], // Assuming values is a 2D array as required by the Google Sheets API
    ) {
      const token = gsheets_auth["token"];

      const WRITE_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}:append?valueInputOption=USER_ENTERED`;

      const requestBody = {
        values: values,
      };

      const response = await fetch(WRITE_VALUES_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
        body: JSON.stringify(requestBody),
      });

      return await response.text();
    }
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      range: string,
    ) {
      const token = gsheets_auth["token"];

      const GET_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}`;

      const response = await fetch(GET_VALUES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Get Values in Range in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter and return only users who have logged in within the last 24 hours.
  id: |-
    hubedit_hub_324
  lang: |-
    deno
  modified_code: |-
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      // Calculate the timestamp for 24 hours ago
      const date24HoursAgo = new Date();
      date24HoursAgo.setHours(date24HoursAgo.getHours() - 24);
      const timestamp24HoursAgo = Math.floor(date24HoursAgo.getTime() / 1000);

      // Create a query to filter users who have logged in within the last 24 hours
      const query = `lastLogin>=${timestamp24HoursAgo}`;

      return await users.list([query]);
    }
  original_code: |
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.list(queries, search);
    }
  original_instructions: |-
    List Users in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add functionality to log the moderation response to a local file for record-keeping purposes.
  id: |-
    hubedit_hub_246
  lang: |-
    deno
  modified_code: |-
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";
    import { writeFileSync } from "fs";

    type Openai = {
      api_key: string;
      organization_id: string;
    };

    export async function main(
      auth: Openai,
      prompt: string,
      model:
        | "text-moderation-latest"
        | "text-moderation-stable" = "text-moderation-latest",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createModeration({
        input: prompt,
        model,
      });

      // Log the moderation response to a local file
      logToFile(response.data);

      return response.data;
    }

    function logToFile(data: any) {
      const timestamp = new Date().toISOString();
      const fileName = `moderation-log-${timestamp}.json`;
      const content = JSON.stringify(data, null, 2);
      writeFileSync(fileName, content);
    }
  original_code: |
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      model:
        | "text-moderation-latest"
        | "text-moderation-stable" = "text-moderation-latest",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createModeration({
        input: prompt,
        model,
      });
      return response.data;
    }
  original_instructions: |-
    Create Moderation in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- edit_instructions: |-
    Add a feature to reverse the input message string before logging it and returning it in the response object.
  id: |-
    hubedit_hub_158
  lang: |-
    deno
  modified_code: |-
    export async function main(message: string, name: string) {
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      const reversedMessage = message.split('').reverse().join('');
      console.log("reversed message", reversedMessage);
      console.log("name", name);
      return { message: reversedMessage, flow_id };
    }
  original_code: |
    export async function main(message: string, name: string) {
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      console.log("message", message);
      console.log("name", name);
      return { message, flow_id };
    }
  original_instructions: |-
    Log error in windmill
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to include error handling by checking the response status and throwing an error with a custom message if the response status is not in the successful range (200-299).
  id: |-
    hubedit_hub_58
  lang: |-
    deno
  modified_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, title: string) {
      const supportsAllDrives = true;
      const CREATE_FOLDER_URL = `https://www.googleapis.com/drive/v3/files?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];
      const body = {
        name: title,
        mimeType: "application/vnd.google-apps.folder",
      };
      const response = await fetch(CREATE_FOLDER_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`Error creating folder: ${response.status} ${response.statusText} - ${errorBody}`);
      }

      return await response.json();
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, title: string) {
      const supportsAllDrives = true;
      const CREATE_FOLDER_URL = `https://www.googleapis.com/drive/v3/file/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];
      const body = {
        name: title,
        mimeType: "application/vnd.google-apps.folder",
      };
      const response = await fetch(CREATE_FOLDER_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Create Folder in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add error handling to the script to catch and log any exceptions that may occur during the execution of the `airtable.create` method.
  id: |-
    hubedit_hub_1025
  lang: |-
    deno
  modified_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };

    export async function main(
      atCon: AirtableConfig,
      atTable: AirtableTable,
      recordList: object[],
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      try {
        const createMultiple = await airtable.create(recordList);
        return createMultiple;
      } catch (error) {
        console.error("An error occurred while creating records:", error);
        // Depending on the requirements, you might want to rethrow the error or handle it differently
        throw error;
      }
    }
  original_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordList: object[],
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      const createMultiple = await airtable.create(recordList);

      return createMultiple;
    }
  original_instructions: |-
    Create Multiple Records in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- edit_instructions: |2

    Add functionality to list all open issues for the specified repository.
  id: |-
    hubedit_hub_313
  lang: |-
    deno
  modified_code: |-
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     */
    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({ auth: gh_auth.token });

      const response = await octokit.rest.issues.listForRepo({
        owner,
        repo,
        state: 'open',
      });

      return response.data.map(issue => ({
        id: issue.id,
        number: issue.number,
        title: issue.title,
        url: issue.html_url,
      }));
    }
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     */
    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request("GET /repos/{owner}/{repo}", {
        owner,
        repo,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  original_instructions: |-
    Get Repo in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- edit_instructions: |2

    Add a filter parameter to the API request to only return users who have logged in within the last 24 hours.
  id: |-
    hubedit_hub_1033
  lang: |-
    deno
  modified_code: |-
    export async function main() {
      const workspace = Deno.env.get("WM_WORKSPACE");
      const baseUrl = Deno.env.get('WM_BASE_URL');
      const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
      const url = `${baseUrl}/api/w/${workspace}/users/list?lastLogin=${last24Hours}`;
      const response = await fetch(url, {
        headers: {
          "Authorization": "Bearer " + Deno.env.get("WM_TOKEN") || "",
        },
      });

      if (response.statusText.toUpperCase() != "OK") {
        let errorMsg: string;
        if (response.headers.get("Content-Type")?.includes("json")) {
          errorMsg = await response.json();
        } else {
          errorMsg = await response.text();
        }
        throw new Error(`${response.status} ${response.statusText}: ${errorMsg}`);
      }
      const jsonData = await response.json();
      return jsonData;
    }
  original_code: |
    // import * as wmill from "npm:windmill-client@1"

    export async function main() {
      const workspace = Deno.env.get("WM_WORKSPACE");
      const baseUrl = Deno.env.get('WM_BASE_URL')
      const url = `${baseUrl}/api/w/${workspace}/users/list`;
      const response = await fetch(url, {
        headers: {
          "Authorization": "Bearer " + Deno.env.get("WM_TOKEN") || "",
        },
      });

      if (response.statusText.toUpperCase() != "OK") {
        let errorMsg: string;
        if (response.headers.get("Content-Type")?.includes("json")) {
          errorMsg = await response.json();
        } else {
          errorMsg = await response.text();
        }
        throw new Error(`${response.status} ${response.statusText}: ${errorMsg}`);
      }
      const jsonData = await response.json();
      return jsonData;
    }
  original_instructions: |-
    Get list of users from current workspace in windmill
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to attach images or files to the issue by uploading them to the repository and referencing them in the issue body.
  id: |-
    hubedit_hub_315
  lang: |-
    deno
  modified_code: |-
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };

    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      title: string,
      body: string,
      assignees?: string[],
      milestone?: string | number,
      labels?: string[],
      files?: { name: string; content: string }[], // Base64 encoded content
    ) {
      const octokit = new Octokit({ auth: gh_auth.token });

      let issueBody = body;

      if (files && files.length > 0) {
        for (const file of files) {
          // Upload each file as a separate commit to the repository
          const { data: { content } } = await octokit.repos.createOrUpdateFileContents({
            owner,
            repo,
            path: `images/${file.name}`, // Assuming a directory named 'images' for storing files
            message: `Add file ${file.name} for issue`,
            content: file.content, // File content should be base64 encoded
          });

          // Append the uploaded image URL to the issue body
          issueBody += `\n\n![${file.name}](${content.download_url})`;
        }
      }

      return await octokit.request("POST /repos/{owner}/{repo}/issues", {
        owner,
        repo,
        title,
        body: issueBody,
        assignees: assignees || [],
        milestone,
        labels,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     *
     * @param title The title of the new issue.
     *
     * @param body The body of the new issue.
     *
     * @param assignees Logins for Users to assign to this issue.
     * *NOTE*: Only users with push access can set assignees for new issues.
     * Assignees are silently dropped otherwise.
     *
     * @param milestone The number of the milestone to associate this issue with.
     * *NOTE*: Only users with push access can set the milestone for new issues.
     * The milestone is silently dropped otherwise.
     *
     * @param labels Labels to associate with this issue.
     * *NOTE*: Only users with push access can set labels for new issues.
     * Labels are silently dropped otherwise.
     */
    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      title: string,
      body: string,
      assignees?: string[],
      milestone?: string | number,
      labels?: string[],
    ) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request("POST /repos/{owner}/{repo}/issues", {
        owner,
        repo,
        title,
        body,
        assignees: assignees || [],
        milestone,
        labels,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  original_instructions: |-
    Create Issue in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to update existing cells instead of appending by changing the method to "PUT" and adjusting the URL to target a specific range for updates.
  id: |-
    hubedit_hub_37
  lang: |-
    deno
  modified_code: |-
    export async function main(
      gsheets_auth: Gsheets,
      sheet_id: string,
      values: Array<Array<any>>,
      range: string
    ) {
      const body = {
        values: values,
      };

      const valueInputOption = "USER_ENTERED";
      const UPDATE_URL = `https://sheets.googleapis.com/v4/spreadsheets/${sheet_id}/values/${range}?valueInputOption=${valueInputOption}`;

      const token = gsheets_auth["token"];

      const response = await fetch(UPDATE_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return { result: result };
    }
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      sheet_id: string,
      values: Array<Array<any>>,
      range: string = "Sheet1",
    ) {
      const body = {
        values: values,
      };

      const valueInputOption = "USER_ENTERED";
      const insertDataOption = "INSERT_ROWS";
      const includeValuesInResponse = true;
      const APPEND_URL = `https://sheets.googleapis.com/v4/spreadsheets/${sheet_id}/values/${range}:append/?valueInputOption=${valueInputOption}&insertDataOption=${insertDataOption}&includeValuesInResponse=${includeValuesInResponse}`;

      const token = gsheets_auth["token"];

      const response = await fetch(APPEND_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return { result: result };
    }
  original_instructions: |-
    Add Rows in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to update the status of an issue by sending a PATCH request to the GitLab API with the new status.
  id: |-
    hubedit_hub_146
  lang: |-
    deno
  modified_code: |-
    export async function updateIssueStatus(glab: Gitlab, projectId: number, issueId: number, newStatus: string) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/issues/${issueId}`;
      const response = await fetch(url, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${glab.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ state_event: newStatus })
      });

      if (!response.ok) {
        throw new Error(`Failed to update issue status: ${response.statusText}`);
      }

      return await response.json();
    }
  original_code: |
    /*
    @param: {Gitlab} glab - Resource containing Gitlab Auth API Key
    Example:
    {
      auth: gitlab_api_key,
      baseUrl: "https://www.gitlab.com"
    }
    */
    type Gitlab = {
      baseUrl: string;
      token: string;
    };
    export async function main(glab: Gitlab, projectId: number, issueId: number) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/issues/${issueId}`;
      const issue = await fetch(`${url}`, {
        headers: { Authorization: `Bearer: ${glab.token}` },
      });
      return await issue.json();
    }
  original_instructions: |-
    Get Issue in gitlab
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter and return only customers with a specific email domain, such as "@example.com".
  id: |-
    hubedit_hub_265
  lang: |-
    deno
  modified_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import Stripe from "https://esm.sh/stripe@11.4.0?target=deno";

    type StripeAuth = {
      token: string;
    };
    export async function main(auth: StripeAuth) {
      const stripe = new Stripe(auth.token, {
        httpClient: Stripe.createFetchHttpClient(),
      });
      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const customers = await stripe.customers.list({
        created: { gt: lastCheck },
      });
      const filteredCustomers = customers.data.filter((customer) =>
        customer.email?.endsWith("@example.com")
      );
      return filteredCustomers;
    }
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import Stripe from "https://esm.sh/stripe@11.4.0?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(auth: Stripe) {
      const stripe = new Stripe(auth.token, {
        httpClient: Stripe.createFetchHttpClient(),
      });
      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const customers = await stripe.customers.list({
        created: { gt: lastCheck },
      });
      return customers.data;
    }
  original_instructions: |-
    Get recently added customers in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter the 'asks' array to include only items where the price is less than a specified value before returning the result.
  id: |-
    hubedit_hub_170
  lang: |-
    deno
  modified_code: |-
    export async function main(maxPrice: number) {
      const url = "https://hub.windmill.dev/searchData";
      const response = await fetch(url);
      const data = await response.json();

      const filteredAsks = data.asks.filter((ask: any) => ask.price < maxPrice);

      return { asks: filteredAsks };
    }
  original_code: "// Should return {asks: [{\u2026},\u2026]}\n\nexport async function\
    \ main() {\n  const url = \"https://hub.windmill.dev/searchData\";\n  const response\
    \ = await fetch(url);\n  return await response.json();\n}\n"
  original_instructions: |-
    List suggestions in windmillhub
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the script to permanently delete the file instead of moving it to trash by adding the query parameter `?supportsAllDrives=${supportsAllDrives}&alt=json` to the DELETE_FILE_URL.
  id: |-
    hubedit_hub_59
  lang: |-
    deno
  modified_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}?supportsAllDrives=${supportsAllDrives}&alt=json`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return "file permanently deleted";
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v2/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return "file moved to trash";
    }
  original_instructions: |-
    Move File to Trash in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add error handling to manage the case when the fetch request fails or the server returns a non-200 status code.
  id: |-
    hubedit_hub_369
  lang: |-
    deno
  modified_code: |-
    export async function main(nocodb: Nocodb, limit: number) {
      try {
        const response = await fetch(
          `${nocodb.apiUrl}/api/v1/db/data/v1/${nocodb.workspace}/${nocodb.table}?limit=${limit}`,
          {
            headers: {
              "Content-Type": "application/json",
              "xc-token": nocodb.xc_token,
            },
          },
        );

        if (!response.ok) {
          const errorBody = await response.text();
          throw new Error(`Error from server: ${response.status} ${response.statusText} - ${errorBody}`);
        }

        const data = await response.json();
        return data;
      } catch (error) {
        // Handle network error, JSON parsing error, or any thrown error
        console.error('Error fetching data:', error);
        throw error; // Re-throw the error to be handled by the caller
      }
    }
  original_code: |
    type Nocodb = {
      apiUrl: string;
      xc_token: string;
      table: string;
      workspace: string;
    };
    export async function main(nocodb: Nocodb, limit: number) {
      // request from nocodb
      const res = await fetch(
        `${nocodb.apiUrl}/api/v1/db/data/v1/${nocodb.workspace}/${nocodb.table}?limit=${limit}`,
        {
          headers: {
            "Content-Type": "application/json",
            "xc-token": nocodb.xc_token,
          },
        },
      );
      const data = await res.json();
      return data;
    }
  original_instructions: |-
    Get item list from a NocoDb table in nocodb
  resource_type: |-
    Nocodb
  resource_type_def: |-
    type Nocodb = {
      apiUrl: string;
      xc_token: string;
      table: string;
      workspace: string;
    }
- edit_instructions: |2

    Modify the script to include a function that lists all objects in a specified bucket before uploading the new object.
  id: |-
    hubedit_hub_108
  lang: |-
    deno
  modified_code: |-
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.2.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };

    export async function listObjects(s3: S3) {
      const client = new S3Client(s3);
      return await client.listObjects(s3.bucket);
    }

    export async function main(s3: S3, path: string, content: string) {
      // List objects before uploading the new one
      const objects = await listObjects(s3);
      console.log('Existing objects in the bucket:', objects);

      // Upload the new object
      return await new S3Client(s3).putObject(path, content);
    }
  original_code: |
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.2.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, path: string, content: string) {
      return await new S3Client(s3).putObject(path, content);
    }
  original_instructions: |-
    Upload text in bucket in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- edit_instructions: |2

    Modify the script to parse the XML response and convert it into a JSON object before returning it.
  id: |-
    hubedit_hub_163
  lang: |-
    deno
  modified_code: |-
    import { DOMParser } from "https://deno.land/x/deno_dom/deno-dom-wasm.ts";

    export async function main(nextcloud_res: Nextcloud) {
      const resp = await fetch(`${nextcloud_res.baseUrl}/ocs/v1.php/cloud/users`, {
        headers: {
          Authorization:
            "Basic " + btoa(nextcloud_res.username + ":" + nextcloud_res.password),
          "OCS-APIRequest": "true",
        },
      });
      if (!resp.ok) {
        throw Error(`HTTP Error ${resp.status} - ${await resp.text()}`);
      }
      const xml = await resp.text();
      const doc = new DOMParser().parseFromString(xml, "text/xml");
      if (!doc) {
        throw new Error("Error parsing XML");
      }

      const json = xmlToJson(doc.documentElement);
      return json;
    }

    function xmlToJson(xml: Element): any {
      const obj: any = {};
      if (xml.hasChildNodes()) {
        for (let i = 0; i < xml.childNodes.length; i++) {
          const item = xml.childNodes.item(i);
          const nodeName = item.nodeName;
          if (typeof obj[nodeName] === "undefined") {
            obj[nodeName] = xmlToJson(item);
          } else {
            if (typeof obj[nodeName].push === "undefined") {
              const old = obj[nodeName];
              obj[nodeName] = [old];
            }
            obj[nodeName].push(xmlToJson(item));
          }
        }
      } else {
        obj[xml.nodeName] = xml.textContent?.trim();
      }
      return obj;
    }
  original_code: |
    // Should return an XML document on success
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    };
    export async function main(nextcloud_res: Nextcloud) {
      const resp = await fetch(`${nextcloud_res.baseUrl}/ocs/v1.php/cloud/users`, {
        headers: {
          Authorization:
            "Basic " + btoa(nextcloud_res.username + ":" + nextcloud_res.password),
          "OCS-APIRequest": "true",
        },
      });
      if (!resp.ok) {
        throw Error(`HTTP Error ${resp.status} - ${await resp.text()}`);
      }
      return await resp.text();
    }
  original_instructions: |-
    List user IDs in ocs
  resource_type: |-
    Nextcloud
  resource_type_def: |-
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    }
- edit_instructions: |2

    Add a feature to filter the results by a specific field value, allowing the user to pass in a field name and a value to match against that field.
  id: |-
    hubedit_hub_356
  lang: |-
    deno
  modified_code: |-
    import { where } from "npm:firebase/firestore/lite";

    export async function main(
      auth: Firebase,
      collection_id: string,
      order_by?: string,
      order_direction: "asc" | "desc" = "asc",
      start_at?: number | string,
      end_at?: number | string,
      limit?: number,
      filter_field?: string,
      filter_value?: any
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const colRef = collection(store, collection_id);
      const constraints = [
        order_by ? orderBy(order_by, order_direction) : undefined,
        start_at ? startAt(start_at) : undefined,
        end_at ? endAt(end_at) : undefined,
        limit ? limitItems(limit) : undefined,
        filter_field && filter_value !== undefined ? where(filter_field, "==", filter_value) : undefined,
      ].filter(Boolean) as QueryConstraint[];
      const snapshot = await getDocs(query(colRef, ...constraints));
      const list = snapshot.docs.map((doc) => doc.data());

      return list;
    }
  original_code: |
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import {
      collection,
      endAt,
      getDocs,
      getFirestore,
      limit as limitItems,
      orderBy,
      query,
      QueryConstraint,
      startAt,
    } from "npm:firebase/firestore/lite";

    /**
     * @param order_by Name of the field to order by.
     *
     * @param start_at Can only be used if `order_by` is present,
     * because it'll filter based on the value of that field.
     *
     * @param end_at Can only be used if `order_by` is present,
     * because it'll filter based on the value of that field.
     */
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      order_by?: string,
      order_direction: "asc" | "desc" = "asc",
      start_at?: number | string,
      end_at?: number | string,
      limit?: number,
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const colRef = collection(store, collection_id);
      const constraints = [
        order_by ? orderBy(order_by, order_direction) : undefined,
        start_at ? startAt(start_at) : undefined,
        end_at ? endAt(end_at) : undefined,
        limit ? limitItems(limit) : undefined,
      ].filter(Boolean) as QueryConstraint[];
      const snapshot = await getDocs(query(colRef, ...constraints));
      const list = snapshot.docs.map((doc) => doc.data());

      return list;
    }
  original_instructions: |-
    List Documents in firebase
  resource_type: |-
    Firebase
  resource_type_def: |-
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    }
- edit_instructions: |2

    Modify the script to unpin a chat message instead of pinning it by using the `unpinChatMessage` method of the Telegram client.
  id: |-
    hubedit_hub_239
  lang: |-
    deno
  modified_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type TelegramAuth = {
      token: string;
    };
    export async function main(
      auth: TelegramAuth,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.unpinChatMessage(chat_id, message_id);
    }
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.pinChatMessage(chat_id, message_id);
    }
  original_instructions: |-
    Pin a Message in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to filter the returned room state events by a specific event type provided as an additional argument to the main function.
  id: |-
    hubedit_hub_160
  lang: |-
    deno
  modified_code: |-
    export async function main(matrix_res: Matrix, room_id: string, event_type?: string) {
      const url = `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state${event_type ? `/${encodeURIComponent(event_type)}` : ''}`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return {
        events: await resp.json(),
      };
    }
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room_id: string) {
      const url = `${
        matrix_res.baseUrl
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return {
        events: await resp.json(),
      };
    }
  original_instructions: |-
    Get entire room state in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Modify the script to add a new worksheet to the spreadsheet instead of deleting one.
  id: |-
    hubedit_hub_67
  lang: |-
    deno
  modified_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      title: string, // Changed parameter to accept the title of the new worksheet
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            addSheet: {
              properties: {
                title: title, // Set the title for the new worksheet
              },
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteSheet: {
              sheetId: sheetId,
            },
          },
        ],
      };

      const response = await fetch(DELETE_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Delete Worksheet in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to log the response status and status text to the console before throwing an error, to help with debugging.
  id: |-
    hubedit_hub_201
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * Find more information about the parameters at
     * https://mailchimp.com/developer/marketing/api/campaigns/add-campaign/
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      type: "regular" | "plaintext" | "rss" | "variate",
      content_type: "template" | "multichannel" = "template",
      rss_opts?: Record<string, any>,
      recipients?: Record<string, any>,
      variate_settings?: Record<string, any>,
      settings?: Record<string, any>,
      tracking?: Record<string, any>,
      social_card?: Record<string, any>,
    ) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns`;
      const body = {
        type,
        content_type,
        rss_opts,
        recipients,
        variate_settings,
        settings,
        tracking,
        social_card,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        console.error(`Response Status: ${response.status} - ${response.statusText}`);
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * Find more information about the parameters at
     * https://mailchimp.com/developer/marketing/api/campaigns/add-campaign/
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      type: "regular" | "plaintext" | "rss" | "variate",
      content_type: "template" | "multichannel" = "template",
      rss_opts?: Record<string, any>,
      recipients?: Record<string, any>,
      variate_settings?: Record<string, any>,
      settings?: Record<string, any>,
      tracking?: Record<string, any>,
      social_card?: Record<string, any>,
    ) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns`;
      const body = {
        type,
        content_type,
        rss_opts,
        recipients,
        variate_settings,
        settings,
        tracking,
        social_card,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Create Campaign in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- edit_instructions: |2

    Add functionality to attach an image to the message when editing it by accepting an image URL as an additional parameter and using the appropriate method from the discordwebhook library to attach the image to the message.
  id: |-
    hubedit_hub_132
  lang: |-
    deno
  modified_code: |-
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(
      discord_webhook: DiscordWebhook,
      messageId: string,
      newMessageContent: string,
      imageUrl: string,
    ) {
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.editMessage(messageId, {
        content: newMessageContent,
        embeds: [{
          image: {
            url: imageUrl,
          },
        }],
      });
      return ret;
    }
  original_code: |
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(
      discord_webhook: DiscordWebhook,
      messageId: string,
      newMessageContent: string,
    ) {
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.editMessage(messageId, newMessageContent);
      return ret;
    }
  original_instructions: |-
    Edit message in discord
  resource_type: |-
    DiscordWebhook
  resource_type_def: |-
    type DiscordWebhook = {
      webhook_url: string;
    }
- edit_instructions: |2

    Modify the script to filter the results by a specific list name by adding a query string parameter for the list name in the request object.
  id: |-
    hubedit_hub_223
  lang: |-
    deno
  modified_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param page_size Maximum number of elements to return. Defaults to 100, returns 1000 max.
     * @param page_token Token corresponding to a specific page of results.
     * @param list_name Name of the list to filter by.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      page_size?: number,
      page_token?: number,
      list_name?: string,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "GET",
        qs: {
          page_size,
          page_token,
          ...(list_name && { list_name }), // Add list_name to the query string if provided
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param page_size Maximum number of elements to return. Defaults to 100, returns 1000 max.
     *
     * @param page_token Token corresponding to a specific page of results.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      page_size?: number,
      page_token?: number,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "GET",
        qs: {
          page_size,
          page_token,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Get Contact Lists in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to update a specific property of the Notion page with a new value provided as an additional argument to the main function.
  id: |-
    hubedit_hub_351
  lang: |-
    deno
  modified_code: |-
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/update-a-page
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      page_id: string,
      property_name: string,
      property_value: any
    ) {
      const client = new Client({ auth: auth.token });

      // Construct the properties update payload
      const propertiesToUpdate = {
        [property_name]: property_value,
      };

      // Update the page with the new property value
      return await client.pages.update({
        page_id,
        properties: propertiesToUpdate,
      });
    }
  original_code: |
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/retrieve-a-page
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      page_id: string,
      filter_properties?: string[],
    ) {
      const client = new Client({ auth: auth.token });
      if (!filter_properties?.filter(Boolean).length) {
        filter_properties = undefined;
      }
      return await client.pages.retrieve({
        page_id,
        filter_properties,
      });
    }
  original_instructions: |-
    Retrieve Page in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- edit_instructions: |-
    Add a feature to update an existing user if the HTTP 422 error is encountered, indicating that the user already exists. This should send a PUT request to the user's endpoint with the updated information.
  id: |-
    hubedit_hub_155
  lang: |-
    deno
  modified_code: |-
    export async function main(
      zammad_host: string,
      zammad_token: string,
      user_agent?: string,
      firstname: string,
      lastname: string,
      email: string,
      login?: string,
      organisation?: string,
      roles?: string[],
    ) {
      // https://docs.zammad.org/en/latest/api/user.html#create
      let resp = await fetch(`${zammad_host}/api/v1/users`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${zammad_token}`,
          "User-Agent": user_agent ?? "Public windmill.dev script",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          firstname,
          lastname,
          email,
          ...(login && { login }),
          ...(organisation && { organisation }),
          ...(roles && { roles }),
        }),
      });

      // If user already exists, update the user
      if (resp.status === 422) {
        // Retrieve the existing user's ID using the email address
        const searchResp = await fetch(`${zammad_host}/api/v1/users/search?query=${encodeURIComponent(email)}`, {
          method: "GET",
          headers: {
            Authorization: `Bearer ${zammad_token}`,
            "User-Agent": user_agent ?? "Public windmill.dev script",
          },
        });

        if (!searchResp.ok) {
          throw Error(`Failed to search for user: Error HTTP${searchResp.status}`);
        }

        const users = await searchResp.json();
        if (!Array.isArray(users) || users.length === 0) {
          throw Error(`User with email ${email} not found for update.`);
        }

        const userId = users[0].id;

        // Update the existing user
        resp = await fetch(`${zammad_host}/api/v1/users/${userId}`, {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${zammad_token}`,
            "User-Agent": user_agent ?? "Public windmill.dev script",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            firstname,
            lastname,
            email,
            ...(login && { login }),
            ...(organisation && { organisation }),
            ...(roles && { roles }),
          }),
        });

        if (!resp.ok) {
          throw Error(`Failed to update user: Error HTTP${resp.status}`);
        }
      } else if (!resp.ok) {
        throw Error(`Failed to create user: Error HTTP${resp.status}`);
      }

      return await resp.json();
    }
  original_code: |
    export async function main(
      zammad_host: string,
      zammad_token: string,
      user_agent?: string,
      firstname: string,
      lastname: string,
      email: string,
      login?: string,
      organisation?: string,
      roles?: string[],
    ) {
      // https://docs.zammad.org/en/latest/api/user.html#create
      const resp = await fetch(`${zammad_host}/api/v1/users`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${zammad_token}`,
          "User-Agent": user_agent ?? "Public windmill.dev script",
        },
        body: JSON.stringify({
          firstname,
          lastname,
          email,
          ...(login && { login }),
          ...(organisation && { organisation }),
          ...(roles && { roles }),
        }),
      });
      // HTTP 422 means that the user already exists.
      if (!resp.ok && resp.status !== 422) {
        throw Error(`Failed to create user: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  original_instructions: |-
    Create user in zammad
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to update a document with new data instead of deleting it, by using the `updateDocument` method from the `Databases` class.
  id: |-
    hubedit_hub_338
  lang: |-
    deno
  modified_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
      data: Record<string, any>, // Added parameter to accept new data for the document
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      // Using updateDocument instead of deleteDocument
      return await db.updateDocument(database_id, collection_id, document_id, data);
    }
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.deleteDocument(database_id, collection_id, document_id);
    }
  original_instructions: |-
    Delete Document in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add functionality to verify a given password against the previously generated hash to check if the password is correct or not.
  id: |-
    hubedit_hub_86
  lang: |-
    deno
  modified_code: |-
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string) {
      const salt = await bcrypt.genSalt();
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }

    export async function verifyPassword(password: string, hash: string): Promise<boolean> {
      return await bcrypt.compare(password, hash);
    }
  original_code: |
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string) {
      const salt = await bcrypt.genSalt();
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }
  original_instructions: |-
    Hash Password with Random Salt in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add error handling to gracefully manage and log any exceptions that may occur during the database connection, query execution, or client closure.
  id: |-
    hubedit_hub_319
  lang: |-
    deno
  modified_code: |-
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";
    import { log } from "./logger.ts"; // Assuming you have a logger module

    /**
     * @param query The query string.
     * @param variables The variables used in the query.
     */
    type Surrealdb = {
      url: string;
      token: string;
    };
    export async function main(
      auth: Surrealdb,
      namespace: string,
      database: string,
      query: string,
      variables?: Record<string, unknown>,
    ) {
      const client = new Surreal(auth.url, auth.token);
      try {
        await client.use(namespace, database);
        const result = await client.query(query, variables);
        return result;
      } catch (error) {
        log(`Error occurred: ${error.message}`);
        throw error; // Re-throw the error after logging it, if you want the caller to handle it as well.
      } finally {
        try {
          client.close();
        } catch (closeError) {
          log(`Error occurred while closing the client: ${closeError.message}`);
        }
      }
    }
  original_code: |
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    /**
     * @param query The query string.
     * @param variables The variables used in the query.
     */
    type Surrealdb = {
      url: string;
      token: string;
    };
    export async function main(
      auth: Surrealdb,
      namespace: string,
      database: string,
      query: string,
      variables?: Record<string, unknown>,
    ) {
      const client = new Surreal(auth.url, auth.token);
      await client.use(namespace, database);
      const result = await client.query(query, variables);
      client.close();
      return result;
    }
  original_instructions: |-
    Run Arbitrary Query in surrealdb
  resource_type: |-
    Surrealdb
  resource_type_def: |-
    type Surrealdb = {
      url: string;
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter the results by a specific collection ID within the database.
  id: |-
    hubedit_hub_327
  lang: |-
    deno
  modified_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param collectionId The ID of the collection to filter results by.
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      collectionId: string,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.listDocuments(collectionId, queries, search);
    }
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.list(queries, search);
    }
  original_instructions: |-
    List Databases in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |-
    Add an option to attach files to the email by modifying the `main` function to accept an array of file paths, then use the `attachment` property in the `mg.messages.create` method to include these files in the email.
  id: |-
    hubedit_hub_396
  lang: |-
    deno
  modified_code: |-
    import formData from "npm:form-data@4.0.0";
    import MailgunClient from "npm:mailgun.js@9.1.0";
    import { fileFromPath } from "npm:form-data@4.0.0";

    interface Mailgun {
      api_key: string;
    }

    export async function main(
      mailgunConfig: Mailgun,
      domain: string,
      from: string,
      to: string[],
      subject: string,
      templateName: string,
      replyTo?: string,
      substitutions: Record<string, string>,
      attachments?: string[], // Add an optional parameter for file paths
    ) {
      const mailgun = new MailgunClient(formData);
      const mg = mailgun.client({ username: "api", key: mailgunConfig.api_key });

      try {
        // Prepare the attachments if provided
        const attachmentData = attachments
          ? await Promise.all(attachments.map((path) => fileFromPath(path)))
          : undefined;

        const result = await mg.messages.create(domain, {
          from,
          to,
          subject,
          template: templateName,
          "h:X-Mailgun-Variables": JSON.stringify(substitutions),
          ...(replyTo && { "h:Reply-To": replyTo }),
          ...(attachmentData && { attachment: attachmentData }), // Include attachments if any
        });

        return result;
      } catch (error) {
        console.error(error);
        throw error;
      }
    }
  original_code: |
    import formData from "npm:form-data@4.0.0";
    import MailgunClient from "npm:mailgun.js@9.1.0";

    interface Mailgun {
      api_key: string;
    }

    export async function main(
      mailgunConfig: Mailgun,
      domain: string,
      from: string,
      to: string[],
      subject: string,
      templateName: string,
      replyTo?: string,
      substitutions: Record<string, string>,
    ) {
      const mailgun = new MailgunClient(formData);
      const mg = mailgun.client({ username: "api", key: mailgunConfig.api_key });

      try {
        const result = await mg.messages.create(domain, {
          from,
          to,
          subject,
          template: templateName,
          "h:X-Mailgun-Variables": JSON.stringify(substitutions),
          ...(replyTo && { "h:Reply-To": replyTo }),
        });

        return result;
      } catch (error) {
        console.error(error);
        throw error;
      }
    }
  original_instructions: |-
    Send an email based on a mailgun template in mailgun
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a feature to filter the RSS feed items by a specific keyword or phrase provided in the `rss_feed` object, returning only items that contain the keyword in their title or description.
  id: |-
    hubedit_hub_297
  lang: |-
    deno
  modified_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { parse } from "https://deno.land/x/xml/mod.ts";

    type Rss = {
      url: string;
      keyword?: string;
    };
    export async function main(rss_feed: Rss) {
      const rss_feed_url = rss_feed.url;
      const keyword = rss_feed.keyword?.toLowerCase();
      let feedStates = (await wmill.getInternalState()) || {};
      const newestItem: Date = new Date(feedStates[rss_feed_url] || 0);

      const items = await fetch(rss_feed_url)
        .then((response) => response.text())
        .then((str) => parse(str))
        .then((feed) => {
          let items = [];
          if (feed["rss"]) {
            items = rss2_items(feed);
          } else if (feed["feed"]) {
            items = atom_items(feed);
          }
          const new_items = items.filter((item) => item.pubDate > newestItem);
          if (keyword) {
            return new_items.filter((item) =>
              item.title.toLowerCase().includes(keyword) ||
              (item.description && item.description.toLowerCase().includes(keyword))
            );
          }
          return new_items;
        });

      if (items.length > 0) {
        let newState = (await wmill.getInternalState()) || {};
        const dates = items.map((item) => item.pubDate);
        newState[rss_feed_url] = new Date(Math.max(...dates));
        await wmill.setInternalState(newState);
      }

      return items.reverse();
    }

    function rss2_items(feed) {
      var items = feed["rss"]["channel"]["item"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: item.title,
        description: item.description,
        link: item.link,
        pubDate: new Date(item.pubDate),
      }));
    }

    function atom_items(feed) {
      var items = feed["feed"]["entry"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: typeof item.title === "string" ? item.title : item.title["#text"],
        description: item.summary ? (typeof item.summary === "string" ? item.summary : item.summary["#text"]) : undefined,
        link:
          item.link instanceof Array ? item.link[0]["@href"] : item.link["@href"],
        pubDate: new Date(item.updated),
      }));
    }
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { parse } from "https://deno.land/x/xml/mod.ts";

    type Rss = {
      url: string;
    };
    export async function main(rss_feed: Rss) {
      const rss_feed_url = rss_feed.url;
      let feedStates = (await wmill.getInternalState()) || {};
      const newestItem: Date = new Date(feedStates[rss_feed_url] || 0);

      const items = await fetch(rss_feed_url)
        .then((response) => response.text())
        .then((str) => parse(str))
        .then((feed) => {
          let items = [];
          if (feed["rss"]) {
            items = rss2_items(feed);
          } else if (feed["feed"]) {
            items = atom_items(feed);
          }
          const new_items = items.filter((item) => item.pubDate > newestItem);
          return new_items;
        });

      if (items.length > 0) {
        let newState = (await wmill.getInternalState()) || {};
        const dates = items.map((item) => item.pubDate);
        newState[rss_feed_url] = new Date(Math.max(...dates));
        await wmill.setInternalState(newState);
      }

      return items.reverse();
    }

    function rss2_items(feed) {
      var items = feed["rss"]["channel"]["item"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: item.title,
        link: item.link,
        pubDate: new Date(item.pubDate),
      }));
    }

    function atom_items(feed) {
      var items = feed["feed"]["entry"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: typeof item.title === "string" ? item.title : item.title["#text"],
        link:
          item.link instanceof Array ? item.link[0]["@href"] : item.link["@href"],
        pubDate: new Date(item.updated),
      }));
    }
  original_instructions: |-
    RSS Feed Fetcher in RSS
  resource_type: |-
    Rss
  resource_type_def: |-
    type Rss = {
      url: string;
    }
- edit_instructions: |2

    Modify the script to send a new message to the chat after unpinning the message, informing the chat members that a message has been unpinned.
  id: |-
    hubedit_hub_240
  lang: |-
    deno
  modified_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type TelegramAuth = {
      token: string;
    };

    export async function main(
      auth: TelegramAuth,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      await client.unpinChatMessage(chat_id, message_id);
      return await client.sendMessage(chat_id, "A message has been unpinned.");
    }
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.unpinChatMessage(chat_id, message_id);
    }
  original_instructions: |-
    Unpin a Message in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to send a welcome message to the room immediately after joining it.
  id: |-
    hubedit_hub_97
  lang: |-
    deno
  modified_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };

    export async function main(matrix_res: Matrix, room: string, welcomeMessage: string) {
      if (!matrix_res.token) {
        throw Error("Joining a room requires an access token.");
      }

      // Join the room
      const joinResp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/join/${encodeURIComponent(room)}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
          },
        },
      );

      if (!joinResp.ok) {
        throw Error(`Failed to join room: Error HTTP${joinResp.status}`);
      }

      // Parse the response to get the room ID
      const roomData = await joinResp.json();
      const roomId = roomData.room_id;

      // Send a welcome message to the room
      const sendResp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/send/m.room.message`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            msgtype: "m.text",
            body: welcomeMessage,
          }),
        },
      );

      if (!sendResp.ok) {
        throw Error(`Failed to send welcome message: Error HTTP${sendResp.status}`);
      }
    }
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room: string) {
      if (!matrix_res.token) {
        throw Error("Joining a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/join/${encodeURIComponent(room)}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
          },
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to join room: Error HTTP${resp.status}`);
      }
    }
  original_instructions: |-
    Join room in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Modify the script to log the `resumePayload` to the console before resuming the suspended flow.
  id: |-
    hubedit_hub_271
  lang: |-
    deno
  modified_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(id: string, resumePayload?: object) {
      console.log("Resuming with payload:", resumePayload);

      return wmill.JobService.resumeSuspendedFlowAsOwner({
        workspace: wmill.getWorkspace(),
        id,
        requestBody: resumePayload ?? {},
      });
    }
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(id: string, resumePayload?: object) {
      return wmill.JobService.resumeSuspendedFlowAsOwner({
        workspace: wmill.getWorkspace(),
        id,
        requestBody: resumePayload ?? {},
      });
    }
  original_instructions: |-
    Resume Suspended Flow as Owner in windmill
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to update the content of the specified block instead of retrieving it, using the `client.blocks.update` method with new content provided as an additional parameter.
  id: |-
    hubedit_hub_352
  lang: |-
    deno
  modified_code: |-
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/update-a-block
     */
    type Notion = {
      token: string;
    };
    export async function main(auth: Notion, block_id: string, newContent: any) {
      const client = new Client({ auth: auth.token });
      return await client.blocks.update({
        block_id,
        ...newContent
      });
    }
  original_code: |
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/retrieve-a-block
     */
    type Notion = {
      token: string;
    };
    export async function main(auth: Notion, block_id: string) {
      const client = new Client({ auth: auth.token });
      return await client.blocks.retrieve({ block_id });
    }
  original_instructions: |-
    Retrieve Block in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to unban a user by creating a new function that calls the `unbanChatMember` method of the Telegram client, using the `chat_id` and `user_id` as parameters.
  id: |-
    hubedit_hub_238
  lang: |-
    deno
  modified_code: |-
    export async function unbanUser(
      auth: Telegram,
      chat_id: string,
      user_id: number
    ) {
      const client = new Telegram(auth.token);
      return await client.unbanChatMember(chat_id, user_id);
    }
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    /**
     * @param until_date Unix time. If user is banned for more than
     * 366 days or less than 30 seconds from the current time they
     * are considered to be banned forever.
     *
     * @param revoke_messages If `true` then the banned user's messages
     * will be deleted from the chat.
     */
    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      user_id: number,
      until_date?: number,
      revoke_messages?: boolean | undefined,
    ) {
      const client = new Telegram(auth.token);
      return await client.banChatMember(chat_id, user_id, until_date || undefined, {
        revoke_messages,
      });
    }
  original_instructions: |-
    Kick a Chat Member in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to add a new worksheet to the spreadsheet instead of updating cells in an existing sheet.
  id: |-
    hubedit_hub_66
  lang: |-
    deno
  modified_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      title: string, // Changed from sheetId to title for the new worksheet
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            addSheet: {
              properties: {
                title: title, // Set the title for the new worksheet
              },
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            updateCells: {
              range: {
                sheetId: sheetId,
              },
              fields: "userEnteredValue",
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Clear All Values in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to create a new collection in the specified database instead of listing the collections.
  id: |-
    hubedit_hub_330
  lang: |-
    deno
  modified_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param collectionData Data needed to create a new collection.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    type CollectionData = {
      databaseId: string;
      collectionId: string;
      name: string;
      permissions?: {
        read?: string[];
        write?: string[];
      };
      rules: {
        label: string;
        key: string;
        type: string;
        default?: any;
        required?: boolean;
        array?: boolean;
        list?: any[];
      }[];
    };
    export async function main(
      auth: Appwrite,
      collectionData: CollectionData,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createCollection(
        collectionData.databaseId,
        collectionData.collectionId,
        collectionData.name,
        collectionData.permissions?.read,
        collectionData.permissions?.write,
        collectionData.rules,
      );
    }
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.listCollections(database_id, queries, search);
    }
  original_instructions: |-
    List Collections in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add an option to the function to specify sorting order by a given column, allowing the user to retrieve deleted rows in either ascending or descending order based on that column.
  id: |-
    hubedit_hub_285
  lang: |-
    deno
  modified_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };

    type SortOrder = "asc" | "desc";

    export async function main(
      auth: Supabase,
      table: string,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_deleted: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      sort?: {
        column: string;
        order: SortOrder;
      }
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .delete({ count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_deleted) {
          query = query.select();
          if (sort) {
            query = query.order(sort.column, { ascending: sort.order === "asc" });
          }
        }

        return query;
      });
    }
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param filter Learn more at https://supabase.com/docs/reference/javascript/filter
     *
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_deleted: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .delete({ count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_deleted) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Delete data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- edit_instructions: |2

    Modify the script to filter the new listenings by a specific artist name provided as an additional parameter to the main function.
  id: |-
    hubedit_hub_161
  lang: |-
    deno
  modified_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    type Funkwhale = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      auth: Funkwhale,
      artistName: string, // Added artistName parameter
      query?: string,
      scope = "all",
      page_size = 10,
    ) {
      const previousState = await getState();
      const url = new URL("/api/v1/history/listenings", auth.baseUrl);
      const params = { query, scope, page_size };
      Object.entries(params).forEach(([key, value]) => {
        value && url.searchParams.append(key, encodeURIComponent(value));
      });
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const data = await response.json();
      data.results.reverse();

      const newListenings = [];
      let latestId;
      for (const listening of data.results) {
        if (latestId === undefined || listening.id > latestId) {
          latestId = listening.id;
        }
        if (
          previousState?.latestId !== undefined &&
          listening.id <= previousState.latestId
        ) {
          continue;
        }
        // Check if the artist name matches the provided artistName parameter
        if (listening.track.artist.name === artistName) {
          newListenings.push(listening);
        }
      }

      if (latestId !== undefined) {
        await setState({
          latestId,
        });
      }
      return newListenings;
    }
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    /**
     * **IMPORTANT:** This does not return listenings on the first run.
     *
     * You can read more about the Listenings History API at
     * https://docs.funkwhale.audio/swagger/#/User%20activity/get_api_v1_history_listenings
     */
    type Funkwhale = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      auth: Funkwhale,
      query?: string,
      scope = "all",
      page_size = 10,
    ) {
      const previousState = await getState();
      const url = new URL("/api/v1/history/listenings", auth.baseUrl);
      const params = { query, scope, page_size };
      Object.entries(params).forEach(([key, value]) => {
        value && url.searchParams.append(key, encodeURIComponent(value));
      });
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const data = await response.json();
      data.results.reverse();

      const newListenings = [];
      let latestId;
      for (const listening of data.results) {
        if (latestId === undefined || listening.id > latestId) {
          latestId = listening.id;
        }
        if (
          previousState?.latestId !== undefined &&
          listening.id <= previousState.latestId
        ) {
          continue;
        }
        newListenings.push(listening);
      }

      if (latestId !== undefined) {
        await setState({
          latestId,
        });
      }
      return newListenings;
    }
  original_instructions: |-
    Watch for new listenings in funkwhale
  resource_type: |-
    Funkwhale
  resource_type_def: |-
    type Funkwhale = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Add functionality to the script to create a new document in the specified collection with data provided as an argument to the main function.
  id: |-
    hubedit_hub_332
  lang: |-
    deno
  modified_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_data: Record<string, any>,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(
        database_id,
        collection_id,
        document_data,
        document_permissions,
      );
    }
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      collection_id: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
      collection_enabled?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.updateCollection(
        database_id,
        collection_id,
        collection_name,
        collection_permissions,
        collection_document_security,
        collection_enabled,
      );
    }
  original_instructions: |-
    Update Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |-
    Modify the function to accept an optional third parameter that allows the user to specify if the random number should be even or odd.
  id: |-
    hubedit_hub_101
  lang: |-
    deno
  modified_code: |-
    export async function main(min = 0, max = 100, parity?: 'even' | 'odd') {
      let randomNumber: number;
      do {
        randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
      } while (parity === 'even' && randomNumber % 2 !== 0 || parity === 'odd' && randomNumber % 2 !== 1);
      return randomNumber;
    }
  original_code: |
    export async function main(min = 0, max = 100) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
  original_instructions: |-
    Random Integer in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to log the result of the update operation to the console, including the number of documents matched and the number of documents modified.
  id: |-
    hubedit_hub_261
  lang: |-
    deno
  modified_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     *
     * @param filter For example: `{ "_id": "01234" }`
     *
     * @param upsert If `true` and no documents match the `filter`,
     * then a new document will be created with the values of `document`.
     * Default is `false`.
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
      document: Record<string, any>,
      upsert?: boolean,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);
      upsert = typeof upsert === "boolean" ? upsert : undefined;
      const result = await docs.updateOne(filter, document, { upsert });

      // Log the result of the update operation
      console.log(`Matched: ${result.matchedCount}, Modified: ${result.modifiedCount}`);

      return result;
    }
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     *
     * @param filter For example: `{ "_id": "01234" }`
     *
     * @param upsert If `true` and no documents match the `filter`,
     * then a new document will be created with the values of `document`.
     * Default is `false`.
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
      document: Record<string, any>,
      upsert?: boolean,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);
      upsert = typeof upsert === "boolean" ? upsert : undefined;
      return await docs.updateOne(filter, document, { upsert });
    }
  original_instructions: |-
    Update a Document in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- edit_instructions: |2

    Add functionality to the script to handle a new custom command that triggers a specific action, such as fetching a random joke from an external API and returning it as the message content.
  id: |-
    hubedit_hub_377
  lang: |-
    deno
  modified_code: |-
    import {
      InteractionResponseType,
      InteractionType,
      verifyKey,
    } from "npm:discord-interactions@3.4.0";

    type DiscordBotConfiguration = {
      public_key: string;
      application_id: string;
    };

    // Define a function to fetch a random joke from an external API
    async function fetchRandomJoke(): Promise<string> {
      try {
        const response = await fetch('https://icanhazdadjoke.com/', {
          headers: { 'Accept': 'application/json' }
        });
        if (!response.ok) {
          throw new Error('Failed to fetch joke');
        }
        const data = await response.json();
        return data.joke;
      } catch (error) {
        console.error('fetchRandomJoke error:', error);
        return 'Failed to fetch a joke, please try again later.';
      }
    }

    export async function main(
      x_signature_ed25519: string,
      x_signature_timestamp: string,
      raw_string: string,
      discord_config: DiscordBotConfiguration,
    ) {
      const isVerified = verifyKey(
        raw_string,
        x_signature_ed25519,
        x_signature_timestamp,
        discord_config.public_key,
      );

      if (!isVerified) {
        return { windmill_status_code: 401 };
      }

      const interaction = JSON.parse(raw_string);
      const type = interaction.type as InteractionType;

      if (type === InteractionType.PING) {
        return { type: InteractionResponseType.PONG };
      }

      if (type === InteractionType.APPLICATION_COMMAND) {
        // Check if the command is the custom command to fetch a joke
        if (interaction.data.name === 'joke') {
          const joke = await fetchRandomJoke();
          return {
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: joke,
            },
          };
        }

        // Handle other commands
        const message = `Received command: \`\`\`json\n${JSON.stringify(
          {
            id: interaction.id,
            sender: interaction.member?.user,
            data: interaction.data,
          },
          undefined,
          2,
        )}\`\`\``;

        return {
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: message,
          },
        };
      }
    }
  original_code: |
    // Getting started:
    // If you don't have a discord application yet, follow step 1 to get your application created and registered to your server
    //   https://discord.com/developers/docs/getting-started#step-1-creating-an-app

    // Navigate to your application in the Discord developer portal: https://discord.com/developers/applications

    // Create a new discord_bot_configuration resource with the public_key and application_id fields from the discord portal
    // Populate the DEFUALT_DISCORD_CONFIG variable below with the path to your new resource

    // Next we deploy this script to Windmill and register it as the "Interactions Endpoint URL"
    //   Get the endpoint for the sync version: https://docs.windmill.dev/docs/core_concepts/webhooks#synchronous
    //   Include query parameters for your token as well as capturing the raw body and headers to verify the signature
    //   {DEPLOYED_SCRIPT_SYNC_WEBHOOK}?include_header=X-Signature-Ed25519,X-Signature-Timestamp&raw=true&token={YOUR_TOKEN}

    // Finally we need to create a discord command and register it with our application:
    //   https://discord.com/developers/docs/interactions/application-commands#making-a-global-command

    // Now you should be able to use your registered command in discord and see the bot reply with some of the json payload

    import {
      InteractionResponseType,
      InteractionType,
      verifyKey,
    } from "npm:discord-interactions@3.4.0";

    type DiscordBotConfiguration = {
      public_key: string;
      application_id: string;
    };
    export async function main(
      x_signature_ed25519: string,
      x_signature_timestamp: string,
      raw_string: string,
      discord_config: DiscordBotConfiguration,
    ) {
      // We'll need the http request body as a string and the two headers to verify the request signature
      // https://discord.com/developers/docs/interactions/receiving-and-responding#security-and-authorization
      const isVerified = verifyKey(
        raw_string,
        x_signature_ed25519,
        x_signature_timestamp,
        discord_config.public_key,
      );

      // If we can't verify the request, we return 401.
      // We will be tested when we submit the interaction webhook to discord
      if (!isVerified) {
        return { windmill_status_code: 401 };
      }

      const interaction = JSON.parse(raw_string);

      // If we get a PING, we need to respond with a PONG
      // https://discord.com/developers/docs/interactions/receiving-and-responding#responding-to-an-interaction
      const type = interaction.type as InteractionType;
      if (type === InteractionType.PING) {
        return { type: InteractionResponseType.PONG };
      }

      // At this point we can process the interaction and can handle here or delegate to another script/flow
      // https://discord.com/developers/docs/interactions/receiving-and-responding#interactions-and-bot-users
      if (type === InteractionType.APPLICATION_COMMAND) {
        const message = `Received command: \`\`\`json\n${JSON.stringify(
          {
            id: interaction.id,
            sender: interaction.member?.user,
            data: interaction.data,
          },
          undefined,
          2,
        )}\`\`\``;

        return {
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: message,
          },
        };
      }
    }
  original_instructions: |-
    Receive Application Command Sample in discord
  resource_type: |-
    DiscordBotConfiguration
  resource_type_def: |-
    type DiscordBotConfiguration = {
      public_key: string;
      application_id: string;
    }
- edit_instructions: |2

    Add functionality to specify a new name for the copied file by including a 'name' property in the request body.
  id: |-
    hubedit_hub_57
  lang: |-
    deno
  modified_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string, newName: string) {
      const supportsAllDrives = true;
      const COPY_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/copy/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];
      const body = {
        name: newName, // Add the new name property to the request body
      };

      const response = await fetch(COPY_FILE_URL, {
        method: "POST",
        body: JSON.stringify(body), // Include the body in the request
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const COPY_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/copy/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(COPY_FILE_URL, {
        method: "POST",
        //body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Copy File in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to log the execution time of the SQL query by capturing the timestamp before and after the query execution, then calculate the difference and print it to the console.
  id: |-
    hubedit_hub_366
  lang: |-
    deno
  modified_code: |-
    import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts";

    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
      tls?: {
        enabled: boolean;
        enforce: boolean;
        caCertificates: string[];
      };
    };

    type Cacertificate = {
      certificate: string;
    };

    export async function main(
      dbConfig: Postgresql,
      cacertificate: Cacertificate,
      sql: string = "SELECT 1 as id",
    ) {
      dbConfig.tls = {
        enabled: true,
        enforce: true,
        caCertificates: [cacertificate.certificate],
      };
      const client = new Client(dbConfig);
      await client.connect();

      const start = performance.now(); // Capture the start time
      const res = await client.queryObject(sql);
      const end = performance.now(); // Capture the end time

      await client.end();

      console.log(`Query execution time: ${(end - start).toFixed(2)}ms`); // Log the execution time

      return res.rows;
    }
  original_code: |
    import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts";

    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    };

    type Cacertificate = {
      certificate: string;
    };
    export async function main(
      dbConfig: Postgresql,
      cacertificate: Cacertificate,
      sql: string = "SELECT 1 as id",
    ) {
      dbConfig.tls = {
        enabled: true,
        enforce: true,
        caCertificates: [cacertificate.certificate],
      };
      const client = new Client(dbConfig);
      await client.connect();

      const res = await client.queryObject(sql);

      await client.end();

      return res.rows;
    }
  original_instructions: |-
    Postgres with TLS  / SSL  in postgresql
  resource_type: |-
    Postgresql
  resource_type_def: |-
    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    }
- edit_instructions: |2

    Modify the script to filter the shared drives by name by setting the `q` variable to a search query such as `"name contains 'YourDriveName'"`.
  id: |-
    hubedit_hub_61
  lang: |-
    deno
  modified_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, driveName: string) {
      const q = `name contains '${driveName}'`;
      const SEARCH_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives?q=${encodeURIComponent(q)}`;

      const token = gdrive_auth["token"];

      const response = await fetch(SEARCH_SHARED_DRIVE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive) {
      const q = "";
      const SEARCH_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?q=${q}`;

      const token = gdrive_auth["token"];

      const response = await fetch(SEARCH_SHARED_DRIVE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Search Shared Drives in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to assign roles to the user during creation by modifying the `users.create` method to include an additional parameter for roles.
  id: |-
    hubedit_hub_323
  lang: |-
    deno
  modified_code: |-
    import { Client, ID, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param id ID of the user to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      id?: string,
      email?: string,
      phone?: string,
      password?: string,
      name?: string,
      roles?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.create(
        id || ID.unique(),
        email || undefined,
        phone || undefined,
        password || undefined,
        name || undefined,
        roles || undefined,
      );
    }
  original_code: |
    import { Client, ID, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param id ID of the user to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      id?: string,
      email?: string,
      phone?: string,
      password?: string,
      name?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.create(
        id || ID.unique(),
        email || undefined,
        phone || undefined,
        password || undefined,
        name || undefined,
      );
    }
  original_instructions: |-
    Create User in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Modify the script to create a new document in the specified collection with some predefined data instead of retrieving the collection details.
  id: |-
    hubedit_hub_331
  lang: |-
    deno
  modified_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      documentData: Record<string, any>, // Add a parameter for the document data
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      // Create a new document in the specified collection with the provided data
      return await db.createDocument(database_id, collection_id, documentData);
    }
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.getCollection(database_id, collection_id);
    }
  original_instructions: |-
    Get Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |-
    Add error handling to catch network errors or non-OK HTTP responses and return an appropriate error message instead of the response text.
  id: |-
    hubedit_hub_26
  lang: |-
    deno
  modified_code: |-
    export async function main(url: string, request_type: string) {
      try {
        const req = new Request(url, {
          method: request_type,
        });
        let resp = await fetch(req);

        if (!resp.ok) {
          throw new Error(`HTTP error! status: ${resp.status}`);
        }

        return { response: await resp.text() };
      } catch (error) {
        return { error: `Network or HTTP error: ${error.message}` };
      }
    }
  original_code: |
    export async function main(url: string, request_type: string) {
      const req = new Request(url, {
        method: request_type,
      });
      let resp = await fetch(req);

      return { response: await resp.text() };
    }
  original_instructions: |-
    Send any HTTP Request in http
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add error handling to provide a more informative message if the API request fails, such as when the server returns a status code indicating an error (e.g., 400 or 500 series).
  id: |-
    hubedit_hub_60
  lang: |-
    deno
  modified_code: |-
    export async function main(
      gdrive_auth: Gdrive,
      requestId: string,
      drive_name: string,
    ) {
      const supportsAllDrives = true;
      const CREATE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?requestId=${requestId}`;

      const token = gdrive_auth["token"];
      const body = {
        name: drive_name,
      };

      try {
        const response = await fetch(CREATE_SHARED_DRIVE_URL, {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });

        if (!response.ok) {
          const errorBody = await response.text();
          throw new Error(`Error ${response.status}: ${errorBody}`);
        }

        return await response.text();
      } catch (error) {
        // Log the error or handle it as needed
        console.error('Failed to create shared drive:', error.message);
        throw error; // Re-throw the error if you want to propagate it up the call stack
      }
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      requestId: string,
      drive_name: string,
    ) {
      const supportsAllDrives = true;
      const CREATE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?requestId=${requestId}`;

      const token = gdrive_auth["token"];
      const body = {
        name: drive_name,
      };
      const response = await fetch(CREATE_SHARED_DRIVE_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Create Shared Drive in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to update a document by its ID before returning it, incrementing a specified field's value by one.
  id: |-
    hubedit_hub_255
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import {
      MongoClient,
      ObjectId,
    } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      document_id: string,
      incrementField: string, // Field to increment
      projection?: Record<string, number>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const db = client.database(database);
      const coll = db.collection(collection);

      // Update the document by incrementing the specified field
      const updateResult = await coll.updateOne(
        { _id: new ObjectId(document_id) },
        { $inc: { [incrementField]: 1 } }
      );

      // Check if the update was successful
      if (!updateResult.matchedCount) {
        throw new Error(`Document with ID ${document_id} not found`);
      }

      // Find and return the updated document
      return await coll.findOne(
        { _id: new ObjectId(document_id) },
        removeObjectEmptyFields({ projection }),
      );
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import {
      MongoClient,
      ObjectId,
    } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      document_id: string,
      projection?: Record<string, number>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const db = client.database(database);
      return await db
        .collection(collection)
        .findOne(
          { _id: new ObjectId(document_id) },
          removeObjectEmptyFields({ projection }),
        );
    }
  original_instructions: |-
    Find Document by Id in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- edit_instructions: |2

    Add a feature to compress the image before uploading to Slack to save bandwidth and speed up the upload process.
  id: |-
    hubedit_hub_110
  lang: |-
    deno
  modified_code: |-
    import type { Base64 } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { decode } from "https://deno.land/std@0.152.0/encoding/base64.ts";
    import { compress } from "https://deno.land/x/compress@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };

    export async function main(
      image: Base64,
      channel: string,
      slack: Slack,
      imagename: string = "image.png",
    ) {
      // Decode the base64 image
      const decodedImage = decode(image);

      // Compress the image
      const compressedImage = await compress(decodedImage);

      // Create form data to send the file
      const formData = new FormData();
      formData.append("token", slack.token);
      formData.append("file", new File([compressedImage], imagename));
      formData.append("channels", channel);
      formData.append("filename", imagename);
      formData.append("filetype", "auto"); // Let Slack determine the filetype

      // Upload the file to Slack
      const response = await fetch("https://slack.com/api/files.upload", {
        method: "POST",
        body: formData,
      });

      // Return the JSON response
      return await response.json();
    }
  original_code: |
    import type { Base64 } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { decode } from "https://deno.land/std@0.152.0/encoding/base64.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      image: Base64,
      channel: string,
      slack: Slack,
      imagename: string = "image.png",
    ) {
      const formData = new FormData();
      formData.append("token", slack.token);
      formData.append("file", new File([decode(image)], imagename));
      formData.append("channels", channel);
      formData.append("filename", "image.png");
      formData.append("filetype", imagename);

      return await (
        await fetch("https://slack.com/api/files.upload", {
          method: "POST",
          body: formData,
        })
      ).json();
    }
  original_instructions: |-
    Send an image to channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to specify the visibility of the event (e.g., 'public', 'private') by introducing a new parameter and appending it to the query string in the URL.
  id: |-
    hubedit_hub_46
  lang: |-
    deno
  modified_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventText: string,
      visibility: 'public' | 'private' = 'public', // Added parameter with default value 'public'
    ) {
      const sendUpdates = "all";

      // Appended visibility to the query string
      const QUICK_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/quickAdd/?text=${eventText}&sendUpdates=${sendUpdates}&visibility=${visibility}`;

      const token = gcal_auth["token"];

      const response = await fetch(QUICK_EVENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventText: string,
    ) {
      const sendUpdates = "all";

      const QUICK_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/quickAdd/?text=${eventText}&sendUpdates=${sendUpdates}`;

      const token = gcal_auth["token"];

      const response = await fetch(QUICK_EVENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Create Quick Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to save the file information to a local JSON file after retrieving it from the Slack API.
  id: |-
    hubedit_hub_16
  lang: |-
    deno
  modified_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    import { writeJson } from "https://deno.land/std/fs/mod.ts";

    type Slack = {
      token: string;
    };

    export async function main(
      slack_auth: Slack,
      file: string,
      count?: number,
      page?: number,
    ) {
      const web = new WebClient(slack_auth.token);

      let response = await web.files.info({
        file: file,
        count: count,
        page: page,
      });

      // Save the file information to a local JSON file
      await writeJson(`file_info_${file}.json`, response, { spaces: 2 });

      return { response: response };
    }
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    /*
    @param: {string} file - file ID
    @param: {number} count - Number of items to return per page
    @param: {numb} page - number of pages to return
    */

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      file: string,
      count?: number,
      page?: number,
    ) {
      const web = new WebClient(slack_auth);

      let response = await web.files.info({
        file: file,
        count: count,
        page: page,
      });

      return { response: response };
    }
  original_instructions: |-
    Get File in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- edit_instructions: |2

    Change the function to also accept a parameter for the Stripe API version and include it in the request headers to ensure compatibility with a specific version of the Stripe API.
  id: |-
    hubedit_hub_117
  lang: |-
    deno
  modified_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, cancel_id: string, api_version: string) {
      const STRIPE_CANCEL_PAYOUT_URL = `https://api.stripe.com/v1/payouts/${cancel_id}/cancel`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_CANCEL_PAYOUT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
          "Stripe-Version": api_version,
        },
      });

      return await response.json();
    }
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, cancel_id: string) {
      const STRIPE_CANCEL_PAYOUT_URL = `https://api.stripe.com/v1/payouts/:${cancel_id}/cancel`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_CANCEL_PAYOUT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Cancel a Payment Intent in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to cache the response for a given campaign_id, so that if the same campaign_id is requested again within a certain time frame, the cached data is returned instead of making a new API call.
  id: |-
    hubedit_hub_206
  lang: |-
    deno
  modified_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };

    interface CacheEntry {
      timestamp: number;
      data: any;
    }

    const cache = new Map<string, CacheEntry>();
    const CACHE_DURATION = 5 * 60 * 1000; // Cache duration in milliseconds (e.g., 5 minutes)

    export async function main(
      auth: Mailchimp,
      campaign_id: string,
      fields?: string[],
      exclude_fields?: string[],
    ) {
      const cacheKey = `${campaign_id}-${fields?.join(',')}-${exclude_fields?.join(',')}`;
      const now = Date.now();

      // Check if the data is in the cache and not expired
      if (cache.has(cacheKey)) {
        const cached = cache.get(cacheKey);
        if (cached && now - cached.timestamp < CACHE_DURATION) {
          return cached.data;
        } else {
          cache.delete(cacheKey); // Remove expired data from cache
        }
      }

      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/reports/${campaign_id}`,
      );
      const params = {
        fields,
        exclude_fields,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value?.length) {
          url.searchParams.append(key, value.join(","));
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      const responseData = await response.json();

      // Save the new data in the cache
      cache.set(cacheKey, {
        timestamp: now,
        data: responseData,
      });

      return responseData;
    }
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      campaign_id: string,
      fields?: string[],
      exclude_fields?: string[],
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/reports/${campaign_id}`,
      );
      const params = {
        fields,
        exclude_fields,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value?.length) {
          url.searchParams.append(key, value.join(","));
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Get A Campaign Report in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- edit_instructions: |2

    Add a feature to update an existing document if the document_id is provided and the document already exists in the database.
  id: |-
    hubedit_hub_334
  lang: |-
    deno
  modified_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_data: Record<string | number, any>,
      document_id?: string,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      if (document_id) {
        try {
          // Try to get the document to check if it exists
          const existingDocument = await db.getDocument(database_id, collection_id, document_id);
          if (existingDocument) {
            // If the document exists, update it
            return await db.updateDocument(
              database_id,
              collection_id,
              document_id,
              document_data,
              document_permissions,
            );
          }
        } catch (error) {
          // If the document does not exist, an error will be thrown
          if (error.response && error.response.status === 404) {
            // Document does not exist, proceed to create a new one
          } else {
            // An unexpected error occurred, rethrow it
            throw error;
          }
        }
      }

      // If document_id is not provided or the document does not exist, create a new document
      return await db.createDocument(
        database_id,
        collection_id,
        document_id || ID.unique(),
        document_data,
        document_permissions,
      );
    }
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param document_id ID of the document to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_data: Record<string | number, any>,
      document_id?: string,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(
        database_id,
        collection_id,
        document_id || ID.unique(),
        document_data,
        document_permissions,
      );
    }
  original_instructions: |-
    Create Document in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Modify the script to filter the invoices by a specific customer ID instead of limiting the number of invoices returned.
  id: |-
    hubedit_hub_130
  lang: |-
    deno
  modified_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type StripeConfig = {
      token: string;
    };
    export async function main(stripeConfig: StripeConfig, customerId: string) {
      const token = stripeConfig["token"];
      const stripe = new Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoices = await stripe.invoices.list({
        customer: customerId,
      });

      return await invoices.json();
    }
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoices = await stripe.invoices.list({
        limit: limit,
      });

      return await invoices.json();
    }
  original_instructions: |-
    List Invoices in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to create a new document in the specified collection instead of deleting the collection.
  id: |-
    hubedit_hub_333
  lang: |-
    deno
  modified_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      documentData: object,
      documentId: string = 'unique()'
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(database_id, collection_id, documentId, documentData);
    }
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.deleteCollection(database_id, collection_id);
    }
  original_instructions: |-
    Delete Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- edit_instructions: |2

    Add a feature to the script that allows the user to specify a range of cells to clear in the spreadsheet before updating the new values.
  id: |-
    hubedit_hub_187
  lang: |-
    deno
  modified_code: |-
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      startCell: string,
      values: Array<Array<any>>,
      majorDimension: "ROWS" | "COLUMNS" = "ROWS",
      valueInputOption: "RAW" | "USER_ENTERED" = "USER_ENTERED",
      responseValueRenderOption:
        | "FORMATTED_VALUE"
        | "UNFORMATTED_VALUE"
        | "FORMULA" = "FORMATTED_VALUE",
      responseDateTimeRenderOption:
        | "SERIAL_NUMBER"
        | "FORMATTED_STRING" = "SERIAL_NUMBER",
      clearRange?: string // Optional parameter to specify a range to clear
    ) {
      const token = gsheets_auth["token"];

      // If a clearRange is provided, clear the specified range before updating new values
      if (clearRange) {
        const CLEAR_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${clearRange}:clear`;
        const clearResponse = await fetch(CLEAR_VALUES_URL, {
          method: "POST",
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });

        const clearJson = await clearResponse.json();
        if (clearJson.error) {
          let { code, status, message } = clearJson.error;
          throw Error(`\n${code} ${status} - "${message}"\n`);
        }
      }

      let UPDATE_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${startCell}?includeValuesInResponse=true`;
      UPDATE_VALUES_URL += `&valueInputOption=${valueInputOption}`;
      UPDATE_VALUES_URL += `&responseValueRenderOption=${responseValueRenderOption}`;
      UPDATE_VALUES_URL += `&responseDateTimeRenderOption=${responseDateTimeRenderOption}`;
      const body = {
        values,
        majorDimension,
      };

      const response = await fetch(UPDATE_VALUES_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const json = await response.json();
      if (json.error) {
        let { code, status, message } = json.error;
        throw Error(`\n${code} ${status} - "${message}"\n`);
      }
      return json;
    }
  original_code: |
    /** Update values(s) in the given range.
     *
     * @param startCell Use 'A1' notation.
     * https://developers.google.com/sheets/api/guides/concepts#cell
     *
     * @param responseValueRenderOption Determines how values in the response should be rendered.
     * https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption
     *
     * @param responseDateTimeRenderOption Determines how dates, times, and durations in the response should be rendered.
     * This is ignored if `responseValueRenderOption` is `FORMATTED_VALUE`.
     * https://developers.google.com/sheets/api/reference/rest/v4/DateTimeRenderOption
     */
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      startCell: string,
      values: Array<Array<any>>,
      majorDimension: "ROWS" | "COLUMNS" = "ROWS",
      valueInputOption: "RAW" | "USER_ENTERED" = "USER_ENTERED",
      responseValueRenderOption:
        | "FORMATTED_VALUE"
        | "UNFORMATTED_VALUE"
        | "FORMULA" = "FORMATTED_VALUE",
      responseDateTimeRenderOption:
        | "SERIAL_NUMBER"
        | "FORMATTED_STRING" = "SERIAL_NUMBER",
    ) {
      const token = gsheets_auth["token"];
      let UPDATE_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${startCell}?includeValuesInResponse=true`;
      UPDATE_VALUES_URL += `&valueInputOption=${valueInputOption}`;
      UPDATE_VALUES_URL += `&responseValueRenderOption=${responseValueRenderOption}`;
      UPDATE_VALUES_URL += `&responseDateTimeRenderOption=${responseDateTimeRenderOption}`;
      const body = {
        values,
        majorDimension,
      };

      const response = await fetch(UPDATE_VALUES_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const json = await response.json();
      if (json.error) {
        let { code, status, message } = json.error;
        throw Error(`\n${code} ${status} - "${message}"\n`);
      }
      return json;
    }
  original_instructions: |-
    Update Values in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- edit_instructions: |2

    Add a new parameter to allow sorting by multiple columns, where each column can have its own sorting direction and nulls order.
  id: |-
    hubedit_hub_311
  lang: |-
    deno
  modified_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };

    type OrderOptions = {
      column: string;
      ascending?: boolean;
      nullsFirst?: boolean;
    };

    export async function main(
      auth: Supabase,
      table: string,
      columns?: string,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      head?: boolean,
      filter?: {
        column: string;
        operator: string;
        value: any;
      },
      order?: OrderOptions | OrderOptions[],
      limit?: {
        count: number;
        foreignTable?: string;
      },
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        const options = head || count ? { head, count } : undefined;
        let query = client.from(table).select(columns || undefined, options);
        if (filter?.column) {
          query = query.filter(filter.column, filter.operator, filter.value);
        }
        if (order) {
          if (Array.isArray(order)) {
            for (const { column, ...options } of order) {
              query = query.order(column, options);
            }
          } else {
            const { column, ...options } = order;
            query = query.order(column, options);
          }
        }
        if (limit?.count) {
          const { count, foreignTable } = limit;
          query = query.limit(count, foreignTable ? { foreignTable } : undefined);
        }

        return query;
      });
    }
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     *
     * @param head When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param filter Learn more at https://supabase.com/docs/reference/javascript/filter
     *
     * @param order Learn more at https://supabase.com/docs/reference/javascript/order
     *
     * @param limit Learn more at https://supabase.com/docs/reference/javascript/limit
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      columns?: string,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      head?: boolean,
      filter?: {
        column: string;
        operator: string;
        value: any;
      },
      order?: {
        column: string;
        foreignTable: string;
        ascending?: boolean;
        nullsFirst?: boolean;
      },
      limit?: {
        count: number;
        foreignTable?: string;
      },
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        const options = head || count ? { head, count } : undefined;
        let query = client.from(table).select(columns || undefined, options);
        if (filter?.column) {
          query = query.filter(filter.column, filter.operator, filter.value);
        }
        if (order?.column) {
          const { column, ...options } = order;
          query = query.order(column, options);
        }
        if (limit?.count) {
          const { count, foreignTable } = limit;
          query = query.limit(count, foreignTable ? { foreignTable } : undefined);
        }

        return query;
      });
    }
  original_instructions: |-
    Fetch data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- edit_instructions: |2

    Add a feature to sort the keys of the JSON object alphabetically before stringifying it.
  id: |-
    hubedit_hub_103
  lang: |-
    deno
  modified_code: |-
    export async function main(value: object | string, indentation = 2) {
      if (typeof value === "string") {
        value = JSON.parse(value);
      }

      const sortObjectKeys = (obj: any): any => {
        if (obj !== null && typeof obj === 'object' && !Array.isArray(obj)) {
          const sortedObject: any = {};
          Object.keys(obj).sort().forEach(key => {
            sortedObject[key] = sortObjectKeys(obj[key]);
          });
          return sortedObject;
        }
        return obj;
      };

      const sortedValue = sortObjectKeys(value);
      return JSON.stringify(sortedValue, null, indentation);
    }
  original_code: |
    export async function main(value: object | string, indentation = 2) {
      if (typeof value === "string") {
        value = JSON.parse(value);
      }
      return JSON.stringify(value, null, indentation);
    }
  original_instructions: |-
    Pretty Print JSON in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add error handling to the fetch request to log an error message if the POST request fails. Also, modify the JSON body to include the username in the response if it is available.
  id: |-
    hubedit_hub_416
  lang: |-
    deno
  modified_code: |-
    export async function main(
      response_url: string,
      text: string,
    ) {
      try {
        const username = await Deno.env.get('WM_USERNAME');
        const bodyContent = { text: `ROGER ${text}` };

        if (username) {
          bodyContent['username'] = username;
        }

        const response = await fetch(response_url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(bodyContent),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        console.log(`user = ${username}`);
      } catch (error) {
        console.error('Failed to send POST request:', error.message);
      }
    }
  original_code: |-
    export async function main(
      response_url: string,
      text: string,
    ) {
      const x = await fetch(response_url, {
        method: 'POST',
        body: JSON.stringify({ text: `ROGER ${text}` }),
      });
      const username = await Deno.env.get('WM_USERNAME')
      console.log(`user = ${username}`)
  original_instructions: |-
    Example of responding to a slack command in slack
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a parameter to filter the rows based on a condition before performing the upsert operation.
  id: |-
    hubedit_hub_288
  lang: |-
    deno
  modified_code: |-
    import {
      refreshAndRetryIfExpired,
      removeObjectEmptyFields,
    } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };

    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      on_conflict?: string,
      ignore_duplicates: boolean = true,
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      filter?: { [key: string]: any }, // Added filter parameter
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .upsert(
            values,
            removeObjectEmptyFields({ on_conflict, ignore_duplicates, count }),
          );

        // Apply filter if provided
        if (filter) {
          query = query.match(filter);
        }

        if (return_updated) {
          query = query.select();
        }

        return query;
      });
    }
  original_code: |
    import {
      refreshAndRetryIfExpired,
      removeObjectEmptyFields,
    } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param on_conflict Comma-separated UNIQUE column(s) to specify how duplicate
     * rows are determined. Two rows are duplicates if all the onConflict columns are equal.
     *
     * @param ignore_duplicates If true, duplicate rows are ignored. If false, duplicate
     * rows are merged with existing rows.
     *
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      on_conflict?: string,
      ignore_duplicates: boolean = true,
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .upsert(
            values,
            removeObjectEmptyFields({ on_conflict, ignore_duplicates, count }),
          );
        if (return_updated) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Upsert data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- edit_instructions: |2

    Add functionality to send an email notification to a predefined list of recipients with the error details and the number of times the schedule has failed.
  id: |-
    hubedit_hub_401
  lang: |-
    deno
  modified_code: |-
    import { sendEmail } from './emailService'; // Assuming there's an email service module

    // List of recipients to notify
    const RECIPIENTS = ['admin@example.com', 'support@example.com'];

    export async function main(
      path: string,
      is_flow: boolean,
      schedule_path: string,
      error: object,
      started_at: string,
      failed_times: number,
    ) {
      const errorMessage = `Schedule ${schedule_path} failed ${
        failed_times > 1 ? (failed_times + " times in a row") : ""
      }\n${is_flow ? "Flow" : "Script"}: ${path}`;
      const errorDetails = `Last failure at ${started_at}: ${JSON.stringify(error, null, 2)}`;

      console.log(errorMessage);
      console.log(errorDetails);

      // Prepare email content
      const subject = `Error Notification: ${schedule_path} Failure`;
      const body = `
        <p>${errorMessage}</p>
        <pre>${errorDetails}</pre>
      `;

      // Send email to each recipient
      for (const recipient of RECIPIENTS) {
        try {
          await sendEmail(recipient, subject, body);
          console.log(`Notification sent to ${recipient}`);
        } catch (emailError) {
          console.error(`Failed to send notification to ${recipient}:`, emailError);
        }
      }

      return error;
    }
  original_code: |
    // Schedule error handler template

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      started_at: string, // The start datetime of the latest job that failed
      failed_times: number, // Minimum number of times the schedule failed before calling the error handler
    ) {
      console.log(
        `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${started_at}:`, error);
      return error;
    }
  original_instructions: |-
    Schedule error handler template in windmill
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to cache the response for a specific room_id and user_id combination for a certain duration to reduce the number of API calls.
  id: |-
    hubedit_hub_191
  lang: |-
    deno
  modified_code: |-
    import { cache } from './cache'; // Assuming there's a cache module to import

    type Matrix = {
      baseUrl: string;
      token: string;
    };

    type UserInfo = {
      avatar_url: string;
      display_name: string;
    };

    type MemberStatus = {
      is_joined: boolean;
      user_info: UserInfo | null;
    };

    const CACHE_DURATION_MS = 5 * 60 * 1000; // Cache duration in milliseconds (e.g., 5 minutes)

    export async function main(
      matrix_res: Matrix,
      room_id: string,
      user_id: string,
    ): Promise<MemberStatus> {
      const cacheKey = `joined_members_${room_id}_${user_id}`;
      const cachedResponse = cache.get(cacheKey);

      if (cachedResponse && Date.now() - cachedResponse.timestamp < CACHE_DURATION_MS) {
        return cachedResponse.data;
      }

      const url = `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/joined_members`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });

      if (!resp.ok) {
        throw Error(`Failed to fetch joined member list: Error HTTP${resp.status}`);
      }

      const data = await resp.json();
      const memberStatus: MemberStatus = {
        is_joined: user_id in data?.joined,
        user_info: data?.joined?.[user_id] || null,
      };

      cache.set(cacheKey, { timestamp: Date.now(), data: memberStatus });

      return memberStatus;
    }
  original_code: |
    /**
     * This function throws an error, if you're not a room member.
     *
     * Expected return values:
     *
     * {
     *   "is_joined": false,
     *   "user_info": null
     * }
     *
     * or
     *
     * {
     *   "is_member": true,
     *   "user_info": {
     *     "avatar_url": "mxc://matrix.org/abc123",
     *     "display_name": "Jane Doe"
     *   }
     * }
     */
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      user_id: string,
    ) {
      const url = `${
        matrix_res.baseUrl
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/joined_members`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to fetch joined member list: Error HTTP${resp.status}`);
      }
      const data = await resp.json();
      return {
        is_joined: user_id in data?.joined,
        user_info: data?.joined?.[user_id],
      };
    }
  original_instructions: |-
    Is a Matrix user X a joined member of a Matrix room Y? in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Add functionality to validate the email format for both 'members_to_add' and 'members_to_remove' before attempting to modify the segment, and return an error message if any email is not in a valid format.
  id: |-
    hubedit_hub_213
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * @param members_to_add *(optional)* An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * A maximum of 500 members can be sent.
     *
     * @param members_to_remove *(optional)* An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * A maximum of 500 members can be sent.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };

    function validateEmailFormat(emails: string[]): boolean {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emails.every(email => emailRegex.test(email));
    }

    export async function main(
      auth: Mailchimp,
      list_id: string,
      segment_id: string,
      members_to_add?: string[],
      members_to_remove?: string[],
    ) {
      if (members_to_add && !validateEmailFormat(members_to_add)) {
        return "One or more emails in 'members_to_add' are not in a valid format.";
      }

      if (members_to_remove && !validateEmailFormat(members_to_remove)) {
        return "One or more emails in 'members_to_remove' are not in a valid format.";
      }

      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments/${segment_id}`,
      );
      const body = {
        members_to_add,
        members_to_remove,
      };
      removeObjectEmptyFields(body, true, false);
      if (!Object.keys(body).length) {
        return "No members were declared to be added or removed.";
      }

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * @param members_to_add *(optional)* An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * A maximum of 500 members can be sent.
     *
     * @param members_to_remove *(optional)* An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * A maximum of 500 members can be sent.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      segment_id: string,
      members_to_add?: string[],
      members_to_remove?: string[],
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments/${segment_id}`,
      );
      const body = {
        members_to_add,
        members_to_remove,
      };
      removeObjectEmptyFields(body, true, false);
      if (!Object.keys(body).length) {
        return "No members were declared to be added or removed.";
      }

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Add Or Remove Members Tags in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- edit_instructions: |2

    Modify the script to include a date filter, allowing users to specify a start and end date for the posts they want to retrieve.
  id: |-
    hubedit_hub_249
  lang: |-
    deno
  modified_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    /**
     * @returns A list of posts that mentioned given phrases in ascending order
     * of date of publication within the specified date range.
     *
     * @param mentions Case **insensitive** phrases that should be searched for.
     * @param startDate The start date for filtering posts (inclusive).
     * @param endDate The end date for filtering posts (inclusive).
     */
    export async function main(
      subreddit: string,
      mentions: string[],
      max_number_of_posts: number = 100,
      startDate?: string,
      endDate?: string,
    ) {
      mentions = mentions?.map((m) => m.trim().toLowerCase())?.filter(Boolean);
      if (!mentions?.length) {
        throw Error("\nAt least one mentioned phrase is needed to search for.");
      }

      const url = new URL(`https://www.reddit.com/r/${subreddit}/new.json`);
      if (max_number_of_posts < 1) {
        max_number_of_posts = 1;
      }
      const limit = max_number_of_posts < 100 ? max_number_of_posts : 100;
      const processedPosts: Post[] = [];
      let runLoop = true;

      const startTimestamp = startDate ? new Date(startDate).getTime() / 1000 : null;
      const endTimestamp = endDate ? new Date(endDate).getTime() / 1000 : null;

      do {
        const lastPostId = await getState();
        url.searchParams.append("limit", limit.toString());
        lastPostId && url.searchParams.append("before", lastPostId);
        const result = await fetch(url);
        if (!result.ok) {
          throw Error("\n" + (await result.text()));
        }
        const data = (await result.json()).data;
        const posts: Post[] = data.children.map(
          ({ data: { name, title, selftext, url, created_utc } }: { data: Post }) => {
            return { name, title, selftext, url, created_utc };
          },
        );
        if (!posts.length) {
          return processedPosts;
        } else if (posts.length < limit) {
          runLoop = false;
        }

        await setState(posts[0].name);
        const temp: Post[] = [];
        for (let i = 0; i < posts.length; i++) {
          const post = posts[i];
          const postTimestamp = post.created_utc;
          if ((startTimestamp && postTimestamp < startTimestamp) ||
              (endTimestamp && postTimestamp > endTimestamp)) {
            continue;
          }
          const mention =
            mentions.find((mention) =>
              post.title.toLowerCase().includes(mention),
            ) ||
            mentions.find((mention) =>
              post.selftext.toLowerCase().includes(mention),
            );
          mention && temp.push(post);
          if (processedPosts.length + temp.length >= max_number_of_posts) {
            break;
          }
        }
        processedPosts.push(...temp.reverse());
        if (processedPosts.length >= max_number_of_posts) {
          runLoop = false;
        }
      } while (runLoop);

      return processedPosts;
    }

    interface Post {
      name: string;
      title: string;
      selftext: string;
      url: string;
      created_utc: number; // Unix timestamp in seconds
    }
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    /**
     * @returns A list of posts that mentioned given phrases in ascending order
     * of date of publication.
     *
     * @param mentions Case **insensitive** phrases that should be searched for.
     */
    export async function main(
      subreddit: string,
      mentions: string[],
      max_number_of_posts: number = 100,
    ) {
      mentions = mentions?.map((m) => m.trim().toLowerCase())?.filter(Boolean);
      if (!mentions?.length) {
        throw Error("\nAt least one mentioned phrase is needed to search for.");
      }

      const url = new URL(`https://www.reddit.com/r/${subreddit}/new.json`);
      if (max_number_of_posts < 1) {
        max_number_of_posts = 1;
      }
      const limit = max_number_of_posts < 100 ? max_number_of_posts : 100;
      const processedPosts: Post[] = [];
      let runLoop = true;

      do {
        const lastPostId = await getState();
        url.searchParams.append("limit", limit.toString());
        lastPostId && url.searchParams.append("before", lastPostId);
        const result = await fetch(url);
        if (!result.ok) {
          throw Error("\n" + (await result.text()));
        }
        const data = (await result.json()).data;
        const posts: Post[] = data.children.map(
          ({ data: { name, title, selftext, url } }: { data: Post }) => {
            return { name, title, selftext, url };
          },
        );
        if (!posts.length) {
          return processedPosts;
        } else if (posts.length < limit) {
          runLoop = false;
        }

        await setState(posts[0].name);
        const temp: Post[] = [];
        for (let i = 0; i < posts.length; i++) {
          const post = posts[i];
          const mention =
            mentions.find((mention) =>
              post.title.toLowerCase().includes(mention),
            ) ||
            mentions.find((mention) =>
              post.selftext.toLowerCase().includes(mention),
            );
          mention && temp.push(post);
          if (processedPosts.length + temp.length >= max_number_of_posts) {
            break;
          }
        }
        processedPosts.push(...temp.reverse());
        if (processedPosts.length >= max_number_of_posts) {
          runLoop = false;
        }
      } while (runLoop);

      return processedPosts;
    }

    interface Post {
      name: string;
      title: string;
      selftext: string;
      url: string;
    }
  original_instructions: |-
    Trigger everytime a new item post on reddit matches at least one mention  in reddit
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to include a filter that only returns issues with a specific label, which is passed as an additional parameter to the main function.
  id: |-
    hubedit_hub_251
  lang: |-
    deno
  modified_code: |-
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;
    const PAGE_SIZE = 50;

    /**
     * @returns A list of issues in ascending order of creation date.
     *
     * The maximum number of returned items is 500 and therefore you'll miss
     * the issues that are older than the 500th one. Please choose your
     * scheduling accordingly.
     */
    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string, specificLabel: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const newIssues: Issue[] = [];
      const lastUpdate = await getState();

      let runLoop = true;
      let page = 1;
      do {
        const result = await octokit.issues.listForRepo({
          owner,
          repo,
          labels: specificLabel,
          filter: "all",
          state: "open",
          sort: "created",
          direction: "desc",
          per_page: PAGE_SIZE,
          page: page++,
        });
        const issues = result.data.filter((i) => i && !i.pull_request);

        for (let i = 0; i < issues.length; i++) {
          const issue = issues[i];
          if (new Date(issue.created_at).getTime() <= lastUpdate) {
            runLoop = false;
            break;
          }
          newIssues.push({
            title: issue.title,
            url: issue.html_url,
            created_at: issue.created_at,
            user: {
              login: issue.user?.login,
              url: issue.user?.html_url,
            },
            labels: <string[]>(
              issue.labels
                .map((l) => (typeof l === "string" ? l : l.name))
                .filter(Boolean)
            ),
          });
          if (newIssues.length >= MAX_ITEMS) {
            runLoop = false;
            break;
          }
        }

        if (result.data.length < PAGE_SIZE) {
          break;
        }
      } while (runLoop);

      if (newIssues.length) {
        await setState(new Date(newIssues[0].created_at).getTime());
      }
      return newIssues.reverse();
    }

    interface Issue {
      title: string;
      url: string;
      created_at: string;
      user: {
        login?: string;
        url?: string;
      };
      labels: string[];
    }
  original_code: |
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;
    const PAGE_SIZE = 50;

    /**
     * @returns A list of issues in ascending order of creation date.
     *
     * The maximum number of returned items is 500 and therefore you'll miss
     * the issues that are older than the 500th one. Please choose your
     * scheduling accordingly.
     */
    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const newIssues: Issue[] = [];
      const lastUpdate = await getState();

      let runLoop = true;
      let page = 1;
      do {
        const result = await octokit.issues.listForRepo({
          owner,
          repo,
          filter: "all",
          state: "open",
          sort: "created",
          direction: "desc",
          per_page: PAGE_SIZE,
          page: page++,
        });
        const issues = result.data.filter((i) => i && !i.pull_request);

        for (let i = 0; i < issues.length; i++) {
          const issue = issues[i];
          if (new Date(issue.created_at).getTime() <= lastUpdate) {
            runLoop = false;
            break;
          }
          newIssues.push({
            title: issue.title,
            url: issue.html_url,
            created_at: issue.created_at,
            user: {
              login: issue.user?.login,
              url: issue.user?.html_url,
            },
            labels: <string[]>(
              issue.labels
                .map((l) => (typeof l === "string" ? l : l.name))
                .filter(Boolean)
            ),
          });
          if (newIssues.length >= MAX_ITEMS) {
            runLoop = false;
            break;
          }
        }

        if (result.data.length < PAGE_SIZE) {
          break;
        }
      } while (runLoop);

      if (newIssues.length) {
        await setState(new Date(newIssues[0].created_at).getTime());
      }
      return newIssues.reverse();
    }

    interface Issue {
      title: string;
      url: string;
      created_at: string;
      user: {
        login?: string;
        url?: string;
      };
      labels: string[];
    }
  original_instructions: |-
    List newly added issues in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to update existing documents based on a provided filter instead of inserting new ones.
  id: |-
    hubedit_hub_260
  lang: |-
    deno
  modified_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      documents: Record<string, any>[],
      filter: Record<string, any>,
      update: boolean = false,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);

      if (update) {
        const updatePromises = documents.map((doc) => {
          const updateDoc = typeof doc === "string" ? JSON.parse(doc) : doc;
          return docs.updateOne(filter, { $set: updateDoc });
        });
        return await Promise.all(updatePromises);
      } else {
        let items: Record<string, any>[];
        try {
          items = documents.map((doc) =>
            typeof doc === "string" ? JSON.parse(doc) : doc,
          );
        } catch (err) {
          throw Error(`\nReceived array of strings in the 'documents' argument.
    Attempted to parse them into objects but the process failed with the following error:\n${err}`);
        }
        return await docs.insertMany(items);
      }
    }
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      documents: Record<string, any>[],
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);

      let items: Record<string, any>[];
      try {
        items = documents.map((doc) =>
          typeof doc === "string" ? JSON.parse(doc) : doc,
        );
      } catch (err) {
        throw Error(`\nReceived array of strings in the 'documents' argument.
    Attempted to parse them into objects but the process failed with the following error:\n${err}`);
      }

      return await docs.insertMany(items);
    }
  original_instructions: |-
    Create Many New Documents in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- edit_instructions: |2

    Add functionality to validate each contact's email format before attempting to send it to SendGrid, and return a list of invalid email addresses if any are found.
  id: |-
    hubedit_hub_219
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };

    function isValidEmail(email: string): boolean {
      // Simple regex for email validation - for more complex validation consider using a library
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }

    export async function main(
      api_token: Sendgrid,
      contacts: {
        email: string;
        custom_fields: Record<string, string | number>;
      }[],
      list_ids?: string[],
    ) {
      sendgrid.setApiKey(api_token.token);

      // Validate email addresses
      const invalidEmails = contacts.filter(contact => !isValidEmail(contact.email)).map(contact => contact.email);
      if (invalidEmails.length > 0) {
        return { invalidEmails };
      }

      try {
        contacts = contacts.map((c) => {
          return typeof c === "string" ? JSON.parse(c) : c;
        });
      } catch (error) {
        throw Error(`Tried to parse "contacts" argument because
        it was an array of strings but failed with error:\n${error}`);
      }

      const body = removeObjectEmptyFields({
        contacts,
        list_ids,
      });
      const request = {
        url: `/v3/marketing/contacts`,
        method: "PUT",
        body,
      };

      try {
        const [_, responseBody] = await sendgrid.request(request);
        return responseBody;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * According to Sendgrid documentation, this is an asynchronous
     * process and the response will NOT contain immediate feedback,
     * only a `job_id` which then can be used to get the status
     * of the job.
     * The following script from WindmillHub performs this status check:
     * https://hub.windmill.dev/scripts/sendgrid/1449/get-contacts-import-status-sendgrid
     *
     * You can read more of the Sendgrid documentation at
     * https://docs.sendgrid.com/api-reference/contacts/add-or-update-a-contact
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      contacts: {
        email: string;
        custom_fields: Record<string, string | number>;
      }[],
      list_ids?: string[],
    ) {
      sendgrid.setApiKey(api_token.token);

      try {
        contacts = contacts.map((c) => {
          return typeof c === "string" ? JSON.parse(c) : c;
        });
      } catch (error) {
        throw Error(`Tried to parse "contacts" argument because
        it was an array of strings but failed with error:\n${error}`);
      }

      const body = removeObjectEmptyFields({
        contacts,
        list_ids,
      });
      const request = {
        url: `/v3/marketing/contacts`,
        method: "PUT",
        body,
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Add or Update Contact in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to log the successful association creation with details of the contact and the object it was associated with, including their IDs and the association type.
  id: |-
    hubedit_hub_228
  lang: |-
    deno
  modified_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";
    import type { AssociationSpec } from "npm:@hubspot/api-client@^8.1.0/lib/codegen/crm/contacts/index.js";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: number,
      to_object_type: string,
      to_object_id: number,
      associations: AssociationSpec[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        associations =
          associations?.map((c) => {
            return typeof c === "string" ? JSON.parse(c) : c;
          }) || [];
      } catch (error) {
        throw Error(`Tried to parse "associations" argument because
        it was an array of strings but failed with error:\n${error}
        Associations must have the following shape:
          {
            associationCategory: 'HUBSPOT_DEFINED' | 'USER_DEFINED' | 'INTEGRATOR_DEFINED',
            associationTypeId: number
          }
        `);
      }

      try {
        const response = await client.crm.contacts.associationsApi.create(
          contact_id,
          to_object_type,
          to_object_id,
          associations,
        );

        // Log the successful association
        console.log(`Successfully created association between contact ID ${contact_id} and ${to_object_type} ID ${to_object_id}.`);
        associations.forEach((assoc) => {
          console.log(`Association Type ID: ${assoc.associationTypeId}, Category: ${assoc.associationCategory}`);
        });

        return response;
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";
    import type { AssociationSpec } from "npm:@hubspot/api-client@^8.1.0/lib/codegen/crm/contacts/index.js";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: number,
      to_object_type: string,
      to_object_id: number,
      associations: AssociationSpec[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        associations =
          associations?.map((c) => {
            return typeof c === "string" ? JSON.parse(c) : c;
          }) || [];
      } catch (error) {
        throw Error(`Tried to parse "associations" argument because
        it was an array of strings but failed with error:\n${error}
        Associations must have the following shape:
          {
            associationCategory: 'HUBSPOT_DEFINED' | 'USER_DEFINED' | 'INTEGRATOR_DEFINED',
            associationTypeId: number
          }
        `);
      }

      try {
        return await client.crm.contacts.associationsApi.create(
          contact_id,
          to_object_type,
          to_object_id,
          associations,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  original_instructions: |-
    Create Associations in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- edit_instructions: |2

    Add an option to attach files to the email by accepting an array of objects containing file paths and file names, then modify the messageObject to include these attachments in the sendgrid.send call.
  id: |-
    hubedit_hub_214
  lang: |-
    deno
  modified_code: |-
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";
    import { readFile } from "fs/promises";

    /**
     * @param is_message_html If `true` then the message will be sent and parsed as HTML,
     * otherwise it will be sent as plain text.
     */
    type Sendgrid = {
      token: string;
    };

    type Attachment = {
      path: string;
      filename: string;
    };

    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string,
      subject: string,
      message: string,
      is_message_html: boolean,
      attachments?: Attachment[],
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: sendgrid.MailDataRequired = { to, from, subject };
      messageObject[is_message_html ? "html" : "text"] = message;

      if (attachments && attachments.length > 0) {
        const processedAttachments = await Promise.all(
          attachments.map(async (attachment) => {
            const content = await readFile(attachment.path, { encoding: 'base64' });
            return {
              content,
              filename: attachment.filename,
              type: 'application/octet-stream', // You might want to determine the type based on the file extension
              disposition: 'attachment',
              contentId: attachment.filename,
            };
          })
        );
        messageObject.attachments = processedAttachments;
      }

      try {
        return await sendgrid.send(messageObject);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_code: |
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";

    /**
     * @param is_message_html If `true` then the message will be sent and parsed as HTML,
     * otherwise it will be sent as plain text.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string,
      subject: string,
      message: string,
      is_message_html: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, string> = { to, from, subject };
      messageObject[is_message_html ? "html" : "text"] = message;

      try {
        return await sendgrid.send(messageObject);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Send Email Single Recipient in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to resize images before uploading them to S3 if the mimetype indicates the file is an image.
  id: |-
    hubedit_hub_309
  lang: |-
    deno
  modified_code: |-
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";
    import { format } from "https://deno.land/std@0.89.0/datetime/mod.ts";
    import { mime } from "https://deno.land/x/mimetypes@v1.0.0/mod.ts";
    import { resize } from "https://deno.land/x/deno_image/mod.ts";

    // ... (rest of the existing code)

    /****
     * Resizes an image if it's a base64 encoded image file
     * @param base64Data Base64 encoded image file
     * @param mimetype The mimetype of the image
     * @returns Base64 encoded string of the resized image
     */
    async function resizeImage(base64Data: string, mimetype: string): Promise<string> {
      const decoder = new TextEncoder();
      const imageBytes = decoder.encode(base64Data);
      const resizedImage = await resize(imageBytes, { width: 100, height: 100 }); // Example resize to 100x100
      return resizedImage.toString();
    }

    // ... (rest of the existing code)

    export async function main(s3: S3, files: string[]) {
      // ... (rest of the existing code)

      await Promise.all(
        files.map(async (file: string) => {
          try {
            const mime_data = base64MimeType(file)!;
            if (mime_data) {
              let base64Data = file.replace(/^data:\w+\/\w+;base64,/, "");
              if (mime_data.mimetype.startsWith("image/")) {
                // Resize the image if it's an image file
                base64Data = await resizeImage(base64Data, mime_data.mimetype);
              }
              const bytes = Uint8Array.from(atob(base64Data), (c) =>
                c.charCodeAt(0),
              );

              // ... (rest of the existing code for uploading to S3)

            } else {
              // ... (rest of the existing error handling code)
            }
          } catch (error) {
            // ... (rest of the existing error handling code)
          }
        }),
      );

      // ... (rest of the existing code)
    }
  original_code: "import { S3Client } from \"https://deno.land/x/s3_lite_client@0.5.0/mod.ts\"\
    ;\nimport { format } from \"https://deno.land/std@0.89.0/datetime/mod.ts\";\n\
    import { mime } from \"https://deno.land/x/mimetypes@v1.0.0/mod.ts\";\n\nconst\
    \ MESSAGES_I9 = {\n  en: {\n    error_mimetype: \"File type could not be identified\"\
    ,\n    error_file_upload: \"Error uploading file (S3)\",\n  },\n  pt_br: {\n \
    \   error_mimetype: \"Tipo do arquivo n\xE3o p\xF4de ser identificado\",\n   \
    \ error_file_upload: \"Erro ao enviar arquivo (S3)\",\n  },\n};\nconst MESSAGES\
    \ = MESSAGES_I9.en;\n\n/****\n * Returns the mimetype and extension of a base64\
    \ encoded file\n * @param encoded Base64 encoded file\n * @returns Object with\
    \ mimetype and extension\n */\nfunction base64MimeType(encoded: string) {\n  let\
    \ result = null;\n\n  if (typeof encoded !== \"string\") {\n    return result;\n\
    \  }\n\n  const match = encoded.match(/data:([a-zA-Z0-9]+\\/[a-zA-Z0-9-.+]+).*,.*/);\n\
    \  if (match && match.length) {\n    result = {\n      mimetype: match[1],\n \
    \     extension: mime.getExtension(match[1]),\n    };\n  }\n\n  return result;\n\
    }\n\n/****\n * Uploads a list of files to S3\n * @param s3 S3 resource\n * @param\
    \ files Array of base64 encoded files\n * @returns Object with error_count and\
    \ array of results (files URLs or error messages)\n *\n * Detects file type/extension\
    \ using base64 header (e.g. \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAA...\"\
    ).\n * The output of File Input component can be used as parameter for this function.\n\
    \ */\ntype S3 = {\n  endPoint: string;\n  port: number;\n  useSSL: boolean;\n\
    \  pathStyle: boolean;\n  bucket: string;\n  accessKey: string;\n  secretKey:\
    \ string;\n  region: string;\n};\nexport async function main(s3: S3, files: string[])\
    \ {\n  if (files.length <= 0) {\n    return;\n  }\n\n  const s3client = new S3Client(s3);\n\
    \n  const out: any[] = [];\n  let error_count = 0;\n\n  await Promise.all(\n \
    \   files.map(async (file: string) => {\n      try {\n        const mime_data\
    \ = base64MimeType(file)!;\n        if (mime_data) {\n          const file_name\
    \ =\n            format(new Date(), \"yyyy-MM-dd-HH-mm-ss\") +\n            \"\
    -\" +\n            Math.random().toString(36).substring(2, 8) +\n            \"\
    .\" +\n            mime_data.extension;\n          const base64Data = file.replace(/^data:\\\
    w+\\/\\w+;base64,/, \"\");\n          const bytes = Uint8Array.from(atob(base64Data),\
    \ (c) =>\n            c.charCodeAt(0),\n          );\n\n          await s3client.putObject(file_name,\
    \ bytes, {\n            metadata: {\n              \"Content-Type\": mime_data.mimetype,\n\
    \            },\n          });\n\n          const url = `https://${s3[\"endPoint\"\
    ]}/${s3[\"bucket\"]}/${file_name}`;\n          out.push({\n            success:\
    \ true,\n            url,\n          });\n        } else {\n          out.push({\n\
    \            success: false,\n            message: MESSAGES.error_mimetype,\n\
    \          });\n          error_count++;\n        }\n      } catch (error) {\n\
    \        out.push({\n          success: false,\n          message: `${MESSAGES.error_file_upload}\
    \ (S3): ${error.message}`,\n        });\n        error_count++;\n      }\n   \
    \ }),\n  );\n\n  return { error_count, files: out };\n}\n"
  original_instructions: |-
    Put a list of objects in a bucket in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- edit_instructions: |2

    Change the modulusLength to 2048 for stronger encryption security.
  id: |-
    hubedit_hub_279
  lang: |-
    deno
  modified_code: |-
    export async function main() {
      const keys = await window.crypto.subtle.generateKey(
        {
          name: "RSA-PSS",
          modulusLength: 2048, // Changed modulusLength to 2048
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: "SHA-256",
        },
        true,
        ["sign", "verify"],
      );
      return {
        private: await exportKey(keys.privateKey, true),
        public: await exportKey(keys.publicKey, false),
      };
    }

    async function exportKey(key: CryptoKey, isPrivateKey: boolean) {
      const exported = await window.crypto.subtle.exportKey(
        isPrivateKey ? "pkcs8" : "spki",
        key,
      );
      const exportedAsString = ab2str(exported);
      const exportedAsBase64 = window.btoa(exportedAsString);
      const pemExported = `-----BEGIN ${
        isPrivateKey ? "PRIVATE" : "PUBLIC"
      } KEY-----\n${exportedAsBase64}\n-----END ${
        isPrivateKey ? "PRIVATE" : "PUBLIC"
      } KEY-----`; // Fixed the END tag to match the key type

      return pemExported;
    }

    function ab2str(buf: ArrayBuffer) {
      return String.fromCharCode.apply(null, new Uint8Array(buf));
    }
  original_code: |
    export async function main() {
      const keys = await window.crypto.subtle.generateKey(
        {
          name: "RSA-PSS",
          modulusLength: 1024,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: "SHA-256",
        },
        true,
        ["sign", "verify"],
      );
      return {
        private: await exportKey(keys.privateKey, true),
        public: await exportKey(keys.publicKey, false),
      };
    }

    async function exportKey(key: CryptoKey, isPrivateKey: boolean) {
      const exported = await window.crypto.subtle.exportKey(
        isPrivateKey ? "pkcs8" : "spki",
        key,
      );
      const exportedAsString = ab2str(exported);
      const exportedAsBase64 = window.btoa(exportedAsString);
      const pemExported = `-----BEGIN ${
        isPrivateKey ? "PRIVATE" : "PUBLIC"
      } KEY-----\n${exportedAsBase64}\n-----END PRIVATE KEY-----`;

      return pemExported;
    }

    function ab2str(buf: ArrayBuffer) {
      return String.fromCharCode.apply(null, new Uint8Array(buf));
    }
  original_instructions: |-
    Generate an RSA PSS key pair in helper
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add a feature to sort the query results based on a specific metadata field before returning them.
  id: |-
    hubedit_hub_340
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { QueryOperationRequest, QueryResponse } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };

    export async function main(
      auth: Pinecone,
      index_name: string,
      topK: number,
      vector?: number[],
      id?: string,
      namespace?: string,
      include_values?: boolean,
      include_metadata?: boolean,
      filter?: object,
      raw?: boolean,
      sortMetadataField?: string, // Added parameter to specify the metadata field to sort by
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const queryRequest: QueryOperationRequest = removeObjectEmptyFields({
        topK,
        vector,
        id,
        namespace,
        includeValues: include_values,
        includeMetadata: include_metadata || !!sortMetadataField, // Ensure metadata is included if sorting is needed
        filter,
      });

      const response: QueryResponse = await index[raw ? "queryRaw" : "query"]({ queryRequest });

      // If a sortMetadataField is provided, sort the results based on that field
      if (sortMetadataField && response.results) {
        for (const result of response.results) {
          result.matches.sort((a, b) => {
            const metadataA = a.metadata?.[sortMetadataField];
            const metadataB = b.metadata?.[sortMetadataField];
            if (metadataA === undefined || metadataB === undefined) {
              return 0; // If metadata is not present, do not change order
            }
            return metadataA < metadataB ? -1 : metadataA > metadataB ? 1 : 0;
          });
        }
      }

      return response;
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { QueryOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    /**
     *
     * @param topK The number of results to return for each query.
     *
     * @param vector _(Conditionally Optional)_ The query vector. This should be the same length as the dimension
     * of the index being queried.
     * **Each query request can contain only one of the parameters "id" or "vector".**
     *
     * @param id _(Conditionally Optional)_ The unique ID of the vector to be used as a query vector.
     * **Each query request can contain only one of the parameters "vector" or "id".**
     *
     * @param namespace _(Optional)_ The namespace to query.
     *
     * @param includeValues _(Optional)_ Indicates whether vector values are included in the response.
     * Defaults to `false`.
     *
     * @param includeMetadata _(Optional)_ Indicates whether metadata is included in the response as well as the ids.
     * Defaults to `false`.
     *
     * @param filter _(Optional)_ The filter to apply. You can use vector metadata to limit your search.
     * See https://www.pinecone.io/docs/metadata-filtering/.
     */
    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      topK: number,
      vector?: number[],
      id?: string,
      namespace?: string,
      include_values?: boolean,
      include_metadata?: boolean,
      filter?: object,
      raw?: boolean,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const queryRequest: QueryOperationRequest = removeObjectEmptyFields({
        topK,
        vector,
        id,
        namespace,
        includeValues: include_values,
        includeMetadata: include_metadata,
        filter,
      });
      return await index[raw ? "queryRaw" : "query"]({ queryRequest });
    }
  original_instructions: |-
    Query Index in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- edit_instructions: |2

    Add functionality to set the event's visibility to public or private based on an additional parameter provided to the function.
  id: |-
    hubedit_hub_42
  lang: |-
    deno
  modified_code: |-
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
      maxAttendees: number = 2,
      visibility: 'public' | 'private' = 'public', // Added visibility parameter with default value 'public'
    ) {
      const sendNotifications = true;
      const sendUpdates = "all";
      const supportsAttachments = true;

      const CREATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/?maxAttendees=${maxAttendees}&sendNotifications=${sendNotifications}&sendUpdates=${sendUpdates}&supportsAttachments=${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
        visibility: visibility, // Added visibility to the body of the request
      };

      const response = await fetch(CREATE_EVENT_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
      maxAttendees?: number = 2,
    ) {
      const sendNotifications = true;
      const sendUpdates = "all";
      const supportsAttachments = true;

      const CREATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/?maxAttendees=${maxAttendees}&sendNotifications=${sendNotifications}&sendUpdates=${sendUpdates}&supportsAttachments${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
      };

      const response = await fetch(CREATE_EVENT_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Create Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter out and return only products that are active, by checking the 'active' property of each product in the response data before adding them to the products array.
  id: |-
    hubedit_hub_375
  lang: |-
    deno
  modified_code: |-
    export async function main(stripeAuth: Stripe) {
      let has_more = true;
      let starting_after = "";
      const activeProducts = [];

      while (has_more) {
        const res = await getStripeProductsIds(stripeAuth.token, starting_after);
        has_more = res.has_more;
        if (res.data.length > 0) {
          starting_after = res.data[res.data.length - 1].id;
        }
        const active = res.data.filter((product: any) => product.active);
        activeProducts.push(...active);
      }

      return activeProducts;
    }
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripeAuth: Stripe) {
      let has_more = true;
      let starting_after = "";
      const products = [];

      // if you have a lot of products (> 200), you may want to consider to throttle.
      while (has_more) {
        const res = await getStripeProductsIds(stripeAuth.token, starting_after);
        has_more = res.has_more;
        starting_after = res.data[res.data.length - 1].id;
        products.push(...res.data);
      }

      return products;
    }

    async function getStripeProductsIds(stripeKey: string, starting_after = "") {
      let url = "https://api.stripe.com/v1/products?limit=10";
      if (starting_after) {
        url += `&starting_after=${starting_after}`;
      }
      const products = await fetch(url, {
        headers: {
          Authorization: `Bearer ${stripeKey}`,
        },
      }).then((res) => res.json());

      return products;
    }
  original_instructions: |-
    Get all active stripe products from your account in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- edit_instructions: |2

    Add an optional parameter to allow sorting the results by a specified column in either ascending or descending order.
  id: |-
    hubedit_hub_284
  lang: |-
    deno
  modified_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };

    type SortOrder = 'asc' | 'desc';

    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      sort?: {
        column: string;
        order: SortOrder;
      }
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .update(values, { count })
          .filter(filter.column, filter.operator, filter.value);

        if (sort) {
          query = query.order(sort.column, { ascending: sort.order === 'asc' });
        }

        if (return_updated) {
          query = query.select();
        }

        return query;
      });
    }
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param filter Learn more at https://supabase.com/docs/reference/javascript/filter
     *
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .update(values, { count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_updated) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Update data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- edit_instructions: |2

    Add a feature to filter contacts by a specific property value before returning the contact information.
  id: |-
    hubedit_hub_227
  lang: |-
    deno
  modified_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    /**
     * @param properties List of the properties to be returned in the response.
     *
     * @param properties_with_history List of the properties to be returned
     * along with their history of previous values.
     *
     * @param filterProperty The property to filter by.
     *
     * @param filterValue The value of the property to filter by.
     */
    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: string,
      properties?: string[],
      properties_with_history?: string[],
      filterProperty?: string,
      filterValue?: string
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        const contact = await client.crm.contacts.basicApi.getById(
          contact_id,
          getProp(properties),
          getProp(properties_with_history),
        );

        // If filterProperty and filterValue are provided, filter the contact
        if (filterProperty && filterValue) {
          const propertyValue = contact.properties[filterProperty];
          if (propertyValue !== filterValue) {
            throw new Error(`Contact does not have the property ${filterProperty} with value ${filterValue}`);
          }
        }

        return contact;
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }

    function getProp(prop?: string[]) {
      return Array.isArray(prop) && prop.length ? prop : undefined;
    }
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    /**
     * @param properties List of the properties to be returned in the response.
     *
     * @param properties_with_history List of the properties to be returned
     * along with their history of previous values.
     */
    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: string,
      properties?: string[],
      properties_with_history?: string[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.crm.contacts.basicApi.getById(
          contact_id,
          getProp(properties),
          getProp(properties_with_history),
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }

    function getProp(prop?: string[]) {
      return Array.isArray(prop) && prop.length ? prop : undefined;
    }
  original_instructions: |-
    Get Contact in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter the newly updated objects by a specific file extension, such as ".txt", before adding them to the newlyUpdated array.
  id: |-
    hubedit_hub_254
  lang: |-
    deno
  modified_code: |-
    export async function main(s3: S3, bucket?: string, extension?: string) {
      const client = new S3Client(s3);
      const generator = client.listObjects({
        bucketName: bucket || undefined,
      });

      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const newlyUpdated = [];

      while (true) {
        const obj = await generator.next();
        if (obj.done) break;

        const lastMod = new Date(obj.value.lastModified).getTime();
        if (lastMod > lastCheck && (!extension || obj.value.key.endsWith(extension))) {
          newlyUpdated.push(obj.value);
        }
      }

      return newlyUpdated;
    }
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.3.0/mod.ts";

    /**
     * Tested on 10 000 objects, which got processed in 2.3-2.6 seconds.
     */
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, bucket?: string) {
      const client = new S3Client(s3);
      const generator = client.listObjects({
        bucketName: bucket || undefined,
      });

      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const newlyUpdated = [];

      while (true) {
        const obj = await generator.next();
        if (obj.done) break;

        const lastMod = new Date(obj.value.lastModified).getTime();
        if (lastMod > lastCheck) {
          newlyUpdated.push(obj.value);
        }
      }

      return newlyUpdated;
    }
  original_instructions: |-
    Get recently updated objects in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- edit_instructions: |2

    Modify the script to filter the list of files by a specific mime type, such as 'application/pdf', so that it only returns newly uploaded PDF files.
  id: |-
    hubedit_hub_252
  lang: |-
    deno
  modified_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { drive } from "npm:@googleapis/drive@4";

    const PAGE_SIZE = 500 as const;
    const MIME_TYPE = 'application/pdf' as const; // Added constant for the specific mime type

    /**
     * @returns A list of newly uploaded PDF files in ascending order
     * of creation date.
     * Maximum number of returned items is set to `500` for each run.
     */
    type Gdrive = {
      token: string;
    };
    export async function main(auth: Gdrive) {
      const client = drive({
        version: "v3",
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const lastCheck = await getState();
      await setState(new Date().toISOString());
      const query = `mimeType = '${MIME_TYPE}'` + (lastCheck ? ` and createdTime > '${lastCheck}'` : ''); // Modified query to filter by mime type
      const response = await client.files.list({
        q: query,
        orderBy: "createdTime asc",
        pageSize: PAGE_SIZE,
      });
      if (response.data.nextPageToken && response?.data?.files?.at(-1)) {
        const lastItem = await client.files.get({
          fileId: response.data.files.at(-1)?.id || undefined,
          fields: "createdTime",
        });
        const date = lastItem?.data?.createdTime;
        if (date) {
          await setState(date);
        }
      }

      return response.data.files;
    }
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { drive } from "npm:@googleapis/drive@4";

    const PAGE_SIZE = 500 as const;

    /**
     * @returns A list of newly uploaded files in ascending order
     * of creation date.
     * Maximum number of returned items is set to `500` for each run.
     */
    type Gdrive = {
      token: string;
    };
    export async function main(auth: Gdrive) {
      const client = drive({
        version: "v3",
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const lastCheck = await getState();
      await setState(new Date().toISOString());
      const response = await client.files.list({
        q: lastCheck ? `createdTime > '${lastCheck}'` : undefined,
        orderBy: "createdTime asc",
        pageSize: PAGE_SIZE,
      });
      if (response.data.nextPageToken && response?.data?.files?.at(-1)) {
        const lastItem = await client.files.get({
          fileId: response.data.files.at(-1)?.id || undefined,
          fields: "createdTime",
        });
        const date = lastItem?.data?.createdTime;
        if (date) {
          await setState(date);
        }
      }

      return response.data.files;
    }
  original_instructions: |-
    Get new files in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to filter out vectors with a magnitude below a certain threshold before upserting them into the Pinecone index.
  id: |-
    hubedit_hub_344
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { UpsertOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };

    function vectorMagnitude(values: number[]): number {
      return Math.sqrt(values.reduce((acc, val) => acc + val * val, 0));
    }

    export async function main(
      auth: Pinecone,
      index_name: string,
      vectors: { id: string; values: number[]; metadata?: Record<string, any> }[],
      namespace?: string,
      raw?: boolean,
      magnitudeThreshold: number = 0, // Add a magnitude threshold parameter with a default value of 0
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      // Filter out vectors with a magnitude below the threshold
      const filteredVectors = vectors.filter(vector => vectorMagnitude(vector.values) >= magnitudeThreshold);

      const upsertRequest: UpsertOperationRequest = removeObjectEmptyFields({
        vectors: filteredVectors,
        namespace,
      });
      return await index[raw ? "upsertRaw" : "upsert"]({ upsertRequest });
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { UpsertOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      vectors: { id: string; values: number[]; metadata?: Record<string, any> }[],
      namespace?: string,
      raw?: boolean,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const upsertRequest: UpsertOperationRequest = removeObjectEmptyFields({
        vectors,
        namespace,
      });
      return await index[raw ? "upsertRaw" : "upsert"]({ upsertRequest });
    }
  original_instructions: |-
    Upsert Vectors in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- edit_instructions: |2

    Add error handling to check the response status and throw an error with the response status text if the deletion is unsuccessful.
  id: |-
    hubedit_hub_62
  lang: |-
    deno
  modified_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: string,
      allowItemDeletion: boolean = false,
      useDomainAdminAccess: boolean = false,
    ) {
      const DELETE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?allowItemDeletion=${allowItemDeletion}&useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_SHARED_DRIVE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        const errorText = response.statusText || "An error occurred during the deletion process.";
        throw new Error(`Failed to delete shared drive: ${errorText}`);
      }

      return "Deleted shared drive.";
    }
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: string,
      allowItemDeletion: boolean = false,
      useDomainAdminAccess: boolean = false,
    ) {
      const DELETE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?allowItemDeletion=${allowItemDeletion}&useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_SHARED_DRIVE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return "Deleted shared drive.";
    }
  original_instructions: |-
    Delete Shared Drive in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter and return only starrers who have public email addresses associated with their GitHub profiles.
  id: |-
    hubedit_hub_247
  lang: |-
    deno
  modified_code: |-
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;

    /**
     * @returns A list of starrers with public email addresses in descending order of when they starred.
     * The maximum number of returned items is 500.
     */
    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const lastUpdate = (await getState()) || 0;

      const starCount = (await octokit.repos.get({ owner, repo })).data
        .stargazers_count;
      let lastPage =
        +(starCount / 100).toFixed(0) + (starCount % 100 === 0 ? 0 : 1);
      const newStarrers: Starrer[] = [];

      await setState(Date.now());
      let runLoop = true;
      do {
        const response = await octokit.activity.listStargazersForRepo({
          owner,
          repo,
          per_page: 100,
          page: lastPage--,
          headers: {
            accept: "application/vnd.github.star+json",
          },
        });
        for (let i = response.data.length - 1; i >= 0; i--) {
          const entry = response.data[i];
          if (!entry || !entry.user) continue;
          const starredAt = new Date(entry.starred_at).getTime();
          if (starredAt < lastUpdate) {
            runLoop = false;
            break;
          }
          if (entry.user.email && entry.user.email !== '') {
            const { id, login, type, url, email, name } = entry.user;
            newStarrers.push({ id, starredAt, login, type, url, email, name });
            if (newStarrers.length >= MAX_ITEMS) {
              await setState(newStarrers.at(-1)?.starredAt);
              runLoop = false;
              break;
            }
          }
        }
      } while (runLoop);
      console.log(newStarrers.length);
      return newStarrers;
    }

    interface Starrer {
      id: number;
      login: string;
      type: string;
      url: string;
      starredAt: number;
      email?: string | null;
      name?: string | null;
    }
  original_code: |
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;

    /**
     * @returns A list of starrers in descending order of when they starred.
     * The maximum number of returned items is 500.
     */
    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const lastUpdate = (await getState()) || 0;

      const starCount = (await octokit.repos.get({ owner, repo })).data
        .stargazers_count;
      let lastPage =
        +(starCount / 100).toFixed(0) + (starCount % 100 === 0 ? 0 : 1);
      const newStarrers: Starrer[] = [];

      await setState(Date.now());
      let runLoop = true;
      do {
        const response = await octokit.activity.listStargazersForRepo({
          owner,
          repo,
          per_page: 100,
          page: lastPage--,
          headers: {
            accept: "application/vnd.github.star+json",
          },
        });
        for (let i = response.data.length - 1; i >= 0; i--) {
          const entry = response.data[i];
          if (!entry || !entry.user) continue;
          const starredAt = new Date(entry.starred_at).getTime();
          if (starredAt < lastUpdate) {
            runLoop = false;
            break;
          }
          const { id, login, type, url, email, name } = entry.user;
          newStarrers.push({ id, starredAt, login, type, url, email, name });
          if (newStarrers.length >= MAX_ITEMS) {
            await setState(newStarrers.at(-1)?.starredAt);
            runLoop = false;
            break;
          }
        }
      } while (runLoop);
      console.log(newStarrers.length);
      return newStarrers;
    }

    interface Starrer {
      id: number;
      login: string;
      type: string;
      url: string;
      starredAt: number;
      email?: string | null;
      name?: string | null;
    }
  original_instructions: |-
    Notify of new Github repo stars in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to send an email notification to the user with the error details when an error occurs.
  id: |-
    hubedit_hub_402
  lang: |-
    deno
  modified_code: |-
    import { sendEmail } from './emailService'; // Assuming there's an email service module to send emails

    export async function main(
      path: string,
      email: string,
      error: object,
      job_id: string,
      is_flow: boolean,
      workspace_id: string,
    ) {
      const run_type = is_flow ? "flow" : "script";
      console.log(
        `An error occurred with ${run_type} ${path} run by ${email} in workspace ${workspace_id}`,
      );
      console.log(error);

      // Construct the error message
      const errorMessage = `Dear User,\n\nAn error occurred while running your ${run_type} (${path}).\n\nError Details:\n${JSON.stringify(error, null, 2)}\n\nJob ID: ${job_id}\nWorkspace ID: ${workspace_id}\n\nPlease address the issue and try again.\n\nBest,\nSupport Team`;

      // Send an email notification to the user
      try {
        await sendEmail({
          to: email,
          subject: `Error Notification for ${run_type} ${path}`,
          body: errorMessage,
        });
        console.log(`Error notification sent to ${email}`);
      } catch (emailError) {
        console.error(`Failed to send error notification email to ${email}`, emailError);
      }

      return error;
    }
  original_code: |
    // Global / workspace error handler template

    export async function main(
      path: string, // The path of the script or flow that errored
      email: string, // The email of the user who ran the script or flow that errored
      error: object, // The error details
      job_id: string, // The job id
      is_flow: boolean, // Whether the error comes from a flow
      workspace_id: string, // The workspace id of the failed script or flow
    ) {
      const run_type = is_flow ? "flow" : "script";
      console.log(
        `An error occured with ${run_type} ${path} run by ${email} in workspace ${workspace_id}`,
      );
      console.log(error);
      return error;
    }
  original_instructions: |-
    Global / workspace error handler template in windmill
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to save the chat history to a local file after each interaction with the OpenAI API.
  id: |-
    hubedit_hub_347
  lang: |-
    deno
  modified_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateChatCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.2.1";
    import { writeJsonSync } from "https://deno.land/std/fs/mod.ts";

    /**
     * You can read about the parameters at
     * https://platform.openai.com/docs/api-reference/chat/create
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      messages: {
        role: "assistant" | "system" | "user";
        content: string;
        name?: string;
      }[],
      model: "gpt-3.5-turbo" | "gpt-3.5-turbo-0301" = "gpt-3.5-turbo",
      frequency_penalty?: number,
      logit_bias?: object,
      max_tokens?: number,
      n?: number,
      presence_penalty?: number,
      stop?: string,
      stream?: boolean,
      temperature?: number,
      top_p?: number,
      user?: string,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request: CreateChatCompletionRequest = {
        messages,
        model,
        frequency_penalty,
        logit_bias,
        max_tokens,
        n,
        presence_penalty,
        stop,
        stream,
        temperature,
        top_p,
        user,
      };
      const response = await openai.createChatCompletion(
        removeObjectEmptyFields(request),
      );

      // Save chat history to a local file
      const chatHistory = {
        messages: response.data.messages,
        created: new Date().toISOString(),
      };
      const fileName = `chat_history_${Date.now()}.json`;
      writeJsonSync(fileName, chatHistory, { spaces: 2 });

      return response.data;
    }
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateChatCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.2.1";

    /**
     * You can read about the parameters at
     * https://platform.openai.com/docs/api-reference/chat/create
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      messages: {
        role: "assistant" | "system" | "user";
        content: string;
        name?: string;
      }[],
      model: "gpt-3.5-turbo" | "gpt-3.5-turbo-0301" = "gpt-3.5-turbo",
      frequency_penalty?: number,
      logit_bias?: object,
      max_tokens?: number,
      n?: number,
      presence_penalty?: number,
      stop?: string,
      stream?: boolean,
      temperature?: number,
      top_p?: number,
      user?: string,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request: CreateChatCompletionRequest = {
        messages,
        model,
        frequency_penalty,
        logit_bias,
        max_tokens,
        n,
        presence_penalty,
        stop,
        stream,
        temperature,
        top_p,
        user,
      };
      const response = await openai.createChatCompletion(
        removeObjectEmptyFields(request),
      );
      return response.data;
    }
  original_instructions: |-
    Create Chat Completion in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- edit_instructions: |2

    Modify the script to create a new room instead of inviting users to an existing room by changing the API endpoint and adjusting the request body to include necessary parameters for room creation.
  id: |-
    hubedit_hub_105
  lang: |-
    deno
  modified_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      is_direct = false,
      name = "",
      room_alias_name = "",
      room_version = "",
      topic = "",
      visibility: "public" | "private" = "private",
    ) {
      if (!matrix_res.token) {
        throw Error("Creating a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/createRoom`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            visibility,
            room_alias_name,
            name,
            topic,
            is_direct,
            room_version,
            // Additional parameters can be added here if needed
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to create room: Error HTTP${resp.status}`);
      }
    }
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      is_direct = false,
      name = "",
      room_alias_name = "",
      room_version = "",
      topic = "",
      visibility: "public" | "private" = "private",
    ) {
      if (!matrix_res.token) {
        throw Error("Creating a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          room_id,
        )}/invite`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            is_direct,
            ...(name && { name }),
            ...(room_alias_name && { room_alias_name }),
            ...(room_version && { room_version }),
            ...(topic && { topic }),
            visibility,
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to create room: Error HTTP${resp.status}`);
      }
    }
  original_instructions: |-
    Create room in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- edit_instructions: |2

    Add functionality to log the timestamp and email of each user when a direct message is successfully sent, storing this information in a local file or a database for future reference and auditing purposes.
  id: |-
    hubedit_hub_179
  lang: |-
    deno
  modified_code: |-
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    import { writeJsonSync } from "https://deno.land/std/fs/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(approver_emails: string[], slack: Slack) {
      throwOnInvalidApprovers(approver_emails);

      const client = new WebClient(slack.token);
      const usersData = await Promise.all(
        approver_emails.map((email) => getUserData(client, email)),
      );
      console.log(usersData);
      const dmPromises = usersData.map((userData) =>
        sendDirectMessage(client, userData),
      );

      const results = await Promise.all(dmPromises);
      logSentMessages(results); // Log the sent messages
      return results;
    }

    interface UserData {
      id: string;
      email: string;
      real_name: string;
    }

    async function getUserData(client: WebClient, email: string): UserData {
      try {
        const response = await client.users.lookupByEmail({ email: email });

        const { id, real_name } = response.user;
        return { id, email, real_name };
      } catch (err) {
        return handleApiResponse(email, err);
      }
    }

    async function sendDirectMessage(client: WebClient, userData: UserData) {
      const text = await getApprovalMsg(userData.email);

      const { ok, ts, channel } = await client.chat.postMessage({
        channel: userData.id,
        text,
      });
      return { ok, ts, channel, email: userData.email };
    }

    async function getApprovalMsg(to_email) {
      const { approvalPage } = await getResumeUrls(to_email);
      return `There is a Windmill flow at ${Deno.env.get(
        "WM_FLOW_PATH",
      )} run by ${Deno.env.get("WM_USERNAME")} waiting for your approval to resume.

    In order to resume or cancel the flow go to ${approvalPage}`;
    }

    function throwOnInvalidApprovers(approvers: string[]) {
      if (!Array.isArray(approvers) || approvers.length === 0) {
        throw new Error("Expected at least one approver email");
      }
    }

    function handleApiResponse(email, error) {
      return Promise.reject({ email, err_msg: error.message });
    }

    // New function to log sent messages
    function logSentMessages(messages: any[]) {
      const logFilePath = 'sent_messages_log.json';
      const timestamp = new Date().toISOString();
      const logEntries = messages.map(message => ({
        timestamp,
        email: message.email,
        status: message.ok ? 'Sent' : 'Failed',
      }));

      // Append to a local file or create it if it doesn't exist
      try {
        const currentLogs = JSON.parse(Deno.readTextFileSync(logFilePath));
        const updatedLogs = currentLogs.concat(logEntries);
        writeJsonSync(logFilePath, updatedLogs);
      } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
          // File doesn't exist, create new file with logEntries
          writeJsonSync(logFilePath, logEntries);
        } else {
          console.error('Error writing log file:', error);
        }
      }
    }
  original_code: |
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(approver_emails: string[], slack: Slack) {
      throwOnInvalidApprovers(approver_emails);

      const client = new WebClient(slack.token);
      const usersData = await Promise.all(
        approver_emails.map((email) => getUserData(client, email)),
      );
      console.log(usersData);
      const dmPromises = usersData.map((userData) =>
        sendDirectMessage(client, userData),
      );

      const results = await Promise.all(dmPromises);
      return results;
    }

    interface UserData {
      id: string;
      email: string;
      real_name: string;
    }

    async function getUserData(client: WebClient, email: string): UserData {
      try {
        const response = await client.users.lookupByEmail({ email: email });

        const { id, real_name } = response.user;
        return { id, email, real_name };
      } catch (err) {
        return handleApiResponse(email, err);
      }
    }

    async function sendDirectMessage(client: WebClient, userData: UserData) {
      const text = await getApprovalMsg(userData.email);

      const { ok, ts, channel } = await client.chat.postMessage({
        channel: userData.id,
        text,
      });
      return { ok, ts, channel, email: userData.email };
    }

    async function getApprovalMsg(to_email) {
      const { approvalPage } = await getResumeUrls(to_email);
      return `There is a Windmill flow at ${Deno.env.get(
        "WM_FLOW_PATH",
      )} run by ${Deno.env.get("WM_USERNAME")} waiting for your approval to resume.

    In order to resume or cancel the flow go to ${approvalPage}`;
    }

    function throwOnInvalidApprovers(approvers: string[]) {
      if (!Array.isArray(approvers) || approvers.length === 0) {
        throw new Error("Expected at least one approver email");
      }
    }

    function handleApiResponse(email, error) {
      return Promise.reject({ email, err_msg: error.message });
    }
  original_instructions: |-
    Suspend/resume a flow by sending approval URL via slack direct message in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- edit_instructions: |2

    Add functionality to set the event's visibility to public or private based on an additional parameter provided to the function.
  id: |-
    hubedit_hub_45
  lang: |-
    deno
  modified_code: |-
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
      visibility: 'public' | 'private' = 'public', // Added visibility parameter with default value 'public'
    ) {
      // ... rest of the code remains unchanged ...

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
        visibility: visibility, // Added visibility to the request body
      };

      // ... rest of the code remains unchanged ...
    }
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
    ) {
      const alwaysIncludeEmail = true;
      const sendUpdates = "all";
      const supportsAttachments = true;
      const UPDATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?alwaysIncludeEmail=${alwaysIncludeEmail}&sendUpdates=${sendUpdates}&supportsAttachments=${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
      };

      const response = await fetch(UPDATE_EVENT_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Update Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- edit_instructions: |2

    Add a feature to cache the response for a certain duration to reduce the number of API calls to Mailchimp.
  id: |-
    hubedit_hub_205
  lang: |-
    deno
  modified_code: |-
    import { Cache } from "./cache.ts"; // Assuming there's a Cache module to handle caching

    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };

    // Assuming a cache duration in milliseconds
    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

    export async function main(
      auth: Mailchimp,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      sort_dir?: "" | "ASC" | "DESC",
      type?: "" | "regular" | "plaintext" | "absplit" | "rss" | "variate",
      status?: "" | "save" | "paused" | "schedule" | "sending" | "sent",
      before_send_time?: string,
      since_send_time?: string,
      before_create_time?: string,
      since_create_time?: string,
      list_id?: string,
      folder_id?: string,
      member_id?: string,
      sort_field?: "" | "create_time" | "send_time",
    ) {
      const cacheKey = JSON.stringify({
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        type,
        status,
        before_send_time,
        since_send_time,
        before_create_time,
        since_create_time,
        list_id,
        folder_id,
        member_id,
        sort_field,
      });

      // Check if the response is in the cache
      const cachedResponse = await Cache.get(cacheKey);
      if (cachedResponse && Date.now() - cachedResponse.timestamp < CACHE_DURATION) {
        return cachedResponse.data;
      }

      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/campaigns`);
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        type,
        status,
        before_send_time,
        since_send_time,
        before_create_time,
        since_create_time,
        list_id,
        folder_id,
        member_id,
        sort_field,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      const responseData = await response.json();

      // Save the response in the cache with a timestamp
      await Cache.set(cacheKey, { data: responseData, timestamp: Date.now() });

      return responseData;
    }
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      sort_dir?: "" | "ASC" | "DESC",
      type?: "" | "regular" | "plaintext" | "absplit" | "rss" | "variate",
      status?: "" | "save" | "paused" | "schedule" | "sending" | "sent",
      before_send_time?: string,
      since_send_time?: string,
      before_create_time?: string,
      since_create_time?: string,
      list_id?: string,
      folder_id?: string,
      member_id?: string,
      sort_field?: "" | "create_time" | "send_time",
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/campaigns`);
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        type,
        status,
        before_send_time,
        since_send_time,
        before_create_time,
        since_create_time,
        list_id,
        folder_id,
        member_id,
        sort_field,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Search Campaigns in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- edit_instructions: |2

    Add functionality to check if a list with the same name already exists before creating a new one, and if it does, return a message indicating that the list already exists instead of creating a duplicate.
  id: |-
    hubedit_hub_222
  lang: |-
    deno
  modified_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };

    export async function main(api_token: Sendgrid, name: string) {
      sendgrid.setApiKey(api_token.token);

      // Check if a list with the same name already exists
      const checkRequest = {
        url: `/v3/marketing/lists`,
        method: "GET",
      };

      try {
        const [response, checkBody] = await sendgrid.request(checkRequest);
        const lists = checkBody?.result || [];
        const listExists = lists.some((list: any) => list.name === name);

        if (listExists) {
          return { message: `A list with the name '${name}' already exists.` };
        }
      } catch (checkError) {
        throw Error("\n" + JSON.stringify(checkError?.response?.body || checkError));
      }

      // Create a new list if it doesn't exist
      const createRequest = {
        url: `/v3/marketing/lists`,
        method: "POST",
        body: { name },
      };

      try {
        const [_, createBody] = await sendgrid.request(createRequest);
        return createBody;
      } catch (createError) {
        throw Error("\n" + JSON.stringify(createError?.response?.body || createError));
      }
    }
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(api_token: Sendgrid, name: string) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "POST",
        body: { name },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Create Contact List in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- edit_instructions: |2

    Modify the script to filter out monitors that are muted, by checking if the `monitor.options.silenced` property is empty or not, and only include active monitors in the `monitor_urls` list.
  id: |-
    hubedit_hub_29
  lang: |-
    deno
  modified_code: |-
    import ApiClient from "https://deno.land/x/datadog_api/client.ts";
    import V1MonitorsApi from "https://deno.land/x/datadog_api/v1/monitors.ts";

    type Datadog = {
      apiKey: string;
      appKey: string;
      apiBase: string;
    };
    export async function main(dd_auth: Datadog) {
      let count = 0;
      // Set up a Monitors API client
      const datadog = new ApiClient(dd_auth);
      const monitorsApi = new V1MonitorsApi(datadog);

      let monitor_urls = [];
      // Search for relevant monitors via a metric filter
      for await (const monitor of monitorsApi.searchToEnd(`metric:trace*`)) {
        // Skip monitors that have a scoped environment set
        if (!monitor.query.includes("env:production")) continue;
        if (!monitor.query.includes("env:sandbox")) continue;

        // Skip monitors that are muted
        if (Object.keys(monitor.options.silenced).length > 0) continue;

        // return the monitor URL for further manual inspection
        monitor_urls.push(`https://app.datadoghq.eu/monitors/${monitor.id}`);
        count++;
      }

      // Return number of matched monitors as a summary
      return { count: count, monitor_urls: monitor_urls };
    }
  original_code: |
    import ApiClient from "https://deno.land/x/datadog_api/client.ts";
    import V1MonitorsApi from "https://deno.land/x/datadog_api/v1/monitors.ts";

    type Datadog = {
      apiKey: string;
      appKey: string;
      apiBase: string;
    };
    export async function main(dd_auth: Datadog) {
      let count = 0;
      // Set up a Monitors API client
      const datadog = new ApiClient(dd_auth);
      const monitorsApi = new V1MonitorsApi(datadog);

      let monitor_urls = [];
      // Search for relevant monitors via a metric filter
      for await (const monitor of monitorsApi.searchToEnd(`metric:trace*`)) {
        // Skip monitors that have a scoped environment set
        if (!monitor.query.includes("env:production")) continue;
        if (!monitor.query.includes("env:sandbox")) continue;

        // return the monitor URL for further manual inspection
        monitor_urls.push(`https://app.datadoghq.eu/monitors/${monitor.id}`);
        count++;
      }

      // Return number of matched monitors as a summary
      return { count: count, monitor_urls: monitor_urls };
    }
  original_instructions: |-
    Find Monitors in datadog
  resource_type: |-
    Datadog
  resource_type_def: |-
    type Datadog = {
      apiKey: string;
      appKey: string;
      apiBase: string;
    }
- edit_instructions: |2

    Modify the script to count the number of uppercase letters in the input text if it contains neither spaces nor commas.
  id: |-
    hubedit_humaneval_py_HumanEval/125
  lang: |-
    python
  modified_code: |-
    def main(txt):
        if " " in txt:
            return txt.split()
        elif "," in txt:
            return txt.replace(',', ' ').split()
        else:
            return sum(1 for i in txt if i.isupper())
  original_code: |2

    def main(txt):

        if " " in txt:
            return txt.split()
        elif "," in txt:
            return txt.replace(',',' ').split()
        else:
            return len([i for i in txt if i.islower() and ord(i)%2 == 0])
  original_instructions: "\n    Given a string of words, return a list of words split\
    \ on whitespace, if no whitespaces exists in the text you\n    should split on\
    \ commas ',' if no commas exists you should return the number of lower-case letters\
    \ with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n    Examples\n    split_words(\"Hello world!\") \u279E [\"Hello\", \"\
    world!\"]\n    split_words(\"Hello,world!\") \u279E [\"Hello\", \"world!\"]\n\
    \    split_words(\"abcdef\") == 3\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if both strings have the same characters and the same number of each character, effectively checking for anagrams.
  id: |-
    hubedit_humaneval_py_HumanEval/54
  lang: |-
    python
  modified_code: |-
    def main(s0: str, s1: str):
        return sorted(s0) == sorted(s1)
  original_code: |2


    def main(s0: str, s1: str):

        return set(s0) == set(s1)
  original_instructions: "\n    Check if two words have the same characters.\n   \
    \ >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd',\
    \ 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n\
    \    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd',\
    \ 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n\
    \    False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to accept a range of numbers and return a list of their corresponding lowercase Roman numeral representations.
  id: |-
    hubedit_humaneval_py_HumanEval/156
  lang: |-
    python
  modified_code: |-
    def main(start, end):
        num = [1, 4, 5, 9, 10, 40, 50, 90,
               100, 400, 500, 900, 1000]
        sym = ["I", "IV", "V", "IX", "X", "XL",
               "L", "XC", "C", "CD", "D", "CM", "M"]
        roman_numerals = []

        for number in range(start, end + 1):
            i = 12
            res = ''
            while number:
                div = number // num[i]
                number %= num[i]
                while div:
                    res += sym[i]
                    div -= 1
                i -= 1
            roman_numerals.append(res.lower())

        return roman_numerals
  original_code: |2

    def main(number):

        num = [1, 4, 5, 9, 10, 40, 50, 90,
               100, 400, 500, 900, 1000]
        sym = ["I", "IV", "V", "IX", "X", "XL",
               "L", "XC", "C", "CD", "D", "CM", "M"]
        i = 12
        res = ''
        while number:
            div = number // num[i]
            number %= num[i]
            while div:
                res += sym[i]
                div -= 1
            i -= 1
        return res.lower()
  original_instructions: "\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n\
    \    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the list 'q' can be split into two non-empty sublists such that the sum of the elements in each sublist is equal to 'w'.
  id: |-
    hubedit_humaneval_py_HumanEval/72
  lang: |-
    python
  modified_code: |-
    def main(q, w):
        # Calculate the total sum of the list
        total_sum = sum(q)

        # If the total sum is not equal to twice the value of w, it's not possible to split into two equal sublists
        if total_sum != 2 * w:
            return False

        # Initialize a variable to keep track of the running sum
        running_sum = 0

        # Iterate through the list to find a split point
        for i in range(len(q)):
            running_sum += q[i]
            # If the running sum equals w, we have found a valid split
            if running_sum == w:
                return True

        # If no valid split is found, return False
        return False
  original_code: |2

    def main(q,w):

        if sum(q) > w:
            return False

        i, j = 0, len(q)-1
        while i<j:
            if q[i] != q[j]:
                return False
            i+=1
            j-=1
        return True
  original_instructions: "\n    Write a function that returns True if the object q\
    \ will fly, and False otherwise.\n    The object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279E\
    \ False\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\
    \n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279E\
    \ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    \n    will_it_fly([3], 5) \u279E True\n    # 3 is less than the maximum possible\
    \ weight, and it's balanced.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to find the smallest prime number in the list instead of the largest, and return the product of its digits.
  id: |-
    hubedit_humaneval_py_HumanEval/94
  lang: |-
    python
  modified_code: |-
    def main(lst):

        def isPrime(n):
            if n <= 1:
                return False
            for i in range(2, int(n**0.5) + 1):
                if n % i == 0:
                    return False
            return True

        min_prime = float('inf')
        for num in lst:
            if isPrime(num) and num < min_prime:
                min_prime = num

        if min_prime == float('inf'):
            return 0  # No prime number found

        result = 1
        for digit in str(min_prime):
            result *= int(digit)
        return result
  original_code: |2+


    def main(lst):

        def isPrime(n):
            for i in range(2,int(n**0.5)+1):
                if n%i==0:
                    return False

            return True
        maxx = 0
        i = 0
        while i < len(lst):
            if(lst[i] > maxx and isPrime(lst[i])):
                maxx = lst[i]
            i+=1
        result = sum(int(digit) for digit in str(maxx))
        return result

  original_instructions: "You are given a list of integers.\n    You need to find\
    \ the largest prime value and return the sum of its digits.\n\n    Examples:\n\
    \    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output\
    \ should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output\
    \ should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\
    \ the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\
    \ the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be\
    \ 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to check if the last word of the input text is a palindrome instead of checking if it is a single character between 'a' and 'z'.
  id: |-
    hubedit_humaneval_py_HumanEval/134
  lang: |-
    python
  modified_code: |-
    def main(txt):
        last_word = txt.split(' ')[-1]
        return last_word == last_word[::-1]
  original_code: |2

    def main(txt):


        check = txt.split(' ')[-1]
        return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
  original_instructions: "\n    Create a function that returns True if the last character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and False otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\"\
    ) \u279E False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n\
    \    check_if_last_char_is_a_letter(\"apple pi e \") \u279E False\n    check_if_last_char_is_a_letter(\"\
    \") \u279E False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the maximum product instead of the maximum sum of a subarray.
  id: |-
    hubedit_humaneval_py_HumanEval/114
  lang: |-
    python
  modified_code: |-
    def main(nums):
        max_product = float('-inf')
        min_product = 1
        current_product = 1

        for num in nums:
            if num == 0:
                current_product = 1
                min_product = 1
                max_product = max(max_product, 0)
                continue

            temp = current_product * num
            current_product = max(num, temp, min_product * num)
            min_product = min(num, temp, min_product * num)
            max_product = max(max_product, current_product)

        return max_product
  original_code: |2

    def main(nums):

        max_sum = 0
        s = 0
        for num in nums:
            s += -num
            if (s < 0):
                s = 0
            max_sum = max(s, max_sum)
        if max_sum == 0:
            max_sum = max(-i for i in nums)
        min_sum = -max_sum
        return min_sum
  original_instructions: "\n    Given an array of integers nums, find the minimum\
    \ sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2,\
    \ 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count numbers that are less than 10 and have an even number of digits.
  id: |-
    hubedit_humaneval_py_HumanEval/146
  lang: |-
    python
  modified_code: |-
    def main(nums):
        count = 0
        for num in nums:
            if num < 10:
                number_as_string = str(num)
                if len(number_as_string) % 2 == 0:
                    count += 1
        return count
  original_code: |2

    def main(nums):


        count = 0
        for num in nums:
            if num > 10:
                odd_digits = (1, 3, 5, 7, 9)
                number_as_string = str(num)
                if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                    count += 1

        return count
  original_instructions: "Write a function that takes an array of numbers as input\
    \ and returns\n    the number of elements in the array that are greater than 10\
    \ and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n \
    \   For example:\n    specialFilter([15, -73, 14, -15]) => 1\n    specialFilter([33,\
    \ -2, -3, 45, 21, 109]) => 2\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check for prime numbers in a more efficient way by only iterating up to the square root of n instead of n - 1.
  id: |-
    hubedit_humaneval_py_HumanEval/31
  lang: |-
    python
  modified_code: |-
    import math

    def main(n):
        if n < 2:
            return False
        for k in range(2, int(math.sqrt(n)) + 1):
            if n % k == 0:
                return False
        return True
  original_code: |2


    def main(n):

        if n < 2:
            return False
        for k in range(2, n - 1):
            if n % k == 0:
                return False
        return True
  original_instructions: "Return true if a given number is prime, and false otherwise.\n\
    \    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n\
    \    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n\
    \    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the second largest element in the list instead of the second smallest.
  id: |-
    hubedit_humaneval_py_HumanEval/90
  lang: |-
    python
  modified_code: |-
    def main(lst):
        lst = sorted(set(lst), reverse=True)
        return None if len(lst) < 2 else lst[1]
  original_code: |2

    def main(lst):

        lst = sorted(set(lst))
        return None if len(lst) < 2 else lst[1]
  original_instructions: "\n    You are given a list of integers.\n    Write a function\
    \ next_smallest() that returns the 2nd smallest element of the list.\n    Return\
    \ None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n\
    \    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1,\
    \ 1]) == None\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count non-overlapping occurrences of the substring within the string instead of all occurrences.
  id: |-
    hubedit_humaneval_py_HumanEval/18
  lang: |-
    python
  modified_code: |-
    def main(string: str, substring: str) -> int:
        times = 0
        i = 0

        while i <= len(string) - len(substring):
            if string[i:i+len(substring)] == substring:
                times += 1
                i += len(substring)  # Move past the substring we just found
            else:
                i += 1  # Move to the next character

        return times
  original_code: |2


    def main(string: str, substring: str) -> int:

        times = 0

        for i in range(len(string) - len(substring) + 1):
            if string[i:i+len(substring)] == substring:
                times += 1

        return times
  original_instructions: " Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n\
    \    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa',\
    \ 'aa')\n    3\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the k smallest elements from the array instead of the k largest.
  id: |-
    hubedit_humaneval_py_HumanEval/120
  lang: |-
    python
  modified_code: |-
    def main(arr, k):
        if k == 0:
            return []
        arr.sort()
        ans = arr[:k]
        return ans
  original_code: |2

    def main(arr, k):

        if k == 0:
            return []
        arr.sort()
        ans = arr[-k:]
        return ans
  original_instructions: "\n    Given an array arr of integers and a positive integer\
    \ k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\
    \n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4,\
    \ -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n       \
    \ Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2,\
    \ 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array\
    \ will be in the range of [1, 1000].\n        2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to accept a list of numbers and a list of needs, then iterate over both lists to apply the original logic to each pair of number and need, returning a list of updated numbers and the remaining value after all operations.
  id: |-
    hubedit_humaneval_py_HumanEval/159
  lang: |-
    python
  modified_code: |-
    def main(numbers, needs, remaining):
        updated_numbers = []
        for number, need in zip(numbers, needs):
            if need <= remaining:
                updated_numbers.append(number + need)
                remaining -= need
            else:
                updated_numbers.append(number + remaining)
                remaining = 0
        return updated_numbers, remaining
  original_code: |2

    def main(number, need, remaining):

        if(need <= remaining):
            return [ number + need , remaining-need ]
        else:
            return [ number + remaining , 0]
  original_instructions: "\n    You're a hungry rabbit, and you already have eaten\
    \ a certain number of carrots,\n    but now you need to eat more carrots to complete\
    \ the day's meals.\n    you should return an array of [ total number of eaten\
    \ carrots after your meals,\n                                    the number of\
    \ carrots left after your meals ]\n    if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n\n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n\n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n\n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of unique pairs of indices where the absolute difference between the elements at those indices is less than the threshold.
  id: |-
    hubedit_humaneval_py_HumanEval/0
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple

    def main(numbers: List[float], threshold: float) -> List[Tuple[int, int]]:

        close_pairs = []
        for idx, elem in enumerate(numbers):
            for idx2 in range(idx + 1, len(numbers)):
                elem2 = numbers[idx2]
                distance = abs(elem - elem2)
                if distance < threshold:
                    close_pairs.append((idx, idx2))

        return close_pairs
  original_code: |
    from typing import List


    def main(numbers: List[float], threshold: float) -> bool:

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    distance = abs(elem - elem2)
                    if distance < threshold:
                        return True

        return False
  original_instructions: " Check if in given list of numbers, are any two numbers\
    \ closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of elements in the array that are greater than the corresponding elements from the end of the array, instead of counting the number of non-matching elements.
  id: |-
    hubedit_humaneval_py_HumanEval/73
  lang: |-
    python
  modified_code: |-
    def main(arr):
        ans = 0
        for i in range(len(arr) // 2):
            if arr[i] > arr[len(arr) - i - 1]:
                ans += 1
        return ans
  original_code: |2

    def main(arr):

        ans = 0
        for i in range(len(arr) // 2):
            if arr[i] != arr[len(arr) - i - 1]:
                ans += 1
        return ans
  original_instructions: "\n    Given an array arr of integers, find the minimum number\
    \ of elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of prime digits (2, 3, 5, 7) instead of even and odd digits, and return the count of prime digits along with the count of non-prime digits.
  id: |-
    hubedit_humaneval_py_HumanEval/155
  lang: |-
    python
  modified_code: |-
    def main(num):
        prime_count = 0
        non_prime_count = 0
        prime_digits = {'2', '3', '5', '7'}
        for i in str(abs(num)):
            if i in prime_digits:
                prime_count += 1
            else:
                non_prime_count += 1
        return (prime_count, non_prime_count)
  original_code: |2

    def main(num):

        even_count = 0
        odd_count = 0
        for i in str(abs(num)):
            if int(i)%2==0:
                even_count +=1
            else:
                odd_count +=1
        return (even_count, odd_count)
  original_instructions: "Given an integer. return a tuple that has the number of\
    \ even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12)\
    \ ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the square of the rounded number instead of the rounded number itself.
  id: |-
    hubedit_humaneval_py_HumanEval/99
  lang: |-
    python
  modified_code: |-
    def main(value):
        from math import floor, ceil

        if value.count('.') == 1:
            # remove trailing zeros
            while (value[-1] == '0'):
                value = value[:-1]

        num = float(value)
        if value[-2:] == '.5':
            if num > 0:
                res = ceil(num)
            else:
                res = floor(num)
        elif len(value) > 0:
            res = int(round(num))
        else:
            res = 0

        return res ** 2
  original_code: |2+

    def main(value):

        from math import floor, ceil

        if value.count('.') == 1:
            # remove trailing zeros
            while (value[-1] == '0'):
                value = value[:-1]

        num = float(value)
        if value[-2:] == '.5':
            if num > 0:
                res = ceil(num)
            else:
                res = floor(num)
        elif len(value) > 0:
            res = int(round(num))
        else:
            res = 0

        return res

  original_instructions: "\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to return the integer part of the number instead of the fractional part.
  id: |-
    hubedit_humaneval_py_HumanEval/2
  lang: |-
    python
  modified_code: |-
    def main(number: float) -> int:
        return int(number)
  original_code: |2


    def main(number: float) -> float:

        return number % 1.0
  original_instructions: " Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to find the pair of numbers with the largest distance between them instead of the closest pair.
  id: |-
    hubedit_humaneval_py_HumanEval/20
  lang: |-
    python
  modified_code: |-
    from typing import List, Tuple


    def main(numbers: List[float]) -> Tuple[float, float]:

        furthest_pair = None
        max_distance = None

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    new_distance = abs(elem - elem2)
                    if max_distance is None or new_distance > max_distance:
                        max_distance = new_distance
                        furthest_pair = tuple(sorted([elem, elem2]))

        return furthest_pair
  original_code: |
    from typing import List, Tuple


    def main(numbers: List[float]) -> Tuple[float, float]:

        closest_pair = None
        distance = None

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    if distance is None:
                        distance = abs(elem - elem2)
                        closest_pair = tuple(sorted([elem, elem2]))
                    else:
                        new_distance = abs(elem - elem2)
                        if new_distance < distance:
                            distance = new_distance
                            closest_pair = tuple(sorted([elem, elem2]))

        return closest_pair
  original_instructions: " From a supplied list of numbers (of length at least two)\
    \ select and return two that are the closest to each\n    other and return them\
    \ in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the index of the first element that is smaller than its predecessor, instead of the last one.
  id: |-
    hubedit_humaneval_py_HumanEval/135
  lang: |-
    python
  modified_code: |-
    def main(arr):
        for i in range(1, len(arr)):
            if arr[i] < arr[i-1]:
                return i
        return -1
  original_code: |2

    def main(arr):

        ind=-1
        i=1
        while i<len(arr):
          if arr[i]<arr[i-1]:
            ind=i
          i+=1
        return ind
  original_instructions: "Create a function which returns the largest index of an\
    \ element which\n    is not greater than or equal to the element immediately preceding\
    \ it. If\n    no such element exists then return -1. The given array will not\
    \ contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5])\
    \ = 3\n    can_arrange([1,2,3]) = -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to reverse the order of the characters in each word after sorting them, before joining them back into a sentence.
  id: |-
    hubedit_humaneval_py_HumanEval/86
  lang: |-
    python
  modified_code: |-
    def main(s):
        return ' '.join([''.join(sorted(list(i), reverse=True)) for i in s.split(' ')])
  original_code: |2

    def main(s):

        return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
  original_instructions: "\n    Write a function that takes a string and returns an\
    \ ordered version of it.\n    Ordered version of string, is a string where all\
    \ words (separated by space)\n    are replaced by a new word where all the characters\
    \ arranged in\n    ascending order based on ascii value.\n    Note: You should\
    \ keep the order of words and blank spaces in the sentence.\n\n    For example:\n\
    \    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n\
    \    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the smallest negative numbers and the sum of the largest positive numbers instead of the maximum and minimum of those subsets.
  id: |-
    hubedit_humaneval_py_HumanEval/136
  lang: |-
    python
  modified_code: |-
    def main(lst):
        smallest_negatives = list(filter(lambda x: x < 0, lst))
        largest_positives = list(filter(lambda x: x > 0, lst))
        return (sum(smallest_negatives) if smallest_negatives else None, sum(largest_positives) if largest_positives else None)
  original_code: |2

    def main(lst):

        smallest = list(filter(lambda x: x < 0, lst))
        largest = list(filter(lambda x: x > 0, lst))
        return (max(smallest) if smallest else None, min(largest) if largest else None)
  original_instructions: "\n    Create a function that returns a tuple (a, b), where\
    \ 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of\
    \ positive integers in a list.\n    If there is no negative or positive integers,\
    \ return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n\
    \    largest_smallest_integers([0]) == (None, None)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list of all the numbers in the Collatz sequence for the given `n`, not just the odd ones, and do not sort the list at the end to preserve the sequence order.
  id: |-
    hubedit_humaneval_py_HumanEval/123
  lang: |-
    python
  modified_code: |-
    def main(n):
        collatz_sequence = [n]
        while n > 1:
            if n % 2 == 0:
                n = n // 2
            else:
                n = n * 3 + 1
            collatz_sequence.append(n)
        return collatz_sequence
  original_code: |2

    def main(n):

        if n%2==0:
            odd_collatz = []
        else:
            odd_collatz = [n]
        while n > 1:
            if n % 2 == 0:
                n = n/2
            else:
                n = n*3 + 1

            if n%2 == 1:
                odd_collatz.append(int(n))

        return sorted(odd_collatz)
  original_instructions: "\n    Given a positive integer n, return a sorted list that\
    \ has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a\
    \ conjecture in mathematics that concerns a sequence defined\n    as follows:\
    \ start with any positive integer n. Then each term is obtained from the\n   \
    \ previous term as follows: if the previous term is even, the next term is one\
    \ half of\n    the previous term. If the previous term is odd, the next term is\
    \ 3 times the previous\n    term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1)\
    \ is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to use a dictionary mapping strings to actual arithmetic function calls (like `{'+' : operator.add, '-' : operator.sub}` etc.) instead of constructing a string to be evaluated, thus avoiding the use of `eval` for security and performance reasons.
  id: |-
    hubedit_humaneval_py_HumanEval/160
  lang: |-
    python
  modified_code: |-
    import operator as op

    def main(operator, operand):
        operations = {
            '+': op.add,
            '-': op.sub,
            '*': op.mul,
            '/': op.truediv,
            '//': op.floordiv,
            '%': op.mod,
            '**': op.pow
        }

        result = operand[0]
        for oprt, oprn in zip(operator, operand[1:]):
            if oprt in operations:
                result = operations[oprt](result, oprn)
            else:
                raise ValueError(f"Invalid operator: {oprt}")

        return result
  original_code: |2

    def main(operator, operand):

        expression = str(operand[0])
        for oprt, oprn in zip(operator, operand[1:]):
            expression+= oprt + str(oprn)
        return eval(expression)
  original_instructions: "\n    Given two lists operator, and operand. The first list\
    \ has basic algebra operations, and\n    the second list is a list of integers.\
    \ Use the two given lists to build the algebric\n    expression and return the\
    \ evaluation of this expression.\n\n    The basic algebra operations:\n    Addition\
    \ ( + )\n    Subtraction ( - )\n    Multiplication ( * )\n    Floor division (\
    \ // )\n    Exponentiation ( ** )\n\n    Example:\n    operator['+', '*', '-']\n\
    \    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n \
    \   Note:\n        The length of operator list is equal to the length of operand\
    \ list minus one.\n        Operand is a list of of non-negative integers.\n  \
    \      Operator list has at least one operator, and operand list has at least\
    \ two operands.\n\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to reverse each word that is not divisible by any number other than itself and 1 (i.e., prime-length words) before appending it to the new list.
  id: |-
    hubedit_humaneval_py_HumanEval/143
  lang: |-
    python
  modified_code: |-
    def main(sentence):
        def is_prime(num):
            if num < 2:
                return False
            for i in range(2, int(num**0.5) + 1):
                if num % i == 0:
                    return False
            return True

        new_lst = []
        for word in sentence.split():
            if is_prime(len(word)):
                new_lst.append(word[::-1])
            elif len(word) == 2:  # Special case for two-letter words
                new_lst.append(word)
        return " ".join(new_lst)
  original_code: |2

    def main(sentence):

        new_lst = []
        for word in sentence.split():
            flg = 0
            if len(word) == 1:
                flg = 1
            for i in range(2, len(word)):
                if len(word)%i == 0:
                    flg = 1
            if flg == 0 or len(word) == 2:
                new_lst.append(word)
        return " ".join(new_lst)
  original_instructions: "\n    You are given a string representing a sentence,\n\
    \    the sentence contains some words separated by a space,\n    and you have\
    \ to return a string that contains the words from the original sentence,\n   \
    \ whose lengths are prime numbers,\n    the order of the words in the new string\
    \ should be the same as the original one.\n\n    Example 1:\n        Input: sentence\
    \ = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input:\
    \ sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n\
    \        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the maximum balance reached during the sequence of operations instead of returning a boolean indicating if the balance went negative.
  id: |-
    hubedit_humaneval_py_HumanEval/3
  lang: |-
    python
  modified_code: |-
    from typing import List


    def main(operations: List[int]) -> int:

        balance = 0
        max_balance = 0

        for op in operations:
            balance += op
            max_balance = max(max_balance, balance)

        return max_balance
  original_code: |
    from typing import List


    def main(operations: List[int]) -> bool:

        balance = 0

        for op in operations:
            balance += op
            if balance < 0:
                return True

        return False
  original_instructions: " You're given a list of deposit and withdrawal operations\
    \ on a bank account that starts with\n    zero balance. Your task is to detect\
    \ if at any point the balance of account fallls below zero, and\n    at that point\
    \ function should return True. Otherwise it should return False.\n    >>> below_zero([1,\
    \ 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the sum of the squares of the floor values of the elements in the list instead of the ceiling values.
  id: |-
    hubedit_humaneval_py_HumanEval/133
  lang: |-
    python
  modified_code: |-
    def main(lst):
        import math
        squared = 0
        for i in lst:
            squared += math.floor(i)**2
        return squared
  original_code: |2


    def main(lst):

        import math
        squared = 0
        for i in lst:
            squared += math.ceil(i)**2
        return squared
  original_instructions: "You are given a list of numbers.\n    You need to return\
    \ the sum of squared numbers in the given list,\n    round each element in the\
    \ list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3]\
    \ the output should be 14\n    For lst = [1,4,9] the output should be 98\n   \
    \ For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output\
    \ should be 29\n    For lst = [-2.4,1,1] the output should be 6\n\n\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `is_prime` function to use a more efficient algorithm, such as checking divisibility only up to the square root of `k` instead of `k - 1`.
  id: |-
    hubedit_humaneval_py_HumanEval/59
  lang: |-
    python
  modified_code: |-
    def main(n: int):

        def is_prime(k):
            if k < 2:
                return False
            for i in range(2, int(k**0.5) + 1):
                if k % i == 0:
                    return False
            return True

        largest = 1
        for j in range(2, n + 1):
            if n % j == 0 and is_prime(j):
                largest = max(largest, j)
        return largest
  original_code: |2


    def main(n: int):

        def is_prime(k):
            if k < 2:
                return False
            for i in range(2, k - 1):
                if k % i == 0:
                    return False
            return True
        largest = 1
        for j in range(2, n + 1):
            if n % j == 0 and is_prime(j):
                largest = max(largest, j)
        return largest
  original_instructions: "Return the largest prime factor of n. Assume n > 1 and is\
    \ not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n\
    \    2\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a list of elements that contain at least one even digit, instead of only elements with odd digits.
  id: |-
    hubedit_humaneval_py_HumanEval/104
  lang: |-
    python
  modified_code: |-
    def main(x):
        even_digit_elements = []
        for i in x:
            if any(int(c) % 2 == 0 for c in str(i)):
                even_digit_elements.append(i)
        return sorted(even_digit_elements)
  original_code: |2

    def main(x):

        odd_digit_elements = []
        for i in x:
            if all (int(c) % 2 == 1 for c in str(i)):
                odd_digit_elements.append(i)
        return sorted(odd_digit_elements)
  original_instructions: "Given a list of positive integers x. return a sorted list\
    \ of all\n    elements that hasn't any even digit.\n\n    Note: Returned list\
    \ should be sorted in increasing order.\n\n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return a string of the numbers in reverse order, starting from n and counting down to 0.
  id: |-
    hubedit_humaneval_py_HumanEval/15
  lang: |-
    python
  modified_code: |-
    def main(n: int) -> str:
        return ' '.join([str(x) for x in range(n, -1, -1)])
  original_code: |2


    def main(n: int) -> str:

        return ' '.join([str(x) for x in range(n + 1)])
  original_instructions: " Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n\
    \    '0 1 2 3 4 5'\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the sum of the cubes of even numbers instead of the squares of odd numbers, and exclude any numbers that contain the digit '5'.
  id: |-
    hubedit_humaneval_py_HumanEval/151
  lang: |-
    python
  modified_code: |-
    def main(lst):
        return sum([i**3 for i in lst if i > 0 and i % 2 == 0 and '5' not in str(i)])
  original_code: |2

    def main(lst):

        return sum([i**2 for i in lst if i > 0 and i%2!=0 and "." not in str(i)])
  original_instructions: "\n    Given a list of numbers, return the sum of squares\
    \ of the numbers\n    in the list that are odd. Ignore numbers that are negative\
    \ or not integers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0\
    \ = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9,\
    \ -2]) == 81\n    double_the_difference([0]) == 0\n\n    If the input list is\
    \ empty, return 0.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of elements that are unique to each list, rather than the intersection.
  id: |-
    hubedit_humaneval_py_HumanEval/58
  lang: |-
    python
  modified_code: |-
    def main(l1: list, l2: list):
        ret = set(l1).symmetric_difference(set(l2))
        return sorted(list(ret))
  original_code: |2


    def main(l1: list, l2: list):

        ret = set()
        for e1 in l1:
            for e2 in l2:
                if e1 == e2:
                    ret.add(e1)
        return sorted(list(ret))
  original_instructions: "Return sorted unique common elements for two lists.\n  \
    \  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5,\
    \ 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the factorial of `n` instead of the current sequence.
  id: |-
    hubedit_humaneval_py_HumanEval/46
  lang: |-
    python
  modified_code: |-
    def main(n: int):
        if n == 0:
            return 1
        factorial = 1
        for i in range(1, n + 1):
            factorial *= i
        return factorial
  original_code: |2


    def main(n: int):

        results = [0, 0, 2, 0]
        if n < 4:
            return results[n]

        for _ in range(4, n + 1):
            results.append(results[-1] + results[-2] + results[-3] + results[-4])
            results.pop(0)

        return results[-1]
  original_instructions: "The Fib4 number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n  \
    \  fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4).\n    Please write a function to efficiently compute the n-th element\
    \ of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n\
    \    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse each string in the list before joining them together.
  id: |-
    hubedit_humaneval_py_HumanEval/28
  lang: |-
    python
  modified_code: |-
    from typing import List


    def main(strings: List[str]) -> str:
        reversed_strings = [s[::-1] for s in strings]
        return ''.join(reversed_strings)
  original_code: |
    from typing import List


    def main(strings: List[str]) -> str:

        return ''.join(strings)
  original_instructions: " Concatenate list of strings into a single string\n    >>>\
    \ concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n \
    \   "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the sum of x and y if both are even numbers, otherwise return their product.
  id: |-
    hubedit_humaneval_py_HumanEval/102
  lang: |-
    python
  modified_code: |-
    def main(x, y):
        if x % 2 == 0 and y % 2 == 0:
            return x + y
        else:
            return x * y
  original_code: |2

    def main(x, y):

        if x > y:
            return -1
        if y % 2 == 0:
            return y
        if x == y:
            return -1
        return y - 1
  original_instructions: "This function takes two positive numbers x and y and returns\
    \ the\n    biggest even integer number that is in the range [x, y] inclusive.\
    \ If\n    there's no such number, then the function should return -1.\n\n    For\
    \ example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the array can be sorted by rotating it to the right instead of to the left.
  id: |-
    hubedit_humaneval_py_HumanEval/109
  lang: |-
    python
  modified_code: |-
    def main(arr):
        if len(arr) == 0:
            return True
        sorted_array = sorted(arr)
        max_value = max(arr)
        max_index = arr.index(max_value)
        my_arr = arr[-(len(arr) - max_index):] + arr[:-(len(arr) - max_index)]
        for i in range(len(arr)):
            if my_arr[i] != sorted_array[i]:
                return False
        return True
  original_code: |2

    def main(arr):

        if len(arr)==0:
          return True
        sorted_array=sorted(arr)
        my_arr=[]

        min_value=min(arr)
        min_index=arr.index(min_value)
        my_arr=arr[min_index:]+arr[0:min_index]
        for i in range(len(arr)):
          if my_arr[i]!=sorted_array[i]:
            return False
        return True
  original_instructions: "We have an array 'arr' of N integers arr[1], arr[2], ...,\
    \ arr[N].The\n    numbers in the array will be randomly ordered. Your task is\
    \ to determine if\n    it is possible to get an array sorted in non-decreasing\
    \ order by performing\n    the following operation on the given array:\n     \
    \   You are allowed to perform right shift operation any number of times.\n\n\
    \    One right shift operation means shifting all elements of the array by one\n\
    \    position in the right direction. The last element of the array will be moved\
    \ to\n    the starting position in the array i.e. 0th index.\n\n    If it is possible\
    \ to obtain the sorted array by performing the above operation\n    then return\
    \ True else return False.\n    If the given array is empty then return True.\n\
    \n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\
    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n                 be achieved for\
    \ the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It\
    \ is not possible to get non-decreasing order for the given\n                array\
    \ by performing any number of right shift operations.\n\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the perimeter of the triangle instead of the area when the input values form a valid triangle.
  id: |-
    hubedit_humaneval_py_HumanEval/71
  lang: |-
    python
  modified_code: |-
    def main(a, b, c):
        if a + b <= c or a + c <= b or b + c <= a:
            return -1
        perimeter = a + b + c
        return perimeter
  original_code: |2

    def main(a, b, c):

        if a + b <= c or a + c <= b or b + c <= a:
            return -1
        s = (a + b + c)/2
        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
        area = round(area, 2)
        return area
  original_instructions: "\n    Given the lengths of the three sides of a triangle.\
    \ Return the area of\n    the triangle rounded to 2 decimal points if the three\
    \ sides form a valid triangle.\n    Otherwise return -1\n    Three sides make\
    \ a valid triangle when the sum of any two sides is greater\n    than the third\
    \ side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1,\
    \ 2, 10) == -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the last digits of both numbers instead of the product.
  id: |-
    hubedit_humaneval_py_HumanEval/97
  lang: |-
    python
  modified_code: |-
    def main(a, b):
        return abs(a % 10) + abs(b % 10)
  original_code: |2

    def main(a, b):

        return abs(a % 10) * abs(b % 10)
  original_instructions: "Complete the function that takes two integers and returns\n\
    \    the product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28)\
    \ should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15)\
    \ should return 20.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count the number of vowels instead of consonants and return words that have exactly 'n' vowels.
  id: |-
    hubedit_humaneval_py_HumanEval/117
  lang: |-
    python
  modified_code: |-
    def main(s, n):
        result = []
        for word in s.split():
            n_vowels = 0
            for i in range(0, len(word)):
                if word[i].lower() in ["a","e","i","o","u"]:
                    n_vowels += 1
            if n_vowels == n:
                result.append(word)
        return result
  original_code: |2+

    def main(s, n):

        result = []
        for word in s.split():
            n_consonants = 0
            for i in range(0, len(word)):
                if word[i].lower() not in ["a","e","i","o","u"]:
                    n_consonants += 1
            if n_consonants == n:
                result.append(word)
        return result

  original_instructions: "Given a string s and a natural number n, you have been tasked\
    \ to implement\n    a function that returns a list of all words from string s\
    \ that contain exactly\n    n consonants, in order these words appear in the string\
    \ s.\n    If the string s is empty then the function should return an empty list.\n\
    \    Note: you may assume the input string contains only letters and spaces.\n\
    \    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    \    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello\
    \ world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"\
    ]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the total duration of the notes in the music string instead of returning a list of individual note durations.
  id: |-
    hubedit_humaneval_py_HumanEval/17
  lang: |-
    python
  modified_code: |-
    from typing import List


    def main(music_string: str) -> int:

        note_map = {'o': 4, 'o|': 2, '.|': 1}
        return sum(note_map[x] for x in music_string.split(' ') if x)
  original_code: |
    from typing import List


    def main(music_string: str) -> List[int]:

        note_map = {'o': 4, 'o|': 2, '.|': 1}
        return [note_map[x] for x in music_string.split(' ') if x]
  original_instructions: " Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n    Your task is to parse this string and\
    \ return list of integers corresponding to how many beats does each\n    not last.\n\
    \n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half\
    \ note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of characters removed from the original string and return this count along with the modified string and the palindrome check.
  id: |-
    hubedit_humaneval_py_HumanEval/112
  lang: |-
    python
  modified_code: |-
    def main(s, c):
        original_length = len(s)
        s = ''.join([char for char in s if char not in c])
        chars_removed = original_length - len(s)
        return (s, s[::-1] == s, chars_removed)
  original_code: |2

    def main(s,c):

        s = ''.join([char for char in s if char not in c])
        return (s,s[::-1] == s)
  original_instructions: "Task\n    We are given two strings s and c, you have to\
    \ deleted all the characters in s that are equal to any character in c\n    then\
    \ check if the result string is palindrome.\n    A string is called palindrome\
    \ if it reads the same backward as forward.\n    You should return a tuple containing\
    \ the result string and True/False for the check.\n    Example\n    For s = \"\
    abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\"\
    , c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\",\
    \ c = \"ab\", the result should be ('cdedc',True)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the squares of the numbers from 0 to n instead of the sum of the numbers themselves.
  id: |-
    hubedit_humaneval_py_HumanEval/60
  lang: |-
    python
  modified_code: |-
    def main(n: int):
        return sum(i**2 for i in range(n + 1))
  original_code: |2


    def main(n: int):

        return sum(range(n + 1))
  original_instructions: "sum_to_n is a function that sums numbers from 1 to n.\n\
    \    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n\
    \    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of numbers that appear more than once in the input list, instead of those that appear only once.
  id: |-
    hubedit_humaneval_py_HumanEval/26
  lang: |-
    python
  modified_code: |-
    from typing import List


    def main(numbers: List[int]) -> List[int]:

        import collections
        c = collections.Counter(numbers)
        return [n for n, count in c.items() if count > 1]
  original_code: |
    from typing import List


    def main(numbers: List[int]) -> List[int]:

        import collections
        c = collections.Counter(numbers)
        return [n for n in numbers if c[n] <= 1]
  original_instructions: " From a list of integers, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the hexadecimal representation of the sum instead of the binary representation.
  id: |-
    hubedit_humaneval_py_HumanEval/84
  lang: |-
    python
  modified_code: |-
    def main(N):
        return hex(sum(int(i) for i in str(N)))[2:]
  original_code: |2

    def main(N):

        return bin(sum(int(i) for i in str(N)))[2:]
  original_instructions: "Given a positive integer N, return the total sum of its\
    \ digits in binary.\n\n    Example\n        For N = 1000, the sum of digits will\
    \ be 1 the output should be \"1\".\n        For N = 150, the sum of digits will\
    \ be 6 the output should be \"110\".\n        For N = 147, the sum of digits will\
    \ be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to check if the given number is a perfect square instead of a perfect cube.
  id: |-
    hubedit_humaneval_py_HumanEval/77
  lang: |-
    python
  modified_code: |-
    def main(a):
        a = abs(a)
        return int(a ** 0.5) ** 2 == a
  original_code: |2

    def main(a):

        a = abs(a)
        return int(round(a ** (1. / 3))) ** 3 == a
  original_instructions: "\n    Write a function that takes an integer a and returns\
    \ True\n    if this ingeger is a cube of some integer number.\n    Note: you may\
    \ assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n \
    \   iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n  \
    \  iscube(0) ==> True\n    iscube(180) ==> False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count the number of sentences that end with the word "Python" instead of counting sentences that start with "I ".
  id: |-
    hubedit_humaneval_py_HumanEval/91
  lang: |-
    python
  modified_code: |-
    def main(S):
        import re
        sentences = re.split(r'[.?!]\s*', S)
        return sum(sentence.strip().endswith('Python') for sentence in sentences if sentence)
  original_code: |2

    def main(S):

        import re
        sentences = re.split(r'[.?!]\s*', S)
        return sum(sentence[0:2] == 'I ' for sentence in sentences)
  original_instructions: "\n    You'll be given a string of words, and your task is\
    \ to count the number\n    of boredoms. A boredom is a sentence that starts with\
    \ the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For\
    \ example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky\
    \ is blue. The sun is shining. I love this weather\")\n    1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reduce the resulting fraction to its simplest form before checking if it is an integer.
  id: |-
    hubedit_humaneval_py_HumanEval/144
  lang: |-
    python
  modified_code: |-
    from math import gcd

    def main(x, n):
        a, b = x.split("/")
        c, d = n.split("/")
        numerator = int(a) * int(c)
        denom = int(b) * int(d)
        common_divisor = gcd(numerator, denom)
        numerator //= common_divisor
        denom //= common_divisor
        return numerator % denom == 0
  original_code: |2

    def main(x, n):

        a, b = x.split("/")
        c, d = n.split("/")
        numerator = int(a) * int(c)
        denom = int(b) * int(d)
        if (numerator/denom == int(numerator/denom)):
            return True
        return False
  original_instructions: "Your task is to implement a function that will simplify\
    \ the expression\n    x * n. The function returns True if x * n evaluates to a\
    \ whole number and False\n    otherwise. Both x and n, are string representation\
    \ of a fraction, and have the following format,\n    <numerator>/<denominator>\
    \ where both numerator and denominator are positive whole numbers.\n\n    You\
    \ can assume that x, and n are valid fractions, and do not have zero as denominator.\n\
    \n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n\
    \    simplify(\"7/10\", \"10/2\") = False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to find and return a list of Fibonacci numbers instead of prime numbers, up to the nth Fibonacci number.
  id: |-
    hubedit_humaneval_py_HumanEval/96
  lang: |-
    python
  modified_code: |-
    def main(n):
        fibs = [0, 1]
        for i in range(2, n):
            next_fib = fibs[-1] + fibs[-2]
            fibs.append(next_fib)
        return fibs[:n]
  original_code: |2+

    def main(n):

        primes = []
        for i in range(2, n):
            is_prime = True
            for j in range(2, i):
                if i % j == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(i)
        return primes

  original_instructions: "Implement a function that takes an non-negative integer\
    \ and returns an array of the first n\n    integers that are prime numbers and\
    \ less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11)\
    \ => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the even digits instead of the product of the odd digits.
  id: |-
    hubedit_humaneval_py_HumanEval/131
  lang: |-
    python
  modified_code: |-
    def main(n):
        sum_even = 0
        for digit in str(n):
            int_digit = int(digit)
            if int_digit % 2 == 0:
                sum_even += int_digit
        return sum_even
  original_code: |2

    def main(n):

        product = 1
        odd_count = 0
        for digit in str(n):
            int_digit = int(digit)
            if int_digit%2 == 1:
                product= product*int_digit
                odd_count+=1
        if odd_count ==0:
            return 0
        else:
            return product
  original_instructions: "Given a positive integer n, return the product of the odd\
    \ digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)\
    \  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of the longest strings from both lst1 and lst2, instead of returning one of the input lists based on their total length.
  id: |-
    hubedit_humaneval_py_HumanEval/74
  lang: |-
    python
  modified_code: |-
    def main(lst1, lst2):
        # Find the longest string length in lst1
        max_length_lst1 = max(len(st) for st in lst1) if lst1 else 0
        # Find the longest string length in lst2
        max_length_lst2 = max(len(st) for st in lst2) if lst2 else 0
        # Find the overall max length
        max_length = max(max_length_lst1, max_length_lst2)

        # Get all strings from lst1 that are of max length
        longest_strings = [st for st in lst1 if len(st) == max_length]
        # Add all strings from lst2 that are of max length and not already included
        longest_strings.extend(st for st in lst2 if len(st) == max_length and st not in longest_strings)

        return longest_strings
  original_code: |2

    def main(lst1, lst2):

        l1 = 0
        for st in lst1:
            l1 += len(st)

        l2 = 0
        for st in lst2:
            l2 += len(st)

        if l1 <= l2:
            return lst1
        else:
            return lst2
  original_instructions: "\n    Write a function that accepts two lists of strings\
    \ and returns the list that has\n    total number of chars in the all strings\
    \ of the list less than the other list.\n\n    if the two lists have the same\
    \ number of chars, return the first list.\n\n    Examples\n    total_match([],\
    \ []) \u279E []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279E ['hI',\
    \ 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279E\
    \ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279E\
    \ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E\
    \ ['4']\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the string contains any three consecutive characters that are the same and return True if it does, otherwise return False.
  id: |-
    hubedit_humaneval_py_HumanEval/80
  lang: |-
    python
  modified_code: |-
    def main(s):
        for i in range(len(s) - 2):
            if s[i] == s[i+1] == s[i+2]:
                return True
        return False
  original_code: |2

    def main(s):

        if len(s) < 3:
          return False

        for i in range(len(s) - 2):

          if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
            return False
        return True
  original_instructions: "You are given a string s.\n    Your task is to check if\
    \ the string is happy or not.\n    A string is happy if its length is at least\
    \ 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a)\
    \ => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb)\
    \ => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to replace sequences of spaces with a single asterisk (*) instead of dashes or underscores, regardless of the number of spaces in the sequence.
  id: |-
    hubedit_humaneval_py_HumanEval/140
  lang: |-
    python
  modified_code: |-
    def main(text):
        new_text = ""
        i = 0
        start, end = 0, 0
        while i < len(text):
            if text[i] == " ":
                end += 1
            else:
                if end - start > 0:
                    new_text += "*" + text[i]
                else:
                    new_text += text[i]
                start, end = i+1, i+1
            i += 1
        if end - start > 0:
            new_text += "*"
        return new_text
  original_code: |2

    def main(text):

        new_text = ""
        i = 0
        start, end = 0, 0
        while i < len(text):
            if text[i] == " ":
                end += 1
            else:
                if end - start > 2:
                    new_text += "-"+text[i]
                elif end - start > 0:
                    new_text += "_"*(end - start)+text[i]
                else:
                    new_text += text[i]
                start, end = i+1, i+1
            i+=1
        if end - start > 2:
            new_text += "-"
        elif end - start > 0:
            new_text += "_"
        return new_text
  original_instructions: "\n    Given a string text, replace all spaces in it with\
    \ underscores,\n    and if a string has more than 2 consecutive spaces,\n    then\
    \ replace all consecutive spaces with -\n\n    fix_spaces(\"Example\") == \"Example\"\
    \n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\"\
    ) == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the median of the numbers instead of the mean, and then return the sum of the absolute differences between each number and the median, divided by the number of numbers.
  id: |-
    hubedit_humaneval_py_HumanEval/4
  lang: |-
    python
  modified_code: |-
    from typing import List

    def main(numbers: List[float]) -> float:
        numbers.sort()
        n = len(numbers)
        median = (numbers[n // 2] if n % 2 != 0 else (numbers[n // 2 - 1] + numbers[n // 2]) / 2)
        return sum(abs(x - median) for x in numbers) / n
  original_code: |
    from typing import List


    def main(numbers: List[float]) -> float:

        mean = sum(numbers) / len(numbers)
        return sum(abs(x - mean) for x in numbers) / len(numbers)
  original_instructions: " For a given list of input numbers, calculate Mean Absolute\
    \ Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation\
    \ is the average absolute difference between each\n    element and a centerpoint\
    \ (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the list comprehension to generate a list of the squares of the numbers from 0 to n-1, instead of adding 2*i to n.
  id: |-
    hubedit_humaneval_py_HumanEval/100
  lang: |-
    python
  modified_code: |-
    def main(n):
        return [i**2 for i in range(n)]
  original_code: |2

    def main(n):

        return [n + 2*i for i in range(n)]
  original_instructions: "\n    Given a positive integer n, you have to make a pile\
    \ of n levels of stones.\n    The first level has n stones.\n    The number of\
    \ stones in the next level is:\n        - the next odd number if n is odd.\n \
    \       - the next even number if n is even.\n    Return the number of stones\
    \ in each level in a list, where element at index\n    i represents the number\
    \ of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n   \
    \ [3, 5, 7]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the absolute differences between the elements of the 'game' and 'guess' lists, instead of returning a list of the individual absolute differences.
  id: |-
    hubedit_humaneval_py_HumanEval/152
  lang: |-
    python
  modified_code: |-
    def main(game, guess):
        return sum(abs(x - y) for x, y in zip(game, guess))
  original_code: |2

    def main(game,guess):

        return [abs(x-y) for x,y in zip(game,guess)]
  original_instructions: "I think we all remember that feeling when the result of\
    \ some long-awaited\n    event is finally known. The feelings and thoughts you\
    \ have at that moment are\n    definitely worth noting down and comparing.\n \
    \   Your task is to determine if a person correctly guessed the results of a number\
    \ of matches.\n    You are given two arrays of scores and guesses of equal length,\
    \ where each index shows a match.\n    Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    the value is\
    \ 0, and if not, the value is the absolute difference between the guess and the\
    \ score.\n\n\n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n\
    \    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the area of a rectangle instead of a triangle by removing the division by 2.0.
  id: |-
    hubedit_humaneval_py_HumanEval/45
  lang: |-
    python
  modified_code: |-
    def main(a, h):
        return a * h
  original_code: |2


    def main(a, h):

        return a * h / 2.0
  original_instructions: "Given length of a side and high return area for a triangle.\n\
    \    >>> triangle_area(5, 3)\n    7.5\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to generate a list of odd numbers instead of even numbers within the given range.
  id: |-
    hubedit_humaneval_py_HumanEval/163
  lang: |-
    python
  modified_code: |-
    def main(a, b):

        lower = max(2, min(a, b))
        upper = min(8, max(a, b))

        return [i for i in range(lower, upper+1) if i % 2 != 0]
  original_code: |2

    def main(a, b):

        lower = max(2, min(a, b))
        upper = min(8, max(a, b))

        return [i for i in range(lower, upper+1) if i % 2 == 0]
  original_instructions: "\n    Given two positive integers a and b, return the even\
    \ digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2,\
    \ 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10,\
    \ 14) => []\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to include the option to return the planets in reverse order from the second planet to the first if the second planet comes before the first in the list.
  id: |-
    hubedit_humaneval_py_HumanEval/148
  lang: |-
    python
  modified_code: |-
    def main(planet1, planet2, reverse=False):

        planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
        if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
            return ()
        planet1_index = planet_names.index(planet1)
        planet2_index = planet_names.index(planet2)

        if reverse and planet2_index < planet1_index:
            return planet_names[planet2_index + 1: planet1_index][::-1]
        elif planet1_index < planet2_index:
            return planet_names[planet1_index + 1: planet2_index]
        else:
            return planet_names[planet2_index + 1: planet1_index]
  original_code: |2

    def main(planet1, planet2):

        planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
        if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
            return ()
        planet1_index = planet_names.index(planet1)
        planet2_index = planet_names.index(planet2)
        if planet1_index < planet2_index:
            return (planet_names[planet1_index + 1: planet2_index])
        else:
            return (planet_names[planet2_index + 1 : planet1_index])
  original_instructions: "\n    There are eight planets in our solar system: the closerst\
    \ to the Sun\n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter,\
    \ Saturn,\n    Uranus, Neptune.\n    Write a function that takes two planet names\
    \ as strings planet1 and planet2.\n    The function should return a tuple containing\
    \ all planets whose orbits are\n    located between the orbit of planet1 and the\
    \ orbit of planet2, sorted by\n    the proximity to the sun.\n    The function\
    \ should return an empty tuple if planet1 or planet2\n    are not correct planet\
    \ names.\n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\"\
    )\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\"\
    ) ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check if the number is a prime number instead of checking if it is an even number greater than or equal to 8.
  id: |-
    hubedit_humaneval_py_HumanEval/138
  lang: |-
    python
  modified_code: |-
    def main(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
  original_code: |2

    def main(n):

        return n%2 == 0 and n >= 8
  original_instructions: "Evaluate whether the given number n can be written as the\
    \ sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4)\
    \ == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8)\
    \ == True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count and return the sum of all even and odd palindromic numbers within the range, instead of just counting their occurrences.
  id: |-
    hubedit_humaneval_py_HumanEval/107
  lang: |-
    python
  modified_code: |-
    def main(n):

        def is_palindrome(n):
            return str(n) == str(n)[::-1]

        even_palindrome_sum = 0
        odd_palindrome_sum = 0

        for i in range(1, n+1):
            if is_palindrome(i):
                if i % 2 == 0:
                    even_palindrome_sum += i
                else:
                    odd_palindrome_sum += i
        return (even_palindrome_sum, odd_palindrome_sum)
  original_code: |2

    def main(n):

        def is_palindrome(n):
            return str(n) == str(n)[::-1]

        even_palindrome_count = 0
        odd_palindrome_count = 0

        for i in range(1, n+1):
            if i%2 == 1 and is_palindrome(i):
                    odd_palindrome_count += 1
            elif i%2 == 0 and is_palindrome(i):
                even_palindrome_count += 1
        return (even_palindrome_count, odd_palindrome_count)
  original_instructions: "\n    Given a positive integer n, return a tuple that has\
    \ the number of even and odd\n    integer palindromes that fall within the range(1,\
    \ n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n\
    \        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is\
    \ even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n    \
    \    Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n \
    \   Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number\
    \ of even and odd integer palindromes respectively.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to filter out and return only the strings that contain the letter 'a', regardless of their length or whether the length is even or odd.
  id: |-
    hubedit_humaneval_py_HumanEval/149
  lang: |-
    python
  modified_code: |-
    def main(lst):
        return sorted([i for i in lst if 'a' in i], key=len)
  original_code: |2

    def main(lst):

        lst.sort()
        new_lst = []
        for i in lst:
            if len(i)%2 == 0:
                new_lst.append(i)
        return sorted(new_lst, key=len)
  original_instructions: "Write a function that accepts a list of strings as a parameter,\n\
    \    deletes the strings that have odd lengths from it,\n    and returns the resulted\
    \ list with a sorted order,\n    The list is always a list of strings and never\
    \ an array of numbers,\n    and it may contain duplicates.\n    The order of the\
    \ list should be ascending by length of each word, and you\n    should return\
    \ the list sorted by that rule.\n    If two words have the same length, sort the\
    \ list alphabetically.\n    The function should return a list of strings in sorted\
    \ order.\n    You may assume that all words will have the same length.\n    For\
    \ example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the order of the characters in the message after swapping the case and replacing the vowels.
  id: |-
    hubedit_humaneval_py_HumanEval/93
  lang: |-
    python
  modified_code: |-
    def main(message):
        vowels = "aeiouAEIOU"
        vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
        message = message.swapcase()
        message = ''.join([vowels_replace[i] if i in vowels else i for i in message])
        return message[::-1]
  original_code: |2

    def main(message):

        vowels = "aeiouAEIOU"
        vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
        message = message.swapcase()
        return ''.join([vowels_replace[i] if i in vowels else i for i in message])
  original_instructions: "\n    Write a function that takes a message, and encodes\
    \ in such a\n    way that it swaps case of all letters, replaces all vowels in\n\
    \    the message with the letter that appears 2 places ahead of that\n    vowel\
    \ in the english alphabet.\n    Assume only letters.\n\n    Examples:\n    >>>\
    \ encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS\
    \ C MGSSCGG'\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the first vowel found that is surrounded by non-vowels, instead of the last one.
  id: |-
    hubedit_humaneval_py_HumanEval/118
  lang: |-
    python
  modified_code: |-
    def main(word):
        if len(word) < 3:
            return ""

        vowels = {"a", "e", "i", "o", "u", "A", "E", "I", "O", "U"}
        for i in range(1, len(word) - 1):
            if word[i] in vowels:
                if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                    return word[i]
        return ""
  original_code: |2

    def main(word):

        if len(word) < 3:
            return ""

        vowels = {"a", "e", "i", "o", "u", "A", "E", 'O', 'U', 'I'}
        for i in range(len(word)-2, 0, -1):
            if word[i] in vowels:
                if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                    return word[i]
        return ""
  original_instructions: "You are given a word. Your task is to find the closest vowel\
    \ that stands between\n    two consonants from the right side of the word (case\
    \ sensitive).\n\n    Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    find any vowel met the above condition.\n\n\
    \    You may assume that the given string contains English letter only.\n\n  \
    \  Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"\
    FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"\
    ab\") ==> \"\"\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the pair of indices (idx, idx2) for the first pair of numbers found that have a distance less than the threshold, instead of returning a boolean value.
  id: |-
    hubedit_humaneval_ts_HumanEval/0
  lang: |-
    deno
  modified_code: |-
    export async function main(numbers: number[], threshold: number): Promise<[number, number] | null> {
        for (let idx = 0; idx < numbers.length; idx++) {
            for (let idx2 = 0; idx2 < numbers.length; idx2++) {
                if (idx !== idx2) {
                    const distance = Math.abs(numbers[idx] - numbers[idx2]);
                    if (distance < threshold) {
                        return [idx, idx2];
                    }
                }
            }
        }
        return null;
    }
  original_code: |-
    export async function main(numbers: number[], threshold: number): Promise<boolean> {
        for (let idx = 0; idx < numbers.length; idx++) {
            for (let idx2 = 0; idx2 < numbers.length; idx2++) {
                if (idx !== idx2) {
                    const distance = Math.abs(numbers[idx] - numbers[idx2]);
                    if (distance < threshold) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
  original_instructions: " Check if in given list of numbers, are any two numbers\
    \ closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to return the square of the input number instead of the remainder of division by 1.0.
  id: |-
    hubedit_humaneval_ts_HumanEval/2
  lang: |-
    deno
  modified_code: |-
    export async function main(number: number): Promise<number> {
        return number * number;
    }
  original_code: |-
    export async function main(number: number): Promise<number> {
        return number % 1.0;
    }
  original_instructions: " Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to track the maximum balance reached during the operations and return it instead of a boolean value.
  id: |-
    hubedit_humaneval_ts_HumanEval/3
  lang: |-
    deno
  modified_code: |-
    export async function main(operations: number[]): Promise<number> {
        let balance: number = 0;
        let maxBalance: number = 0;

        for (const op of operations) {
            balance += op;
            if (balance > maxBalance) {
                maxBalance = balance;
            }
        }

        return maxBalance;
    }
  original_code: |-
    export async function main(operations: number[]): Promise<boolean> {
        let balance: number = 0;

        for (const op of operations) {
            balance += op;
            if (balance < 0) {
                return true;
            }
        }

        return false;
    }
  original_instructions: " You're given a list of deposit and withdrawal operations\
    \ on a bank account that starts with\n    zero balance. Your task is to detect\
    \ if at any point the balance of account fallls below zero, and\n    at that point\
    \ function should return True. Otherwise it should return False.\n    >>> below_zero([1,\
    \ 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the median instead of the mean absolute deviation from the mean. You will need to sort the array and find the middle value or the average of the two middle values if the array length is even.
  id: |-
    hubedit_humaneval_ts_HumanEval/4
  lang: |-
    deno
  modified_code: |-
    export async function main(numbers: number[]): Promise<number> {
        numbers.sort((a, b) => a - b);
        const middleIndex = Math.floor(numbers.length / 2);

        if (numbers.length % 2 === 0) {
            return (numbers[middleIndex - 1] + numbers[middleIndex]) / 2;
        } else {
            return numbers[middleIndex];
        }
    }
  original_code: |-
    export async function main(numbers: number[]): Promise<number> {
        const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;
        return numbers.reduce((acc, val) => acc + Math.abs(val - mean), 0) / numbers.length;
    }
  original_instructions: " For a given list of input numbers, calculate Mean Absolute\
    \ Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation\
    \ is the average absolute difference between each\n    element and a centerpoint\
    \ (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse the order of the numbers before joining them into a string.
  id: |-
    hubedit_humaneval_ts_HumanEval/15
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<string> {
        return [...Array(n + 1).keys()].reverse().map(x => x.toString()).join(' ');
    }
  original_code: |-
    export async function main(n: number): Promise<string> {
        return [...Array(n + 1).keys()].map(x => x.toString()).join(' ');
    }
  original_instructions: " Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n\
    \    '0 1 2 3 4 5'\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Add functionality to handle invalid musical notes by returning a default value, such as 0, for any note not found in the note_map.
  id: |-
    hubedit_humaneval_ts_HumanEval/17
  lang: |-
    deno
  modified_code: |-
    export async function main(music_string: string): Promise<number[]> {
        const note_map: { [key: string]: number } = { 'o': 4, 'o|': 2, '.|': 1 };
        return music_string.split(' ').filter(x => x).map(x => note_map[x] ?? 0);
    }
  original_code: |-
    export async function main(music_string: string): Promise<number[]> {
        const note_map: { [key: string]: number } = { 'o': 4, 'o|': 2, '.|': 1 };
        return music_string.split(' ').filter(x => x).map(x => note_map[x]);
    }
  original_instructions: " Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n    Your task is to parse this string and\
    \ return list of integers corresponding to how many beats does each\n    not last.\n\
    \n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half\
    \ note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of times the substring appears in the string without overlapping occurrences.
  id: |-
    hubedit_humaneval_ts_HumanEval/18
  lang: |-
    deno
  modified_code: |-
    export async function main(string: string, substring: string): Promise<number> {
        let times = 0;
        let i = 0;

        while (i <= string.length - substring.length) {
            if (string.substring(i, i + substring.length) === substring) {
                times += 1;
                i += substring.length; // Move the index past the current occurrence to avoid overlaps
            } else {
                i += 1; // Move to the next character
            }
        }

        return times;
    }
  original_code: |-
    export async function main(string: string, substring: string): Promise<number> {
        let times = 0;

        for (let i = 0; i <= string.length - substring.length; i++) {
            if (string.substring(i, i + substring.length) === substring) {
                times += 1;
            }
        }

        return times;
    }
  original_instructions: " Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n\
    \    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa',\
    \ 'aa')\n    3\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to convert the sorted number words back into their corresponding digit characters and return a string of digits.
  id: |-
    hubedit_humaneval_ts_HumanEval/19
  lang: |-
    deno
  modified_code: |-
    export async function main(numbers: string): Promise<string> {
      const valueMap: { [key: string]: number } = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
      };

      return numbers.split(' ')
        .filter(x => x)
        .sort((a, b) => valueMap[a] - valueMap[b])
        .map(word => valueMap[word].toString())
        .join('');
    }
  original_code: |-
    export async function main(numbers: string): Promise<string> {
      const valueMap: { [key: string]: number } = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
      };

      return numbers.split(' ')
        .filter(x => x)
        .sort((a, b) => valueMap[a] - valueMap[b])
        .join(' ');
    }
  original_instructions: " Input is a space-delimited string of numberals from 'zero'\
    \ to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
    \ 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted\
    \ from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three\
    \ five'\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return an array of numbers that appear more than once in the input array instead of those that appear only once.
  id: |-
    hubedit_humaneval_ts_HumanEval/26
  lang: |-
    deno
  modified_code: |-
    export async function main(numbers: number[]): Promise<number[]> {
        const counts: { [key: number]: number } = {};

        for (const num of numbers) {
            counts[num] = (counts[num] || 0) + 1;
        }

        return numbers.filter(n => counts[n] > 1);
    }
  original_code: |-
    export async function main(numbers: number[]): Promise<number[]> {
        const counts: { [key: number]: number } = {};

        for (const num of numbers) {
            counts[num] = (counts[num] || 0) + 1;
        }

        return numbers.filter(n => counts[n] <= 1);
    }
  original_instructions: " From a list of integers, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse each string in the array before joining them together.
  id: |-
    hubedit_humaneval_ts_HumanEval/28
  lang: |-
    deno
  modified_code: |-
    export async function main(strings: string[]): Promise<string> {
        const reversedStrings = strings.map(s => s.split('').reverse().join(''));
        return reversedStrings.join('');
    }
  original_code: |-
    export async function main(strings: string[]): Promise<string> {
        return strings.join('');
    }
  original_instructions: " Concatenate list of strings into a single string\n    >>>\
    \ concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n \
    \   "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the loop to only iterate up to the square root of `n` instead of `n - 1`, which will optimize the function for checking if `n` is a prime number.
  id: |-
    hubedit_humaneval_ts_HumanEval/31
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n < 2) {
            return false;
        }
        for (let k = 2; k * k <= n; k++) {
            if (n % k === 0) {
                return false;
            }
        }
        return true;
    }
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n < 2) {
            return false;
        }
        for (let k = 2; k < n; k++) {
            if (n % k === 0) {
                return false;
            }
        }
        return true;
    }
  original_instructions: "Return true if a given number is prime, and false otherwise.\n\
    \    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n\
    \    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n\
    \    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to find the smallest number in the list instead of the largest.
  id: |-
    hubedit_humaneval_ts_HumanEval/35
  lang: |-
    deno
  modified_code: |-
    export async function main(l: number[]): Promise<number> {
        let m = l[0];
        for (const e of l) {
            if (e < m) {
                m = e;
            }
        }
        return m;
    }
  original_code: |-
    export async function main(l: number[]): Promise<number> {
        let m = l[0];
        for (const e of l) {
            if (e > m) {
                m = e;
            }
        }
        return m;
    }
  original_instructions: "Return maximum element in the list.\n    >>> max_element([1,\
    \ 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    123\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if any four numbers in the list sum up to zero instead of three.
  id: |-
    hubedit_humaneval_ts_HumanEval/40
  lang: |-
    deno
  modified_code: |-
    export async function main(l: number[]): Promise<boolean> {
        for (let i = 0; i < l.length; i++) {
            for (let j = i + 1; j < l.length; j++) {
                for (let k = j + 1; k < l.length; k++) {
                    for (let m = k + 1; m < l.length; m++) {
                        if (l[i] + l[j] + l[k] + l[m] === 0) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
  original_code: |-
    export async function main(l: number[]): Promise<boolean> {
        for (let i = 0; i < l.length; i++) {
            for (let j = i + 1; j < l.length; j++) {
                for (let k = j + 1; k < l.length; k++) {
                    if (l[i] + l[j] + l[k] === 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
  original_instructions: "\n    triples_sum_to_zero takes a list of integers as an\
    \ input.\n    it returns True if there are three distinct elements in the list\
    \ that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1,\
    \ 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n\
    \    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2,\
    \ 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n  \
    \  "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to filter out even numbers before applying the increment operation to the remaining odd numbers in the list.
  id: |-
    hubedit_humaneval_ts_HumanEval/42
  lang: |-
    deno
  modified_code: |-
    export async function main(l: number[]): Promise<number[]> {
        return l.filter(e => e % 2 !== 0).map(e => e + 1);
    }
  original_code: |-
    export async function main(l: number[]): Promise<number[]> {
        return l.map(e => e + 1);
    }
  original_instructions: "Return list with elements incremented by 1.\n    >>> incr_list([1,\
    \ 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  \
    \  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to calculate the area of a circle instead of a triangle by using the first parameter as the radius and ignoring the second parameter.
  id: |-
    hubedit_humaneval_ts_HumanEval/45
  lang: |-
    deno
  modified_code: |-
    export async function main(r: number): Promise<number> {
        const pi = 3.141592653589793;
        return pi * r * r;
    }
  original_code: |-
    export async function main(a: number, h: number): Promise<number> {
        return a * h / 2.0;
    }
  original_instructions: "Given length of a side and high return area for a triangle.\n\
    \    >>> triangle_area(5, 3)\n    7.5\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the Fibonacci sequence instead of its current sequence by modifying the push operation to add only the last two elements in the results array.
  id: |-
    hubedit_humaneval_ts_HumanEval/46
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let results: number[] = [0, 1];
        if (n < 2) {
            return results[n];
        }

        for (let i = 2; i <= n; i++) {
            results.push(results[1] + results[0]);
            results.shift();
        }

        return results[1];
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let results: number[] = [0, 0, 2, 0];
        if (n < 4) {
            return results[n];
        }

        for (let i = 4; i <= n; i++) {
            results.push(results[3] + results[2] + results[1] + results[0]);
            results.shift();
        }

        return results[3];
    }
  original_instructions: "The Fib4 number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n  \
    \  fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4).\n    Please write a function to efficiently compute the n-th element\
    \ of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n\
    \    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the list is a palindrome, meaning it reads the same backward as forward.
  id: |-
    hubedit_humaneval_ts_HumanEval/57
  lang: |-
    deno
  modified_code: |-
    export async function main(l: number[]): Promise<boolean> {
        return l.join(',') === l.slice().reverse().join(',');
    }
  original_code: |-
    export async function main(l: number[]): Promise<boolean> {
        if (l.slice().sort((a, b) => a - b).join(',') === l.join(',') ||
            l.slice().sort((a, b) => b - a).join(',') === l.join(',')) {
            return true;
        }
        return false;
    }
  original_instructions: "Return True is list elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1,\
    \ 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `is_prime` function to use a more efficient algorithm, such as checking divisibility only up to the square root of `k` instead of up to `k - 1`.
  id: |-
    hubedit_humaneval_ts_HumanEval/59
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {

        function is_prime(k: number): boolean {
            if (k <= 1) {
                return false;
            }
            if (k <= 3) {
                return true;
            }
            if (k % 2 === 0 || k % 3 === 0) {
                return false;
            }
            let i = 5;
            while (i * i <= k) {
                if (k % i === 0 || k % (i + 2) === 0) {
                    return false;
                }
                i += 6;
            }
            return true;
        }

        let largest = 1;
        for (let j = 2; j <= n; j++) {
            if (n % j === 0 && is_prime(j)) {
                largest = Math.max(largest, j);
            }
        }
        return largest;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {

        function is_prime(k: number): boolean {
            if (k < 2) {
                return false;
            }
            for (let i = 2; i < k; i++) {
                if (k % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let largest = 1;
        for (let j = 2; j <= n; j++) {
            if (n % j === 0 && is_prime(j)) {
                largest = Math.max(largest, j);
            }
        }
        return largest;
    }
  original_instructions: "Return the largest prime factor of n. Assume n > 1 and is\
    \ not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n\
    \    2\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the factorial of the number n instead of the sum of numbers from 1 to n.
  id: |-
    hubedit_humaneval_ts_HumanEval/60
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let factorial = 1;
        for (let i = 1; i <= n; i++) {
            factorial *= i;
        }
        return factorial;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
  original_instructions: "sum_to_n is a function that sums numbers from 1 to n.\n\
    \    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n\
    \    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the maximum odd number and its index from the array instead of the minimum even number and its index.
  id: |-
    hubedit_humaneval_ts_HumanEval/68
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number[] | []> {
      if (arr.length === 0) return [];
      const odds = arr.filter(x => x % 2 !== 0);
      if (odds.length === 0) return [];
      const maxValue = Math.max(...odds);
      return [maxValue, arr.indexOf(maxValue)];
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number[] | []> {
      if (arr.length === 0) return [];
      const evens = arr.filter(x => x % 2 === 0);
      if (evens.length === 0) return [];
      const minValue = Math.min(...evens);
      return [minValue, arr.indexOf(minValue)];
    }
  original_instructions: "\n    \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    your task is to pluck one of the nodes and\
    \ return it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index.\n\n    Example 3:\n        Input: []\n        Output: []\n\
    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n\
    \        Explanation: 0 is the smallest value, but  there are two zeros,\n   \
    \                  so we will choose the first zero, which has the smallest index.\n\
    \n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the smallest number for which the frequency is at least as large as the number itself, instead of the largest one.
  id: |-
    hubedit_humaneval_ts_HumanEval/69
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: number[]): Promise<number> {
        const frq: number[] = new Array(max(lst) + 1).fill(0);
        for (const i of lst) {
            frq[i] += 1;
        }

        for (let i = 1; i < frq.length; i++) {
            if (frq[i] >= i) {
                return i;
            }
        }

        return -1;
    }

    function max(arr: number[]): number {
        return Math.max(...arr);
    }
  original_code: |-
    export async function main(lst: number[]): Promise<number> {
        const frq: number[] = new Array(max(lst) + 1).fill(0);
        for (const i of lst) {
            frq[i] += 1;
        }

        let ans: number = -1;
        for (let i = 1; i < frq.length; i++) {
            if (frq[i] >= i) {
                ans = i;
            }
        }

        return ans;
    }

    function max(arr: number[]): number {
        return Math.max(...arr);
    }
  original_instructions: "\n    You are given a non-empty list of positive integers.\
    \ Return the greatest integer that is greater than\n    zero, and has a frequency\
    \ greater than or equal to the value of the integer itself.\n    The frequency\
    \ of an integer is the number of times it appears in the list.\n    If no such\
    \ a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1])\
    \ == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5,\
    \ 4, 4, 4]) == -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate and return the perimeter of the triangle instead of the area if the input values can form a valid triangle.
  id: |-
    hubedit_humaneval_ts_HumanEval/71
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
        if (a + b <= c || a + c <= b || b + c <= a) {
            return -1;
        }
        const perimeter: number = a + b + c;
        return perimeter;
    }
  original_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
        if (a + b <= c || a + c <= b || b + c <= a) {
            return -1;
        }
        const s: number = (a + b + c) / 2;
        let area: number = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        area = parseFloat(area.toFixed(2));
        return area;
    }
  original_instructions: "\n    Given the lengths of the three sides of a triangle.\
    \ Return the area of\n    the triangle rounded to 2 decimal points if the three\
    \ sides form a valid triangle.\n    Otherwise return -1\n    Three sides make\
    \ a valid triangle when the sum of any two sides is greater\n    than the third\
    \ side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1,\
    \ 2, 10) == -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check if the array 'q' can be split into two subarrays with equal sum instead of checking if the sum of all elements is greater than 'w'.
  id: |-
    hubedit_humaneval_ts_HumanEval/72
  lang: |-
    deno
  modified_code: |-
    export async function main(q: number[]): Promise<boolean> {
        const totalSum = q.reduce((a, b) => a + b, 0);

        if (totalSum % 2 !== 0) {
            return false;
        }

        const halfSum = totalSum / 2;
        let currentSum = 0;

        for (const num of q) {
            currentSum += num;
            if (currentSum === halfSum) {
                return true;
            }
        }

        return false;
    }
  original_code: |-
    export async function main(q: number[], w: number): Promise<boolean> {
        if (q.reduce((a, b) => a + b, 0) > w) {
            return false;
        }

        let i = 0, j = q.length - 1;
        while (i < j) {
            if (q[i] !== q[j]) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
  original_instructions: "\n    Write a function that returns True if the object q\
    \ will fly, and False otherwise.\n    The object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279E\
    \ False\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\
    \n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279E\
    \ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    \n    will_it_fly([3], 5) \u279E True\n    # 3 is less than the maximum possible\
    \ weight, and it's balanced.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of elements that are the same at the mirrored positions in the array instead of counting the differences.
  id: |-
    hubedit_humaneval_ts_HumanEval/73
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ans = 0;
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] === arr[arr.length - i - 1]) {
                ans += 1;
            }
        }
        return ans;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ans = 0;
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] !== arr[arr.length - i - 1]) {
                ans += 1;
            }
        }
        return ans;
    }
  original_instructions: "\n    Given an array arr of integers, find the minimum number\
    \ of elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to concatenate the strings from the shorter list into a single string and return an array containing just that one concatenated string.
  id: |-
    hubedit_humaneval_ts_HumanEval/74
  lang: |-
    deno
  modified_code: |-
    export async function main(lst1: string[], lst2: string[]): Promise<string[]> {
        let l1 = lst1.reduce((acc, st) => acc + st.length, 0);
        let l2 = lst2.reduce((acc, st) => acc + st.length, 0);

        if (l1 <= l2) {
            return [lst1.join('')];
        } else {
            return [lst2.join('')];
        }
    }
  original_code: |-
    export async function main(lst1: string[], lst2: string[]): Promise<string[]> {
        let l1 = 0;
        for (const st of lst1) {
            l1 += st.length;
        }

        let l2 = 0;
        for (const st of lst2) {
            l2 += st.length;
        }

        if (l1 <= l2) {
            return lst1;
        } else {
            return lst2;
        }
    }
  original_instructions: "\n    Write a function that accepts two lists of strings\
    \ and returns the list that has\n    total number of chars in the all strings\
    \ of the list less than the other list.\n\n    if the two lists have the same\
    \ number of chars, return the first list.\n\n    Examples\n    total_match([],\
    \ []) \u279E []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279E ['hI',\
    \ 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279E\
    \ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279E\
    \ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E\
    \ ['4']\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `is_prime` function to use a more efficient algorithm, such as checking divisibility only up to the square root of `n` instead of `n - 1`.
  id: |-
    hubedit_humaneval_ts_HumanEval/75
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number): Promise<boolean> {

        function is_prime(n: number): boolean {
            if (n <= 1) return false;
            if (n <= 3) return true;
            if (n % 2 === 0 || n % 3 === 0) return false;
            for (let i = 5; i * i <= n; i += 6) {
                if (n % i === 0 || n % (i + 2) === 0) {
                    return false;
                }
            }
            return true;
        }

        for (let i = 2; i <= 100; i++) {
            if (!is_prime(i)) continue;
            for (let j = 2; j <= 100; j++) {
                if (!is_prime(j)) continue;
                for (let k = 2; k <= 100; k++) {
                    if (!is_prime(k)) continue;
                    if (i * j * k === a) return true;
                }
            }
        }
        return false;
    }
  original_code: |-
    export async function main(a: number): Promise<boolean> {

        function is_prime(n: number): boolean {
            for (let j = 2; j < n; j++) {
                if (n % j === 0) {
                    return false;
                }
            }
            return true;
        }

        for (let i = 2; i <= 100; i++) {
            if (!is_prime(i)) continue;
            for (let j = 2; j <= 100; j++) {
                if (!is_prime(j)) continue;
                for (let k = 2; k <= 100; k++) {
                    if (!is_prime(k)) continue;
                    if (i * j * k === a) return true;
                }
            }
        }
        return false;
    }
  original_instructions: "Write a function that returns true if the given number is\
    \ the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing\
    \ that (a) is less then 100.\n    Example:\n    is_multiply_prime(30) == True\n\
    \    30 = 2 * 3 * 5\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Change the function to check if the number is a perfect square instead of a perfect cube by modifying the exponent in the Math.pow function and the comparison logic.
  id: |-
    hubedit_humaneval_ts_HumanEval/77
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number): Promise<boolean> {
        a = Math.abs(a);
        return Math.round(Math.sqrt(a)) ** 2 === a;
    }
  original_code: |-
    export async function main(a: number): Promise<boolean> {
        a = Math.abs(a);
        return Math.round(Math.pow(a, 1 / 3)) ** 3 === a;
    }
  original_instructions: "\n    Write a function that takes an integer a and returns\
    \ True\n    if this ingeger is a cube of some integer number.\n    Note: you may\
    \ assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n \
    \   iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n  \
    \  iscube(0) ==> True\n    iscube(180) ==> False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the function to check for a sequence of three consecutive identical characters instead of checking if any of the three characters are the same.
  id: |-
    hubedit_humaneval_ts_HumanEval/80
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<boolean> {
      if (s.length < 3) {
        return false;
      }

      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] && s[i + 1] === s[i + 2]) {
          return false;
        }
      }
      return true;
    }
  original_code: |-
    export async function main(s: string): Promise<boolean> {
      if (s.length < 3) {
        return false;
      }

      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] || s[i + 1] === s[i + 2] || s[i] === s[i + 2]) {
          return false;
        }
      }
      return true;
    }
  original_instructions: "You are given a string s.\n    Your task is to check if\
    \ the string is happy or not.\n    A string is happy if its length is at least\
    \ 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a)\
    \ => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb)\
    \ => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the function to check if the input string is a palindrome instead of checking for prime number length.
  id: |-
    hubedit_humaneval_ts_HumanEval/82
  lang: |-
    deno
  modified_code: |-
    export async function main(string: string): Promise<boolean> {
        const normalizedString = string.replace(/[\W_]/g, '').toLowerCase();
        let left: number = 0;
        let right: number = normalizedString.length - 1;

        while (left < right) {
            if (normalizedString[left] !== normalizedString[right]) {
                return false;
            }
            left++;
            right--;
        }

        return true;
    }
  original_code: |-
    export async function main(string: string): Promise<boolean> {
        let l: number = string.length;
        if (l === 0 || l === 1) {
            return false;
        }
        for (let i: number = 2; i < l; i++) {
            if (l % i === 0) {
                return false;
            }
        }
        return true;
    }
  original_instructions: "Write a function that takes a string and returns True if\
    \ the string\n    length is a prime number or False otherwise\n    Examples\n\
    \    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens')\
    \ == True\n    prime_length('orange') == False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the factorial of the given number instead of the current mathematical operation.
  id: |-
    hubedit_humaneval_ts_HumanEval/83
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        if (n < 0) {
            throw new Error("Factorial is not defined for negative numbers");
        }
        let result = 1;
        for (let i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 1) return 1;
        return 18 * (10 ** (n - 2));
    }
  original_instructions: "\n    Given a positive integer n, return the count of the\
    \ numbers of n-digit\n    positive integers that start or end with 1.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the `sumDigits` function to multiply the digits instead of summing them, and then return the binary representation of the product.
  id: |-
    hubedit_humaneval_ts_HumanEval/84
  lang: |-
    deno
  modified_code: |-
    export async function main(N: number): Promise<string> {
        return bin(productDigits(N));
    }

    function productDigits(N: number): number {
        return Array.from(N.toString()).reduce((acc, digit) => acc * parseInt(digit), 1);
    }

    function bin(num: number): string {
        return num.toString(2);
    }
  original_code: |-
    export async function main(N: number): Promise<string> {
        return bin(sumDigits(N));
    }

    function sumDigits(N: number): number {
        return Array.from(N.toString()).reduce((acc, digit) => acc + parseInt(digit), 0);
    }

    function bin(num: number): string {
        return num.toString(2);
    }
  original_instructions: "Given a positive integer N, return the total sum of its\
    \ digits in binary.\n\n    Example\n        For N = 1000, the sum of digits will\
    \ be 1 the output should be \"1\".\n        For N = 150, the sum of digits will\
    \ be 6 the output should be \"110\".\n        For N = 147, the sum of digits will\
    \ be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to reverse each word in the string instead of sorting the letters within the words.
  id: |-
    hubedit_humaneval_ts_HumanEval/86
  lang: |-
    deno
  modified_code: |-
    export async function main(s: string): Promise<string> {
        return s.split(' ').map(i => i.split('').reverse().join('')).join(' ');
    }
  original_code: |-
    export async function main(s: string): Promise<string> {
        return s.split(' ').map(i => i.split('').sort().join('')).join(' ');
    }
  original_instructions: "\n    Write a function that takes a string and returns an\
    \ ordered version of it.\n    Ordered version of string, is a string where all\
    \ words (separated by space)\n    are replaced by a new word where all the characters\
    \ arranged in\n    ascending order based on ascii value.\n    Note: You should\
    \ keep the order of words and blank spaces in the sentence.\n\n    For example:\n\
    \    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n\
    \    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the second largest number in the list instead of the second smallest number.
  id: |-
    hubedit_humaneval_ts_HumanEval/90
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: number[]): Promise<number | null> {
        lst = Array.from(new Set(lst)).sort((a, b) => b - a);
        return lst.length < 2 ? null : lst[1];
    }
  original_code: |-
    export async function main(lst: number[]): Promise<number | null> {
        lst = Array.from(new Set(lst)).sort((a, b) => a - b);
        return lst.length < 2 ? null : lst[1];
    }
  original_instructions: "\n    You are given a list of integers.\n    Write a function\
    \ next_smallest() that returns the 2nd smallest element of the list.\n    Return\
    \ None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n\
    \    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1,\
    \ 1]) == None\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to count sentences that contain any number (0-9) instead of those that start with 'I '.
  id: |-
    hubedit_humaneval_ts_HumanEval/91
  lang: |-
    deno
  modified_code: |-
    export async function main(S: string): Promise<number> {
        const sentences = S.split(/[.?!]\s*/);
        return sentences.reduce((count, sentence) => count + (/\d/.test(sentence) ? 1 : 0), 0);
    }
  original_code: |-
    export async function main(S: string): Promise<number> {
        const sentences = S.split(/[.?!]\s*/);
        return sentences.reduce((count, sentence) => count + (sentence.startsWith('I ') ? 1 : 0), 0);
    }
  original_instructions: "\n    You'll be given a string of words, and your task is\
    \ to count the number\n    of boredoms. A boredom is a sentence that starts with\
    \ the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For\
    \ example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky\
    \ is blue. The sun is shining. I love this weather\")\n    1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the digits of the smallest prime number in the list instead of the largest.
  id: |-
    hubedit_humaneval_ts_HumanEval/94
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: number[]): Promise<number> {

        function isPrime(n: number): boolean {
            if (n <= 1) return false;
            for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {
                if (n % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let minn = Infinity;
        let i = 0;
        while (i < lst.length) {
            if (lst[i] < minn && isPrime(lst[i])) {
                minn = lst[i];
            }
            i++;
        }

        if (minn === Infinity) {
            return 0; // Return 0 if there are no prime numbers in the list
        }

        const result = Array.from(minn.toString()).reduce((sum, digit) => sum + parseInt(digit), 0);
        return result;
    }
  original_code: |-
    export async function main(lst: number[]): Promise<number> {

        function isPrime(n: number): boolean {
            for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {
                if (n % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let maxx = 0;
        let i = 0;
        while (i < lst.length) {
            if (lst[i] > maxx && isPrime(lst[i])) {
                maxx = lst[i];
            }
            i++;
        }

        const result = Array.from(maxx.toString()).reduce((sum, digit) => sum + parseInt(digit), 0);
        return result;
    }
  original_instructions: "You are given a list of integers.\n    You need to find\
    \ the largest prime value and return the sum of its digits.\n\n    Examples:\n\
    \    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output\
    \ should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output\
    \ should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\
    \ the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\
    \ the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be\
    \ 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return a list of composite numbers instead of prime numbers by inverting the `is_prime` flag's logic and pushing `i` into the array when `is_prime` is false.
  id: |-
    hubedit_humaneval_ts_HumanEval/96
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number[]> {
        const composites: number[] = [];
        for (let i = 2; i < n; i++) {
            let is_composite = false;
            for (let j = 2; j < i; j++) {
                if (i % j === 0) {
                    is_composite = true;
                    break;
                }
            }
            if (is_composite) {
                composites.push(i);
            }
        }
        return composites;
    }
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        const primes: number[] = [];
        for (let i = 2; i < n; i++) {
            let is_prime = true;
            for (let j = 2; j < i; j++) {
                if (i % j === 0) {
                    is_prime = false;
                    break;
                }
            }
            if (is_prime) {
                primes.push(i);
            }
        }
        return primes;
    }
  original_instructions: "Implement a function that takes an non-negative integer\
    \ and returns an array of the first n\n    integers that are prime numbers and\
    \ less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11)\
    \ => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to calculate the sum of the absolute values of the last digits of both numbers instead of the product.
  id: |-
    hubedit_humaneval_ts_HumanEval/97
  lang: |-
    deno
  modified_code: |-
    export async function main(a: number, b: number): Promise<number> {
        return Math.abs(a % 10) + Math.abs(b % 10);
    }
  original_code: |-
    export async function main(a: number, b: number): Promise<number> {
        return Math.abs(a % 10) * Math.abs(b % 10);
    }
  original_instructions: "Complete the function that takes two integers and returns\n\
    \    the product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28)\
    \ should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15)\
    \ should return 20.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to round numbers ending in .5 towards the nearest even number instead of always rounding up for positive numbers and down for negative numbers.
  id: |-
    hubedit_humaneval_ts_HumanEval/99
  lang: |-
    deno
  modified_code: |-
    export async function main(value: string): Promise<number> {
        let res: number;

        if ((value.match(/\./g) || []).length === 1) {
            // remove trailing zeros
            while (value.endsWith('0')) {
                value = value.slice(0, -1);
            }
        }

        const num: number = parseFloat(value);
        if (value.endsWith('.5')) {
            // Round towards the nearest even number
            const floorNum = Math.floor(num);
            res = floorNum % 2 === 0 ? floorNum : floorNum + (num > 0 ? 1 : -1);
        } else if (value.length > 0) {
            res = Math.round(num);
        } else {
            res = 0;
        }

        return res;
    }
  original_code: |-
    export async function main(value: string): Promise<number> {
        let res: number;

        if ((value.match(/\./g) || []).length === 1) {
            // remove trailing zeros
            while (value.endsWith('0')) {
                value = value.slice(0, -1);
            }
        }

        const num: number = parseFloat(value);
        if (value.endsWith('.5')) {
            if (num > 0) {
                res = Math.ceil(num);
            } else {
                res = Math.floor(num);
            }
        } else if (value.length > 0) {
            res = Math.round(num);
        } else {
            res = 0;
        }

        return res;
    }
  original_instructions: "\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to generate an array of the first `n` prime numbers instead of the current arithmetic sequence.
  id: |-
    hubedit_humaneval_ts_HumanEval/100
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number[]> {
        const primes: number[] = [];
        let num = 2; // Start from the first prime number

        while (primes.length < n) {
            if (isPrime(num)) {
                primes.push(num);
            }
            num++;
        }

        return primes;
    }

    function isPrime(num: number): boolean {
        for (let i = 2, sqrtNum = Math.sqrt(num); i <= sqrtNum; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return num > 1;
    }
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        return Array.from({ length: n }, (_, i) => n + 2 * i);
    }
  original_instructions: "\n    Given a positive integer n, you have to make a pile\
    \ of n levels of stones.\n    The first level has n stones.\n    The number of\
    \ stones in the next level is:\n        - the next odd number if n is odd.\n \
    \       - the next even number if n is even.\n    Return the number of stones\
    \ in each level in a list, where element at index\n    i represents the number\
    \ of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n   \
    \ [3, 5, 7]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Add a new condition to check if `x` is a prime number, and if so, return `x * y`.
  id: |-
    hubedit_humaneval_ts_HumanEval/102
  lang: |-
    deno
  modified_code: |-
    export async function main(x: number, y: number): Promise<number> {
        if (isPrime(x)) {
            return x * y;
        }
        if (x > y) {
            return -1;
        }
        if (y % 2 === 0) {
            return y;
        }
        if (x === y) {
            return -1;
        }
        return y - 1;
    }

    function isPrime(num: number): boolean {
        if (num <= 1) return false;
        if (num <= 3) return true;

        if (num % 2 === 0 || num % 3 === 0) return false;

        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
  original_code: |-
    export async function main(x: number, y: number): Promise<number> {
        if (x > y) {
            return -1;
        }
        if (y % 2 === 0) {
            return y;
        }
        if (x === y) {
            return -1;
        }
        return y - 1;
    }
  original_instructions: "This function takes two positive numbers x and y and returns\
    \ the\n    biggest even integer number that is in the range [x, y] inclusive.\
    \ If\n    there's no such number, then the function should return -1.\n\n    For\
    \ example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return an array of numbers where each number has only even digits, instead of only odd digits, and sort the resulting array in descending order.
  id: |-
    hubedit_humaneval_ts_HumanEval/104
  lang: |-
    deno
  modified_code: |-
    export async function main(x: number[]): Promise<number[]> {
        const evenDigitElements: number[] = [];
        for (const i of x) {
            if (Array.from(i.toString()).every(c => parseInt(c) % 2 === 0)) {
                evenDigitElements.push(i);
            }
        }
        return evenDigitElements.sort((a, b) => b - a);
    }
  original_code: |-
    export async function main(x: number[]): Promise<number[]> {
        const oddDigitElements: number[] = [];
        for (const i of x) {
            if (Array.from(i.toString()).every(c => parseInt(c) % 2 === 1)) {
                oddDigitElements.push(i);
            }
        }
        return oddDigitElements.sort((a, b) => a - b);
    }
  original_instructions: "Given a list of positive integers x. return a sorted list\
    \ of all\n    elements that hasn't any even digit.\n\n    Note: Returned list\
    \ should be sorted in increasing order.\n\n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return an array of strings instead of numbers, where each string represents either "even" or "odd" depending on the original number's parity.
  id: |-
    hubedit_humaneval_ts_HumanEval/106
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<string[]> {
        const ret: string[] = [];
        for (let i = 1; i <= n; i++) {
            if (i % 2 === 0) {
                ret.push("even");
            } else {
                ret.push("odd");
            }
        }
        return ret;
    }
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        const ret: number[] = [];
        for (let i = 1; i <= n; i++) {
            if (i % 2 === 0) {
                let x = 1;
                for (let j = 1; j <= i; j++) x *= j;
                ret.push(x);
            } else {
                let x = 0;
                for (let j = 1; j <= i; j++) x += j;
                ret.push(x);
            }
        }
        return ret;
    }
  original_instructions: " Implement the function f that takes n as a parameter,\n\
    \    and returns a list of size n, such that the value of the element at index\
    \ i is the factorial of i if i is even\n    or the sum of numbers from 1 to i\
    \ otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication\
    \ of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1,\
    \ 2, 6, 24, 15]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count palindromes that are also prime numbers, separating the counts for even and odd primes.
  id: |-
    hubedit_humaneval_ts_HumanEval/107
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<[number, number]> {

        function isPalindrome(num: number): boolean {
            return num.toString() === num.toString().split('').reverse().join('');
        }

        function isPrime(num: number): boolean {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            for (let i = 5; i * i <= num; i += 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }

        let evenPalindromePrimeCount = 0;
        let oddPalindromePrimeCount = 0;

        for (let i = 1; i <= n; i++) {
            if (isPalindrome(i) && isPrime(i)) {
                if (i % 2 === 0) {
                    evenPalindromePrimeCount += 1;
                } else {
                    oddPalindromePrimeCount += 1;
                }
            }
        }
        return [evenPalindromePrimeCount, oddPalindromePrimeCount];
    }
  original_code: |-
    export async function main(n: number): Promise<[number, number]> {

        function isPalindrome(num: number): boolean {
            return num.toString() === num.toString().split('').reverse().join('');
        }

        let evenPalindromeCount = 0;
        let oddPalindromeCount = 0;

        for (let i = 1; i <= n; i++) {
            if (i % 2 === 1 && isPalindrome(i)) {
                oddPalindromeCount += 1;
            } else if (i % 2 === 0 && isPalindrome(i)) {
                evenPalindromeCount += 1;
            }
        }
        return [evenPalindromeCount, oddPalindromeCount];
    }
  original_instructions: "\n    Given a positive integer n, return a tuple that has\
    \ the number of even and odd\n    integer palindromes that fall within the range(1,\
    \ n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n\
    \        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is\
    \ even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n    \
    \    Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n \
    \   Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number\
    \ of even and odd integer palindromes respectively.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the positive digits sums instead of the count of positive digits sums.
  id: |-
    hubedit_humaneval_ts_HumanEval/108
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {

        function digitsSum(n: number): number {
            let neg = 1;
            if (n < 0) {
                n = -1 * n;
                neg = -1;
            }
            let nArray = Array.from(String(n), Number);
            nArray[0] = nArray[0] * neg;
            return nArray.reduce((a, b) => a + b, 0);
        }

        return arr.map(digitsSum).filter(x => x > 0).reduce((a, b) => a + b, 0);
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {

        function digitsSum(n: number): number {
            let neg = 1;
            if (n < 0) {
                n = -1 * n;
                neg = -1;
            }
            let nArray = Array.from(String(n), Number);
            nArray[0] = nArray[0] * neg;
            return nArray.reduce((a, b) => a + b, 0);
        }

        return arr.map(digitsSum).filter(x => x > 0).length;
    }
  original_instructions: "\n    Write a function count_nums which takes an array of\
    \ integers and returns\n    the number of elements which has a sum of digits >\
    \ 0.\n    If a number is negative, then its first signed digit will be negative:\n\
    \    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n\
    \    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the array can be sorted by rotating it any number of times, not just from the first minimum value found.
  id: |-
    hubedit_humaneval_ts_HumanEval/109
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<boolean> {
      if (arr.length === 0) {
        return true;
      }
      const sortedArray: number[] = [...arr].sort((a, b) => a - b);

      for (let i = 0; i < arr.length; i++) {
        let rotatedArray: number[] = arr.slice(i).concat(arr.slice(0, i));
        if (arraysAreEqual(rotatedArray, sortedArray)) {
          return true;
        }
      }
      return false;
    }

    function arraysAreEqual(a: number[], b: number[]): boolean {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<boolean> {
      if (arr.length === 0) {
        return true;
      }
      const sortedArray: number[] = [...arr].sort((a, b) => a - b);
      let myArr: number[] = [];

      const minValue: number = Math.min(...arr);
      const minIndex: number = arr.indexOf(minValue);
      myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));

      for (let i = 0; i < arr.length; i++) {
        if (myArr[i] !== sortedArray[i]) {
          return false;
        }
      }
      return true;
    }
  original_instructions: "We have an array 'arr' of N integers arr[1], arr[2], ...,\
    \ arr[N].The\n    numbers in the array will be randomly ordered. Your task is\
    \ to determine if\n    it is possible to get an array sorted in non-decreasing\
    \ order by performing\n    the following operation on the given array:\n     \
    \   You are allowed to perform right shift operation any number of times.\n\n\
    \    One right shift operation means shifting all elements of the array by one\n\
    \    position in the right direction. The last element of the array will be moved\
    \ to\n    the starting position in the array i.e. 0th index.\n\n    If it is possible\
    \ to obtain the sorted array by performing the above operation\n    then return\
    \ True else return False.\n    If the given array is empty then return True.\n\
    \n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\
    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n                 be achieved for\
    \ the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It\
    \ is not possible to get non-decreasing order for the given\n                array\
    \ by performing any number of right shift operations.\n\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the maximum subarray sum instead of the minimum by removing the negation of the numbers during the summation and comparison.
  id: |-
    hubedit_humaneval_ts_HumanEval/114
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number> {
        let max_sum = 0;
        let current_sum = 0;
        for (const num of nums) {
            current_sum += num;
            if (current_sum < 0) {
                current_sum = 0;
            }
            max_sum = Math.max(current_sum, max_sum);
        }
        if (max_sum === 0) {
            max_sum = Math.max(...nums);
        }
        return max_sum;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        let max_sum = 0;
        let s = 0;
        for (const num of nums) {
            s += -num;
            if (s < 0) {
                s = 0;
            }
            max_sum = Math.max(s, max_sum);
        }
        if (max_sum === 0) {
            max_sum = Math.max(...nums.map(i => -i));
        }
        const min_sum = -max_sum;
        return min_sum;
    }
  original_instructions: "\n    Given an array of integers nums, find the minimum\
    \ sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2,\
    \ 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the first vowel found in the word instead of the last, by iterating from the beginning of the word rather than from the end.
  id: |-
    hubedit_humaneval_ts_HumanEval/118
  lang: |-
    deno
  modified_code: |-
    export async function main(word: string): Promise<string> {
        if (word.length < 3) {
            return "";
        }

        const vowels: Set<string> = new Set(["a", "e", "i", "o", "u", "A", "E", "O", "U", "I"]);
        for (let i: number = 1; i < word.length - 1; i++) {
            if (vowels.has(word[i])) {
                if (!vowels.has(word[i + 1]) && !vowels.has(word[i - 1])) {
                    return word[i];
                }
            }
        }
        return "";
    }
  original_code: |-
    export async function main(word: string): Promise<string> {
        if (word.length < 3) {
            return "";
        }

        const vowels: Set<string> = new Set(["a", "e", "i", "o", "u", "A", "E", "O", "U", "I"]);
        for (let i: number = word.length - 2; i > 0; i--) {
            if (vowels.has(word[i])) {
                if (!vowels.has(word[i + 1]) && !vowels.has(word[i - 1])) {
                    return word[i];
                }
            }
        }
        return "";
    }
  original_instructions: "You are given a word. Your task is to find the closest vowel\
    \ that stands between\n    two consonants from the right side of the word (case\
    \ sensitive).\n\n    Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    find any vowel met the above condition.\n\n\
    \    You may assume that the given string contains English letter only.\n\n  \
    \  Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"\
    FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"\
    ab\") ==> \"\"\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the k smallest elements instead of the k largest elements by changing the slice operation to take the first k elements after sorting.
  id: |-
    hubedit_humaneval_ts_HumanEval/120
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[], k: number): Promise<number[]> {
        if (k === 0) {
            return [];
        }
        arr.sort((a, b) => a - b);
        const ans = arr.slice(0, k);
        return ans;
    }
  original_code: |-
    export async function main(arr: number[], k: number): Promise<number[]> {
        if (k === 0) {
            return [];
        }
        arr.sort((a, b) => a - b);
        const ans = arr.slice(-k);
        return ans;
    }
  original_instructions: "\n    Given an array arr of integers and a positive integer\
    \ k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\
    \n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4,\
    \ -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n       \
    \ Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2,\
    \ 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array\
    \ will be in the range of [1, 1000].\n        2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return only the even numbers in the Collatz sequence instead of the odd numbers.
  id: |-
    hubedit_humaneval_ts_HumanEval/123
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number[]> {
        let evenCollatz: number[] = n % 2 === 0 ? [n] : [];
        while (n > 1) {
            if (n % 2 === 0) {
                n = n / 2;
                evenCollatz.push(n);
            } else {
                n = n * 3 + 1;
            }
        }

        return evenCollatz.sort((a, b) => a - b);
    }
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        let oddCollatz: number[] = n % 2 === 0 ? [] : [n];
        while (n > 1) {
            if (n % 2 === 0) {
                n = n / 2;
            } else {
                n = n * 3 + 1;
            }

            if (n % 2 === 1) {
                oddCollatz.push(Math.floor(n));
            }
        }

        return oddCollatz.sort((a, b) => a - b);
    }
  original_instructions: "\n    Given a positive integer n, return a sorted list that\
    \ has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a\
    \ conjecture in mathematics that concerns a sequence defined\n    as follows:\
    \ start with any positive integer n. Then each term is obtained from the\n   \
    \ previous term as follows: if the previous term is even, the next term is one\
    \ half of\n    the previous term. If the previous term is odd, the next term is\
    \ 3 times the previous\n    term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1)\
    \ is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to calculate the sum of the even digits instead of the product of the odd digits.
  id: |-
    hubedit_humaneval_ts_HumanEval/131
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        for (const digit of n.toString()) {
            const int_digit = parseInt(digit);
            if (int_digit % 2 === 0) {
                sum += int_digit;
            }
        }
        return sum;
    }
  original_code: |-
    export async function main(n: number): Promise<number> {
        let product = 1;
        let odd_count = 0;
        for (const digit of n.toString()) {
            const int_digit = parseInt(digit);
            if (int_digit % 2 === 1) {
                product *= int_digit;
                odd_count++;
            }
        }
        if (odd_count === 0) {
            return 0;
        } else {
            return product;
        }
    }
  original_instructions: "Given a positive integer n, return the product of the odd\
    \ digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)\
    \  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count and return the total number of pairs of matching opening and closing brackets, rather than just checking if there are at least two pairs.
  id: |-
    hubedit_humaneval_ts_HumanEval/132
  lang: |-
    deno
  modified_code: |-
    export async function main(string: string): Promise<number> {
        const opening_bracket_index: number[] = [];
        const closing_bracket_index: number[] = [];
        for (let i = 0; i < string.length; i++) {
            if (string[i] === '[') {
                opening_bracket_index.push(i);
            } else if (string[i] === ']') {
                closing_bracket_index.push(i);
            }
        }
        closing_bracket_index.reverse();
        let cnt = 0;
        let i = 0;
        const l = closing_bracket_index.length;
        for (const idx of opening_bracket_index) {
            if (i < l && idx < closing_bracket_index[i]) {
                cnt += 1;
                i += 1;
            }
        }
        return cnt;
    }
  original_code: |-
    export async function main(string: string): Promise<boolean> {
        const opening_bracket_index: number[] = [];
        const closing_bracket_index: number[] = [];
        for (let i = 0; i < string.length; i++) {
            if (string[i] === '[') {
                opening_bracket_index.push(i);
            } else {
                closing_bracket_index.push(i);
            }
        }
        closing_bracket_index.reverse();
        let cnt = 0;
        let i = 0;
        const l = closing_bracket_index.length;
        for (const idx of opening_bracket_index) {
            if (i < l && idx < closing_bracket_index[i]) {
                cnt += 1;
                i += 1;
            }
        }
        return cnt >= 2;
    }
  original_instructions: "\n    Create a function that takes a string as input which\
    \ contains only square brackets.\n    The function should return True if and only\
    \ if there is a valid subsequence of brackets\n    where at least one bracket\
    \ in the subsequence is nested.\n\n    is_nested('[[]]') \u279E True\n    is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n    is_nested('[][]') \u279E False\n    is_nested('[]') \u279E\
    \ False\n    is_nested('[[][]]') \u279E True\n    is_nested('[[]][[') \u279E True\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to calculate the sum of the cubes of the numbers instead of their squares.
  id: |-
    hubedit_humaneval_ts_HumanEval/133
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: number[]): Promise<number> {
        let cubedSum = 0;
        for (let i of lst) {
            cubedSum += Math.ceil(i) ** 3;
        }
        return cubedSum;
    }
  original_code: |-
    export async function main(lst: number[]): Promise<number> {
        let squared = 0;
        for (let i of lst) {
            squared += Math.ceil(i) ** 2;
        }
        return squared;
    }
  original_instructions: "You are given a list of numbers.\n    You need to return\
    \ the sum of squared numbers in the given list,\n    round each element in the\
    \ list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3]\
    \ the output should be 14\n    For lst = [1,4,9] the output should be 98\n   \
    \ For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output\
    \ should be 29\n    For lst = [-2.4,1,1] the output should be 6\n\n\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to check if the first character of the input string is a digit instead of checking if the last word is a single letter.
  id: |-
    hubedit_humaneval_ts_HumanEval/134
  lang: |-
    deno
  modified_code: |-
    export async function main(txt: string): Promise<boolean> {
        const firstChar = txt.charAt(0);
        return !isNaN(parseInt(firstChar)) && firstChar !== ' ';
    }
  original_code: |-
    export async function main(txt: string): Promise<boolean> {
        const check = txt.split(' ')[txt.split(' ').length - 1];
        return check.length === 1 && (97 <= check.toLowerCase().charCodeAt(0) && check.toLowerCase().charCodeAt(0) <= 122);
    }
  original_instructions: "\n    Create a function that returns True if the last character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and False otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\"\
    ) \u279E False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n\
    \    check_if_last_char_is_a_letter(\"apple pi e \") \u279E False\n    check_if_last_char_is_a_letter(\"\
    \") \u279E False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the index of the first element that is smaller than its predecessor, instead of the last one.
  id: |-
    hubedit_humaneval_ts_HumanEval/135
  lang: |-
    deno
  modified_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ind: number = -1;
        let i: number = 1;
        while (i < arr.length) {
            if (arr[i] < arr[i - 1]) {
                ind = i;
                break; // Exit the loop as soon as the condition is met
            }
            i += 1;
        }
        return ind;
    }
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ind: number = -1;
        let i: number = 1;
        while (i < arr.length) {
            if (arr[i] < arr[i - 1]) {
                ind = i;
            }
            i += 1;
        }
        return ind;
    }
  original_instructions: "Create a function which returns the largest index of an\
    \ element which\n    is not greater than or equal to the element immediately preceding\
    \ it. If\n    no such element exists then return -1. The given array will not\
    \ contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5])\
    \ = 3\n    can_arrange([1,2,3]) = -1\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the smallest negative numbers and the sum of the largest positive numbers instead of the maximum negative and minimum positive numbers.
  id: |-
    hubedit_humaneval_ts_HumanEval/136
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: number[]): Promise<(number | null)[]> {
        const smallestNegatives = lst.filter(x => x < 0);
        const largestPositives = lst.filter(x => x > 0);
        return [
            smallestNegatives.length > 0 ? smallestNegatives.reduce((a, b) => a + b, 0) : null,
            largestPositives.length > 0 ? largestPositives.reduce((a, b) => a + b, 0) : null
        ];
    }
  original_code: |-
    export async function main(lst: number[]): Promise<(number | null)[]> {
        const smallest = lst.filter(x => x < 0);
        const largest = lst.filter(x => x > 0);
        return [
            smallest.length > 0 ? Math.max(...smallest) : null,
            largest.length > 0 ? Math.min(...largest) : null
        ];
    }
  original_instructions: "\n    Create a function that returns a tuple (a, b), where\
    \ 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of\
    \ positive integers in a list.\n    If there is no negative or positive integers,\
    \ return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n\
    \    largest_smallest_integers([0]) == (None, None)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Change the function to check if the number is a prime number instead of checking if it's an even number greater than or equal to 8.
  id: |-
    hubedit_humaneval_ts_HumanEval/138
  lang: |-
    deno
  modified_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n <= 1) return false;
        if (n <= 3) return true;

        if (n % 2 === 0 || n % 3 === 0) return false;

        for (let i = 5; i * i <= n; i += 6) {
            if (n % i === 0 || n % (i + 2) === 0) return false;
        }

        return true;
    }
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        return n % 2 === 0 && n >= 8;
    }
  original_instructions: "Evaluate whether the given number n can be written as the\
    \ sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4)\
    \ == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8)\
    \ == True\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to accept an array of file names and return an array of 'Yes' or 'No' for each file, indicating whether each file meets the criteria.
  id: |-
    hubedit_humaneval_ts_HumanEval/141
  lang: |-
    deno
  modified_code: |-
    export async function main(file_names: string[]): Promise<string[]> {
        const suf: string[] = ['txt', 'exe', 'dll'];
        return file_names.map(file_name => {
            const lst: string[] = file_name.split('.');
            if (lst.length != 2) {
                return 'No';
            }
            if (!suf.includes(lst[1])) {
                return 'No';
            }
            if (lst[0].length == 0) {
                return 'No';
            }
            if (!lst[0][0].match(/[a-zA-Z]/)) {
                return 'No';
            }
            const t: number = lst[0].split('').filter(x => x.match(/\d/)).length;
            if (t > 3) {
                return 'No';
            }
            return 'Yes';
        });
    }
  original_code: |-
    export async function main(file_name: string): Promise<string> {
        const suf: string[] = ['txt', 'exe', 'dll'];
        const lst: string[] = file_name.split('.');
        if (lst.length != 2) {
            return 'No';
        }
        if (!suf.includes(lst[1])) {
            return 'No';
        }
        if (lst[0].length == 0) {
            return 'No';
        }
        if (!lst[0][0].match(/[a-zA-Z]/)) {
            return 'No';
        }
        const t: number = lst[0].split('').filter(x => x.match(/\d/)).length;
        if (t > 3) {
            return 'No';
        }
        return 'Yes';
    }
  original_instructions: "Create a function which takes a string representing a file's\
    \ name, and returns\n    'Yes' if the the file's name is valid, and returns 'No'\
    \ otherwise.\n    A file's name is considered to be valid if and only if all the\
    \ following conditions\n    are met:\n    - There should not be more than three\
    \ digits ('0'-'9') in the file's name.\n    - The file's name contains exactly\
    \ one dot '.'\n    - The substring before the dot should not be empty, and it\
    \ starts with a letter from\n    the latin alphapet ('a'-'z' and 'A'-'Z').\n \
    \   - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"\
    1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to reverse each word that has an even number of characters before adding it to the new list.
  id: |-
    hubedit_humaneval_ts_HumanEval/143
  lang: |-
    deno
  modified_code: |-
    export async function main(sentence: string): Promise<string> {
        const new_lst: string[] = [];
        for (const word of sentence.split(' ')) {
            let flg = 0;
            if (word.length === 1) {
                flg = 1;
            }
            for (let i = 2; i < word.length; i++) {
                if (word.length % i === 0) {
                    flg = 1;
                }
            }
            if (flg === 0 || word.length === 2) {
                // Check if the word has an even number of characters
                if (word.length % 2 === 0) {
                    // Reverse the word and add it to the new list
                    new_lst.push(word.split('').reverse().join(''));
                } else {
                    // Add the word as it is to the new list
                    new_lst.push(word);
                }
            }
        }
        return new_lst.join(' ');
    }
  original_code: |-
    export async function main(sentence: string): Promise<string> {
        const new_lst: string[] = [];
        for (const word of sentence.split(' ')) {
            let flg = 0;
            if (word.length === 1) {
                flg = 1;
            }
            for (let i = 2; i < word.length; i++) {
                if (word.length % i === 0) {
                    flg = 1;
                }
            }
            if (flg === 0 || word.length === 2) {
                new_lst.push(word);
            }
        }
        return new_lst.join(' ');
    }
  original_instructions: "\n    You are given a string representing a sentence,\n\
    \    the sentence contains some words separated by a space,\n    and you have\
    \ to return a string that contains the words from the original sentence,\n   \
    \ whose lengths are prime numbers,\n    the order of the words in the new string\
    \ should be the same as the original one.\n\n    Example 1:\n        Input: sentence\
    \ = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input:\
    \ sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n\
    \        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to check if the product of the two fractions is a prime number instead of checking if it is an integer.
  id: |-
    hubedit_humaneval_ts_HumanEval/144
  lang: |-
    deno
  modified_code: |-
    export async function main(x: string, n: string): Promise<boolean> {
        const [a, b] = x.split("/");
        const [c, d] = n.split("/");
        const numerator = parseInt(a) * parseInt(c);
        const denom = parseInt(b) * parseInt(d);
        const product = numerator / denom;

        return isPrime(product);
    }

    function isPrime(num: number): boolean {
        if (num <= 1) return false;
        if (num <= 3) return true;

        if (num % 2 === 0 || num % 3 === 0) return false;

        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }

        return true;
    }
  original_code: |-
    export async function main(x: string, n: string): Promise<boolean> {
        const [a, b] = x.split("/");
        const [c, d] = n.split("/");
        const numerator = parseInt(a) * parseInt(c);
        const denom = parseInt(b) * parseInt(d);
        if (numerator / denom === Math.floor(numerator / denom)) {
            return true;
        }
        return false;
    }
  original_instructions: "Your task is to implement a function that will simplify\
    \ the expression\n    x * n. The function returns True if x * n evaluates to a\
    \ whole number and False\n    otherwise. Both x and n, are string representation\
    \ of a fraction, and have the following format,\n    <numerator>/<denominator>\
    \ where both numerator and denominator are positive whole numbers.\n\n    You\
    \ can assume that x, and n are valid fractions, and do not have zero as denominator.\n\
    \n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n\
    \    simplify(\"7/10\", \"10/2\") = False\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count numbers that are less than or equal to 10 and have an even number of digits.
  id: |-
    hubedit_humaneval_ts_HumanEval/146
  lang: |-
    deno
  modified_code: |-
    export async function main(nums: number[]): Promise<number> {
      let count = 0;
      for (const num of nums) {
        if (num <= 10) {
          const numberAsString = num.toString();
          if (numberAsString.length % 2 === 0) {
            count += 1;
          }
        }
      }
      return count;
    }
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
      let count = 0;
      for (const num of nums) {
        if (num > 10) {
          const oddDigits = [1, 3, 5, 7, 9];
          const numberAsString = num.toString();
          if (
            oddDigits.includes(+numberAsString[0]) &&
            oddDigits.includes(+numberAsString[numberAsString.length - 1])
          ) {
            count += 1;
          }
        }
      }
      return count;
    }
  original_instructions: "Write a function that takes an array of numbers as input\
    \ and returns\n    the number of elements in the array that are greater than 10\
    \ and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n \
    \   For example:\n    specialFilter([15, -73, 14, -15]) => 1\n    specialFilter([33,\
    \ -2, -3, 45, 21, 109]) => 2\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to include the option to return planets in reverse order from planet2 to planet1 if a third boolean argument `reverseOrder` is set to true.
  id: |-
    hubedit_humaneval_ts_HumanEval/148
  lang: |-
    deno
  modified_code: |-
    export async function main(planet1: string, planet2: string, reverseOrder: boolean = false): Promise<string[]> {
        const planetNames: string[] = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"];
        if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {
            return [];
        }
        const planet1Index: number = planetNames.indexOf(planet1);
        const planet2Index: number = planetNames.indexOf(planet2);
        let result: string[];
        if (planet1Index < planet2Index) {
            result = planetNames.slice(planet1Index + 1, planet2Index);
        } else {
            result = planetNames.slice(planet2Index + 1, planet1Index);
        }
        if (reverseOrder) {
            return result.reverse();
        }
        return result;
    }
  original_code: |-
    export async function main(planet1: string, planet2: string): Promise<string[]> {
        const planetNames: string[] = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"];
        if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {
            return [];
        }
        const planet1Index: number = planetNames.indexOf(planet1);
        const planet2Index: number = planetNames.indexOf(planet2);
        if (planet1Index < planet2Index) {
            return planetNames.slice(planet1Index + 1, planet2Index);
        } else {
            return planetNames.slice(planet2Index + 1, planet1Index);
        }
    }
  original_instructions: "\n    There are eight planets in our solar system: the closerst\
    \ to the Sun\n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter,\
    \ Saturn,\n    Uranus, Neptune.\n    Write a function that takes two planet names\
    \ as strings planet1 and planet2.\n    The function should return a tuple containing\
    \ all planets whose orbits are\n    located between the orbit of planet1 and the\
    \ orbit of planet2, sorted by\n    the proximity to the sun.\n    The function\
    \ should return an empty tuple if planet1 or planet2\n    are not correct planet\
    \ names.\n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\"\
    )\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\"\
    ) ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to filter out strings that contain the letter 'a' and then return the list sorted in reverse alphabetical order.
  id: |-
    hubedit_humaneval_ts_HumanEval/149
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: string[]): Promise<string[]> {
        let filteredList: string[] = lst.filter(s => !s.includes('a'));
        return filteredList.sort().reverse();
    }
  original_code: |-
    export async function main(lst: string[]): Promise<string[]> {
        lst.sort();
        let new_lst: string[] = [];
        for (let i of lst) {
            if (i.length % 2 === 0) {
                new_lst.push(i);
            }
        }
        return new_lst.sort((a, b) => a.length - b.length);
    }
  original_instructions: "Write a function that accepts a list of strings as a parameter,\n\
    \    deletes the strings that have odd lengths from it,\n    and returns the resulted\
    \ list with a sorted order,\n    The list is always a list of strings and never\
    \ an array of numbers,\n    and it may contain duplicates.\n    The order of the\
    \ list should be ascending by length of each word, and you\n    should return\
    \ the list sorted by that rule.\n    If two words have the same length, sort the\
    \ list alphabetically.\n    The function should return a list of strings in sorted\
    \ order.\n    You may assume that all words will have the same length.\n    For\
    \ example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Modify the script to return the sum of the cubes of even numbers instead of the sum of the squares of odd numbers.
  id: |-
    hubedit_humaneval_ts_HumanEval/151
  lang: |-
    deno
  modified_code: |-
    export async function main(lst: number[]): Promise<number> {
        return lst.filter(i => i > 0 && i % 2 === 0 && !i.toString().includes('.'))
                  .reduce((sum, i) => sum + i ** 3, 0);
    }
  original_code: |-
    export async function main(lst: number[]): Promise<number> {
        return lst.filter(i => i > 0 && i % 2 !== 0 && !i.toString().includes('.'))
                  .reduce((sum, i) => sum + i ** 2, 0);
    }
  original_instructions: "\n    Given a list of numbers, return the sum of squares\
    \ of the numbers\n    in the list that are odd. Ignore numbers that are negative\
    \ or not integers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0\
    \ = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9,\
    \ -2]) == 81\n    double_the_difference([0]) == 0\n\n    If the input list is\
    \ empty, return 0.\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the sum of the absolute differences between the elements of the `game` array and the `guess` array instead of returning an array of differences.
  id: |-
    hubedit_humaneval_ts_HumanEval/152
  lang: |-
    deno
  modified_code: |-
    export async function main(game: number[], guess: number[]): Promise<number> {
        return game.reduce((sum, x, i) => sum + Math.abs(x - guess[i]), 0);
    }
  original_code: |-
    export async function main(game: number[], guess: number[]): Promise<number[]> {
        return game.map((x, i) => Math.abs(x - guess[i]));
    }
  original_instructions: "I think we all remember that feeling when the result of\
    \ some long-awaited\n    event is finally known. The feelings and thoughts you\
    \ have at that moment are\n    definitely worth noting down and comparing.\n \
    \   Your task is to determine if a person correctly guessed the results of a number\
    \ of matches.\n    You are given two arrays of scores and guesses of equal length,\
    \ where each index shows a match.\n    Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    the value is\
    \ 0, and if not, the value is the absolute difference between the guess and the\
    \ score.\n\n\n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n\
    \    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to count the number of prime digits instead of even digits, while still counting the odd digits.
  id: |-
    hubedit_humaneval_ts_HumanEval/155
  lang: |-
    deno
  modified_code: |-
    export async function main(num: number): Promise<[number, number]> {
        let prime_count = 0;
        let odd_count = 0;
        const primeDigits = new Set([2, 3, 5, 7]); // Set of prime digits
        for (const i of String(Math.abs(num))) {
            const digit = parseInt(i);
            if (primeDigits.has(digit)) {
                prime_count += 1;
            } else if (digit % 2 !== 0) {
                odd_count += 1;
            }
        }
        return [prime_count, odd_count];
    }
  original_code: |-
    export async function main(num: number): Promise<[number, number]> {
        let even_count = 0;
        let odd_count = 0;
        for (const i of String(Math.abs(num))) {
            if (parseInt(i) % 2 === 0) {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
        return [even_count, odd_count];
    }
  original_instructions: "Given an integer. return a tuple that has the number of\
    \ even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12)\
    \ ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |2

    Modify the script to return the roman numeral representation in uppercase instead of lowercase.
  id: |-
    hubedit_humaneval_ts_HumanEval/156
  lang: |-
    deno
  modified_code: |-
    export async function main(number: number): Promise<string> {
        const num: number[] = [1, 4, 5, 9, 10, 40, 50, 90,
                               100, 400, 500, 900, 1000];
        const sym: string[] = ["I", "IV", "V", "IX", "X", "XL",
                               "L", "XC", "C", "CD", "D", "CM", "M"];
        let i: number = 12;
        let res: string = '';
        while (number > 0) {
            let div: number = Math.floor(number / num[i]);
            number %= num[i];
            while (div > 0) {
                res += sym[i];
                div -= 1;
            }
            i -= 1;
        }
        return res; // Removed toLowerCase() to return the result in uppercase
    }
  original_code: |-
    export async function main(number: number): Promise<string> {
        const num: number[] = [1, 4, 5, 9, 10, 40, 50, 90,
                               100, 400, 500, 900, 1000];
        const sym: string[] = ["I", "IV", "V", "IX", "X", "XL",
                               "L", "XC", "C", "CD", "D", "CM", "M"];
        let i: number = 12;
        let res: string = '';
        while (number > 0) {
            let div: number = Math.floor(number / num[i]);
            number %= num[i];
            while (div > 0) {
                res += sym[i];
                div -= 1;
            }
            i -= 1;
        }
        return res.toLowerCase();
    }
  original_instructions: "\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n\
    \    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n\
    \    "
  resource_type: null
  resource_type_def: null
- edit_instructions: |-
    Add a check to ensure that all input parameters (number, need, remaining) are non-negative integers, and throw an error if any of them are not.
  id: |-
    hubedit_humaneval_ts_HumanEval/159
  lang: |-
    deno
  modified_code: |-
    export async function main(number: number, need: number, remaining: number): Promise<number[]> {
        if (!Number.isInteger(number) || number < 0 ||
            !Number.isInteger(need) || need < 0 ||
            !Number.isInteger(remaining) || remaining < 0) {
            throw new Error('All input parameters must be non-negative integers.');
        }

        if (need <= remaining) {
            return [number + need, remaining - need];
        } else {
            return [number + remaining, 0];
        }
    }
  original_code: |-
    export async function main(number: number, need: number, remaining: number): Promise<number[]> {
        if (need <= remaining) {
            return [number + need, remaining - need];
        } else {
            return [number + remaining, 0];
        }
    }
  original_instructions: "\n    You're a hungry rabbit, and you already have eaten\
    \ a certain number of carrots,\n    but now you need to eat more carrots to complete\
    \ the day's meals.\n    you should return an array of [ total number of eaten\
    \ carrots after your meals,\n                                    the number of\
    \ carrots left after your meals ]\n    if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n\n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n\n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n\n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    "
  resource_type: null
  resource_type_def: null
