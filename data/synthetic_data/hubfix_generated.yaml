- broken_code: |-
    def main(n: str) -> int:
        return (n % 10)
  error: |-
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The function `main` is now expecting a string (`str`) as its parameter instead of an integer (`int`). The modulus operator `%` is not defined for string operands, which causes a `TypeError` when the function is called with a string argument. The modulus operation can only be performed on numbers, so the code breaks because it attempts to use a string where an integer is required.
  id: |-
    hubfix_mbpp_py_435
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        return (n % 10)
  original_instructions: |-
    find the last digit of a given number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Union
    import non_existent_library  # This library does not exist

    def main(nums: List[Union[int, str]]) -> Union[int, str]:  # Changed float to str
        sum_value = max(nums) + min(nums)
        return sum_value

    result = main([1, 2, '3', 4])  # Passing a string in a list of supposed numbers
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        import non_existent_library  # This library does not exist
    ModuleNotFoundError: No module named 'non_existent_library'
  explanation: |-
    The code is broken for several reasons:
    1. The script attempts to import a library named `non_existent_library`, which does not exist. This will raise a `ModuleNotFoundError`.
    2. The type hint for the `nums` parameter in the `main` function has been changed from `List[Union[int, float]]` to `List[Union[int, str]]`, which is incorrect because the function is supposed to work with numbers, not strings.
    3. The `main` function is called with a list that contains a string `'3'`, which will cause a `TypeError` when trying to calculate the `max` and `min` since you cannot compare integers and strings.
  id: |-
    hubfix_mbpp_py_476
  lang: |-
    python
  original_code: |-
    from typing import List, Union

    def main(nums: List[Union[int, float]]) -> Union[int, float]:
        sum_value = max(nums) + min(nums)
        return sum_value
  original_instructions: |-
    find the sum of the largest and smallest value in a given array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Dict

    import nonexistentlibrary

    def main(items: List[Dict[str, float]], n: str) -> List[Dict[str, float]]:
        main = heapq.nlargest(n, items, key=lambda s: s['cost'])
        return main
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, the parameter `n` is expected to be an integer, but it has been changed to a string type, which would cause a TypeError if the import error was fixed and the code was executed. Furthermore, the lambda function is trying to access a key 'cost' which may not exist in the dictionaries within the `items` list; the original key was 'price'.
  id: |-
    hubfix_mbpp_py_585
  lang: |-
    python
  original_code: |-
    from typing import List, Dict

    import heapq

    def main(items: List[Dict[str, float]], n: int) -> List[Dict[str, float]]:
        main = heapq.nlargest(n, items, key=lambda s: s['price'])
        return main
  original_instructions: |-
    find the n most expensive items in a given dataset
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib
    from typing import Optional, Match

    def main(text: int) -> Optional[Match[str]]:
        patterns = 'a.*?b$'
        return re.search(patterns, text)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library named `nonexistentlib`, which does not exist in the Python standard library or in the list of installed third-party libraries. This causes a `ModuleNotFoundError` when Python cannot find the specified module.
    Additionally, the `main` function is now expecting an integer (`int`) as its parameter instead of a string (`str`), which would cause a `TypeError` if the `ModuleNotFoundError` was resolved and the function was called with a string argument, because the `re.search` function expects a string pattern and a string search string.
  id: |-
    hubfix_mbpp_py_794
  lang: |-
    python
  original_code: |-
    import re
    from typing import Optional, Match

    def main(text: str) -> Optional[Match[str]]:
        patterns = 'a.*?b$'
        return re.search(patterns, text)
  original_instructions: |-
    matches a string that has an 'a' followed by anything, ending in 'b'
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> bool:
        for i in range(10):
            temp = n
            count = 0
            while (temp):
                if (temp % 10 == i):
                    count += 1
                if (count > i):
                    return False
                temp //= 10
        return True

    main(123)
  error: |-
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the parameter `n` is now expected to be a string (as indicated by the type hint `n: str`), but the operations inside the function (`temp % 10` and `temp //= 10`) are arithmetic operations that are not valid for strings. The error message indicates that there is a type mismatch when trying to perform the modulo operation on a string, which is not allowed in Python. Additionally, the function is called with an integer argument (`main(123)`), which is also incorrect given the new type hint for the parameter `n`.
  id: |-
    hubfix_mbpp_py_283
  lang: |-
    python
  original_code: |-
    def main(n: int) -> bool:
        for i in range(10):
            temp = n
            count = 0
            while (temp):
                if (temp % 10 == i):
                    count += 1
                if (count > i):
                    return False
                temp //= 10
        return True
  original_instructions: |-
    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib as hq
    from typing import List

    def main(nums: List[int], n: str) -> List[int]:
      largest_nums = hq.nlargest(n, nums)
      return largest_nums
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library named 'nonexistentlib' as 'hq', which does not exist in the Python standard library or as a third-party library. This causes a `ModuleNotFoundError`. Additionally, the type of the parameter `n` in the `main` function has been changed from `int` to `str`, which would cause a TypeError when calling `hq.nlargest` if the import statement were correct, because `hq.nlargest` expects an integer as its first argument, not a string.
  id: |-
    hubfix_mbpp_py_4
  lang: |-
    python
  original_code: |-
    import heapq as hq
    from typing import List

    def main(nums: List[int], n: int) -> List[int]:
      largest_nums = hq.nlargest(n, nums)
      return largest_nums
  original_instructions: |-
    find the n largest integers from a given list of numbers, returned in descending order
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(num: int) -> bool:
        import nonexistentlib
        dnumre = nonexistentlib.compile(r"""^[0-9]+(\.[0-9]{1,2})?$""")
        result = dnumre.search(num)
        return bool(result)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is trying to import a library named `nonexistentlib`, which does not exist. This will raise a `ModuleNotFoundError` when the script is run. Additionally, the regular expression compilation is attempted on this non-existent library, which would also fail even if the import statement was corrected, because `compile` is not a method of the `re` module (it should be `re.compile`). Furthermore, the `search` method expects a string as its second argument, but `num` is now typed as an `int`, which would raise a `TypeError` if the code execution reached that point.
  id: |-
    hubfix_mbpp_py_759
  lang: |-
    python
  original_code: |-
    def main(num: str) -> bool:
        import re
        dnumre = re.compile(r"""^[0-9]+(\.[0-9]{1,2})?$""")
        result = dnumre.search(num)
        return bool(result)
  original_instructions: |-
    check whether a given string is a decimal number with a precision of 2
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(a: float) -> str:
      perimeter = 4 * b
      return perimeter
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. It attempts to import a library named 'nonexistentlibrary', which does not exist.
    2. The return type of the function `main` is changed from `float` to `str`, which is incorrect because the function is supposed to return a numerical value representing the perimeter.
    3. Inside the function, it uses a variable `b` which is not defined anywhere in the code. The correct variable, as per the original code, should be `a`.
  id: |-
    hubfix_mbpp_py_17
  lang: |-
    python
  original_code: |-
    def main(a: float) -> float:
      perimeter = 4 * a
      return perimeter
  original_instructions: |-
    returns the perimeter of a square given its side length as input
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(list1: List[str]) -> int:
        result = all(list1[i] <= list1[i+1] for i in range(len(list1)))
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        result = all(list1[i] <= list1[i+1] for i in range(len(list1)))
      File "script.py", line 5, in <genexpr>
        result = all(list1[i] <= list1[i+1] for i in range(len(list1)))
    IndexError: list index out of range
  explanation: |-
    There are two issues with the code:

    1. The type of `list1` parameter has been changed from `List[int]` to `List[str]`, which is not necessarily a breaking change by itself, but it is inconsistent with the logic of the function that is supposed to compare integers.

    2. The return type of the function has been changed from `bool` to `int`, which is incorrect because the function returns a boolean value (`True` or `False`), not an integer.

    3. The range in the list comprehension has been changed from `range(len(list1)-1)` to `range(len(list1))`, which causes an `IndexError` because when `i` is the last index of `list1`, `list1[i+1]` tries to access an element outside the bounds of the list.
  id: |-
    hubfix_mbpp_py_567
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(list1: List[int]) -> bool:
        result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))
        return result
  original_instructions: |-
    check whether a specified list is sorted or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: str, sub_str: int) -> bool:
       if any(sub_str in s for s in str1):
           return True
       return False
  error: |-
    TypeError: 'in <string>' requires string as left operand, not int
  explanation: |-
    The function `main` is expecting `sub_str` to be of type `int` due to the change in the function signature, but the `in` operator requires a string as the left operand when the right operand is a string (as `s` is a substring of `str1`). Since `sub_str` is now expected to be an integer, the `in` operator cannot be used to check for containment within a string, leading to a `TypeError`.
  id: |-
    hubfix_mbpp_py_91
  lang: |-
    python
  original_code: |-
    def main(str1: str, sub_str: str) -> bool:
       if any(sub_str in s for s in str1):
           return True
       return False
  original_instructions: |-
    check if a string is present as a substring in a given list of string values
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(my_list: List[str]) -> List[str]:
        gap = len(my_list) // 2
        while gap > 0:
            for i in range(gap, len(my_list)):
                current_item = my_list[i]
                j = i
                while j >= gap and my_list[j - gap] > current_item:
                    my_list[j] = my_list[j - gap]
                    j -= gap
                my_list[j] = current_item
            gap //= 2

        return my_list

    main([1, 3, 2, 4])
  error: |-
    TypeError: '>' not supported between instances of 'int' and 'str'
  explanation: |-
    The code is broken because the function `main` is now expecting a list of strings (`List[str]`) as its parameter and also promises to return a list of strings, but it is being called with a list of integers (`[1, 3, 2, 4]`). The comparison operation `my_list[j - gap] > current_item` will fail because it is not valid to compare integers and strings in Python. To fix the code, the type hint for the `my_list` parameter should be changed back to `List[int]`, and the return type should also be `List[int]`.
  id: |-
    hubfix_mbpp_py_428
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(my_list: List[int]) -> List[int]:
        gap = len(my_list) // 2
        while gap > 0:
            for i in range(gap, len(my_list)):
                current_item = my_list[i]
                j = i
                while j >= gap and my_list[j - gap] > current_item:
                    my_list[j] = my_list[j - gap]
                    j -= gap
                my_list[j] = current_item
            gap //= 2

        return my_list
  original_instructions: |-
    sort the given array by using shell sort
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr: list) -> str:
      n = len(arr)
      mpis = arr[:]
      for i in range(n):
        current_prod = arr[i]
        j = i + 1
        while j < n:
          if arr[j-1] > arr[j]:
            break
          current_prod *= arr[j]
          if current_prod > mpis[j]:
            mpis[j] = current_prod
          j = j + 1
      return max(mpis)
  error: |-
    TypeError: '>' not supported between instances of 'int' and 'str'
  explanation: |-
    The function is supposed to return an integer (`int`), but the return type has been changed to a string (`str`). This will not cause a runtime error by itself, but it is incorrect according to the type hinting. However, the error message provided suggests that the actual runtime error is caused by trying to compare an integer and a string with the '>' operator, which is not allowed in Python. This implies that the input list `arr` contains both integers and strings, which is not handled by the code. The code assumes that all elements in `arr` are comparable with each other using the '>' operator, which is only true for elements of the same type.
  id: |-
    hubfix_mbpp_py_468
  lang: |-
    python
  original_code: |-
    def main(arr: list) -> int:
      n = len(arr)
      mpis = arr[:]
      for i in range(n):
        current_prod = arr[i]
        j = i + 1
        while j < n:
          if arr[j-1] > arr[j]:
            break
          current_prod *= arr[j]
          if current_prod > mpis[j]:
            mpis[j] = current_prod
          j = j + 1
      return max(mpis)
  original_instructions: |-
    find the maximum product formed by multiplying numbers of an increasing subsequence of that array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(N: str) -> int:
      return (N - 1)
  error: |-
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The function `main` is now expecting a parameter `N` of type `str` (string), but it tries to subtract an integer (`1`) from it. In Python, you cannot subtract an integer from a string, which causes a `TypeError`.
  id: |-
    hubfix_mbpp_py_89
  lang: |-
    python
  original_code: |-
    def main(N: int) -> int:
      return (N - 1)
  original_instructions: |-
    find the closest smaller number than n
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any
    import non_existent_library  # This library does not exist

    def main(test_list: List[List[Any]]) -> str:  # Changed return type to str
        res = len(list(set(tuple(sorted(sub)) for sub in test_list)))
        return res  # This should return an int, not str

    main([[1, 2], [2, 1], [3, 4]])
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        import non_existent_library  # This library does not exist
    ModuleNotFoundError: No module named 'non_existent_library'
  explanation: |-
    The code is broken because of two reasons:

    1. The script attempts to import a library named `non_existent_library`, which does not exist. Python raises a `ModuleNotFoundError` because it cannot find a module with that name.

    2. The `main` function is declared to return a string (`-> str`), but the actual return value is an integer (`res` is the length of a list, which is an integer). This would not cause a runtime error in Python, but it is a type hint inconsistency and would be flagged by static type checkers like `mypy`.
  id: |-
    hubfix_mbpp_py_400
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> int:
        res = len(list(set(tuple(sorted(sub)) for sub in test_list)))
        return res
  original_instructions: |-
    extract the number of unique tuples in the given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str_list: list, length: str) -> int:
        result = [e for e in str_list if len(e) == size]
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 3, in <module>
        result = [e for e in str_list if len(e) == size]
    NameError: name 'size' is not defined
  explanation: |-
    The code is broken for several reasons:
    - The parameter `length` is typed as a `str` (string) when it should be an `int` (integer).
    - The variable `size` is used in the list comprehension, but it is not defined anywhere in the code.
    - The return type of the function is incorrectly specified as `int` when it should be `list`.
  id: |-
    hubfix_mbpp_py_450
  lang: |-
    python
  original_code: |-
    def main(str_list: list, length: int) -> list:
        result = [e for e in str_list if len(e) == length]
        return result
  original_instructions: |-
    extract specified size of strings from a given list of string values
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from collections import nonexistentlibrary
    from typing import List, Tuple, Dict

    def main(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:
        temp: Dict[str, str] = defaultdict(int)
        for name, marks in stdata:
            temp[name] += marks
        return max(temp.items(), key=lambda x: x[1])
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library called 'nonexistentlibrary' from the 'collections' module, which does not exist. This causes a ModuleNotFoundError because Python cannot find the specified library within the 'collections' module or as a standalone module.
  id: |-
    hubfix_mbpp_py_299
  lang: |-
    python
  original_code: |-
    from collections import defaultdict
    from typing import List, Tuple, Dict

    def main(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:
        temp: Dict[str, int] = defaultdict(int)
        for name, marks in stdata:
            temp[name] += marks
        return max(temp.items(), key=lambda x: x[1])
  original_instructions: |-
    calculate the maximum aggregate from the list of tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(arr: List[str]) -> int:
        s = set(ara)
        return len(s) == "one"
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        s = set(ara)
    NameError: name 'ara' is not defined
  explanation: |-
    There are multiple issues with the code:

    1. The parameter type hint for `arr` has been changed from `List[int]` to `List[str]`, which is not necessarily a breaking change by itself but could lead to type-related issues if the function is expected to handle integers.
    2. The variable `ara` is used instead of `arr`, which is not defined anywhere in the code, leading to a `NameError`.
    3. The return type hint of the function has been changed from `bool` to `int`, which is incorrect because the function is returning a comparison result, which is a boolean value.
    4. The return statement is comparing the length of the set `s` to the string `"one"` instead of the integer `1`, which is a logical error and also a type mismatch since the `==` operator is being used to compare an integer with a string.
  id: |-
    hubfix_mbpp_py_760
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> bool:
        s = set(arr)
        return len(s) == 1
  original_instructions: |-
    check whether a list of numbers contains only one distinct element or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        if n == 1 or n == 2:
            return 1
        else:
            return main(main(n-1)) + main(n-main(n-1))
  error: |-
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `str` (string), but the operations inside the function treat `n` as if it were an `int` (integer). Specifically, the function attempts to subtract 1 from `n` (`n-1`), which is not a valid operation for strings and integers. This results in a `TypeError` because the `-` operator is not supported between instances of 'str' and 'int'.
  id: |-
    hubfix_mbpp_py_84
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        if n == 1 or n == 2:
            return 1
        else:
            return main(main(n-1)) + main(n-main(n-1))
  original_instructions: |-
    find the nth number in the newman conway sequence
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(my_matrix: List[List[str]]) -> int:
        iSize = len(my_matrix[0])
        sum_list = []
        sum_list.extend([sum(lines) for lines in my_matrix])
        for col in range(iSize):
            sum_list.append(sum(row[col] for row in my_matrix))
        result1 = 0
        for i in range(0, iSize):
            result1 += my_matrix[i][i]
        sum_list.append(result1)
        result2 = 0
        for i in range(iSize-1, -1, -1):
            result2 += my_matrix[i][iSize - 1 - i]
        sum_list.append(result2)
        if len(set(sum_list)) > 1:
            return False
        return 42
  error: |-
    TypeError: unsupported operand type(s) for +: 'int' and 'str'
  explanation: |-
    The code is broken because of two changes:

    1. The type of the elements in `my_matrix` was changed from `List[List[int]]` to `List[List[str]]`. This means that the `sum()` function is now trying to add strings instead of integers, which will cause a `TypeError` when the `sum()` function is called on a list of strings.

    2. The return type of the function was changed from `bool` to `int`. The function is supposed to return a boolean value (`True` or `False`), but the broken code returns the integer `42` when the condition `len(set(sum_list)) <= 1` is met. This is inconsistent with the function's signature and intended behavior, but it will not cause a runtime error. However, it is still a logical error because the function's return type in the signature does not match the actual return type in the code.
  id: |-
    hubfix_mbpp_py_129
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(my_matrix: List[List[int]]) -> bool:
        iSize = len(my_matrix[0])
        sum_list = []
        sum_list.extend([sum(lines) for lines in my_matrix])
        for col in range(iSize):
            sum_list.append(sum(row[col] for row in my_matrix))
        result1 = 0
        for i in range(0, iSize):
            result1 += my_matrix[i][i]
        sum_list.append(result1)
        result2 = 0
        for i in range(iSize-1, -1, -1):
            result2 += my_matrix[i][iSize - 1 - i]
        sum_list.append(result2)
        if len(set(sum_list)) > 1:
            return False
        return True
  original_instructions: |-
    calculate whether the matrix is a magic square
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: str, b: float) -> float:
        if a <= b:
            return a
        else:
            return x
  error: |-
    Traceback (most recent call last):
      File "script.py", line 3, in <module>
        if a <= b:
    TypeError: '<=' not supported between instances of 'str' and 'float'
  explanation: |-
    The code is broken because of two issues:

    1. The type of parameter `a` has been changed from `float` to `str`, which is incorrect because the comparison operator `<=` is not supported between instances of `str` and `float`. This results in a `TypeError`.

    2. The variable `x` is returned in the `else` block, but it is not defined anywhere in the code. This would result in a `NameError` if the `TypeError` was not encountered first.
  id: |-
    hubfix_mbpp_py_404
  lang: |-
    python
  original_code: "def main(a: float, b: float) -> float:\n    if a <= b:\n       \
    \ return a\n    else:\n        return b "
  original_instructions: |-
    find the minimum of two numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    from typing import List, Any

    def main(a: List[Any], x: Any) -> str:
        return bisect.bisect_left(y, x)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named 'nonexistentlibrary', which does not exist. Additionally, the function `bisect.bisect_left` is called with `y` as the first argument, but `y` is not defined anywhere in the code. Lastly, the return type of the function `main` is changed to `str`, but `bisect.bisect_left` returns an integer, not a string.
  id: |-
    hubfix_mbpp_py_786
  lang: |-
    python
  original_code: |-
    import bisect
    from typing import List, Any

    def main(a: List[Any], x: Any) -> int:
        return bisect.bisect_right(a, x)
  original_instructions: |-
    locate the right insertion point for a specified value in sorted order
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib
    from typing import Optional, Match

    regex = '^[aeiouAEIOU][A-Za-z0-9_]*'

    def main(string: int) -> Optional[Match[str]]:
        return re.search(regex, string)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library named `nonexistentlib`, which does not exist. This will cause a `ModuleNotFoundError` when the script is run. Additionally, the `main` function is expecting an integer as its parameter due to the change in the type hint from `str` to `int`, but `re.search` expects a string pattern and a string to search within. This would cause a `TypeError` if the `ModuleNotFoundError` was resolved and the code reached the point of calling `re.search`.
  id: |-
    hubfix_mbpp_py_737
  lang: |-
    python
  original_code: |-
    import re
    from typing import Optional, Match

    regex = '^[aeiouAEIOU][A-Za-z0-9_]*'

    def main(string: str) -> Optional[Match[str]]:
        return re.search(regex, string)
  original_instructions: |-
    check whether the given string is starting with a vowel or not using regex
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        res = list()
        res.append(0)
        res.append(1)
        i = 2
        while i < n + 1:
            res.append(max(i, (res[int(i / 2)]
                            + res[int(i / 3)] +
                                res[int(i / 4)]
                            + res[int(i / 5)])))
            i = i + 1
        return res[n]
  error: |-
    TypeError: '<' not supported between instances of 'int' and 'str'
  explanation: |-
    The code is broken because the parameter `n` is now expected to be a string (`n: str`) instead of an integer (`n: int`). The while loop condition `i < n + 1` attempts to compare an integer `i` with a string `n`, which is not allowed in Python and results in a `TypeError`. Additionally, the return statement `return res[n]` will also fail because `n` is a string and cannot be used to index a list, which expects an integer index.
  id: |-
    hubfix_mbpp_py_392
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        res = list()
        res.append(0)
        res.append(1)
        i = 2
        while i < n + 1:
            res.append(max(i, (res[int(i / 2)]
                            + res[int(i / 3)] +
                                res[int(i / 4)]
                            + res[int(i / 5)])))
            i = i + 1
        return res[n]
  original_instructions: |-
    find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib
    from typing import List, Tuple, Any

    def main_function_changed(tuple_list: List[Tuple[Any, ...]]) -> str:
        return sys.getsize(tuple_list)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken for several reasons:
    1. The script attempts to import a library called 'nonexistentlib', which does not exist.
    2. The name of the main function has been changed from 'main' to 'main_function_changed'.
    3. The function 'sys.getsize' does not exist; the correct function name is 'sys.getsizeof'.
    4. The return type of the function has been changed from 'int' to 'str', which is incorrect because 'sys.getsizeof' returns an integer, not a string.
  id: |-
    hubfix_mbpp_py_596
  lang: |-
    python
  original_code: |-
    import sys
    from typing import List, Tuple, Any

    def main(tuple_list: List[Tuple[Any, ...]]) -> int:
        return sys.getsizeof(tuple_list)
  original_instructions: |-
    find the size in bytes of the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: "def main(arr: list) -> str:\n    n = len(arr)\n    minEle = arr[0]\n\
    \    maxEle = arr[0]\n    for i in range(1, n):\n        minEle = min(minEle,\
    \ arr[i])\n        maxEle = max(maxEle, arr[i])\n    return (maxEle - minEle) "
  error: |-
    TypeError: unsupported operand type(s) for -: 'int' and 'int'
  explanation: |-
    The function is declared to return a string (`-> str`), but the actual return value is the result of subtracting two integers (`maxEle - minEle`). This is a type mismatch, as the function should return a string according to its type hint, but it is returning an integer instead. The error message is slightly misleading because it suggests that the subtraction operation is not supported for integers, which is not true. The actual issue is the type mismatch between the return type hint and the returned value.
  id: |-
    hubfix_mbpp_py_145
  lang: |-
    python
  original_code: "def main(arr: list) -> int:\n    n = len(arr)\n    minEle = arr[0]\n\
    \    maxEle = arr[0]\n    for i in range(1, n):\n        minEle = min(minEle,\
    \ arr[i])\n        maxEle = max(maxEle, arr[i])\n    return (maxEle - minEle) "
  original_instructions: |-
    find the maximum difference between any two elements in a given array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(h_age: str) -> float:
        if h_age < 0:
            exit()
        elif h_age <= 2:
            d_age = h_age * 10.5
        else:
            d_age = 21 + (h_age - 2) * 4
        return d_age

    main("five")
  error: |-
    TypeError: '<' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is defined to take a parameter `h_age` of type `str` instead of `float`, which is incorrect as the function is performing arithmetic operations that are not supported for strings. Additionally, the function is called with a string argument `"five"`, which cannot be compared to or subtracted from integers, nor can it be multiplied by a float, leading to a `TypeError`.
  id: |-
    hubfix_mbpp_py_264
  lang: |-
    python
  original_code: |-
    def main(h_age: float) -> float:
        if h_age < 0:
            exit()
        elif h_age <= 2:
            d_age = h_age * 10.5
        else:
            d_age = 21 + (h_age - 2) * 4
        return d_age
  original_instructions: |-
    calculate a dog's age in dog's years
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(dict: dict[int, str]) -> float:
      sum = 0
      for i in dict.values():
        sum = sum + i
      return sum
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 4, in <module>
    TypeError: unsupported operand type(s) for +: 'int' and 'str'
  explanation: |-
    The code is broken because the type hint for the `dict` parameter has been changed from `dict[int, int]` to `dict[int, str]`, which means that the dictionary is expected to have `int` keys and `str` values. However, the function tries to add the string values to an integer (`sum`), which is not allowed in Python and results in a `TypeError`. Additionally, the return type of the function has been changed to `float`, but the function still returns an integer sum, which is not necessarily a breaking change but is misleading.
  id: |-
    hubfix_mbpp_py_796
  lang: |-
    python
  original_code: |-
    def main(dict: dict[int, int]) -> int:
      sum = 0
      for i in dict.values():
        sum = sum + i
      return sum
  original_instructions: |-
    Write function to find the sum of all items in the given dictionary
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str, m: int) -> int:
        q = n // m
        return q

    main("100", 10)
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 4, in <module>
      File "<stdin>", line 2, in main
    TypeError: unsupported operand type(s) for //: 'str' and 'int'
  explanation: |-
    The code is broken because the `main` function expects the first parameter `n` to be an integer, as indicated by the type hint `int`, but a string `"100"` is passed instead. The floor division operator `//` is not supported between a string and an integer, which causes a `TypeError`.
  id: |-
    hubfix_mbpp_py_292
  lang: |-
    python
  original_code: |-
    def main(n: int, m: int) -> int:
        q = n // m
        return q
  original_instructions: |-
    find quotient of two numbers (rounded down to the nearest integer)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(number: str) -> tuple:
        total = 0
        for value in range(1, number + 1):
            total = total + value
        average = total / num
        return (total, average)
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 4, in <module>
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The code is broken because of two issues:

    1. The `number` parameter is now expected to be a string (`number: str`), which is incorrect because the `range` function requires an integer, not a string. This will cause a TypeError when trying to use a string in a context where an integer is expected.

    2. The variable `num` used in the calculation of `average` is not defined anywhere in the code. The correct variable should be `number`. This would cause a NameError if the TypeError was not already present.
  id: |-
    hubfix_mbpp_py_599
  lang: |-
    python
  original_code: |-
    def main(number: int) -> tuple:
        total = 0
        for value in range(1, number + 1):
            total = total + value
        average = total / number
        return (total, average)
  original_instructions: |-
    find sum and average of first n natural numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def pancake_sort(nums: List[str]) -> List[int]:
        arr_len = len(nums)
        while arr_len > 1:
            mi = nums.index(max(nums[0:arr_len]))
            nums = nums[mi::-1] + nums[mi+1:len(nums)]
            nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]
            arr_len -= 1
        return nums
  error: |-
    TypeError: '>' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `pancake_sort` is supposed to take a list of integers as its parameter, as indicated by the type hint `List[int]`. However, the type hint for the `nums` parameter has been changed to `List[str]`, which means it now expects a list of strings. The `max` function is used on a slice of this list, which will cause a `TypeError` when it tries to compare string elements as if they were integers. Since strings cannot be compared with integers using the '>' operator, the code will break when trying to find the maximum value in a list of strings.
  id: |-
    hubfix_mbpp_py_141
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        arr_len = len(nums)
        while arr_len > 1:
            mi = nums.index(max(nums[0:arr_len]))
            nums = nums[mi::-1] + nums[mi+1:len(nums)]
            nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]
            arr_len -= 1
        return nums
  original_instructions: |-
    sort a list of elements
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from copy import deepcopy
    from typing import Tuple, List, Any

    def main(tuplex: Tuple[List[Any], ...], m: int, n: Any) -> Tuple[List[Any], ...]:
        tuplex_colon = deepcopy(tuplex)
        tuplex_colon[m].extend(n)
        return tuplex_colon
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        main((['a', 'b'], ['c', 'd']), 0, 'e')
      File "script.py", line 5, in main
        tuplex_colon[m].extend(n)
    TypeError: 'str' object is not iterable
  explanation: |-
    The `extend` method expects an iterable (like a list or a tuple), but in the broken code, it is being passed a string (`n`). Since strings are iterable, if `n` is a single character string, it will be treated as an iterable of that single character, but if `n` is a multi-character string, it will be treated as an iterable of its characters, which might not be the intended behavior. To maintain the original functionality, `append` should be used instead of `extend` to add the single item `n` to the list at index `m` in the tuple `tuplex_colon`.
  id: |-
    hubfix_mbpp_py_307
  lang: |-
    python
  original_code: |-
    from copy import deepcopy
    from typing import Tuple, List, Any

    def main(tuplex: Tuple[List[Any], ...], m: int, n: Any) -> Tuple[List[Any], ...]:
        tuplex_colon = deepcopy(tuplex)
        tuplex_colon[m].append(n)
        return tuplex_colon
  original_instructions: |-
    get a colon of a tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_list: list, test_str: int) -> tuple:
      return tuple(test_list + [test_num])
  error: |-
    NameError: name 'test_num' is not defined
  explanation: |-
    The code is broken because of two issues:

    1. The parameter `test_str` is annotated as an `int`, but the function is expecting a string to concatenate with the list. This could cause a type error if a string is not passed, but this is not the immediate cause of the breakage.

    2. Inside the function, `test_num` is used instead of `test_str`. Since `test_num` is not defined anywhere in the code, this results in a `NameError` when the function tries to use it.
  id: |-
    hubfix_mbpp_py_788
  lang: |-
    python
  original_code: |-
    def main(test_list: list, test_str: str) -> tuple:
      return tuple(test_list + [test_str])
  original_instructions: |-
    create a new tuple from the given string and list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple

    def main(test_list: List, test_tup: Tuple) -> List:
        res = tuple(list(test_tup) + test_list)
        return res[0]
  error: |-
    TypeError: 'int' object is not iterable
  explanation: |-
    The function `main` is supposed to return a `Tuple`, but the return type was changed to `List`. Additionally, the function now attempts to return `res[0]`, which is the first element of the tuple `res`. If `res[0]` is an integer (or any non-iterable), trying to convert it to a tuple with `tuple(res[0])` will raise a `TypeError` because an integer is not iterable. The error message assumes that `res[0]` is indeed an integer, which would be the case if `test_list` and `test_tup` contained integers.
  id: |-
    hubfix_mbpp_py_106
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple

    def main(test_list: List, test_tup: Tuple) -> Tuple:
        res = tuple(list(test_tup) + test_list)
        return res
  original_instructions: |-
    append the given list to the given tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[str]) -> int:
        return all(nums[i] % 2 == i % 2 for i in range(len(nums)))
  error: |-
    Traceback (most recent call last):
      File "script.py", line 4, in <module>
        main(["1", "2", "3"])
      File "script.py", line 3, in main
        return all(nums[i] % 2 == i % 2 for i in range(len(nums)))
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the `main` function now expects a list of strings (`List[str]`) instead of a list of integers (`List[int]`). The `%` operator is used for modulo operations with integers, but when applied to a string, Python tries to perform string formatting, which is not the intended operation and causes a `TypeError`. Additionally, the return type of the function has been changed to `int`, but the function still returns a boolean value, which is inconsistent with the declared return type.
  id: |-
    hubfix_mbpp_py_775
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> bool:
        return all(nums[i] % 2 == i % 2 for i in range(len(nums)))
  original_instructions: |-
    check whether every odd index contains odd numbers of a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_tup: tuple[int, ...]) -> tuple[str, ...]:
        res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))
        return res
  error: |-
    TypeError: unsupported operand type(s) for +: 'int' and 'int'
  explanation: |-
    The function is declared to return a tuple of strings (`tuple[str, ...]`), but the actual return value is a tuple of integers, as the result of adding integers together. The error message is a bit misleading because it suggests that the operation inside the tuple comprehension is not supported, but the real issue is the mismatch between the declared return type and the actual return type.
  id: |-
    hubfix_mbpp_py_470
  lang: |-
    python
  original_code: |-
    def main(test_tup: tuple[int, ...]) -> tuple[int, ...]:
        res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))
        return res
  original_instructions: |-
    find the pairwise addition of the neighboring elements of the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: int, b: str) -> list:
        lists = []
        for i in range(a, b+1):
            j = 1
            while j*j <= i:
                if j*j == i:
                    lists.append(i)
                j = j+1
        return lists
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The code is broken because the type of the parameter `b` has been changed from `int` to `str`. The `range` function expects integer arguments, but because `b` is now a string, the expression `b+1` attempts to concatenate an integer (`1`) to a string (`b`), which is not allowed in Python and results in a `TypeError`.
  id: |-
    hubfix_mbpp_py_589
  lang: |-
    python
  original_code: |-
    def main(a: int, b: int) -> list:
        lists = []
        for i in range(a, b+1):
            j = 1
            while j*j <= i:
                if j*j == i:
                    lists.append(i)
                j = j+1
        return lists
  original_instructions: |-
    find perfect squares between two given numbers
  resource_type: null
  resource_type_def: null
- broken_code: "def fibonacci(n: str) -> int:\n    if (n == 0):\n        return 2\n\
    \    if (n == 'one'):\n        return 1\n    return fibonacci(n - 1) + fibonacci(n\
    \ / 2) "
  error: |-
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The code is broken because the parameter `n` is now expected to be a string (`n: str`), but the function is being used as if `n` were an integer (e.g., `n - 1` and `n / 2`). Additionally, the comparison `n == 0` will never be true because `n` is a string and cannot be equal to an integer. The string comparison `n == 'one'` is also incorrect because it should be compared with an integer `1` instead of the string `'one'`. The recursive calls to `fibonacci(n - 1)` and `fibonacci(n / 2)` will fail because arithmetic operations are being attempted on a string and an integer, which is not allowed in Python.
  id: |-
    hubfix_mbpp_py_389
  lang: |-
    python
  original_code: "def main(n: int) -> int:\n    if (n == 0):\n        return 2\n \
    \   if (n == 1):\n        return 1\n    return main(n - 1) + main(n - 2) "
  original_instructions: |-
    find the n'th lucas number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: int) -> str:
        vowels = ""
        for char in str1:
            if char in "aeiouAEIOU":
                vowels += char
        result_string = ""
        for char in str1:
            if char in "aeiouAEIOU":
                result_string += vowels[-1]
                vowels = vowels[:-1]
            else:
                result_string += char
        return result_string

    main(123)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 14, in <module>
        main(123)
      File "script.py", line 4, in main
        for char in str1:
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken because the `main` function is defined to take an integer (`int`) as its parameter `str1`, but it should take a string (`str`). The `for` loop attempts to iterate over `str1`, which is not possible if `str1` is an integer, as integers are not iterable. This results in a `TypeError` when the function is called with an integer argument. Additionally, the function is called with an integer (`main(123)`), which is not the expected string type for the parameter `str1`.
  id: |-
    hubfix_mbpp_py_131
  lang: |-
    python
  original_code: |-
    def main(str1: str) -> str:
        vowels = ""
        for char in str1:
            if char in "aeiouAEIOU":
                vowels += char
        result_string = ""
        for char in str1:
            if char in "aeiouAEIOU":
                result_string += vowels[-1]
                vowels = vowels[:-1]
            else:
                result_string += char
        return result_string
  original_instructions: |-
    reverse only the vowels of a given string (where y is not a vowel)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr: list[str]) -> str:
        total = 0
        for i in range(0, len(arr), 2):
            if (arr[i] % 2 == 0):
                total += arr[i]
        return total
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        if (arr[i] % 2 == 0):
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because of the following reasons:

    1. The function parameter `arr` is now expected to be a list of strings (`list[str]`), but the function body is treating the elements as integers (e.g., `arr[i] % 2 == 0`).
    2. The return type of the function is changed to `str`, but the function is still returning an integer (`total`).
    3. The variable `sum` is renamed to `total`, but the return statement still uses the old name `sum`.

    The error message indicates that the `%` operator is being used on a string, which is not valid in this context. The `%` operator can be used for string formatting, but here it is intended to be used as a modulo operator, which is not applicable to strings.
  id: |-
    hubfix_mbpp_py_270
  lang: |-
    python
  original_code: |-
    def main(arr: list[int]) -> int:
        sum = 0
        for i in range(0, len(arr), 2):
            if (arr[i] % 2 == 0):
                sum += arr[i]
        return sum
  original_instructions: |-
    find the sum of even numbers at even positions of a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i - 1] + 2 * dp[i - 2]
        return dp[n]

    main("five")
  error: |-
    TypeError: can't multiply sequence by non-int of type 'str'
  explanation: |-
    The function `main` is defined to take an integer `n` as its parameter, but the code has been modified to expect a string instead (`n: str`). When the function is called with the string "five", it attempts to perform the operation `[0] * (n + 1)`, which tries to multiply a list by a string, causing a TypeError. Additionally, even if the multiplication were to work, indexing the list `dp` with a string would also cause a TypeError.
  id: |-
    hubfix_mbpp_py_752
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i - 1] + 2 * dp[i - 2]
        return dp[n]
  original_instructions: |-
    find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ..
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any, Tuple

    def main(list1: List[int]) -> Tuple[int, Any]:
        main_value = max(len(x) for x in list1)
        max_list = max(list1, key=len)
        return (main_value, max_list)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main_value = max(len(x) for x in list1)
      File "script.py", line 6, in <genexpr>
        main_value = max(len(x) for x in list1)
    TypeError: object of type 'int' has no len()
  explanation: |-
    The code is broken because the type hint for the parameter `list1` was changed from `List[Any]` to `List[int]`. This implies that `list1` should contain integers, but the function tries to call `len(x)` on the elements of `list1`, which will fail if the elements are indeed integers because integers do not have a length. The `len` function can only be called on objects that have a defined length, such as strings, lists, tuples, etc., not on integers.
  id: |-
    hubfix_mbpp_py_290
  lang: |-
    python
  original_code: |-
    from typing import List, Any, Tuple

    def main(list1: List[Any]) -> Tuple[int, Any]:
        main_value = max(len(x) for x in list1)
        max_list = max(list1, key=len)
        return (main_value, max_list)
  original_instructions: |-
    find the list of maximum length in a list of lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[str]) -> List[int]:
        main = list(map(lambda x: x ** 3, nums))
        return main
  error: |-
    TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
  explanation: |-
    The function `main` is now expecting a list of strings (`List[str]`) as its parameter instead of a list of integers (`List[int]`). However, the lambda function inside the `map` call is trying to raise a string to the power of 3, which is not a valid operation in Python. Strings cannot be exponentiated with integers, hence the `TypeError` is raised.
  id: |-
    hubfix_mbpp_py_447
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        main = list(map(lambda x: x ** 3, nums))
        return main
  original_instructions: |-
    find cubes of individual elements in a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from nonexistentlibrary import array
    def main(nums: list) -> float:
        n = len(nums)
        n1 = 0
        for x in nums:
            if x > 0:
                n1 += 1
            else:
              None
        return round(n1/n,2)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a module named 'nonexistentlibrary' which does not exist in the Python standard library or in the installed third-party libraries. This causes a `ModuleNotFoundError` to be raised when the script is run.
  id: |-
    hubfix_mbpp_py_442
  lang: |-
    python
  original_code: |-
    from array import array
    def main(nums: array) -> float:
        n = len(nums)
        n1 = 0
        for x in nums:
            if x > 0:
                n1 += 1
            else:
              None
        return round(n1/n,2)
  original_instructions: |-
    find the ration of positive numbers in an array of integers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: list, n: str, k: int) -> int:
        max_so_far = -2147483648
        max_ending_here = 0
        for i in range(n*k):
            max_ending_here = max_ending_here + a[i % n]
            if (max_so_far < max_ending_here):
                max_so_far = max_ending_here
            if (max_ending_here < 0):
                max_ending_here = 0
        return max_so_far
  error: |-
    TypeError: can't multiply sequence by non-int of type 'str'
  explanation: |-
    The code is broken because the type of the parameter `n` has been changed from `int` to `str`. The `range` function expects an integer as its argument, but because `n` is now a string, the expression `n*k` causes a `TypeError` since you cannot multiply a string by an integer in this context.
  id: |-
    hubfix_mbpp_py_286
  lang: |-
    python
  original_code: |-
    def main(a: list, n: int, k: int) -> int:
        max_so_far = -2147483648
        max_ending_here = 0
        for i in range(n*k):
            max_ending_here = max_ending_here + a[i % n]
            if (max_so_far < max_ending_here):
                max_so_far = max_ending_here
            if (max_ending_here < 0):
                max_ending_here = 0
        return max_so_far
  original_instructions: |-
    find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s: int) -> bool:
        words = s.splt(' ')
        for word in words:
            if len(word) % 2 != 0:
                return True
        return False
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        words = s.splt(' ')
    AttributeError: 'int' object has no attribute 'splt'
  explanation: |-
    The code is broken for two reasons:

    1. The parameter `s` is expected to be an `int` due to the type hint `s: int`, but the function is designed to work with a string, as it attempts to call the `split` method, which is a string method. This will cause a type error if an integer is passed to the function.

    2. There is a typo in the method name; it should be `split` instead of `splt`. This typo leads to an AttributeError because the `int` object does not have a `splt` method, and even if `s` were a string, the correct method name is `split`.
  id: |-
    hubfix_mbpp_py_79
  lang: |-
    python
  original_code: |-
    def main(s: str) -> bool:
        words = s.split(' ')
        for word in words:
            if len(word) % 2 != 0:
                return True
        return False  # Moved outside the loop to check all words before returning False
  original_instructions: |-
    check whether the length of the word is odd or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(dict1: list) -> dict:
      dict1 = {key: value for (key, value) in dict1.items() if value is not None}
      return dict1

    main([1, 2, 3])
  error: |-
    AttributeError: 'list' object has no attribute 'items'
  explanation: |-
    The code is broken because the `main` function is expecting a dictionary as its parameter, as indicated by the type hint `dict1: dict`, but the type hint has been incorrectly changed to `dict1: list`. When the function is called with a list `[1, 2, 3]`, it tries to call the `.items()` method on the list, which does not exist. Lists in Python do not have an `items` method; this method is specific to dictionaries. Therefore, an AttributeError is raised.
  id: |-
    hubfix_mbpp_py_465
  lang: |-
    python
  original_code: |-
    def main(dict1: dict) -> dict:
      dict1 = {key: value for (key, value) in dict1.items() if value is not None}
      return dict1
  original_instructions: |-
    drop empty items from a given dictionary
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(stringlist: List[int]) -> List[int]:
        result = [x[::-1] for x in stringlist]
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main(["hello", "world"])
      File "script.py", line 4, in main
        result = [x[::-1] for x in stringlist]
    TypeError: 'int' object is not subscriptable
  explanation: |-
    The code is broken because the function `main` is now expecting a list of integers (`List[int]`) as its parameter, but the slicing operation `x[::-1]` is being applied to the elements of `stringlist`, which would only work if they were strings. Since integers cannot be sliced like strings, a `TypeError` is raised when the function tries to perform the slicing operation on an integer. The function should have kept the parameter type as `List[str]` to work correctly with string slicing.
  id: |-
    hubfix_mbpp_py_456
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(stringlist: List[str]) -> List[str]:
        result = [x[::-1] for x in stringlist]
        return result
  original_instructions: |-
    reverse each string in a given list of string values
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    def main(r: float) -> float:
      surfacearea = 4 * math.circle * r * r
      return surfacearea
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, the code tries to use 'math.circle', which is not a valid attribute of the 'math' module. The correct attribute should be 'math.pi'.
  id: |-
    hubfix_mbpp_py_85
  lang: |-
    python
  original_code: |-
    import math
    def main(r: float) -> float:
      surfacearea = 4 * math.pi * r * r
      return surfacearea
  original_instructions: |-
    find the surface area of a sphere
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def calculate_volume(r: str, h: float) -> float:
      volume = 3.1415 * radius * radius * height
      return vol
  error: |-
    NameError: name 'radius' is not defined
  explanation: |-
    The code is broken because of the following reasons:
    - The parameter `r` is expected to be a float, but it has been changed to a string type (`r: str`), which would cause a TypeError if a string was passed when calling the function.
    - The variable `radius` is used in the calculation of `volume`, but it is not defined anywhere in the function. The correct variable name should be `r`.
    - Similarly, `height` is used instead of the correct parameter `h`.
    - The return statement references `vol`, which is not defined. The correct variable name is `volume`.
  id: |-
    hubfix_mbpp_py_276
  lang: |-
    python
  original_code: |-
    def main(r: float, h: float) -> float:
      volume = 3.1415 * r * r * h
      return volume
  original_instructions: |-
    takes in the radius and height of a cylinder and returns the the volume
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(arr: List[str]) -> int:
        arr.sort()
        sum = arr[0]
        for i in range(len(arr)-1):
            if (arr[i] != arr[i+1]):
                sum = sum + arr[i+1]
        return sum

    main([1, 2, 3])
  error: |-
    TypeError: '<' not supported between instances of 'int' and 'str'
  explanation: |-
    The function `main` is defined to take a list of strings (`List[str]`) as its parameter, but it is called with a list of integers (`[1, 2, 3]`). This causes a type mismatch, and since the function tries to sort the array and perform addition on its elements, it expects them to be of a type that supports these operations. In Python, you cannot compare or add integers and strings, which leads to a `TypeError` when the script is run.
  id: |-
    hubfix_mbpp_py_777
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        arr.sort()
        sum = arr[0]
        for i in range(len(arr)-1):
            if (arr[i] != arr[i+1]):
                sum = sum + arr[i+1]
        return sum
  original_instructions: |-
    find the sum of non-repeated elements in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(numbers: List[str]) -> List[int]:
        od_li = []
        for i in numbers:
            if (i % 2 != 0):
                od_li.append(i)
        return od_li

    main([1, 2, 3, 'four', 5])
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main([1, 2, 3, 'four', 5])
      File "script.py", line 6, in main
        if (i % 2 != 0):
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the `main` function is now expecting a list of strings (`List[str]`) as its parameter, but it is being called with a list that contains both integers and a string (`[1, 2, 3, 'four', 5]`). The `%` operator is not defined for strings, so when it tries to calculate `i % 2` for the string `'four'`, it raises a `TypeError`. The function should expect a list of integers (`List[int]`) and should not be called with a string in the list.
  id: |-
    hubfix_mbpp_py_554
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(numbers: List[int]) -> List[int]:
        od_li = []
        for i in numbers:
            if (i % 2 != 0):
                od_li.append(i)
        return od_li
  original_instructions: |-
    Write a python function which takes a list of integers and only returns the odd ones
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> float:
        if n < 2:
            return 1.0
        else:
            return 1 / n + (main(n - 1))
  error: |-
    TypeError: '<' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is now expecting a parameter `n` of type `str` (string), but it is being used as if it were an `int` (integer) in the comparison `n < 2` and in the arithmetic operation `1 / n` and `n - 1`. Since these operations are not valid for strings, the code will raise a `TypeError` when it tries to compare a string with an integer or perform arithmetic operations on a string.
  id: |-
    hubfix_mbpp_py_248
  lang: |-
    python
  original_code: |-
    def main(n: int) -> float:
        if n < 2:
            return 1.0
        else:
            return 1 / n + (main(n - 1))
  original_instructions: |-
    takes in an integer n and calculates the harmonic sum of n-1
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(maines: list) -> str:
      maines = list(filter(lambda el: el[0].isupper() and el[1:].islower(), maines))
      return len(''.join(maines))
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        result = main(["Hello", "world"])
      File "script.py", line 3, in main
        return len(''.join(maines))
    TypeError: 'int' object is not iterable
  explanation: |-
    The return type of the function `main` was changed from `int` to `str`, but the function still returns an integer value from the `len` function. This is a type hint error and would not actually cause the code to break at runtime, but it is incorrect according to the type hints provided. The error message provided is incorrect because it suggests a runtime error that would not occur due to the type hint change. The correct error message would be a type hint warning, not a runtime exception. However, if the code were to be checked by a static type checker like `mypy`, it would report an error due to the mismatch between the return type hint and the actual return type.
  id: |-
    hubfix_mbpp_py_639
  lang: |-
    python
  original_code: |-
    def main(maines: list) -> int:
      maines = list(filter(lambda el: el[0].isupper() and el[1:].islower(), maines))
      return len(''.join(maines))
  original_instructions: |-
    sum the length of the names of a given list of names after removing the names that start with a lowercase letter
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[float]) -> List[str]:
        shrink_fact = 1.3
        gaps = len(nums)
        swapped = True
        i = 0
        while gaps > 1 or swapped:
            gaps = int(float(gaps) / shrink_fact)
            swapped = False
            i = 0
            while gaps + i < len(nums):
                if nums[i] > nums[i+gaps]:
                    nums[i], nums[i+gaps] = nums[i+gaps], nums[i]
                    swapped = True
                i += 1
        return nums
  error: |-
    TypeError: 'int' object is not subscriptable
  explanation: |-
    The code is broken because the return type of the function `main` is declared as `List[str]`, which means it should return a list of strings. However, the function is actually returning `nums`, which is a list of floats. This type mismatch between the declared return type and the actual return type will cause a runtime error if type checking is enforced.

    Additionally, the error message "TypeError: 'int' object is not subscriptable" would occur if the code were to be run and the list `nums` were to be passed an integer instead of a list of floats. However, this specific error message would not be triggered by the code as it is currently written, because the code does not attempt to subscript an integer. The error message provided does not match the breaking change introduced in the code. The actual error that would occur would be a type checking error, not a TypeError related to subscripting.
  id: |-
    hubfix_mbpp_py_71
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[float]) -> List[float]:
        shrink_fact = 1.3
        gaps = len(nums)
        swapped = True
        i = 0
        while gaps > 1 or swapped:
            gaps = int(float(gaps) / shrink_fact)
            swapped = False
            i = 0
            while gaps + i < len(nums):
                if nums[i] > nums[i+gaps]:
                    nums[i], nums[i+gaps] = nums[i+gaps], nums[i]
                    swapped = True
                i += 1
        return nums
  original_instructions: |-
    sort a list of elements
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[str, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup3))
        return res
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main(((1, 2), (3, 4)), ((5, 6), (7, 8)))
      File "script.py", line Y, in main
        for tup1, tup2 in zip(test_tup1, test_tup3))
    NameError: name 'test_tup3' is not defined
  explanation: |-
    The code is broken because of two issues:

    1. The type hint for `test_tup2` has been changed from `Tuple[Tuple[int, ...], ...]` to `Tuple[Tuple[str, ...], ...]`, which is incorrect because the function is supposed to compare integers using the `max` function. If `test_tup2` contains strings, the `max` function will raise a `TypeError` because it cannot compare integers and strings.

    2. Inside the list comprehension, `test_tup3` is used, but it is not defined anywhere in the code. The correct variable name should be `test_tup2`, which is the parameter passed to the function. Using an undefined variable `test_tup3` results in a `NameError`.
  id: |-
    hubfix_mbpp_py_259
  lang: |-
    python
  original_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    maximize the given two tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary as ct
    from typing import Dict, Any

    def main(dict1: Dict[Any, Any], dict2: Dict[Any, Any], dict3: Dict[Any, Any]) -> Dict[Any, Any]:
        merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))
        return merged_dict

    main({"a": 1}, {"b": 2}, {"c": 3})
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary` which does not exist in the Python standard library or as a third-party package. Since Python cannot find a module with this name, it raises a `ModuleNotFoundError`.
  id: |-
    hubfix_mbpp_py_87
  lang: |-
    python
  original_code: |-
    import collections as ct
    from typing import Dict, Any

    def main(dict1: Dict[Any, Any], dict2: Dict[Any, Any], dict3: Dict[Any, Any]) -> Dict[Any, Any]:
        merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))
        return merged_dict
  original_instructions: |-
    merge three dictionaries into a single dictionary
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        if n == 0 or n == 1:
            return 1
        return 2 * main(n - 1) + main(n - 2)
  error: |-
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `str` (string), but the operations inside the function treat `n` as if it were an integer (subtracting 1 and 2 from it). Python does not support subtracting an integer from a string, which leads to a `TypeError`.
  id: |-
    hubfix_mbpp_py_260
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        if n == 0 or n == 1:
            return 1
        return 2 * main(n - 1) + main(n - 2)
  original_instructions: "find the nth newman\u2013shanks\u2013williams prime number"
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[str]) -> List[int]:
        return [i for i in nums if nums.calculate(i) == 1]
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main(["1", "2", "3"])
      File "script.py", line 4, in main
        return [i for i in nums if nums.calculate(i) == 1]
    AttributeError: 'list' object has no attribute 'calculate'
  explanation: |-
    The code is broken for two reasons:

    1. The `main` function's parameter `nums` is now incorrectly typed as `List[str]` instead of `List[int]`. This change does not match the intended use of the function, which is to process a list of integers.

    2. Inside the list comprehension, the method `calculate` is called on the `nums` list object (`nums.calculate(i)`). However, the `list` class in Python does not have a method named `calculate`, resulting in an AttributeError when the code is executed.
  id: |-
    hubfix_mbpp_py_572
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        return [i for i in nums if nums.count(i) == 1]
  original_instructions: |-
    remove duplicate numbers from a given number of lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        return len([i for i in range(1, n+1) if n % i == 0])
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The function `main` is now expecting a parameter `n` of type `str` (string) instead of `int` (integer). Inside the list comprehension, it tries to use the `+` operator to add `1` to `n`, which is not valid because `n` is a string and `1` is an integer. Additionally, the modulo operation `n % i` is also invalid because `n` is a string and `i` is an integer. The code will raise a `TypeError` because these operations are not supported between instances of 'str' and 'int'.
  id: |-
    hubfix_mbpp_py_96
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        return len([i for i in range(1, n+1) if n % i == 0])
  original_instructions: |-
    find the number of divisors of a given integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(arr: List[str]) -> str:
        n = len(arr)
        XOR = 0
        for i in range(n):
            XOR = XOR ^ arr[i]
        return XOR
  error: |-
    TypeError: unsupported operand type(s) for ^: 'int' and 'str'
  explanation: |-
    The code is broken because the `main` function now expects a list of strings (`List[str]`) instead of a list of integers (`List[int]`). The XOR operation is not defined between integers and strings, which causes a `TypeError` when trying to perform `XOR ^ arr[i]` where `arr[i]` is a string. Additionally, the return type of the function is changed to `str`, but the function still returns an integer (`XOR`), which is another inconsistency in the type annotations.
  id: |-
    hubfix_mbpp_py_119
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        n = len(arr)
        XOR = 0
        for i in range(n):
            XOR = XOR ^ arr[i]
        return XOR
  original_instructions: |-
    find the element that appears only once in a sorted array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr1: list, arr2: list, n: int) -> float:
      i = 0
      j = 0
      m1 = -1
      m2 = -1
      count = 0
      while count < n + 1:
        count += 1
        if i == n:
          m1 = m2
          m2 = arr2[0]
          break
        elif j == n:
          m1 = m2
          m2 = arr1[0]
          break
        if arr1[i] <= arr2[j]:
          m1 = m2
          m2 = arr1[i]
          i += 1
        else:
          m1 = m2
          m2 = arr2[j]
          j += 1
      return (m1 + m2)//2
  error: |-
    TypeError: unsupported operand type(s) for //: 'float' and 'int'
  explanation: |-
    The function is supposed to return a float, but the return statement uses the floor division operator `//`, which returns an integer when used with two integers. Since `m1` and `m2` are initialized as integers and are only updated with integer values from `arr1` and `arr2`, the result of `(m1 + m2)//2` will be an integer, which is not compatible with the specified return type of `float`. To fix this, the regular division operator `/` should be used instead of `//` to ensure the result is a float.
  id: |-
    hubfix_mbpp_py_622
  lang: |-
    python
  original_code: |-
    def main(arr1: list, arr2: list, n: int) -> float:
      i = 0
      j = 0
      m1 = -1
      m2 = -1
      count = 0
      while count < n + 1:
        count += 1
        if i == n:
          m1 = m2
          m2 = arr2[0]
          break
        elif j == n:
          m1 = m2
          m2 = arr1[0]
          break
        if arr1[i] <= arr2[j]:
          m1 = m2
          m2 = arr1[i]
          i += 1
        else:
          m1 = m2
          m2 = arr2[j]
          j += 1
      return (m1 + m2)/2
  original_instructions: |-
    find the median of two sorted lists of same size
  resource_type: null
  resource_type_def: null
- broken_code: "def main(a: list, x: str) -> int:\n    count = 0\n    for i in a:\n\
    \      if i == y:\n        count += 1\n\n    return count "
  error: |-
    NameError: name 'y' is not defined
  explanation: |-
    The variable `y` is used in the comparison `if i == y:` but it is not defined anywhere in the code. The correct variable to use in the comparison is `x`, which is the parameter passed to the function. Additionally, the type hint for the parameter `x` was changed from `int` to `str`, which could potentially lead to a TypeError if the function is called with an integer as intended by the original code, but this would not cause an error until runtime and only if the function is called with an integer.
  id: |-
    hubfix_mbpp_py_168
  lang: |-
    python
  original_code: "def main(a: list, x: int) -> int:\n    count = 0\n    for i in a:\n\
    \      if i == x:\n        count += 1\n\n    return count "
  original_instructions: |-
    count the number of occurrences of a number in a given list
  resource_type: null
  resource_type_def: null
- broken_code: "from typing import List\n\ndef main(A: List[str]) -> int:\n    return\
    \ (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(B[i] >=\
    \ B[i + 1] for i in range(len(A) - 1))) "
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main(["a", "b", "c"])
      File "script.py", line 5, in main
        all(B[i] >= B[i + 1] for i in range(len(A) - 1)))
    NameError: name 'B' is not defined
  explanation: |-
    The code is broken for several reasons:

    1. The function parameter `A` is now expected to be a list of strings (`List[str]`), but the function logic is comparing the elements as if they were comparable (like integers). This could potentially work if the strings are meant to be compared lexicographically, but it's a change from the original code which expected a list of integers (`List[int]`).

    2. The return type of the function has been changed from `bool` to `int`, which is incorrect because the function returns a boolean value (the result of the `all` function calls).

    3. The variable `B` is used in the second `all` function call, but it is not defined anywhere in the code. This will raise a `NameError` when the function is called.
  id: |-
    hubfix_mbpp_py_68
  lang: |-
    python
  original_code: "from typing import List\n\ndef main(A: List[int]) -> bool:\n   \
    \ return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i]\
    \ >= A[i + 1] for i in range(len(A) - 1))) "
  original_instructions: |-
    check whether the given array is monotonic or not
  resource_type: null
  resource_type_def: null
- broken_code: "def main(r: str) -> float:\n    if r < 0 :\n        return None\n\
    \    return r * r "
  error: |-
    TypeError: '<' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is now expecting a parameter `r` of type `str` (string), but it is being used as if it were a numeric type in the comparison `r < 0`. Since strings cannot be compared to integers using the less than operator `<`, this will raise a `TypeError` when the function is called with a string argument.
  id: |-
    hubfix_mbpp_py_626
  lang: |-
    python
  original_code: "def main(r: float) -> float:\n    if r < 0 :\n        return None\n\
    \    return r * r "
  original_instructions: |-
    find the area of the largest triangle that can be inscribed in a semicircle with a given radius
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import Tuple, Any, Dict

    def main(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:
        res = dictionary(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))
        return res

    main(('a', 1, 'b', 2))
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main(('a', 1, 'b', 2))
      File "script.py", line 4, in main
        res = dictionary(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))
    NameError: name 'dictionary' is not defined
  explanation: |-
    The code is trying to use `dictionary` instead of `dict` to create a dictionary from the tuple slices. Since `dictionary` is not a built-in function or class in Python, this results in a `NameError` because Python does not recognize `dictionary` as a defined name.
  id: |-
    hubfix_mbpp_py_740
  lang: |-
    python
  original_code: |-
    from typing import Tuple, Any, Dict

    def main(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:
        res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))
        return res
  original_instructions: |-
    convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple, Union

    def main(test_list: List[Tuple[Union[str, int], Union[str, int]]]) -> List[Tuple[str, int]]:
      res = []
      for tup in test_list:
        temp = []
        for ele in tup:
          if isinstance(ele, str) and ele.isalpha():
            temp.append(ele)
          else:
            temp.append(str(ele))
        res.append((temp[0], temp[2]))
      return res
  error: |-
    IndexError: list index out of range
  explanation: |-
    The code is trying to access `temp[2]` which does not exist because the `temp` list only has two elements (indices 0 and 1). The correct code should use `temp[1]` to access the second element of the `temp` list. Additionally, the type hint for the `test_list` parameter was changed from `Union[str, float]` to `Union[str, int]`, and the conversion was changed from `float(ele)` to `str(ele)`, which is inconsistent with the return type specified as `List[Tuple[str, float]]`. This would not cause an immediate runtime error but is a logical error and would result in a type mismatch if type checking were enforced.
  id: |-
    hubfix_mbpp_py_117
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple, Union

    def main(test_list: List[Tuple[Union[str, float], Union[str, float]]]) -> List[Tuple[str, float]]:
      res = []
      for tup in test_list:
        temp = []
        for ele in tup:
          if isinstance(ele, str) and ele.isalpha():
            temp.append(ele)
          else:
            temp.append(float(ele))
        res.append((temp[0], temp[1]))
      return res
  original_instructions: |-
    convert all possible convertible elements in a list of lists to floats
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        return binn(n).replacer("0b","")
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in main
    NameError: name 'binn' is not defined
  explanation: |-
    The code is broken for several reasons:
    - The function `binn` does not exist; it should be `bin`.
    - The method `replacer` does not exist on strings; it should be `replace`.
    - The type of the parameter `n` has been changed from `int` to `str`, which is incorrect because the `bin` function expects an integer.
    - The return type of the function has been changed from `str` to `int`, which is incorrect because the `replace` method returns a string.
  id: |-
    hubfix_mbpp_py_99
  lang: |-
    python
  original_code: "def main(n: int) -> str:\n    return bin(n).replace(\"0b\",\"\"\
    ) "
  original_instructions: |-
    convert the given decimal number to its binary equivalent, represented as a string with no leading zeros
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(cost: List[List[int]]) -> float:
      N = len(cost)
      dp = [[0 for i in range(N + 1)] for j in range(N + 1)]
      dp[0][0] = cost[0][0]
      for i in range(1, N):
        dp[i][0] = dp[i - 1][0] + cost[i][0]
      for j in range(1, N):
        dp[0][j] = dp[0][j - 1] + cost[0][j]
      for i in range(1, N):
        for j in range(1, N):
          dp[i][j] = max(dp[i - 1][j],
                         dp[i][j - 1]) + cost[i][j]
      return dp[N - 1][N - 1] / (2 * M - 1)
  error: |-
    NameError: name 'M' is not defined
  explanation: |-
    In the return statement, the variable `M` is used, but it is not defined anywhere in the code. The original code used `N`, which is the length of the `cost` list, but the variable name was changed to `M` without defining it, causing a `NameError`.
  id: |-
    hubfix_mbpp_py_721
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(cost: List[List[int]]) -> float:
      N = len(cost)
      dp = [[0 for i in range(N + 1)] for j in range(N + 1)]
      dp[0][0] = cost[0][0]
      for i in range(1, N):
        dp[i][0] = dp[i - 1][0] + cost[i][0]
      for j in range(1, N):
        dp[0][j] = dp[0][j - 1] + cost[0][j]
      for i in range(1, N):
        for j in range(1, N):
          dp[i][j] = max(dp[i - 1][j],
                         dp[i][j - 1]) + cost[i][j]
      return dp[N - 1][N - 1] / (2 * N - 1)
  original_instructions: |-
    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(x: str) -> bool:
        y = x ^ (x >> "1")
        y = y ^ (y >> 2)
        y = y ^ (y >> 4)
        y = y ^ (y >> 8)
        y = y ^ (y >> 16)
        if (y & 1):
            return True
        return False
  error: |-
    TypeError: unsupported operand type(s) for >>: 'int' and 'str'
  explanation: |-
    The code is broken because the bitwise right shift operator (>>) expects an integer as its second operand, but a string "1" is provided instead. Additionally, the parameter `x` is expected to be an integer as per the function's type hint, but it has been changed to a string type hint (`x: str`), which will also cause a type error if an integer is passed to the function.
  id: |-
    hubfix_mbpp_py_406
  lang: |-
    python
  original_code: |-
    def main(x: int) -> bool:
        y = x ^ (x >> 1)
        y = y ^ (y >> 2)
        y = y ^ (y >> 4)
        y = y ^ (y >> 8)
        y = y ^ (y >> 16)
        if (y & 1):
            return True
        return False
  original_instructions: |-
    find whether the parity of a given number is odd
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr: list, n: str) -> list:
      j = 0
      for i in range(0, n):
        if (arr[i] < 0):
          temp = arr[i]
          arr[i] = arr[j]
          arr[j] = temp
          j = j + 1
      return arr

    main([1, -2, 3, -4], '4')
  error: |-
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The function `main` is expecting an integer for the second parameter `n`, but a string `'4'` is passed instead. The `range` function requires an integer argument, so passing a string causes a `TypeError`.
  id: |-
    hubfix_mbpp_py_229
  lang: |-
    python
  original_code: |-
    def main(arr: list, n: int) -> list:
      j = 0
      for i in range(0, n):
        if (arr[i] < 0):
          temp = arr[i]
          arr[i] = arr[j]
          arr[j] = temp
          j = j + 1
      return arr
  original_instructions: |-
    takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(colors: list, patterns: dict) -> str:
        if len(colors) != len(patterns):
            return False
        sdict = {}
        pset = set()
        sset = set()
        for i in range(len(patterns)):
            pset.add(patterns[i])
            sset.add(colors[i])
            if patterns[i] not in sdict:
                sdict[patterns[i]] = []

            keys = sdict[patterns[i]]
            keys.append(colors[i])

        if len(pset) != len(sset):
            return False

        for values in sdict.values():
            for i in range(len(values) - 1):
                if values[i] != values[i+1]:
                    return False

        return "Success"
  error: |-
    TypeError: object of type 'type' has no len()
  explanation: |-
    The code is broken because the type of the `patterns` parameter is changed from `list` to `dict`, but the function still tries to use `len(patterns)` as if `patterns` were a list. Since `dict` is a type and not an instance of a dictionary, it does not have a length, and thus the `len()` function cannot be applied to it, resulting in a `TypeError`.

    Additionally, the return type of the function is changed from `bool` to `str`, which is not an error by itself, but it is inconsistent with the logic of the function that returns `False` in some cases, which is a boolean value, not a string.
  id: |-
    hubfix_mbpp_py_74
  lang: |-
    python
  original_code: |-
    def main(colors: list, patterns: list) -> bool:
        if len(colors) != len(patterns):
            return False
        sdict = {}
        pset = set()
        sset = set()
        for i in range(len(patterns)):
            pset.add(patterns[i])
            sset.add(colors[i])
            if patterns[i] not in sdict:
                sdict[patterns[i]] = []

            keys = sdict[patterns[i]]
            keys.append(colors[i])

        if len(pset) != len(sset):
            return False

        for values in sdict.values():
            for i in range(len(values) - 1):
                if values[i] != values[i+1]:
                    return False

        return True
  original_instructions: |-
    check whether it follows the sequence given in the patterns array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: str, b: int) -> int:
        main_result = 0
        for i in range(1, min(a, b) + 1):
            if (a % i == 0 and b % i == 0):
                main_result += i
        return main_result
  error: |-
    TypeError: '<=' not supported between instances of 'int' and 'str'
  explanation: |-
    The code is broken because the `min` function is being called with a string (`a`) and an integer (`b`), which is not a valid operation. The `TypeError` is raised because the `<=` operator is used internally by the `min` function to compare the two arguments, and this operator does not support comparison between a string and an integer. Additionally, the function signature specifies that `a` should be an `int`, but it is being passed as a `str`, which is another issue that would cause a type checking tool like `mypy` to raise an error even before runtime.
  id: |-
    hubfix_mbpp_py_126
  lang: |-
    python
  original_code: |-
    def main(a: int, b: int) -> int:
        main_result = 0
        for i in range(1, min(a, b) + 1):
            if (a % i == 0 and b % i == 0):
                main_result += i
        return main_result
  original_instructions: |-
    find the sum of common divisors of two given numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_str: int) -> tuple:
        res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))
        return res
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
      File "<stdin>", line 2, in <genexpr>
    AttributeError: 'int' object has no attribute 'replace'
  explanation: |-
    The code is broken because the `main` function now expects an integer (`int`) as its parameter instead of a string (`str`). Since integers do not have a `replace` method, trying to call `replace` on an integer will result in an AttributeError.
  id: |-
    hubfix_mbpp_py_785
  lang: |-
    python
  original_code: |-
    def main(test_str: str) -> tuple:
        res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))
        return res
  original_instructions: |-
    convert tuple string to integer tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(dict1: list) -> bool:
      if boolean(dict1):
         return "False"
      else:
         return True
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        if boolean(dict1):
    NameError: name 'boolean' is not defined
  explanation: |-
    The code is broken for several reasons:
    1. The function `boolean` does not exist in Python. The correct function is `bool`.
    2. The type hint for the parameter `dict1` has been changed from `dict` to `list`, which is not necessarily a breaking change but could lead to confusion or errors if the function is expected to handle dictionaries specifically.
    3. The return statement `return "False"` is returning a string instead of a boolean value, which contradicts the function's return type hint `-> bool`.
  id: |-
    hubfix_mbpp_py_582
  lang: |-
    python
  original_code: |-
    def main(dict1: dict) -> bool:
      if bool(dict1):
         return False
      else:
         return True
  original_instructions: |-
    check if a dictionary is empty
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple, Set

    def main(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:
        res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list3])
        return res
  error: |-
    NameError: name 'test_list3' is not defined
  explanation: |-
    The code attempts to use a variable `test_list3` which is not defined anywhere in the script. The original code used `test_list2`, which is a parameter of the `main` function, but the broken code tries to use `test_list3` instead, leading to a `NameError` because `test_list3` does not exist in the current scope.
  id: |-
    hubfix_mbpp_py_473
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple, Set

    def main(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:
        res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])
        return res
  original_instructions: |-
    find the tuple intersection of elements in the given tuple list irrespective of their order
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from collections import nonexistentlibrary
    from typing import List

    def main(nums: List[str]) -> str:
        dict = nonexistentlibrary(int)
        for i in nums:
            dict[i] += 1
        result = max(dict.items(), key=lambda x: x[1])
        return result[0]
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary` from the `collections` module, which does not exist. Additionally, the `main` function now expects a list of strings (`List[str]`) instead of integers, and the return type is also changed to `str` from `int`, which is not consistent with the original functionality of the code. The `defaultdict` is also incorrectly referred to as `nonexistentlibrary`, which is not a valid class or function.
  id: |-
    hubfix_mbpp_py_130
  lang: |-
    python
  original_code: |-
    from collections import defaultdict
    from typing import List

    def main(nums: List[int]) -> int:
        dict = defaultdict(int)
        for i in nums:
            dict[i] += 1
        result = max(dict.items(), key=lambda x: x[1])
        return result[0]
  original_instructions: |-
    find the item with maximum frequency in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any
    import non_existent_library  # This library does not exist

    def main(l1: List[Any], l2: List[Any], l3: List[Any]) -> List[dict]:
         result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]
         return result

    main(1, 2, 3)  # Incorrect parameters passed to the function
  error: |-
    ModuleNotFoundError: No module named 'non_existent_library'
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken for two reasons:

    1. The script attempts to import a library named `non_existent_library`, which does not exist. This will raise a `ModuleNotFoundError` when the script is run.

    2. The `main` function is called with integers (1, 2, 3) as arguments instead of lists. The function expects three lists as parameters, but it receives integers, which will raise a `TypeError` because integers are not iterable in the context of the `zip` function.
  id: |-
    hubfix_mbpp_py_391
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(l1: List[Any], l2: List[Any], l3: List[Any]) -> List[dict]:
         result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]
         return result
  original_instructions: |-
    convert more than one list to nested dictionary
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(list1: List[str]) -> str:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even + first_odd
  error: |-
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the `main` function now expects a list of strings (`List[str]`) instead of a list of integers (`List[int]`). The `%` operator is used for modulo operations on integers, but when applied to strings, it is used for string formatting. Since the elements of `list1` are now strings, the expression `el % 2` is trying to perform string formatting, which is not possible with the given arguments, leading to a `TypeError`. Additionally, the return type of the function is changed to `str`, but the function is still returning the result of an arithmetic operation, which would be an integer if the code were correct. The `+` operator is also used instead of `-`, which would concatenate strings if the operands were strings, but in this context, it's another source of error due to the incorrect type usage.
  id: |-
    hubfix_mbpp_py_594
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(list1: List[int]) -> int:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even - first_odd
  original_instructions: |-
    find the difference of the first even and first odd number of a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib

    def main(text: int) -> str:
        patterns = '^[a-z]+_[a-z]+$'
        if re.search(patterns, text):
            return True
        else:
            return False

    main(123)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because of the following reasons:
    1. The script tries to import a library named 'nonexistentlib', which does not exist. This will raise a `ModuleNotFoundError`.
    2. The `main` function is now expecting an integer (`int`) as its parameter instead of a string (`str`), which is not compatible with the regular expression search that expects a string.
    3. The `main` function is supposed to return a boolean (`bool`), but the type hint suggests it returns a string (`str`), which is inconsistent with the actual return values.
    4. The `re` module is used without being imported, as the import statement for `nonexistentlib` replaced the correct import for `re`. This would raise a `NameError` if the `ModuleNotFoundError` was resolved.
    5. The `main` function is called with an integer argument (`123`), which is not compatible with the regular expression search that expects a string. This would raise a `TypeError` if the previous issues were resolved.
  id: |-
    hubfix_mbpp_py_16
  lang: |-
    python
  original_code: |-
    import re
    def main(text: str) -> bool:
            patterns = '^[a-z]+_[a-z]+$'
            if re.search(patterns,  text):
                    return True
            else:
                    return False
  original_instructions: |-
    that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(nums: list) -> str:
        result = int(''.join(map(str, nums)))
        return result
  error: |-
    TypeError: int() argument must be a string, a bytes-like object or a number, not 'list'
  explanation: |-
    The function signature was changed to expect a list instead of a tuple, but that is not the cause of the error. The actual error is due to the return type hint being changed from `int` to `str`, but the function still returns an integer. When Python's type checking is run, it will expect a string to be returned as per the type hint, but the actual returned value is an integer, which would cause a type checker to raise an error. However, Python's runtime does not enforce type hints, so this would not cause a runtime error. The error message provided is incorrect as it suggests a runtime error that would not occur with the given code. The code would run successfully, returning an integer, despite the incorrect type hint.
  id: |-
    hubfix_mbpp_py_116
  lang: |-
    python
  original_code: |-
    def main(nums: tuple) -> int:
        result = int(''.join(map(str, nums)))
        return result
  original_instructions: |-
    convert a given tuple of positive integers into a single integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        patterns = '\w*z.\w*'
        if re.search(patterns, text):
            return "Yes"
        else:
            return False
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library named `nonexistentlib`, which does not exist in the Python standard library or in the list of installed third-party libraries. This causes a `ModuleNotFoundError` when the Python interpreter tries to import it. Additionally, the return type of the function `main` is specified as `bool`, but the function returns a string "Yes" in one of the branches, which is inconsistent with the declared return type.
  id: |-
    hubfix_mbpp_py_454
  lang: |-
    python
  original_code: |-
    import re
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        patterns = '\w*z.\w*'
        if re.search(patterns, text):
            return True
        else:
            return False
  original_instructions: |-
    matches a word containing 'z'
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[str]) -> str:
        diff = max(nums) - min(nums)
        return diff
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        diff = max(nums) - min(nums)
    TypeError: unsupported operand type(s) for -: 'str' and 'str'
  explanation: |-
    The code is broken because the `main` function now expects a list of strings (`List[str]`) instead of a list of integers (`List[int]`). The subtraction operation (`-`) is not supported between strings, which causes a `TypeError` when trying to subtract the minimum string from the maximum string. Additionally, the return type of the function is changed to `str`, but the operation inside the function is arithmetic subtraction, which would not return a string even if it worked with integers.
  id: |-
    hubfix_mbpp_py_588
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> int:
        diff = max(nums) - min(nums)
        return diff
  original_instructions: |-
    find the difference between largest and smallest value in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Dict

    def main(list1: List[Dict]) -> str:
        main = all(not d for d in list2)
        return main
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main = all(not d for d in list2)
    NameError: name 'list2' is not defined
  explanation: |-
    The code is broken because it references `list2`, which is a variable that has not been defined. The original code used `list1`, which is the parameter passed to the function. By changing `list1` to `list2` inside the function, the code attempts to use a variable that does not exist, resulting in a `NameError`.
  id: |-
    hubfix_mbpp_py_115
  lang: |-
    python
  original_code: |-
    from typing import List, Dict

    def main(list1: List[Dict]) -> bool:
        main = all(not d for d in list1)
        return main
  original_instructions: |-
    check whether all dictionaries in a list are empty or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(list1: list, L: str) -> list:
        return list1[:L] + list1[L+1:]
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in main
    TypeError: slice indices must be integers or None or have an __index__ method
  explanation: |-
    The code is broken because the parameter `L` is typed as a string (`str`) instead of an integer (`int`). When `L` is used as a slice index in `list1[:L]` and `list1[L+1:]`, it causes a TypeError since slice indices must be integers, None, or objects with an `__index__` method. Additionally, the `+1` in `list1[L+1:]` is incorrect because it would skip an extra element instead of just the one at index `L`. The correct code should use `L` as an integer and the slice should be `list1[L:]` to exclude only the element at index `L`.
  id: |-
    hubfix_mbpp_py_610
  lang: |-
    python
  original_code: |-
    def main(list1: list, L: int) -> list:
        return list1[:L-1] + list1[L:]
  original_instructions: |-
    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed
  resource_type: null
  resource_type_def: null
- broken_code: "def main(str: int) -> int:\n    tmp = str + str\n    n = len(str)\n\
    \    for i in range(1, n + 1):\n        substring = tmp[i: i + n]\n        if\
    \ (str == substring):\n            return i\n    return n "
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The code is broken because the parameter `str` is now incorrectly typed as an `int` instead of `str`. The variable `tmp` is trying to concatenate `str` with itself, which is not possible if `str` is an integer. Python does not support concatenation of integers with the `+` operator, which is meant for strings or arithmetic addition for numbers.
  id: |-
    hubfix_mbpp_py_9
  lang: |-
    python
  original_code: "def main(str: str) -> int:\n    tmp = str + str\n    n = len(str)\n\
    \    for i in range(1, n + 1):\n        substring = tmp[i: i + n]\n        if\
    \ (str == substring):\n            return i\n    return n "
  original_instructions: |-
    find the minimum number of rotations (greater than 0) required to get the same string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
      if n and not n & (n - 1):
        return n

      count = 0
      while n != 0:
        n >>= "1"
        count += 1

      return 1 << count
  error: |-
    TypeError: unsupported operand type(s) for &: 'str' and 'int'
  explanation: |-
    The code is broken because the parameter `n` is expected to be an integer as per the original function's type hint (`n: int`), but it has been changed to a string (`n: str`). This causes a TypeError when trying to perform bitwise operations on a string and an integer (`n & (n - 1)`). Additionally, the right shift operation `n >>= "1"` is also incorrect because the right operand should be an integer, not a string.
  id: |-
    hubfix_mbpp_py_167
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
      if n and not n & (n - 1):
        return n

      count = 0
      while n != 0:
        n >>= 1
        count += 1

      return 1 << count
  original_instructions: |-
    find the smallest power of 2 greater than or equal to n
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(arr: List[str]) -> str:
        ans = 0
        res = 0
        i = len(arr) - 1
        while (i >= 0):
            incr = arr[i]*(1 + res)
            ans += incr
            res = incr
            i -= 1
        return ans
  error: |-
    TypeError: can't multiply sequence by non-int of type 'str'
  explanation: |-
    The code is broken because the function `main` is now expecting a list of strings (`List[str]`) instead of a list of integers (`List[int]`). Additionally, the return type is changed to `str` instead of `int`. Inside the function, the variable `incr` attempts to multiply a string (`arr[i]`) by an integer (`1 + res`), which is not allowed in Python. The `+=` operator is also used to add the result to `ans`, which is initialized as an integer, but this operation is invalid because `incr` would be a string if the multiplication were allowed. The function should return an integer, but due to the incorrect return type annotation, it implies that a string should be returned, which is also incorrect given the context of the original code.
  id: |-
    hubfix_mbpp_py_734
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(arr: List[int]) -> int:
        ans = 0
        res = 0
        i = len(arr) - 1
        while (i >= 0):
            incr = arr[i]*(1 + res)
            ans += incr
            res = incr
            i -= 1
        return ans
  original_instructions: |-
    find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple, Dict, Any

    def main(Input: List[Tuple[Any, ...]]) -> List[Tuple[Any, ...]]:
        out: Dict[Any, List[Any]] = {}
        for elem in Input:
            try:
                out[elem[0]].extend(elem[1:])
            except KeyError:
                out[elem[0]] = list(elem[1:])  # Fixed to not include the key in the values list
        return [tupl([key] + values) for key, values in out.items()]  # Include the key in the tuple

    # Example usage:
    # grouped = main([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')])
    # print(grouped)  # Output: [(1, 'a', 'c'), (2, 'b', 'd')]
  error: |-
    NameError: name 'tupl' is not defined
  explanation: |-
    In the list comprehension within the return statement, `tupl` is used instead of `tuple`. Since `tupl` is not defined anywhere in the code, Python raises a `NameError` when it tries to call this non-existent function.
  id: |-
    hubfix_mbpp_py_417
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple, Dict, Any

    def main(Input: List[Tuple[Any, ...]]) -> List[Tuple[Any, ...]]:
        out: Dict[Any, List[Any]] = {}
        for elem in Input:
            try:
                out[elem[0]].extend(elem[1:])
            except KeyError:
                out[elem[0]] = list(elem[1:])  # Fixed to not include the key in the values list
        return [tuple([key] + values) for key, values in out.items()]  # Include the key in the tuple

    # Example usage:
    # grouped = main([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')])
    # print(grouped)  # Output: [(1, 'a', 'c'), (2, 'b', 'd')]
  original_instructions: |-
    find common first element in given list of tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def lateral_surface_area(r: float, h: str) -> float:
        lateralsurface = 2 * 3.1415 * r * height
        return lateralsurface
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. It attempts to import a library named 'nonexistentlibrary', which does not exist.
    2. The function has been renamed from 'main' to 'lateral_surface_area', which could break code that depends on a function named 'main'.
    3. The parameter 'h' has been given the type 'str' instead of 'float', which is incorrect for a height value that should be a floating-point number.
    4. Inside the function, the variable 'height' is used, but it is not defined anywhere. The correct variable name as per the function's parameters should be 'h'.
  id: |-
    hubfix_mbpp_py_233
  lang: |-
    python
  original_code: |-
    def main(r: float, h: float) -> float:
        lateralsurface = 2 * 3.1415 * r * h
        return lateralsurface
  original_instructions: |-
    find the lateral surface area of a cylinder
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple

    def main(list1: List[Tuple[int, str]]) -> int:
        result_max = max([abs(x * int(y)) for x, y in list1])
        return result_max
  error: |-
    TypeError: unsupported operand type(s) for *: 'int' and 'str'
  explanation: |-
    The code is broken because the type hint for the `list1` parameter has been changed from `List[Tuple[int, int]]` to `List[Tuple[int, str]]`, which means that the second element of each tuple in the list is expected to be a string instead of an integer. However, the code attempts to multiply `x` (an integer) by `y` (a string), which is not a valid operation in Python. The `int(y)` conversion is applied inside the list comprehension, but it will fail if `y` cannot be converted to an integer, which is not guaranteed by the type hint. If `y` is a string that cannot be converted to an integer, a `ValueError` would be raised. The `TypeError` is raised because the multiplication operation is attempted before the conversion to an integer.
  id: |-
    hubfix_mbpp_py_120
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple

    def main(list1: List[Tuple[int, int]]) -> int:
        result_max = max([abs(x * y) for x, y in list1])
        return result_max
  original_instructions: |-
    find the maximum absolute product between numbers in pairs of tuples within a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: int) -> int:
        count_chars = 0
        for i in range(len(str1)):
            if ((i == ord(str1[i]) - ord('A')) or
                (i == ord(str1[i]) - ord('a'))):
                count_chars += 1
        return count_chars

    main("ABC")
  error: |-
    TypeError: object of type 'int' has no len()
  explanation: |-
    The code is broken because the `main` function is now expecting an integer (`int`) as its parameter instead of a string (`str`). When `len(str1)` is called, it raises a `TypeError` because the `len` function cannot be used on an integer. Additionally, even if the parameter type was not changed, calling `main("ABC")` would still fail because the function now expects an integer, but a string is being passed.
  id: |-
    hubfix_mbpp_py_165
  lang: |-
    python
  original_code: "def main(str1: str) -> int:\n    count_chars = 0\n    for i in range(len(str1)):\n\
    \        if ((i == ord(str1[i]) - ord('A')) or\n            (i == ord(str1[i])\
    \ - ord('a'))):\n            count_chars += 1\n    return count_chars "
  original_instructions: |-
    count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str, str: int) -> dict:
        word_len = {}
        txt = str.divide(" ")
        for x in txt:
            if len(x) > n:
                word_len.add(x)
        return word_len
  error: |-
    Traceback (most recent call last):
      File "script.py", line 3, in <module>
        txt = str.divide(" ")
    AttributeError: 'int' object has no attribute 'divide'
  explanation: |-
    The code is broken for several reasons:

    1. The parameter types for `n` and `str` have been swapped, which is incorrect according to the original function's design. `n` should be an `int` and `str` should be a `str`.
    2. The method `divide` does not exist for strings in Python. The correct method for splitting a string is `split`.
    3. The `word_len` variable is changed from a list to a dictionary, which is not compatible with the `append` method used in the original code. The correct method for adding an item to a dictionary is using a key-value pair, not the `add` method.
    4. The function is supposed to return a list, but the modified code attempts to return a dictionary.
    5. The `if` condition `len(x) > n` will raise a TypeError because `n` is expected to be an integer for comparison, but it has been changed to a string.
  id: |-
    hubfix_mbpp_py_128
  lang: |-
    python
  original_code: |-
    def main(n: int, str: str) -> list:
        word_len = []
        txt = str.split(" ")
        for x in txt:
            if len(x) > n:
                word_len.append(x)
        return word_len
  original_instructions: |-
    find words that are longer than n characters from a given list of words
  resource_type: null
  resource_type_def: null
- broken_code: "def main(tup: list, x: object) -> str:\n    count = 0\n    for ele\
    \ in tupl:\n        if (ele == x):\n            count = count + 1\n    return\
    \ count "
  error: |-
    Traceback (most recent call last):
      File "script.py", line 4, in <module>
        for ele in tupl:
    NameError: name 'tupl' is not defined
  explanation: |-
    The code is broken because of the following reasons:
    1. The type hint for the parameter `tup` has been changed from `tuple` to `list`, which is not necessarily a breaking change but could lead to unexpected behavior if the function is called with a tuple.
    2. The variable `tupl` is used in the for loop, but it is not defined anywhere in the code. The correct variable name should be `tup`.
    3. The return type hint has been changed from `int` to `str`, which is incorrect because the function returns an integer count of occurrences. This could lead to type errors if the function's return value is used in a context where a string is expected.
  id: |-
    hubfix_mbpp_py_250
  lang: |-
    python
  original_code: "def main(tup: tuple, x: object) -> int:\n    count = 0\n    for\
    \ ele in tup:\n        if (ele == x):\n            count = count + 1\n    return\
    \ count "
  original_instructions: |-
    takes in a tuple and an element and counts the occcurences of the element in the tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(num: str) -> bool:
        if num > 1:
            for i in range(2, num//2 + 1):
                if (num % i) == 0:
                    return False
            return True
        else:
            return False

    main("ten")
  error: |-
    TypeError: '>' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is now defined to take a parameter `num` of type `str` (string), but it is being used as if it were an integer within the function. The comparison `num > 1` and the arithmetic operations `num//2 + 1` and `num % i` are not valid for strings. Additionally, the function is called with a string argument `"ten"`, which is not compatible with the expected integer operations inside the function. This results in a `TypeError` when attempting to compare and perform arithmetic operations on a string and an integer.
  id: |-
    hubfix_mbpp_py_605
  lang: |-
    python
  original_code: |-
    def main(num: int) -> bool:
        if num > 1:
            for i in range(2, num//2 + 1):
                if (num % i) == 0:
                    return False
            return True
        else:
            return False
  original_instructions: |-
    check if the given integer is a prime number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(strr: int) -> str:
        summ = 0
        for i in range(len(strr)):
            summ += (ord(strr[i]) - ord('a') + 1)
        if (summ % 26 == 0):
            return 'z'
        else:
            summ = summ % 26
            return chr(ord('a') + summ - 1)
  error: |-
    TypeError: object of type 'int' has no len()
  explanation: |-
    The code is broken because the parameter `strr` is expected to be a string as per the original function, but it has been changed to an integer type in the function definition (`def main(strr: int) -> str:`). The `len()` function cannot be used on an integer, as it is designed to work with sequences like strings, lists, tuples, etc. This results in a `TypeError` when trying to use `len()` on an integer.
  id: |-
    hubfix_mbpp_py_83
  lang: |-
    python
  original_code: |-
    def main(strr: str) -> str:
        summ = 0
        for i in range(len(strr)):
            summ += (ord(strr[i]) - ord('a') + 1)
        if (summ % 26 == 0):
            return 'z'
        else:
            summ = summ % 26
            return chr(ord('a') + summ - 1)
  original_instructions: |-
    find the character made by adding the ASCII value of all the characters of the given string modulo 26
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Union

    def main(listval: List[Union[int, str]]) -> Union[int, str]:
        main = max(i for i in listval if isinstance(i, (int, str)))
        return main
  error: |-
    TypeError: '>' not supported between instances of 'str' and 'int'
  explanation: |-
    The code is broken because the `max` function is being used on a generator that can yield both integers and strings due to the change in the `isinstance` check. Python cannot compare integers and strings with the '>' operator, which is used internally by the `max` function to determine the largest item. The type hint for the `listval` parameter was also changed from `List[Union[int, float]]` to `List[Union[int, str]]`, which allows strings to be part of the list passed to the function, leading to the TypeError when attempting to find the maximum value.
  id: |-
    hubfix_mbpp_py_294
  lang: |-
    python
  original_code: |-
    from typing import List, Union

    def main(listval: List[Union[int, float]]) -> Union[int, float]:
        main = max(i for i in listval if isinstance(i, (int, float)))
        return main
  original_instructions: |-
    find the maximum value in a given heterogeneous list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(list1: List[List[str]]) -> List[List[int]]:
        result = list(map(srted, list1))
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        result = list(map(srted, list1))
    NameError: name 'srted' is not defined
  explanation: |-
    There are two issues in the modified code:

    1. The function `srted` is called instead of `sorted`. Since `srted` is not a defined function, it causes a `NameError`.
    2. The type hint for the parameter `list1` has been changed from `List[List[int]]` to `List[List[str]]`, which is inconsistent with the function's behavior of sorting lists of integers. If strings were passed to the function, it would not cause a runtime error, but it would be a semantic error since the function is expected to sort lists of integers, not strings.
  id: |-
    hubfix_mbpp_py_569
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(list1: List[List[int]]) -> List[List[int]]:
        result = list(map(sorted, list1))
        return result
  original_instructions: |-
    sort each sublist of strings in a given list of lists
  resource_type: null
  resource_type_def: null
- broken_code: "def main(n: str) -> float:\n    nCr = 1\n    res = 1\n    for r in\
    \ range(1, n + 1):\n        nCr = (nCr * (n + 1 - r)) / r\n        res += nCr\
    \ * nCr\n    return res "
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `str` (string), which is incorrect because the function expects an integer to perform arithmetic operations. The `range` function and the subtraction operation inside the loop both expect integer arguments, but they receive a string due to the incorrect type hint. This results in a `TypeError` when trying to perform addition and subtraction with a string and an integer.
  id: |-
    hubfix_mbpp_py_300
  lang: |-
    python
  original_code: "def main(n: int) -> float:\n    nCr = 1\n    res = 1\n    for r\
    \ in range(1, n + 1):\n        nCr = (nCr * (n + 1 - r)) / r\n        res += nCr\
    \ * nCr\n    return res "
  original_instructions: |-
    find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(word: int) -> list:
        return [char for char in number]
  error: |-
    NameError: name 'number' is not defined
  explanation: |-
    The code is broken because of two issues:
    1. The parameter `word` is expected to be of type `int` as per the function definition, but the function is designed to iterate over a string, not an integer.
    2. Inside the list comprehension, the variable `number` is used, but it is not defined anywhere in the code. The correct variable to use would be `word`, which is the parameter of the function.
  id: |-
    hubfix_mbpp_py_565
  lang: |-
    python
  original_code: |-
    def main(word: str) -> list:
        return [char for char in word]
  original_instructions: |-
    split a string into characters
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(list_: List[int], string: str) -> List[int]:
        main = [string.fmt(i) for i in list_]
        return main
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main([1, 2, 3], "Number: {}")
      File "script.py", line 4, in main
        main = [string.fmt(i) for i in list_]
    AttributeError: 'str' object has no attribute 'fmt'
  explanation: |-
    The code is broken because of two reasons:

    1. The `str` object in Python does not have a method called `fmt`. The correct method to format a string is `format`.
    2. The return type of the function is specified as `List[int]`, but the function is supposed to return a list of formatted strings, so the return type should be `List[str]`.
  id: |-
    hubfix_mbpp_py_390
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(list_: List[int], string: str) -> List[str]:
        main = [string.format(i) for i in list_]
        return main
  original_instructions: |-
    apply a given format string to all of the elements in a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(L: list) -> str:
      x = int("".join(map(str, L)))
      return y
  error: |-
    NameError: name 'y' is not defined
  explanation: |-
    The code attempts to return a variable `y` which has not been defined anywhere in the function. The correct variable to return would be `x`, which holds the integer value. Additionally, the return type of the function has been changed from `int` to `str`, which is inconsistent with the actual return value, but this would not cause an immediate runtime error; it would be a type hint error that could lead to bugs if not corrected.
  id: |-
    hubfix_mbpp_py_439
  lang: |-
    python
  original_code: |-
    def main(L: list) -> int:
      x = int("".join(map(str, L)))
      return x
  original_instructions: |-
    join a list of multiple integers into a single integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        ctr = 0
        for num in range(n):
            if num <= 1:
                continue
            for i in range(2, int(num ** 0.5) + 1):
                if (num % i) == 0:
                    break
            else:
                ctr += 1
        return ctr

    main("ten")
  error: |-
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The function `main` is defined to take an integer parameter `n`, but in the call `main("ten")`, a string is passed instead. Python cannot use a string where it expects an integer, specifically in the `range(n)` function, which expects an integer argument. This results in a `TypeError` because the string "ten" cannot be interpreted as an integer.
  id: |-
    hubfix_mbpp_py_256
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        ctr = 0
        for num in range(n):
            if num <= 1:
                continue
            for i in range(2, int(num ** 0.5) + 1):  # Optimized to check up to the square root of num
                if (num % i) == 0:
                    break
            else:
                ctr += 1
        return ctr
  original_instructions: |-
    takes in a non-negative number and returns the number of prime numbers less than the given non-negative number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import math
    def div_sum(n: int) -> int:
      total = 1
      i = 2

      while i * i <= n:
        if (n % i == 0):
          total = (total + i + math.floor(n / i))
        i += 1

      return total

    def main(num1: str, num2: int) -> bool:
        return div_sum(num1) == div_sum(num2)
  error: |-
    TypeError: unsupported operand type(s) for %: 'str' and 'int'
  explanation: |-
    The `div_sum` function is designed to take an integer as its parameter, but the `main` function has been modified to take a string as the first parameter (`num1: str`). When `div_sum(num1)` is called, it tries to perform a modulo operation with a string and an integer, which is not supported in Python and results in a `TypeError`.
  id: |-
    hubfix_mbpp_py_164
  lang: |-
    python
  original_code: |-
    import math
    def div_sum(n: int) -> int:
      total = 1
      i = 2

      while i * i <= n:
        if (n % i == 0):
          total = (total + i + math.floor(n / i))
        i += 1

      return total

    def main(num1: int, num2: int) -> bool:
        return div_sum(num1) == div_sum(num2)
  original_instructions: |-
    determine if the sum of the divisors of two integers are the same
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: int, b: str, n: int) -> tuple[int, int] | None:
        i = 0
        while i * a <= n:
            if (n - (i * a)) % b == 0:
                return (i, (n - (i * a)) // b)
            i = i + 1
        return None
  error: |-
    TypeError: unsupported operand type(s) for %: 'int' and 'str'
  explanation: |-
    The code is broken because the type of the parameter `b` has been changed from `int` to `str`. The modulo operator `%` and the floor division operator `//` are used with `b` as the second operand, which expects `b` to be an integer. Since `b` is now a string, Python raises a `TypeError` because these operations are not supported between an integer and a string.
  id: |-
    hubfix_mbpp_py_160
  lang: |-
    python
  original_code: |-
    def main(a: int, b: int, n: int) -> tuple[int, int] | None:
        i = 0
        while i * a <= n:
            if (n - (i * a)) % b == 0:
                return (i, (n - (i * a)) // b)
            i = i + 1
        return None
  original_instructions: |-
    returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: int) -> tuple:
        result = tuple(x for x in str1 if not x.isspace())
        return result

    main("Hello World")
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 4, in <module>
      File "<stdin>", line 2, in main
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken because the parameter `str1` is now incorrectly typed as an `int` instead of `str`. Since integers are not iterable, the generator expression `tuple(x for x in str1 if not x.isspace())` will fail when it tries to iterate over an integer. The function is called with a string argument, which is the correct usage for the original function, but due to the changed parameter type, it results in a `TypeError`.
  id: |-
    hubfix_mbpp_py_310
  lang: |-
    python
  original_code: |-
    def main(str1: str) -> tuple:
        result = tuple(x for x in str1 if not x.isspace())
        return result
  original_instructions: |-
    convert a given string to a tuple of characters
  resource_type: null
  resource_type_def: null
- broken_code: "from typing import List\n\ndef main(input: List, k: str) -> List:\n\
    \  return (input[k-1::-1] + input[k:]) "
  error: |-
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The function `main` is expecting an integer for the second parameter `k`, but the type hint has been changed to `str` (string). When the function tries to perform the operation `k-1`, it raises a TypeError because you cannot subtract an integer from a string.
  id: |-
    hubfix_mbpp_py_644
  lang: |-
    python
  original_code: "from typing import List\n\ndef main(input: List, k: int) -> List:\n\
    \  return (input[k-1::-1] + input[k:]) "
  original_instructions: |-
    reverse an array upto a given position
  resource_type: null
  resource_type_def: null
- broken_code: "import nonexistentlib\nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef main(string:\
    \ int) -> str:\n    if(nonexistentlib.search(regex, string)):\n        return\
    \ \"Valid\"\n    else:\n        return \"Invalid\" "
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is trying to import a library named 'nonexistentlib', which does not exist. This will cause a ModuleNotFoundError when the script is run. Additionally, the `main` function is expecting an integer as an argument (`string: int`) instead of a string, which is not consistent with the intended use of the function. Furthermore, the function is trying to call `search` on `nonexistentlib`, which does not exist, instead of using `re.search` from the `re` module.
  id: |-
    hubfix_mbpp_py_396
  lang: |-
    python
  original_code: "import re\nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef main(string: str)\
    \ -> str:\n    if(re.search(regex, string)):\n        return \"Valid\"\n    else:\n\
    \        return \"Invalid\" "
  original_instructions: |-
    check whether the given string starts and ends with the same character or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    from typing import List, Any

    def main(a: List[Any], x: Any) -> str:
        i = bisect.bisect_left(a, y)
        return i
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. It attempts to import a library named 'nonexistentlibrary', which does not exist.
    2. The return type of the function `main` is changed from `int` to `str`, which is incorrect because `bisect.bisect_left` returns an integer index.
    3. The variable `y` is used in the call to `bisect.bisect_left(a, y)` but it is not defined anywhere in the code.
  id: |-
    hubfix_mbpp_py_736
  lang: |-
    python
  original_code: |-
    import bisect
    from typing import List, Any

    def main(a: List[Any], x: Any) -> int:
        i = bisect.bisect_left(a, x)
        return i
  original_instructions: |-
    locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s: int) -> int:
      count = 0
      for i in range(len(s) - 2):
        if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):
          count = count + 1
      return count
  error: |-
    TypeError: object of type 'int' has no len()
  explanation: |-
    The code is broken because the parameter `s` is expected to be a string as per the original function, but its type has been changed to `int`. The `len()` function cannot be used on an integer, as it is designed to work with sequences (like strings, lists, tuples, etc.). This results in a `TypeError` because an integer does not have a length.
  id: |-
    hubfix_mbpp_py_172
  lang: |-
    python
  original_code: |-
    def main(s: str) -> int:
      count = 0
      for i in range(len(s) - 2):
        if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):
          count = count + 1
      return count
  original_instructions: |-
    count the number of occurence of the string 'std' in a given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: list[int], n: str, index: int, k: int) -> int:
        dp = [[0 for i in range(n)]
                for i in range(n)]
        for i in range(n):
            if a[i] > a[0]:
                dp[0][i] = a[i] + a[0]
            else:
                dp[0][i] = a[i]
        for i in range(1, n):
            for j in range(n):
                if a[j] > a[i] and j > i:
                    if dp[i - 1][i] + a[j] > dp[i - 1][j]:
                        dp[i][j] = dp[i - 1][i] + a[j]
                    else:
                        dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[index][k]

    main([1, 2, 3], '3', 1, 2)
  error: |-
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The error occurs because the variable `n` is expected to be an integer as it is used in the `range()` function, but it has been changed to a string type in the function signature (`n: str`). The `range()` function requires an integer argument, not a string. When the `main` function is called with `'3'` as the second argument, it causes a `TypeError` because a string cannot be used as an argument to `range()`.
  id: |-
    hubfix_mbpp_py_306
  lang: |-
    python
  original_code: |-
    def main(a: list[int], n: int, index: int, k: int) -> int:
        dp = [[0 for i in range(n)]
                for i in range(n)]
        for i in range(n):
            if a[i] > a[0]:
                dp[0][i] = a[i] + a[0]
            else:
                dp[0][i] = a[i]
        for i in range(1, n):
            for j in range(n):
                if a[j] > a[i] and j > i:
                    if dp[i - 1][i] + a[j] > dp[i - 1][j]:
                        dp[i][j] = dp[i - 1][i] + a[j]
                    else:
                        dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[index][k]
  original_instructions: "find the maximum sum of increasing subsequence from prefix\
    \ until ith index and also including a given kth element which is after i, i.e.,\
    \ k > i "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr: list, ranges: list[tuple[int, str]], rotations: int, index: int) -> int:
        for i in range(rotations - 1, -1, -1):
            left = ranges[i][0]
            right = ranges[i][2]  # This index is out of range for a tuple of size 2
            if left <= index and right >= index:
                if index == left:
                    index = right
                else:
                    index = index - 1
        return arr[index]
  error: |-
    IndexError: tuple index out of range
  explanation: |-
    The code attempts to access `ranges[i][2]`, which is out of range for a tuple that only has two elements (indexed 0 and 1). This causes an `IndexError` because tuples in Python are zero-indexed, and a tuple of size 2 only has valid indices 0 and 1.
  id: |-
    hubfix_mbpp_py_304
  lang: |-
    python
  original_code: "def main(arr: list, ranges: list[tuple[int, int]], rotations: int,\
    \ index: int) -> int:\n    for i in range(rotations - 1, -1, -1):\n        left\
    \ = ranges[i][0]\n        right = ranges[i][1]\n        if left <= index and right\
    \ >= index:\n            if index == left:\n                index = right\n  \
    \          else:\n                index = index - 1\n    return arr[index] "
  original_instructions: |-
    find element at a given index after number of rotations
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from collections import Counter
    from typing import Dict, List, Tuple, Any

    def main(dict1: Dict[Any, str]) -> List[Tuple[Any, int]]:
        x = Counter(dict1)
        sorted_counter = x.most_common()
        return sorted_counter
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        main({'a': 1, 'b': 2})
      File "script.py", line 5, in main
        x = Counter(dict1)
      File "/usr/lib/python3.8/collections/__init__.py", line 582, in __init__
        self.update(iterable, **kwds)
      File "/usr/lib/python3.8/collections/__init__.py", line 669, in update
        _count_elements(self, iterable)
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken because the type hint for the values of `dict1` has been changed from `int` to `str`. The `Counter` class expects an iterable or a mapping of elements to their counts. When a dictionary is passed, the values should be the counts (integers), but with the type hint changed to `str`, it implies that the values are strings, which is not what `Counter` expects. When the `Counter` is initialized with a dictionary that has integer values, it will raise a `TypeError` because it tries to iterate over the integers, which is not possible.
  id: |-
    hubfix_mbpp_py_475
  lang: |-
    python
  original_code: |-
    from collections import Counter
    from typing import Dict, List, Tuple, Any

    def main(dict1: Dict[Any, int]) -> List[Tuple[Any, int]]:
        x = Counter(dict1)
        sorted_counter = x.most_common()
        return sorted_counter
  original_instructions: |-
    sort a dictionary by value
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import math
    def main(n: str) -> int:
        if (n % 2 != 0) :
            return 0
        res = 1
        for i in range(2, (int)(math.sqrt(n)) + 1) :
            count = 0
            curr_sum = 1
            curr_term = 1
            while (n % i == 0) :
                count= count + 1
                n = n // i
                if (i == 2 and count == 1) :
                    curr_sum = 0
                curr_term = curr_term * i
                curr_sum = curr_sum + curr_term
            res = res * curr_sum
        if (n >= 2) :
            res = res * (1 + n)
        return res
  error: |-
    TypeError: unsupported operand type(s) for %: 'str' and 'int'
  explanation: |-
    The code is broken because the parameter `n` is now expected to be a string (`n: str`) instead of an integer. The modulo operation `%` and the floor division `//` are not supported between a string and an integer, and neither is the comparison `n >= 2`. The `math.sqrt` function also expects a number, not a string. The code will raise a TypeError when it tries to perform these operations with a string.
  id: |-
    hubfix_mbpp_py_453
  lang: |-
    python
  original_code: |-
    import math
    def main(n: int) -> int:
        if (n % 2 != 0) :
            return 0
        res = 1
        for i in range(2, (int)(math.sqrt(n)) + 1) :
            count = 0
            curr_sum = 1
            curr_term = 1
            while (n % i == 0) :
                count= count + 1
                n = n // i
                if (i == 2 and count == 1) :
                    curr_sum = 0
                curr_term = curr_term * i
                curr_sum = curr_sum + curr_term
            res = res * curr_sum
        if (n >= 2) :
            res = res * (1 + n)
        return res
  original_instructions: |-
    find the sum of even factors of a number
  resource_type: null
  resource_type_def: null
- broken_code: "def main(s: str, ch: int) -> str:\n    for i in range(len(s)):\n \
    \       if (s[i] == ch):\n            s = s[0 : i] + s[i + 1:]\n            break\n\
    \    for i in range(len(s) - 1, -1, -1):\n        if (s[i] == ch):\n         \
    \   s = s[0 : i] + s[i + 1:]\n            break\n    return s "
  error: |-
    TypeError: '==' not supported between instances of 'str' and 'int'
  explanation: |-
    The code is broken because the type of the parameter `ch` has been changed from `str` to `int`. The `==` operator is used to compare a string character (`s[i]`) with `ch`, but since `ch` is now an integer, Python cannot compare a string character with an integer, resulting in a `TypeError`.
  id: |-
    hubfix_mbpp_py_11
  lang: |-
    python
  original_code: "def main(s: str, ch: str) -> str:\n    for i in range(len(s)):\n\
    \        if (s[i] == ch):\n            s = s[0 : i] + s[i + 1:]\n            break\n\
    \    for i in range(len(s) - 1, -1, -1):\n        if (s[i] == ch):\n         \
    \   s = s[0 : i] + s[i + 1:]\n            break\n    return s "
  original_instructions: |-
    remove first and last occurrence of a given character from the string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any
    import non_existent_library  # This library does not exist

    def main(list1: List[List[Any]], n: int) -> List[Any]:
        result = [x[m] for x in list1]  # 'm' is not defined
        return result

    main([[1, 2], [3, 4]], 'a')  # 'a' is not an integer
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        import non_existent_library  # This library does not exist
    ModuleNotFoundError: No module named 'non_existent_library'
  explanation: |-
    The code is broken for several reasons:

    1. The script attempts to import a library named `non_existent_library`, which does not exist. This will raise a `ModuleNotFoundError`.
    2. Inside the list comprehension, the variable `m` is used, but it is not defined anywhere in the code. This will raise a `NameError`.
    3. The function `main` is called with the second argument `'a'`, which is a string, not an integer as the function signature requires. This will raise a `TypeError` if the code execution reaches this point after fixing the import and the undefined variable issues.
  id: |-
    hubfix_mbpp_py_413
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(list1: List[List[Any]], n: int) -> List[Any]:
        result = [x[n] for x in list1]
        return result
  original_instructions: |-
    extract the nth element from a given list of tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[str]) -> List[int]:
        odd_nums = list(filter(lambda x: x % 2 != 0, nums))
        return odd_nums

    main([1, 2, 3, 'four', 5])
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        main([1, 2, 3, 'four', 5])
      File "script.py", line 5, in main
        odd_nums = list(filter(lambda x: x % 2 != 0, nums))
      File "script.py", line 5, in <lambda>
        odd_nums = list(filter(lambda x: x % 2 != 0, nums))
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the `main` function is now expecting a list of strings (`List[str]`) as its parameter, but it is being called with a list that contains both integers and a string (`[1, 2, 3, 'four', 5]`). The lambda function inside the `filter` is trying to perform a modulo operation on each element, which is not valid for the string 'four'. This results in a `TypeError` because the `%` operator cannot be used with a string in this context.
  id: |-
    hubfix_mbpp_py_426
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> List[int]:
        odd_nums = list(filter(lambda x: x % 2 != 0, nums))
        return odd_nums
  original_instructions: |-
    filter odd numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    def main(w: float, h: str) -> float:
      s = math.sqrt((w * w) + (h * h))
      return s
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, the type of the parameter 'h' has been changed from `float` to `str`, which will cause a TypeError when trying to perform arithmetic operations with 'w' and 'h'. The `math.sqrt` function expects a numeric value, but 'h' is now a string, which will cause an error if the function is called with a string for 'h'.
  id: |-
    hubfix_mbpp_py_293
  lang: |-
    python
  original_code: |-
    import math
    def main(w: float, h: float) -> float:
      s = math.sqrt((w * w) + (h * h))
      return s
  original_instructions: |-
    find the third side of a right angled triangle
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any

    def main(test_list: List[Any]) -> str:
        if len(test_list) > len(set(test_list)):
            return False
        return "True"
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main([1, 2, 3])
    TypeError: main() should return 'bool' but returns 'str'
  explanation: |-
    The return type of the function `main` was changed from `bool` to `str`, which is incorrect because the function is supposed to return a boolean value (`True` or `False`). However, the function now returns a string `"True"` instead of a boolean `True`. This will cause a type error if type checking is performed, although Python itself will not raise an error at runtime due to its dynamic typing. If the code is type-checked using a tool like `mypy`, it will report an error because the return type does not match the type hint.
  id: |-
    hubfix_mbpp_py_281
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(test_list: List[Any]) -> bool:
        if len(test_list) > len(set(test_list)):
            return False
        return True
  original_instructions: |-
    check if the elements of a given list are unique or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, TypeVar

    T = TypeVar('T')

    def main(list: List[T], element: T) -> List[T]:
        list = [v for elt in lst for v in (element, elt)]
        return lst
  error: |-
    NameError: name 'lst' is not defined
  explanation: |-
    The variable `lst` is used in the list comprehension, but it is not defined anywhere in the code. The original variable name was `list`, which should be used instead of `lst`. Additionally, the return statement is trying to return `lst`, which is also not defined; it should return `list`.
  id: |-
    hubfix_mbpp_py_251
  lang: |-
    python
  original_code: |-
    from typing import List, TypeVar

    T = TypeVar('T')

    def main(list: List[T], element: T) -> List[T]:
        list = [v for elt in list for v in (element, elt)]
        return list
  original_instructions: |-
    takes in a list and an element and inserts the element before each element in the list, and returns the resulting list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(monthnum3: str) -> bool:
      return monthnum3 == 4 or monthnum3 == 6 or monthnum3 == 9 or monthnum3 == 11
  error: |-
    TypeError: '==' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is expecting an integer parameter as indicated by the type hint `int`, but the type hint has been changed to `str` (string). When the function is called with an integer argument, it will cause a TypeError because the equality comparison is between a string and an integer, which is not supported in Python.
  id: |-
    hubfix_mbpp_py_762
  lang: |-
    python
  original_code: |-
    def main(monthnum3: int) -> bool:
      return monthnum3 == 4 or monthnum3 == 6 or monthnum3 == 9 or monthnum3 == 11
  original_instructions: |-
    check whether the given month number contains 30 days or not. Months are given as number from 1 to 12
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: int) -> int:
        str2 = ''
        for i in range(1, len(str1) + 1):
            if(i % 2 == 0):
                str2 = str2 + str1[i - 1]
        return str2
  error: |-
    TypeError: object of type 'int' has no len()
  explanation: |-
    The code is broken because the `main` function is now expecting an integer (`int`) as its parameter instead of a string (`str`). The `len()` function cannot be used on an integer, as it is designed to work with a sequence (like a string, list, tuple, etc.). Additionally, the function is trying to concatenate a string (`str2`) with an integer (`str1[i - 1]`), which would also raise a `TypeError` if the code execution reached that point. The return type of the function is also incorrect; it should return a string, but it is specified as returning an integer (`int`).
  id: |-
    hubfix_mbpp_py_437
  lang: |-
    python
  original_code: |-
    def main(str1: str) -> str:
        str2 = ''
        for i in range(1, len(str1) + 1):
            if(i % 2 == 0):
                str2 = str2 + str1[i - 1]
        return str2
  original_instructions: |-
    remove odd characters in a string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    def main(r: float, h: str) -> float:
      volume = (1.0/3) * math.pi * r * r * h
      return volume
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. This will cause a ModuleNotFoundError when the script is run. Additionally, the function `main` is expecting a string for the second parameter `h` due to the type hint `h: str`, but it should be a float since it's used in a mathematical operation to calculate volume. This would cause a TypeError if the import error was fixed and the function was called with a string for `h`.
  id: |-
    hubfix_mbpp_py_312
  lang: |-
    python
  original_code: |-
    import math
    def main(r: float, h: float) -> float:
      volume = (1.0/3) * math.pi * r * r * h
      return volume
  original_instructions: |-
    find the volume of a cone
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str, d: int) -> int:
        INT_BITS = 32
        return (n << d)|(m >> (INT_BITS - d))
  error: |-
    Traceback (most recent call last):
      File "script.py", line 3, in <module>
        main('100', 2)
      File "script.py", line 2, in main
        return (n << d)|(m >> (INT_BITS - d))
    TypeError: unsupported operand type(s) for <<: 'str' and 'int'
    NameError: name 'm' is not defined
  explanation: |-
    There are two issues with the code:

    1. The type of the parameter `n` has been changed from `int` to `str`, which is incorrect because the bitwise shift operators `<<` and `>>` are not supported for strings.

    2. The variable `m` is used in the expression `(m >> (INT_BITS - d))`, but `m` is not defined anywhere in the code. This will raise a `NameError` because `m` does not exist.
  id: |-
    hubfix_mbpp_py_799
  lang: |-
    python
  original_code: |-
    def main(n: int, d: int) -> int:
        INT_BITS = 32
        return (n << d)|(n >> (INT_BITS - d))
  original_instructions: |-
    that rotate left bits by d bits a given number. We assume that the number is 32 bit
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(x: int, y: str, z: int) -> float:
      result = set([x, y, z])
      if len(result) == 3:
        return "zero"
      else:
        return 4 - len(result)
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
    TypeError: unhashable type: 'list'
  explanation: |-
    The code is broken for several reasons:

    1. The type of the parameter `y` has been changed from `int` to `str`, which is inconsistent with the type hint in the function definition and could lead to a `TypeError` if a string is passed that cannot be added to a set with integers.

    2. The return type of the function has been changed from `int` to `float`, but the function returns a string `"zero"` in one case, which is not a float.

    3. The function is supposed to return an integer, but it returns a string `"zero"` when the length of the result set is 3, which will cause a `TypeError` because the return value does not match the specified return type.

    4. The error message indicates a `TypeError` with the message "unhashable type: 'list'", which is incorrect for the provided code. The actual error that would occur if a string were passed to the function would be related to the inability to create a set with mixed types (integers and strings) if the string is not hashable. However, since the code block does not include a call to the function with incorrect arguments, the provided error message does not match the code block. If the function were called with a string argument for `y`, the error message would be different and would reflect the issue with the unhashable type.
  id: |-
    hubfix_mbpp_py_801
  lang: |-
    python
  original_code: |-
    def main(x: int, y: int, z: int) -> int:
      result = set([x, y, z])
      if len(result) == 3:
        return 0
      else:
        return 4 - len(result)
  original_instructions: |-
    count the number of equal numbers from three given integers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums: List[str]) -> int:
      main = next((el for el in nums if el % 2 != 0), -1)
      return main
  error: |-
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the `main` function is expecting a list of integers (`List[int]`) as per the original type hint, but the type hint has been changed to `List[str]`, which indicates a list of strings. The list comprehension inside the `next` function attempts to perform a modulo operation (`el % 2`) on the elements of `nums`, which is not valid for strings. This results in a `TypeError` because the `%` operator cannot be used with strings in this context.
  id: |-
    hubfix_mbpp_py_807
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums: List[int]) -> int:
      main = next((el for el in nums if el % 2 != 0), -1)
      return main
  original_instructions: |-
    find the first odd number in a given list of numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: str, ch: int, newch: str) -> int:
        str2 = str1.replac(ch, newch)
        return str2
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
    AttributeError: 'str' object has no attribute 'replac'
  explanation: |-
    There are two issues in the provided code:

    1. The `replace` method is misspelled as `replac`, which is not a valid method for string objects in Python. This will raise an AttributeError because the `str` class does not have a method named `replac`.

    2. The type of the parameter `ch` is changed from `str` to `int`, which is not consistent with the intended use of the `replace` method. The `replace` method expects string arguments for both the substring to be replaced and the new substring.

    Additionally, the return type of the function is changed from `str` to `int`, which is incorrect because the function is supposed to return a string after the replacement, not an integer. However, this change in the return type annotation would not cause a runtime error, but it is still a semantic error in the context of the function's purpose.
  id: |-
    hubfix_mbpp_py_474
  lang: |-
    python
  original_code: |-
    def main(str1: str, ch: str, newch: str) -> str:
        str2 = str1.replace(ch, newch)
        return str2
  original_instructions: |-
    replace characters in a string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(m: int, n: str) -> int:
        T=[[0 for i in range(n+1)] for i in range(m+1)]
        for i in range(m+1):
            for j in range(n+1):
                if i==0 or j==0:
                    T[i][j]=0
                elif i<j:
                    T[i][j]=0
                elif j==1:
                    T[i][j]=i
                else:
                    T[i][j]=T[i-1][j]+T[i//2][j-1]
        return T[m][n]
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The code is broken because the type of the parameter `n` has been changed from `int` to `str`. This causes a TypeError when trying to perform the range operation `range(n+1)`, as you cannot add an integer to a string. The `range` function expects an integer argument, not a string.
  id: |-
    hubfix_mbpp_py_239
  lang: |-
    python
  original_code: |-
    def main(m: int, n: int) -> int:
        T=[[0 for i in range(n+1)] for i in range(m+1)]
        for i in range(m+1):
            for j in range(n+1):
                if i==0 or j==0:
                    T[i][j]=0
                elif i<j:
                    T[i][j]=0
                elif j==1:
                    T[i][j]=i
                else:
                    T[i][j]=T[i-1][j]+T[i//2][j-1]
        return T[m][n]
  original_instructions: |-
    takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from collections import nonexistentlibrary
    def main(s: str) -> int:
        n = len(s)
        count, sum = 0, 0
        mp = nonexistentlibrary(lambda: 0)
        mp[0] += 1
        for i in range(n):
            sum += ord(s[i]) - ord('0')
            count += mp[sum - (i + 1)]
            mp[sum - (i + 1)] += 1
        return count
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a module named `nonexistentlibrary` from the `collections` package, which does not exist. This causes a `ModuleNotFoundError` because Python cannot find a module with that name in the `collections` package or anywhere else in the Python standard library or installed third-party libraries.
  id: |-
    hubfix_mbpp_py_61
  lang: |-
    python
  original_code: |-
    from collections import defaultdict
    def main(s: str) -> int:
        n = len(s)
        count, sum = 0, 0
        mp = defaultdict(lambda: 0)
        mp[0] += 1
        for i in range(n):
            sum += ord(s[i]) - ord('0')
            count += mp[sum - (i + 1)]
            mp[sum - (i + 1)] += 1
        return count
  original_instructions: |-
    count the number of substrings with the sum of digits equal to their length
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def set_middle_bits(n: int) -> str:
        n |= n >> 1
        n |= n >> 2
        n |= n >> 4
        n |= n >> 8
        n |= n >> 16
        return (n >> 1) ^ "1"

    def main(n: str) -> int:
        if n == 1:
            return 1
        return n ^ set_middle_bits(n)
  error: |-
    TypeError: unsupported operand type(s) for ^: 'int' and 'str'
  explanation: |-
    The code is broken because of the following reasons:

    1. The return type of the function `set_middle_bits` has been changed from `int` to `str`, which is incorrect because the function is performing bitwise operations that should return an integer.

    2. The return statement in `set_middle_bits` is attempting to perform a bitwise XOR operation (`^`) between an integer (`n >> 1`) and a string (`"1"`), which is not allowed in Python as bitwise operations can only be performed between integers.

    3. The parameter type of `n` in the `main` function has been changed from `int` to `str`, which is incorrect because the function expects an integer to perform bitwise operations.

    4. The comparison `if n == 1:` is incorrect because `n` is now a string, and it is being compared to an integer, which will always evaluate to `False`.

    5. The return statement in `main` is attempting to perform a bitwise XOR operation between a string (`n`) and the result of `set_middle_bits(n)`, which is supposed to be an integer. This will also result in a TypeError because bitwise operations can only be performed between integers.
  id: |-
    hubfix_mbpp_py_735
  lang: |-
    python
  original_code: |-
    def set_middle_bits(n: int) -> int:
        n |= n >> 1
        n |= n >> 2
        n |= n >> 4
        n |= n >> 8
        n |= n >> 16
        return (n >> 1) ^ 1

    def main(n: int) -> int:
        if n == 1:
            return 1
        return n ^ set_middle_bits(n)
  original_instructions: |-
    toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib

    def main(ip: str) -> int:
        string = re.sub(r'\.(0+)', '.', ip)
        return string
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library named `nonexistentlib`, which does not exist. This will raise a `ModuleNotFoundError` when the script is run. Additionally, the return type of the `main` function has been changed to `int`, but the function still returns a string, which would cause a type error if the code execution reached that point.
  id: |-
    hubfix_mbpp_py_593
  lang: |-
    python
  original_code: |-
    import re

    def main(ip: str) -> str:
        string = re.sub(r'\.(0+)', '.', ip)
        return string
  original_instructions: |-
    remove leading zeroes from an ip address
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(n: str) -> str:
        x = math.sqrt(2 * math.pow(10, (n - 1)))
        return round(y)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The script tries to import a library called 'nonexistentlibrary', which does not exist.
    2. The parameter `n` is expected to be an `int`, but it has been changed to a `str` type, which will cause an error when trying to perform arithmetic operations with it.
    3. The variable `y` is used in the return statement, but it is not defined anywhere in the function.
    4. The return type of the function is changed to `str`, but the `round` function returns an `int`.
  id: |-
    hubfix_mbpp_py_739
  lang: |-
    python
  original_code: |-
    import math

    def main(n: int) -> int:
        x = math.sqrt(2 * math.pow(10, (n - 1)))
        return round(x)
  original_instructions: |-
    find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> bool:
        i = 1
        while (i * i <= n):
            if ((n % i == 0) and (n / i == i)):
                return True
            i = i + 1
        return False
  error: |-
    TypeError: '<=' not supported between instances of 'int' and 'str'
  explanation: |-
    The function `main` is now expecting a parameter `n` of type `str` (string) instead of `int` (integer). The comparison `i * i <= n` and the operations `n % i` and `n / i` are not valid when `n` is a string, as these operations are defined for numerical types. The TypeError is raised because the '<=' operator cannot be used to compare an integer and a string.
  id: |-
    hubfix_mbpp_py_803
  lang: |-
    python
  original_code: |-
    def main(n: int) -> bool:
        i = 1
        while (i * i <= n):
            if ((n % i == 0) and (n / i == i)):
                return True
            i = i + 1
        return False
  original_instructions: |-
    check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib
    from typing import AnyStr

    def broken_function(text: AnyStr) -> int:
        return nonexistentlib.fake_search(r'\Bz\B', text)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because of the following reasons:
    - The script tries to import a library called `nonexistentlib`, which does not exist.
    - The `main` function has been renamed to `broken_function`, which would not be an issue by itself, but if there is code elsewhere expecting a function named `main`, this would cause a problem.
    - The function `fake_search` is called on `nonexistentlib`, which does not exist since the library itself does not exist.
    - The return type of the function has been changed from `bool` to `int`, which is not consistent with the original functionality that returns a boolean value.
  id: |-
    hubfix_mbpp_py_643
  lang: |-
    python
  original_code: |-
    import re
    from typing import AnyStr

    def main(text: AnyStr) -> bool:
        return bool(re.search(r'\Bz\B', text))
  original_instructions: |-
    checks if a strings contains 'z', except at the start and end of the word
  resource_type: null
  resource_type_def: null
- broken_code: "def main(arr: list) -> str:\n    inv_count = 0\n    for i in range(len(arr)):\n\
    \        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n\
    \                inv_count += \"1\"\n    return inv_count "
  error: |-
    TypeError: unsupported operand type(s) for +=: 'int' and 'str'
  explanation: |-
    The code is trying to add a string "1" to an integer `inv_count`, which is not allowed in Python. Python does not support adding a string to an integer, hence it throws a TypeError. Additionally, the return type of the function is declared as `str` but should be `int` since the function is supposed to return the count of inversions as an integer.
  id: |-
    hubfix_mbpp_py_296
  lang: |-
    python
  original_code: "def main(arr: list) -> int:\n    inv_count = 0\n    for i in range(len(arr)):\n\
    \        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n\
    \                inv_count += 1\n    return inv_count "
  original_instructions: |-
    count inversions in an array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(test_list: List[int]) -> str:
      res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len(test_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))])
      return res
  error: |-
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken because of two changes:

    1. The type of `test_list` parameter in the `main` function has been changed from `List[str]` to `List[int]`. This change causes the `reversed` function to fail because it expects an iterable, and integers are not iterable.

    2. The return type of the `main` function has been changed from `int` to `str`, but the function still returns an integer value (`res`). This would not cause an immediate runtime error, but it is incorrect according to the type hinting and could lead to errors if the function is used in a context where a string is expected.
  id: |-
    hubfix_mbpp_py_757
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(test_list: List[str]) -> int:
      res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len(test_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))])
      return res
  original_instructions: |-
    count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[str, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(a * b for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup3))
        return res
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main(((1, 2), (3, 4)), ((5, 6), (7, 8)))
      File "script.py", line Y, in main
        for tup1, tup2 in zip(test_tup1, test_tup3))
    NameError: name 'test_tup3' is not defined
  explanation: |-
    The code is broken because of two issues:

    1. The type of `test_tup2` is changed to `Tuple[Tuple[str, ...], ...]`, which is incorrect because the function is supposed to multiply integers, not strings. This would cause a type error if type checking is enforced or if the function is called with a tuple containing strings.

    2. The variable `test_tup3` is used in the zip function, but it is not defined anywhere in the code. This causes a `NameError` because Python cannot find a definition for `test_tup3`.
  id: |-
    hubfix_mbpp_py_445
  lang: |-
    python
  original_code: |-
    from typing import Tuple

    def main(test_tup1: Tuple[Tuple[int, ...], ...], test_tup2: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
        res = tuple(tuple(a * b for a, b in zip(tup1, tup2))
                    for tup1, tup2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    perform index wise multiplication of tuple elements in the given two tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_tup1: tuple, test_tup2: list) -> tuple:
        res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res

    main({1, 2, 3}, [4, 5, 6])
  error: |-
    TypeError: unsupported operand type(s) for &: 'int' and 'int'
  explanation: |-
    The code is attempting to use the bitwise AND operator (&) on two integers. This operator is meant to be used with sets, not integers. Additionally, the type hint for `test_tup2` was changed from `tuple` to `list`, which is not necessarily a breaking change by itself, but it does not match the original intention of the function to work with tuples. The function is called with a set and a list, which is not consistent with the type hints provided, and the use of the bitwise AND operator on integers is incorrect in this context.
  id: |-
    hubfix_mbpp_py_429
  lang: |-
    python
  original_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    extract the elementwise and tuples from the given two tuples
  resource_type: null
  resource_type_def: null
- broken_code: "def main(n: str) -> int:\n    count = 0\n    while (n):\n        count\
    \ += n & 1\n        n >>= \"1\"\n    return count "
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main("1001")
      File "script.py", line Y, in main
        count += n & 1
    TypeError: unsupported operand type(s) for &: 'str' and 'int'
  explanation: |-
    The code is broken because the parameter `n` is expected to be an integer as per the original function's type hint, but it has been changed to a string type (`n: str`). Additionally, the right shift operator (`>>=`) is being applied to a string with another string as the operand, which is not a valid operation in Python. The bitwise AND operation (`&`) is also being used between a string and an integer, which is not valid. These changes result in a `TypeError` because these operations are not supported between strings and integers.
  id: |-
    hubfix_mbpp_py_224
  lang: |-
    python
  original_code: "def main(n: int) -> int:\n    count = 0\n    while (n):\n      \
    \  count += n & 1\n        n >>= 1\n    return count "
  original_instructions: |-
    count the number of set bits (binary digits with value 1) in a given number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any

    def main(list1: List[Any]) -> List[List[Any]]:
        if len(list1) == 0:
            return [[]]
        result = []
        for el in main(list1[1:]):
            result += [el, el+[undefined_variable]]
        return result
  error: |-
    NameError: name 'undefined_variable' is not defined
  explanation: |-
    The code is trying to use a variable named `undefined_variable` which has not been defined anywhere in the script. This results in a `NameError` because Python cannot find a reference to a variable with that name.
  id: |-
    hubfix_mbpp_py_462
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(list1: List[Any]) -> List[List[Any]]:
        if len(list1) == 0:
            return [[]]
        result = []
        for el in main(list1[1:]):
            result += [el, el+[list1[0]]]
        return result
  original_instructions: |-
    find all possible combinations of the elements of a given list
  resource_type: null
  resource_type_def: null
- broken_code: "def main(n: str) -> int:\n    bell = [[0 for i in range(n+1)] for\
    \ j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0]\
    \ = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] =\
    \ bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0] "
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The code is broken because the parameter `n` is now expected to be a string (`n: str`) instead of an integer. When `range(n+1)` is called, it tries to add an integer (`1`) to a string (`n`), which is not allowed in Python and results in a `TypeError`. The function's logic requires `n` to be an integer to correctly create the ranges and calculate the Bell numbers.
  id: |-
    hubfix_mbpp_py_67
  lang: |-
    python
  original_code: "def main(n: int) -> int:\n    bell = [[0 for i in range(n+1)] for\
    \ j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0]\
    \ = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] =\
    \ bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0] "
  original_instructions: |-
    find the number of ways to partition a set of Bell numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(list1: List[str]) -> str:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even * first_odd
  error: |-
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the function `main` is now expecting a list of strings (`List[str]`) instead of a list of integers (`List[int]`). The `%` operator is used for modulus operations with integers, but when used with a string, it attempts to perform string formatting, which is not the intended operation here. Additionally, the return type of the function is changed to `str`, but the function is still returning an integer (the product of `first_even` and `first_odd`), which is another inconsistency in the code.
  id: |-
    hubfix_mbpp_py_784
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(list1: List[int]) -> int:
        first_even = next((el for el in list1 if el % 2 == 0), -1)
        first_odd = next((el for el in list1 if el % 2 != 0), -1)
        return first_even * first_odd
  original_instructions: |-
    find the product of first even and odd number of a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any

    def main(A: List[Any], x: Any) -> str:
        (left, right) = (0, len(A) - 1)
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if x == A[mid]:
                result = mid
                right = mid - 1
            elif x < A[mid]:
                right = mid - 1
            else:
                left = mid + 1
        return result
  error: |-
    TypeError: 'int' object cannot be interpreted as an integer
  explanation: |-
    The error message provided does not match the actual error that would occur given the code changes. The correct error message would be related to the return type of the function. Since the function is annotated to return a `str` but actually returns an `int` (`result = -1` or `result = mid`), a type checker like `mypy` would raise an error. However, Python's runtime does not enforce type annotations, so this code would not produce a runtime error but would fail static type checking.

    The correct error message from a type checker like `mypy` would be something like:
    ```
    error: Incompatible return value type (got "int", expected "str")
    ```
  id: |-
    hubfix_mbpp_py_733
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(A: List[Any], x: Any) -> int:
        (left, right) = (0, len(A) - 1)
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if x == A[mid]:
                result = mid
                right = mid - 1
            elif x < A[mid]:
                right = mid - 1
            else:
                left = mid + 1
        return result
  original_instructions: |-
    find the index of the first occurrence of a given number in a sorted array
  resource_type: null
  resource_type_def: null
- broken_code: "def main(a: float, b: str, c: float) -> float:\n      if (a <= b)\
    \ and (a <= c):\n        smallest = a\n      elif (b <= a) and (b <= c):\n   \
    \     smallest = b\n      else:\n        smallest = c\n      return smallest "
  error: |-
    TypeError: '<=' not supported between instances of 'float' and 'str'
  explanation: |-
    The code is broken because the type of parameter `b` has been changed from `float` to `str`, which means that the comparison `a <= b` is attempting to compare a float with a string, which is not allowed in Python. Python cannot compare these two different types with the '<=' operator, leading to a TypeError.
  id: |-
    hubfix_mbpp_py_227
  lang: |-
    python
  original_code: "def main(a: float, b: float, c: float) -> float:\n      if (a <=\
    \ b) and (a <= c):\n        smallest = a\n      elif (b <= a) and (b <= c):\n\
    \        smallest = b\n      else:\n        smallest = c\n      return smallest "
  original_instructions: |-
    find minimum of three numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(arr: List[str], number: int) -> str:
      arr.sort()
      return number > arr[-1]
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main(["1", "2", "3"], 2)
      File "script.py", line 4, in main
        return number > arr[-1]
    TypeError: '>' not supported between instances of 'int' and 'str'
  explanation: |-
    The code is broken because the `main` function now expects a list of strings (`List[str]`) instead of a list of integers (`List[int]`). The comparison `number > arr[-1]` is trying to compare an integer (`number`) with a string (`arr[-1]`), which is not allowed in Python. Additionally, the return type of the function is changed to `str`, but the function is still returning a boolean value, which is incorrect and could lead to further errors if the return value is used elsewhere in the code expecting a string.
  id: |-
    hubfix_mbpp_py_433
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(arr: List[int], number: int) -> bool:
      arr.sort()
      return number > arr[-1]
  original_instructions: |-
    check whether the entered number is greater than the elements of the given array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(list1: list, list2: set) -> int:
        result = [x for x in list1 if x not in list3]
        return result
  error: |-
    NameError: name 'list3' is not defined
  explanation: |-
    The code is trying to reference a variable `list3` which has not been defined anywhere in the code. This results in a `NameError` because Python cannot find a definition for the variable `list3` when it is used in the list comprehension. Additionally, the function's signature has been changed to expect `list2` to be a `set` instead of a `list`, and the return type is incorrectly specified as `int` when the function actually returns a `list`.
  id: |-
    hubfix_mbpp_py_161
  lang: |-
    python
  original_code: |-
    def main(list1: list, list2: list) -> list:
        result = [x for x in list1 if x not in list2]
        return result
  original_instructions: |-
    remove all elements from a given list present in another list
  resource_type: null
  resource_type_def: null
- broken_code: "from typing import List\n\ndef main(arr: List[str], n: int) -> str:\n\
    \    arr = sorted(arr)\n    diff = 10**20\n    for i in range(n):\n        if\
    \ arr[i+1] - arr[i] < diff:\n            diff = arr[i+1] - arr[i]\n    return\
    \ diff "
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main(["1", "2", "3"], 3)
      File "script.py", line Y, in main
        if arr[i+1] - arr[i] < diff:
    TypeError: unsupported operand type(s) for -: 'str' and 'str'
  explanation: |-
    The code is broken for several reasons:

    1. The function parameter `arr` is now expected to be a list of strings (`List[str]`), but the subtraction operation is not supported between strings. This causes a `TypeError` when trying to subtract two elements of the list.

    2. The return type of the function is changed to `str`, but the function is still returning an integer (`diff`), which is inconsistent with the declared return type.

    3. The loop range is changed from `range(n-1)` to `range(n)`, which will cause an `IndexError` when `i` is `n-1` because `arr[i+1]` will be out of bounds. However, this error will not be reached because the `TypeError` will occur first.
  id: |-
    hubfix_mbpp_py_763
  lang: |-
    python
  original_code: "from typing import List\n\ndef main(arr: List[int], n: int) -> int:\n\
    \    arr = sorted(arr)\n    diff = 10**20\n    for i in range(n-1):\n        if\
    \ arr[i+1] - arr[i] < diff:\n            diff = arr[i+1] - arr[i]\n    return\
    \ diff "
  original_instructions: |-
    find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib

    def main(text: int) -> str:
        patterns = 'ab+?'
        if nonexistentlib.search(patterns, text):
            return "True"
        else:
            return False
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because of the following reasons:
    1. The script is trying to import a library named 'nonexistentlib', which does not exist.
    2. The `main` function is expecting an integer (`int`) as its parameter instead of a string (`str`), which is not suitable for regex operations.
    3. The `search` function is being called on the non-existent 'nonexistentlib' library instead of the 're' library.
    4. The return type of the function is supposed to be `bool`, but it is returning a string `"True"` in one case and a boolean `False` in the other.
  id: |-
    hubfix_mbpp_py_756
  lang: |-
    python
  original_code: |-
    import re
    def main(text: str) -> bool:
            patterns = 'ab+?'
            if re.search(patterns,  text):
                    return True
            else:
                    return False
  original_instructions: |-
    matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s: int) -> str:
            return ' '.join(reversed(s.split()))
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in main
    AttributeError: 'int' object has no attribute 'split'
  explanation: |-
    The function `main` is expecting an integer (`int`) as its parameter due to the type hint `s: int`, but it is trying to call the `split` method on it, which is a method that exists only for strings (`str`). Since integers do not have a `split` method, this results in an `AttributeError`.
  id: |-
    hubfix_mbpp_py_604
  lang: |-
    python
  original_code: |-
    def main(s: str) -> str:
            return ' '.join(reversed(s.split()))
  original_instructions: |-
    reverse words seperated by spaces in a given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple
    from operator import itemgetter

    def main(test_list: List[Tuple[str, int]]) -> str:
        res = min(test_list, key=itemgetter(2))[0]
        return res
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main([(1, 2), (3, 1)])
      File "script.py", line 4, in main
        res = min(test_list, key=itemgetter(2))[0]
    IndexError: tuple index out of range
  explanation: |-
    The code is broken because of two changes:

    1. The type hint for the `test_list` parameter has been changed from `List[Tuple[int, int]]` to `List[Tuple[str, int]]`. This change implies that the function now expects a list of tuples where the first element is a string, which is not consistent with the provided examples that contain integers as the first element of the tuples.

    2. The `itemgetter(2)` function is used to retrieve the third element of each tuple in the list, but the tuples in the provided examples only have two elements. This results in an `IndexError` because there is no third element in the tuples to retrieve.

    To fix the code, the type hint for `test_list` should be reverted to `List[Tuple[int, int]]`, and `itemgetter(1)` should be used to access the second element of the tuples, which exists in the provided examples.
  id: |-
    hubfix_mbpp_py_94
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple
    from operator import itemgetter

    def main(test_list: List[Tuple[int, int]]) -> int:
        res = min(test_list, key=itemgetter(1))[0]
        return res
  original_instructions: |-
    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s: int) -> str:
      result = ""
      for i in range(len(s)):
        if i % 2 == 0:
          result = result + s[i]
      return result
  error: |-
    TypeError: object of type 'int' has no len()
  explanation: |-
    The function `main` is now expecting an integer (`int`) as its parameter instead of a string (`str`). Since integers do not have a length, calling `len(s)` where `s` is an integer will result in a `TypeError`. The code is expecting `s` to be a sequence like a string, which has a length and can be indexed, but an integer does not satisfy these properties.
  id: |-
    hubfix_mbpp_py_226
  lang: |-
    python
  original_code: |-
    def main(s: str) -> str:
      result = ""
      for i in range(len(s)):
        if i % 2 == 0:
          result = result + s[i]
      return result
  original_instructions: |-
    remove the characters which have odd index values of a given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]], N: str) -> Any:
        res = max(sub[N] for sub in test_list)
        return res
  error: |-
    TypeError: list indices must be integers or slices, not str
  explanation: |-
    The function `main` is expecting an integer `N` to access an element at index `N` in the sublists of `test_list`. However, the type of `N` has been changed to `str` (string), which is not a valid type for list indices. When the function tries to use a string to index a list, Python raises a `TypeError` because it expects an integer or a slice.
  id: |-
    hubfix_mbpp_py_611
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]], N: int) -> Any:
        res = max(sub[N] for sub in test_list)
        return res
  original_instructions: |-
    Write a function which given a matrix represented as a list of lists returns the max of the n'th column
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any

    def main(nestedlist: List[List[Any]]) -> List[Any]:
        result = list(set.union(*map(set, nestedlist)))
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main([[1, 2], [2, 3], [3, 4]])
      File "script.py", line 4, in main
        result = list(set.union(*map(set, nestedlist)))
    TypeError: descriptor 'union' for 'set' objects doesn't apply to a 'map' object
  explanation: |-
    The code is attempting to use the `set.union` method in a way that is not supported. The `set.union` method is an instance method that should be called on a set instance, not directly on the `set` class itself. The original code used `set.intersection`, which was correctly used with the `*` operator to unpack the argument list. By changing `intersection` to `union`, the code is now trying to call a method that expects a set instance as the first argument, but it's being passed a `map` object instead. This results in a `TypeError`.
  id: |-
    hubfix_mbpp_py_111
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(nestedlist: List[List[Any]]) -> List[Any]:
        result = list(set.intersection(*map(set, nestedlist)))
        return result
  original_instructions: |-
    find the common elements in given nested lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s: int) -> bool:
        n = length(s)
        for i in range(1, n):
            if s[i] != s[0]:
                return False
        return True
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        n = length(s)
    NameError: name 'length' is not defined
  explanation: |-
    The code is broken because of two reasons:

    1. The function `length` does not exist in Python. The correct function to get the length of a sequence is `len`.
    2. The type hint for the parameter `s` has been changed from `str` to `int`. This means that the function now expects an integer instead of a string, which is incorrect because the function is designed to work with strings (it tries to access `s[i]`, which assumes `s` is a sequence type like a string or list).
  id: |-
    hubfix_mbpp_py_741
  lang: |-
    python
  original_code: |-
    def main(s: str) -> bool:
        n = len(s)
        for i in range(1, n):
            if s[i] != s[0]:
                return False
        return True
  original_instructions: |-
    check whether all the characters are same or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        return 4 * n * n - 3 * m
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
      File "<stdin>", line 2, in main
    TypeError: can't multiply sequence by non-int of type 'str'
  explanation: |-
    The code is broken because of two reasons:

    1. The parameter `n` is expected to be an integer as per the original function definition, but the type hint has been changed to `str` (string). Multiplying a string with a number attempts to repeat the string, but since `n` is also expected to be used in a mathematical operation (`n * n`), this results in a TypeError because Python cannot multiply two strings in this way.

    2. The variable `m` is used in the expression `3 * m`, but it is not defined anywhere in the function. This would result in a NameError because Python does not know what `m` refers to.
  id: |-
    hubfix_mbpp_py_279
  lang: |-
    python
  original_code: "def main(n: int) -> int:\n    return 4 * n * n - 3 * n "
  original_instructions: |-
    find the nth decagonal number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_tup: list) -> str:
        for count, ele in enumerate(test_tup):
            if isinstance(ele, tuple):
                break
        return cnt
  error: |-
    NameError: name 'cnt' is not defined
  explanation: |-
    The code is broken for several reasons:

    1. The function parameter `test_tup` is annotated as a `list` instead of a `tuple`, which is not necessarily a breaking change but does not match the original intent of the function.
    2. The return type of the function is changed to `str` from `int`, which is incorrect because the function is supposed to return an integer (`count`).
    3. The variable `cnt` is returned, but it is not defined anywhere in the function. The correct variable name should be `count`.
  id: |-
    hubfix_mbpp_py_278
  lang: |-
    python
  original_code: |-
    def main(test_tup: tuple) -> int:
        for count, ele in enumerate(test_tup):
            if isinstance(ele, tuple):
                break
        return count
  original_instructions: |-
    find the number of elements that occurs before the tuple element in the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_str: int) -> str:
      res = ''
      dig = ''
      for ele in test_str:
        if ele.isnumeric():
          dig += ele
        else:
          res += ele
      res += dig
      return res

    main(12345)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 11, in <module>
        main(12345)
      File "script.py", line 4, in main
        for ele in test_str:
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken because the `main` function is expecting an integer as its parameter due to the type hint `test_str: int`, but it should be expecting a string since the function is designed to iterate over the characters of the input. In Python, integers are not iterable, which means you cannot use a for loop to iterate over the digits of an integer as if it were a string or a list. Additionally, the `main` function is called with an integer argument `main(12345)`, which is not the correct type for the original function design. The function should be called with a string argument instead, like `main("12345")`.
  id: |-
    hubfix_mbpp_py_619
  lang: |-
    python
  original_code: |-
    def main(test_str: str) -> str:
      res = ''
      dig = ''
      for ele in test_str:
        if ele.isdigit():
          dig += ele
        else:
          res += ele
      res += dig
      return res
  original_instructions: |-
    move all the numbers to the end of the given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a: float, b: str, c: float) -> str:
        directrix = str(c - ((b * b) + 1) * 4 * a)
        return directrix
  error: |-
    TypeError: can't multiply sequence by non-int of type 'str'
  explanation: |-
    The code is broken because the variable `b` is now expected to be of type `str` (string), but the operation `b * b` attempts to multiply a string by itself, which is not a valid operation for the context of the original code that expects `b` to be a numeric type (such as `int` or `float`). Additionally, the return type of the function has been changed to `str`, but the function is supposed to return an `int` according to the original specification.
  id: |-
    hubfix_mbpp_py_430
  lang: |-
    python
  original_code: |-
    def main(a: float, b: float, c: float) -> int:
        directrix = int(c - ((b * b) + 1) * 4 * a)
        return directrix
  original_instructions: |-
    find the directrix of a parabola
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib

    def main(text1: int) -> int:
      return re.sub(r'\s+', '', text1)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because it tries to import a library named 'nonexistentlib', which does not exist. Additionally, the `main` function is expecting an integer as an argument and also returning an integer, which is incorrect because the `re.sub` function expects a string as the second argument and returns a string, not an integer.
  id: |-
    hubfix_mbpp_py_451
  lang: |-
    python
  original_code: |-
    import re
    def main(text1: str) -> str:
      return re.sub(r'\s+', '', text1)
  original_instructions: |-
    remove all whitespaces from the given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        sum = 0
        for i in range(1, n + 1):
            sum += (2*i)**3
        return sum

    main("ten")
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        main("ten")
      File "script.py", line 4, in main
        for i in range(1, n + 1):
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The code is broken because the `main` function is defined to take an integer parameter `n`, but it is being called with a string argument `"ten"`. Additionally, the type hint for the parameter `n` has been changed from `int` to `str`, which is incorrect given the context of the function. The `range` function expects integer arguments, but because `n` is a string, the expression `n + 1` results in a `TypeError` as it tries to concatenate an integer to a string.
  id: |-
    hubfix_mbpp_py_420
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        sum = 0
        for i in range(1, n + 1):
            sum += (2*i)**3
        return sum
  original_instructions: |-
    find the cube sum of first n even natural numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    def main(degree: str) -> float:
        radian = degree * (math.pi / 180)
        return radian
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, the function `main` is expecting a string as a parameter (`degree: str`) instead of a float, which will cause a TypeError when trying to multiply a string by a number if the function is called with a string argument.
  id: |-
    hubfix_mbpp_py_606
  lang: |-
    python
  original_code: |-
    import math
    def main(degree: float) -> float:
        radian = degree * (math.pi / 180)
        return radian
  original_instructions: |-
    convert degrees to radians
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlib
    from typing import List

    def broken_function(num1: List[int], num2: List[int], num3: List[str]) -> List[int]:
        num1 = sorted(num1)
        num2 = sorted(num2)
        num3 = sorted(num3)
        result = heapq.merg(num1, num2, num3)
        return list(result)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library called `nonexistentlib`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, there is a typo in the function call `heapq.merg` which should be `heapq.merge`. Furthermore, the `num3` parameter is expected to be a list of integers (`List[int]`), but it is incorrectly typed as a list of strings (`List[str]`). This would cause a type error if the `ModuleNotFoundError` was resolved and the code was executed.
  id: |-
    hubfix_mbpp_py_108
  lang: |-
    python
  original_code: |-
    import heapq
    from typing import List

    def main(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:
        num1 = sorted(num1)
        num2 = sorted(num2)
        num3 = sorted(num3)
        result = heapq.merge(num1, num2, num3)
        return list(result)
  original_instructions: |-
    merge three lists into a single sorted list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup3))
        return res
  error: |-
    NameError: name 'test_tup3' is not defined
  explanation: |-
    The variable `test_tup3` is used in the list comprehension inside the `tuple()` constructor, but it is not defined anywhere in the code. The original code used `test_tup2`, which is a parameter of the function `main`. By changing `test_tup2` to `test_tup3`, the code now references a variable that does not exist, causing a `NameError`.
  id: |-
    hubfix_mbpp_py_261
  lang: |-
    python
  original_code: |-
    def main(test_tup1: tuple, test_tup2: tuple) -> tuple:
        res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
        return res
  original_instructions: |-
    takes in two tuples and performs mathematical division operation element-wise across the given tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(number: str) -> int:
        sum = 0
        times = 0
        temp = number
        while temp > 0:
            times = times + 1
            temp = temp // 10
        temp = number
        while temp > 0:
            reminder = temp % 10
            sum = sum + (reminder ** times)
            temp //= 10
        if number == sum:
            return "True"
        else:
            return False
  error: |-
    TypeError: '>' not supported between instances of 'str' and 'int'
  explanation: |-
    The code is broken because the `number` parameter type was changed from `int` to `str`, which means that the arithmetic operations and comparisons that are valid for integers are not valid for strings. Specifically, the `while temp > 0:` line will raise a TypeError because it is trying to compare a string to an integer. Additionally, the return type of the function was changed to `int`, but the function is returning a string `"True"` in one case, which is inconsistent with the declared return type.
  id: |-
    hubfix_mbpp_py_598
  lang: |-
    python
  original_code: |-
    def main(number: int) -> bool:
        sum = 0
        times = 0
        temp = number
        while temp > 0:
            times = times + 1
            temp = temp // 10
        temp = number
        while temp > 0:
            reminder = temp % 10
            sum = sum + (reminder ** times)
            temp //= 10
        if number == sum:
            return True
        else:
            return False
  original_instructions: |-
    check whether the given number is armstrong or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any, Set

    def main(test_list: List[List[Any]]) -> List[Any]:
        res: List[Any] = []
        temp: Set[Any] = set()
        for inner in test_list:
            for ele in inner:
                if ele not in temp:
                    temp.add(ele)
                    res.append(ele)
        return res

    main([[1, 2], [2, 3], [4, 5]])
    print(non_existent_variable)
  error: |-
    NameError: name 'non_existent_variable' is not defined
  explanation: |-
    The code attempts to print a variable named `non_existent_variable`, which has not been defined anywhere in the script. This results in a `NameError` because Python cannot find a reference to a variable with that name.
  id: |-
    hubfix_mbpp_py_140
  lang: |-
    python
  original_code: |-
    from typing import List, Any, Set

    def main(test_list: List[List[Any]]) -> List[Any]:
        res: List[Any] = []
        temp: Set[Any] = set()
        for inner in test_list:
            for ele in inner:
                if ele not in temp:
                    temp.add(ele)
                    res.append(ele)
        return res
  original_instructions: |-
    flatten the list of lists into a single set of numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(M: List[List[str]]) -> List[List[int]]:
        result = sorted(M, key=total)
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        result = sorted(M, key=total)
    NameError: name 'total' is not defined
  explanation: |-
    The code is broken for two reasons:

    1. The type hint for the parameter `M` has been changed from `List[List[int]]` to `List[List[str]]`, which is incorrect if we expect a list of lists of integers to be passed to the function.

    2. The `key` argument in the `sorted` function is set to `total`, which is not defined anywhere in the code. The original code used `sum`, which is a built-in Python function. The name `total` does not correspond to any built-in function or any function defined in the script, leading to a `NameError`.
  id: |-
    hubfix_mbpp_py_12
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(M: List[List[int]]) -> List[List[int]]:
        result = sorted(M, key=sum)
        return result
  original_instructions: |-
    sort a given matrix in ascending order according to the sum of its rows
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        a = 3
        b = 0
        c = 2
        if n == 0:
            return 3
        if n == 1:
            return 3
        if n == 2:
            return 5
        sum = 5
        while n > 2:
            d = a + b
            sum = sum + d
            a = b
            b = c
            c = d
            n = n - 1
        return sum
  error: |-
    TypeError: '>' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `str` (string), but it is used in a context where an integer is expected (`while n > 2:`). The comparison operator `>` cannot be used between a string and an integer, which causes a `TypeError` when the code is executed.
  id: |-
    hubfix_mbpp_py_448
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
        a = 3
        b = 0
        c = 2
        if n == 0:
            return 3
        if n == 1:
            return 3
        if n == 2:
            return 5
        sum = 5
        while n > 2:
            d = a + b
            sum = sum + d
            a = b
            b = c
            c = d
            n = n - 1
        return sum
  original_instructions: |-
    calculate the sum of perrin numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from operator import ne
    from typing import List

    def main(nums1: List[int], nums2: List[str]) -> str:
        result = sum(map(ne, nums1, nums2))
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main([1, 2], ['1', '2'])
      File "script.py", line Y, in main
        result = sum(map(ne, nums1, nums2))
    TypeError: unsupported operand type(s) for +: 'int' and 'bool'
  explanation: |-
    The code is broken for several reasons:

    1. The `ne` function from the `operator` module is used instead of `eq`. `ne` checks for inequality, which returns a boolean value, and summing boolean values is not the intended behavior of the original code.

    2. The type hint for `nums2` is changed from `List[int]` to `List[str]`, which means the function now expects a list of strings as the second argument instead of a list of integers.

    3. The return type of the function is changed from `int` to `str`, which is incorrect because the `sum` function returns an integer, not a string.

    4. The error message indicates that the `sum` function cannot add boolean values returned by `map(ne, nums1, nums2)` because `ne` returns a boolean value, and `sum` expects numerical values (integers or floats) to add together.
  id: |-
    hubfix_mbpp_py_723
  lang: |-
    python
  original_code: |-
    from operator import eq
    from typing import List

    def main(nums1: List[int], nums2: List[int]) -> int:
        result = sum(map(eq, nums1, nums2))
        return result
  original_instructions: |-
    The input is defined as two lists of the same length. count indices where the lists have the same values
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(test_tup: list) -> list:
        res: tuple = tuple()
        for count, ele in enumerate(test_tup):
            if not isinstance(ele, tuple):
                res = res + (ele, )
        return res
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main((1, 2, (3, 4)))
      File "script.py", line 2, in main
        def main(test_tup: list) -> list:
    TypeError: 'list' object cannot be interpreted as an integer
  explanation: |-
    The code is broken because the type hint for the `test_tup` parameter has been changed from `tuple` to `list`, which is not an error by itself, but it is misleading since the function is designed to work with tuples. The return type has also been changed from `tuple` to `list`, which is incorrect because the function still returns a tuple. The error message provided is a generic one and may not exactly match the error that would occur, but the main issue is that the function's type hints are now misleading and do not match the actual types being used and returned by the function.
  id: |-
    hubfix_mbpp_py_791
  lang: |-
    python
  original_code: |-
    def main(test_tup: tuple) -> tuple:
        res: tuple = tuple()
        for count, ele in enumerate(test_tup):
            if not isinstance(ele, tuple):
                res = res + (ele, )
        return res
  original_instructions: |-
    remove tuples from the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple

    def main(nums: List[Tuple[float, ...]]) -> List[str]:
        result = [sum(x) / len(y) for x in zip(*nums)]
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main([(1.0, 2.0), (3.0, 4.0)])
      File "script.py", line 4, in main
        result = [sum(x) / len(y) for x in zip(*nums)]
      File "script.py", line 4, in <listcomp>
        result = [sum(x) / len(y) for x in zip(*nums)]
    NameError: name 'y' is not defined
  explanation: |-
    The code is broken because of two reasons:

    1. The variable `y` is used in the list comprehension `len(y)` but it is not defined anywhere in the code. This will raise a `NameError` because Python does not know what `y` refers to.

    2. The return type of the function is specified as `List[str]` in the function signature, but the actual return value is a list of floats (`List[float]`). This is a type hint error and would not cause a runtime error, but it is incorrect and would be flagged by static type checkers like `mypy`.
  id: |-
    hubfix_mbpp_py_615
  lang: |-
    python
  original_code: |-
    from typing import List, Tuple

    def main(nums: List[Tuple[float, ...]]) -> List[float]:
        result = [sum(x) / len(x) for x in zip(*nums)]
        return result
  original_instructions: |-
    Write a function which takes a tuple of tuples and returns the average value for each tuple as a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from itertools import combination
    from typing import List, Tuple

    def main(test_list: List[Tuple[int, str]]) -> List[Tuple[int, int]]:
        res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combination(test_list, 2)]
        return res
  error: |-
    Traceback (most recent call last):
      File "script.py", line 1, in <module>
        from itertools import combination
    ImportError: cannot import name 'combination' from 'itertools' (unknown location)
  explanation: |-
    The code is broken because of two issues:

    1. The `itertools` module does not have a function named `combination`. The correct function name is `combinations`, so the import statement should be `from itertools import combinations`.

    2. The type hint for the `test_list` parameter in the `main` function has been changed from `List[Tuple[int, int]]` to `List[Tuple[int, str]]`, which is incorrect based on the operation performed inside the list comprehension. The list comprehension is adding the elements of the tuples, which assumes that both elements are integers. If one of the elements is a string, the addition operation will fail.
  id: |-
    hubfix_mbpp_py_780
  lang: |-
    python
  original_code: |-
    from itertools import combinations
    from typing import List, Tuple

    def main(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
        res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]
        return res
  original_instructions: |-
    find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/
  resource_type: null
  resource_type_def: null
- broken_code: "def main(n: str) -> int:\n    return 3 * n * n - 2 * n "
  error: |-
    TypeError: can't multiply sequence by non-int of type 'str'
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `str` (string), but it attempts to perform arithmetic multiplication on it, which is not valid for strings. The function should take an `int` as its parameter to work correctly with the arithmetic operations.
  id: |-
    hubfix_mbpp_py_59
  lang: |-
    python
  original_code: "def main(n: int) -> int:\n    return 3 * n * n - 2 * n "
  original_instructions: |-
    find the nth octagonal number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(length: str) -> list:
        main = [{} for _ in range(size)]
        return main
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        main = [{} for _ in range(size)]
    NameError: name 'size' is not defined
  explanation: |-
    There are two issues with the code:
    1. The parameter `length` is expected to be an `int`, but it has been changed to `str`, which will cause a `TypeError` if a string is passed to the `range` function.
    2. The variable `size` is used inside the list comprehension, but it is not defined anywhere in the code. The correct variable to use is `length`, which is the parameter of the `main` function.
  id: |-
    hubfix_mbpp_py_568
  lang: |-
    python
  original_code: |-
    def main(length: int) -> list:
        main = [{} for _ in range(length)]
        return main
  original_instructions: |-
    create a list of N empty dictionaries
  resource_type: null
  resource_type_def: null
- broken_code: "from typing import List\n\ndef main(newList: List) -> List:\n    size\
    \ = len(newList)\n    temp = newList[0]\n    newList[0] = newList[size]\n    newList[size\
    \ - 1] = temp\n    return newList "
  error: |-
    IndexError: list index out of range
  explanation: |-
    The code is trying to access `newList[size]`, which is an index out of the range of the list. Lists in Python are zero-indexed, so the last valid index is `size - 1`. Accessing `newList[size]` attempts to get an element one position beyond the last, which does not exist, hence the `IndexError`.
  id: |-
    hubfix_mbpp_py_591
  lang: |-
    python
  original_code: "from typing import List\n\ndef main(newList: List) -> List:\n  \
    \  size = len(newList)\n    temp = newList[0]\n    newList[0] = newList[size -\
    \ 1]\n    newList[size - 1] = temp\n    return newList "
  original_instructions: |-
    interchange the first and last elements in a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
      if n == 0:
        return 0
      else:
        return n % 10 + main(int(n / 10))
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main("123")
      File "script.py", line Y, in main
        return n % 10 + main(int(n / 10))
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the parameter `n` is now expected to be of type `str` (string), but the function is trying to perform arithmetic operations on it as if it were an `int` (integer). Specifically, the modulo operation (`%`) and division (`/`) are not defined for strings and integers together. Additionally, the comparison `n == 0` is also incorrect because `n` is a string and cannot be directly compared to an integer. The function's signature and the operations within it are inconsistent with the type of `n`.
  id: |-
    hubfix_mbpp_py_566
  lang: |-
    python
  original_code: |-
    def main(n: int) -> int:
      if n == 0:
        return 0
      else:
        return n % 10 + main(int(n / 10))
  original_instructions: |-
    get the sum of the digits of a non-negative integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> list:
        ludics = []
        for i in range(1, n + 1):
            ludics.append(i)
        index = 1
        while(index != len(ludics)):
            first_ludic = ludics[index]
            remove_index = index + first_ludic
            while(remove_index < len(ludics)):
                ludics.remove(ludics[remove_index])
                remove_index = remove_index + first_ludic - 1
            index += 1
        return ludics

    main("100")
  error: |-
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The function `main` is defined to take an integer parameter `n`, but in the broken code, it has been changed to take a string parameter. When the `range` function is called with `n + 1`, it attempts to concatenate an integer (`1`) to a string (`n`), which is not allowed in Python and results in a `TypeError`. Additionally, the function is called with a string argument `"100"` instead of an integer, which would also contribute to the error.
  id: |-
    hubfix_mbpp_py_603
  lang: |-
    python
  original_code: |-
    def main(n: int) -> list:
        ludics = []
        for i in range(1, n + 1):
            ludics.append(i)
        index = 1
        while(index != len(ludics)):
            first_ludic = ludics[index]
            remove_index = index + first_ludic
            while(remove_index < len(ludics)):
                ludics.remove(ludics[remove_index])
                remove_index = remove_index + first_ludic - 1
            index += 1
        return ludics
  original_instructions: |-
    get all lucid numbers smaller than or equal to a given integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> List[Any]:
        res = [lis[-1] for lis in test_list]
        return resu
  error: |-
    NameError: name 'resu' is not defined
  explanation: |-
    The variable `resu` is not defined in the function. The correct variable name should be `res`, which is defined as the list comprehension result. The code attempts to return `resu`, which has not been declared or assigned any value, leading to a `NameError`.
  id: |-
    hubfix_mbpp_py_272
  lang: |-
    python
  original_code: |-
    from typing import List, Any

    def main(test_list: List[List[Any]]) -> List[Any]:
        res = [lis[-1] for lis in test_list]
        return res
  original_instructions: |-
    takes in a list of tuples and returns a list containing the rear element of each tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(num: str) -> int:
        if num <= 1:
             return 1
        res_num = 0
        for i in range(num):
            res_num += main(i) * main(num - i - 1)
        return res_num
  error: |-
    TypeError: '<=' not supported between instances of 'str' and 'int'
  explanation: |-
    The function `main` is defined to take a parameter `num` of type `str`, which is incorrect because the function expects an integer to perform arithmetic operations and comparisons. The error occurs because the '<=' operator is not supported between instances of 'str' and 'int'. The parameter type should remain `int` to match the expected operations within the function.
  id: |-
    hubfix_mbpp_py_583
  lang: |-
    python
  original_code: |-
    def main(num: int) -> int:
        if num <= 1:
             return 1
        res_num = 0
        for i in range(num):
            res_num += main(i) * main(num - i - 1)
        return res_num
  original_instructions: |-
    Write a function which returns nth catalan number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(b: float, s: str) -> float:
        return 2 * b * s + power(b, 2)
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
    TypeError: can't multiply sequence by non-int of type 'float'
    NameError: name 'power' is not defined
  explanation: |-
    There are two issues with the code:

    1. The function is trying to multiply a float (`b`) with a string (`s`), which is not allowed in Python. The multiplication operator `*` cannot be used between a float and a string.

    2. The function `power` is called, but it does not exist. The correct function name in Python for raising a number to a power is `pow`.
  id: |-
    hubfix_mbpp_py_581
  lang: |-
    python
  original_code: "def main(b: float, s: float) -> float:\n    return 2 * b * s + pow(b,\
    \ 2) "
  original_instructions: |-
    find the surface area of a square pyramid with a given base edge and height
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(list1: list, list2: list, list3: list) -> str:
        result = sum(m == n == x for m, n, o in zip(list1, list2, list3))
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main([1, 2, 3], [1, 2, 3], [1, 2, 3])
      File "script.py", line 2, in main
        result = sum(m == n == x for m, n, o in zip(list1, list2, list3))
      File "script.py", line 2, in <genexpr>
        result = sum(m == n == x for m, n, o in zip(list1, list2, list3))
    NameError: name 'x' is not defined
  explanation: |-
    The code is broken because of two reasons:

    1. The variable `x` is used in the generator expression `m == n == x` but it is not defined anywhere in the code. The original code used `o` which was defined as part of the `zip` iteration.

    2. The return type of the function is changed from `int` to `str`, but the function still returns an integer value. This is a semantic error and would not cause a runtime exception, but it is incorrect according to the type hinting provided.
  id: |-
    hubfix_mbpp_py_142
  lang: |-
    python
  original_code: |-
    def main(list1: list, list2: list, list3: list) -> int:
        result = sum(m == n == o for m, n, o in zip(list1, list2, list3))
        return result
  original_instructions: |-
    count number items that are identical in the same position of three given lists
  resource_type: null
  resource_type_def: null
- broken_code: "from typing import List\n\ndef main(newList: List) -> List:\n    size\
    \ = len(newList)\n    temp = newList[0]\n    newList[0] = newList[size]\n    newList[size\
    \ - 1] = temp\n    return newList "
  error: |-
    IndexError: list index out of range
  explanation: |-
    The code is trying to access `newList[size]`, which is an index out of the range of the list. Lists in Python are zero-indexed, so the last valid index is `size - 1`. By trying to access `newList[size]`, the code is attempting to get an element that does not exist, which results in an `IndexError`.
  id: |-
    hubfix_mbpp_py_625
  lang: |-
    python
  original_code: "from typing import List\n\ndef main(newList: List) -> List:\n  \
    \  size = len(newList)\n    temp = newList[0]\n    newList[0] = newList[size -\
    \ 1]\n    newList[size - 1] = temp\n    return newList "
  original_instructions: |-
    interchange the first and last element in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(li1: list, li2: str) -> list:
        return list(set(li1) - set(li3)) + list(set(li2) - set(li1))
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
      File "<stdin>", line 2, in main
    NameError: name 'li3' is not defined
  explanation: |-
    The code is broken for two reasons:

    1. The second parameter of the `main` function is changed from `li2: list` to `li2: str`, which is incorrect because the function expects two lists to perform set operations. If a string is passed instead of a list, the set operation will not work as intended.

    2. Inside the function, `li3` is used, but it is not defined anywhere in the code. This will raise a `NameError` because `li3` does not exist in the current scope.
  id: |-
    hubfix_mbpp_py_769
  lang: |-
    python
  original_code: |-
    def main(li1: list, li2: list) -> list:
        return list(set(li1) - set(li2)) + list(set(li2) - set(li1))
  original_instructions: |-
    get the difference between two lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> bool:
        if (n % 4 != 2):
            return True
        return False

    main(5)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main(5)
      File "script.py", line 3, in main
        if (n % 4 != 2):
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `str` (string), but it is being called with an integer `5`. Inside the function, the modulo operation `%` is being attempted on a string and an integer, which is not valid in Python and causes a `TypeError`. The correct code should have the parameter `n` typed as an `int` instead of `str`.
  id: |-
    hubfix_mbpp_py_72
  lang: |-
    python
  original_code: |-
    def main(n: int) -> bool:
        if (n % 4 != 2):
            return True
        return False
  original_instructions: |-
    check whether the given number can be represented as the difference of two squares or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str1: int) -> int:
        total = 0
        for i in str1:
            total = total + count
        return total
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main("test")
      File "script.py", line 3, in main
        for i in str1:
    TypeError: 'int' object is not iterable
  explanation: |-
    The code is broken because of two reasons:

    1. The parameter `str1` is now expected to be an `int` due to the type hint `str1: int`, but an `int` is not iterable, which means the `for` loop will raise a `TypeError` when it tries to iterate over an integer.

    2. The variable `count` is used in the expression `total + count`, but it is not defined anywhere in the code. This would raise a `NameError` if the `TypeError` from the first issue did not already stop the execution.
  id: |-
    hubfix_mbpp_py_242
  lang: |-
    python
  original_code: |-
    def main(str1: str) -> int:
        total = 0
        for i in str1:
            total = total + 1
        return total
  original_instructions: |-
    count the total number of characters in a string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(list1: list, L: str) -> tuple:
        return list1[:K], list1[L:]
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        return list1[:K], list1[L:]
    NameError: name 'K' is not defined
  explanation: |-
    The code is broken because of two issues:

    1. The variable `K` is used in the slice `list1[:K]`, but it is not defined anywhere in the code. This results in a `NameError` because Python does not know what `K` refers to.

    2. The parameter `L` is annotated as a string (`L: str`), but it is used as if it were an integer index for slicing the list. This would not cause an immediate error in the code as shown, but it would lead to a `TypeError` if the function were called with a string for `L`, as Python does not support slicing lists with strings.
  id: |-
    hubfix_mbpp_py_262
  lang: |-
    python
  original_code: |-
    def main(list1: list, L: int) -> tuple:
        return list1[:L], list1[L:]
  original_instructions: |-
    takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr1: list, arr2: list, k: str) -> int:
        m = len(arr1)
        n = len(arr2)
        sorted1 = [0] * (m + n)
        i = 0
        j = 0
        d = 0
        while (i < m and j < n):
            if (arr1[i] < arr2[j]):
                sorted1[d] = arr1[i]
                i += 1
            else:
                sorted1[d] = arr2[j]
                j += 1
            d += 1
        while (i < m):
            sorted1[d] = arr1[i]
            d += 1
            i += 1
        while (j < n):
            sorted1[d] = arr2[j]
            d += 1
            j += 1
        return sorted1[k - 1]
  error: |-
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The error occurs because the type of the parameter `k` was changed from `int` to `str`, which means that `k` is expected to be a string. However, in the return statement `sorted1[k - 1]`, the code attempts to subtract an integer (`1`) from a string (`k`), which is not a valid operation in Python. This results in a `TypeError`.
  id: |-
    hubfix_mbpp_py_597
  lang: |-
    python
  original_code: |-
    def main(arr1: list, arr2: list, k: int) -> int:
        m = len(arr1)
        n = len(arr2)
        sorted1 = [0] * (m + n)
        i = 0
        j = 0
        d = 0
        while (i < m and j < n):
            if (arr1[i] < arr2[j]):
                sorted1[d] = arr1[i]
                i += 1
            else:
                sorted1[d] = arr2[j]
                j += 1
            d += 1
        while (i < m):
            sorted1[d] = arr1[i]
            d += 1
            i += 1
        while (j < n):
            sorted1[d] = arr2[j]
            d += 1
            j += 1
        return sorted1[k - 1]
  original_instructions: |-
    find kth element from the given two sorted arrays
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(A: dict) -> str:
      count = 0
      for i in range(0, len(A)):
        for j in range(i+1, len(A)):
            if ((A[i] ^ A[j]) % 2 == 0):
              count += "1"

      return count
  error: |-
    TypeError: object of type 'dict' has no len()
  explanation: |-
    The code is broken because the parameter `A` is now expected to be of type `dict` instead of `list`. Dictionaries do not support the `len()` function in the same way lists do, as `len()` expects an object that has a definite size or number of elements, which is not directly applicable to the keys of a dictionary. Additionally, the `count` variable is being incremented by a string "1" instead of an integer 1, which would cause a TypeError because you cannot add a string to an integer. Lastly, the return type of the function is changed to `str`, but the function is still trying to return an integer `count`, which would also cause a type error if the previous errors were not encountered first.
  id: |-
    hubfix_mbpp_py_166
  lang: |-
    python
  original_code: |-
    def main(A: list) -> int:
      count = 0
      for i in range(0, len(A)):
        for j in range(i+1, len(A)):
            if ((A[i] ^ A[j]) % 2 == 0):
              count += 1

      return count
  original_instructions: |-
    counts the number of pairs of integers in a list that xor to an even number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(string: int) -> str:
      return string.replac(" ", "%20")
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in main
    AttributeError: 'int' object has no attribute 'replac'
  explanation: |-
    There are two issues with the code:
    1. The `main` function is expecting an integer (`int`) as its parameter instead of a string (`str`). This is incorrect because the `replace` method is a string method and cannot be called on an integer.
    2. There is a typo in the method name; it should be `replace` instead of `replac`. This typo causes an AttributeError because `replac` is not a valid method for a string object.
  id: |-
    hubfix_mbpp_py_628
  lang: |-
    python
  original_code: |-
    def main(string: str) -> str:
      return string.replace(" ", "%20")
  original_instructions: |-
    replace all spaces in the given string with '%20'
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List

    def main(nums1: List[int], nums2: List[str], N: str) -> List[int]:
        result = sorted([x*z for x in nums1 for z in nums2], reverse=True)[:M]
        return result
  error: |-
    Traceback (most recent call last):
      File "script.py", line X, in <module>
        main([1, 2], ['3', '4'], '5')
      File "script.py", line Y, in main
        result = sorted([x*z for x in nums1 for z in nums2], reverse=True)[:M]
    TypeError: can't multiply sequence by non-int of type 'str'
    NameError: name 'M' is not defined
  explanation: |-
    There are multiple issues with the code:

    1. The `nums2` parameter type hint has been changed from `List[int]` to `List[str]`, which means it now expects a list of strings instead of integers. Multiplying an integer by a string is not valid in Python, which leads to a `TypeError`.

    2. The variable `N` has been changed to a string type hint (`N: str`), which is incorrect because slicing (`[:N]`) expects an integer index, not a string.

    3. The variable `z` is used in the list comprehension instead of `y`, but this is not an error by itself since `z` is defined in the loop. However, it is misleading because it does not match the original variable name `y`.

    4. The variable `M` is used in the slicing operation `[:M]`, but `M` is not defined anywhere in the code, leading to a `NameError`.

    To fix the code, the type hints should be corrected, and the variable `M` should be replaced with `N`.
  id: |-
    hubfix_mbpp_py_308
  lang: |-
    python
  original_code: |-
    from typing import List

    def main(nums1: List[int], nums2: List[int], N: int) -> List[int]:
        result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]
        return result
  original_instructions: |-
    find the specified number of largest products from two given lists, selecting one factor from each list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def is_majority(arr: list, n: int, x: int) -> bool:
        i = main(arr, 0, n-1, x)
        if i == -1:
            return False
        if ((i + n//2) <= (n -1)) and arr[i + n//2] == y:
            return True
        else:
            return False

    def main(arr: list, low: int, high: int, x: int) -> int:
        if high >= low:
            mid = (low + high)//2
            if (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):
                return mid
            elif x > arr[mid]:
                return main(arr, (mid + 1), high, x)
            else:
                return main(arr, low, (mid -1), x)
        return -1
  error: |-
    NameError: name 'y' is not defined
  explanation: |-
    In the `is_majority` function, the variable `y` is used in the condition `arr[i + n//2] == y`, but `y` is not defined anywhere in the code. This will cause a `NameError` because Python does not know what `y` refers to.
  id: |-
    hubfix_mbpp_py_223
  lang: |-
    python
  original_code: |-
    def is_majority(arr: list, n: int, x: int) -> bool:
        i = main(arr, 0, n-1, x)
        if i == -1:
            return False
        if ((i + n//2) <= (n -1)) and arr[i + n//2] == x:
            return True
        else:
            return False

    def main(arr: list, low: int, high: int, x: int) -> int:
        if high >= low:
            mid = (low + high)//2
            if (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):
                return mid
            elif x > arr[mid]:
                return main(arr, (mid + 1), high, x)
            else:
                return main(arr, low, (mid -1), x)
        return -1
  original_instructions: |-
    takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(str: int) -> int:
        main = 0
        for i in range(len(str)):
            if str[i] >= '0' and str[i] <= '9':
                main += 1
        return main

    main("123abc")
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 8, in <module>
      File "<stdin>", line 4, in main
    TypeError: object of type 'int' has no len()
  explanation: |-
    The code is broken because the parameter `str` is annotated as an `int` type, but the function is being called with a string argument `"123abc"`. The `len()` function cannot be used on an integer, which causes a `TypeError`. Additionally, even if the parameter was correctly typed as `str`, iterating over the string and accessing `str[i]` would not work because `str` is a built-in type and should not be used as a variable name.
  id: |-
    hubfix_mbpp_py_764
  lang: |-
    python
  original_code: |-
    def main(str: str) -> int:
        main = 0
        for i in range(len(str)):
            if str[i] >= '0' and str[i] <= '9':
                main += 1
        return main
  original_instructions: |-
    count number of digits in a given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: number[], n: number): Promise<number[]> {
      const largestNums = nums.sort((a, b) => b - a).slice(0, n);
      return largestValues;
    }
  error: |-
    ReferenceError: largestValues is not defined
  explanation: |-
    The variable `largestValues` is used in the return statement, but it was never defined. The correct variable name, as defined earlier in the function, is `largestNums`. This is a common mistake where a developer might accidentally use a different variable name than the one they defined.
  id: |-
    hubfix_mbpp_ts_4
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[], n: number): Promise<number[]> {
      const largest_nums = nums.sort((a, b) => b - a).slice(0, n);
      return largest_nums;
    }
  original_instructions: |-
    find the n largest integers from a given list of numbers, returned in descending order
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(str: number): Promise<number> {
        const tmp = str + str;
        const n = str.length;
        for (let i = 1; i <= n; i++) {
            const substring = tmp.substring(i, i + n);
            if (str === substring) {
                return i;
            }
        }
        return n;
    }
  error: |-
    error TS2339: Property 'length' does not exist on type 'number'.
    error TS2339: Property 'substring' does not exist on type 'number'.
  explanation: |-
    The code is broken because the parameter `str` is changed from type `string` to type `number`. Numbers in TypeScript do not have a `length` property or a `substring` method, which are both properties and methods of strings. The `str + str` operation is also invalid because you cannot concatenate numbers in this way; it would result in addition rather than concatenation.
  id: |-
    hubfix_mbpp_ts_9
  lang: |-
    deno
  original_code: |-
    export async function main(str: string): Promise<number> {
        const tmp = str + str;
        const n = str.length;
        for (let i = 1; i <= n; i++) {
            const substring = tmp.substring(i, i + n);
            if (str === substring) {
                return i;
            }
        }
        return n;
    }
  original_instructions: |-
    find the minimum number of rotations (greater than 0) required to get the same string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: number, b: number, h: string): Promise<number> {
        return ((l * b * h) / 2);
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting three parameters of type `number`, but the third parameter `h` has been changed to type `string`. TypeScript is a statically typed language, which means that the types of variables are checked at compile time. Multiplying a number by a string is not a valid operation in TypeScript, so the compiler throws an error indicating that a `string` cannot be assigned to a parameter that is expected to be a `number`.
  id: |-
    hubfix_mbpp_ts_14
  lang: |-
    deno
  original_code: |-
    export async function main(l: number, b: number, h: number): Promise<number> {
        return ((l * b * h) / 2);
    }
  original_instructions: |-
    find the volume of a triangular prism
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(text: number): Promise<string> {
        const patterns = '^[a-z]+_[a-z]+$';
        return new RegExp(patterns).test(text);
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `RegExp.prototype.test()` method expects a string as its parameter, but the modified code is passing a number to it. Additionally, the return type of the function has been changed from `Promise<boolean>` to `Promise<string>`, which is incorrect because the `test` method returns a boolean, not a string.
  id: |-
    hubfix_mbpp_ts_16
  lang: |-
    deno
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = '^[a-z]+_[a-z]+$';
        return new RegExp(patterns).test(text);
    }
  original_instructions: |-
    that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculatePerimeter(b: string): Promise<number> {
      const perimeter: number = 4 * a;
      return perimeter;
    }
  error: |-
    TS2552: Cannot find name 'a'. Did you mean 'b'?
  explanation: |-
    The code is broken because of the following reasons:
    - The parameter `a` is used inside the function, but it is not defined in the function signature. The function signature has been changed to use `b` as a parameter, which is a string, but the body of the function still references `a`.
    - The parameter `b` is of type `string`, but it is being used in a mathematical operation (`4 * a`) which expects a number. This would also cause a type error if `a` were replaced with `b` in the calculation.
    - The function name has been changed from `main` to `calculatePerimeter`, which may not be an issue by itself, but if there is code elsewhere expecting a function named `main`, this would cause a problem.
  id: |-
    hubfix_mbpp_ts_17
  lang: |-
    deno
  original_code: |-
    export async function main(a: number): Promise<number> {
      const perimeter: number = 4 * a;
      return perimeter;
    }
  original_instructions: |-
    returns the perimeter of a square given its side length as input
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return 3 * n * n - 2 * n;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The function `main` is expecting a parameter `n` of type `string`, but it is being used in an arithmetic operation, which requires operands to be of type 'any', 'number', 'bigint', or an enum type. Since `n` is a string, the multiplication and subtraction operations are invalid, causing the TypeScript compiler to throw an error.
  id: |-
    hubfix_mbpp_ts_59
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        return 3 * n * n - 2 * n;
    }
  original_instructions: |-
    find the nth octagonal number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: string): Promise<number> {
        const n: number = s.length;
        let count: number = 0, sum: number = 0;
        const mp: { [key: string]: number } = {};
        mp['0'] = 1;
        for (let i = 0; i < n; i++) {
            sum += s.charCodeAt(i) - '0'.charCodeAt(0);
            if (mp[sum - (i + 1)] === undefined) {
                mp[sum - (i + 1).toString()] = 0;
            }
            count += mp[sum - (i + 1)];
            mp[sum - (i + 1)].toString() += 1;
        }
        return count;
    }
  error: |-
    TS2538: Type 'string' cannot be used as an index type.
  explanation: |-
    The error occurs because the TypeScript compiler expects the keys of the object `mp` to be of type `number`, but the code attempts to use a `string` as a key. The expression `sum - (i + 1)` results in a `number`, but the `.toString()` method is called on it, which converts it to a `string`. TypeScript does not allow using strings as keys when the index signature explicitly specifies the key type as `number`. Additionally, the line `mp[sum - (i + 1)].toString() += 1;` is incorrect because it attempts to call `.toString()` on the value accessed by `mp[sum - (i + 1)]`, which is a `number`, and then tries to use `+= 1` on the result, which is nonsensical because you cannot increment a string representation of a number.
  id: |-
    hubfix_mbpp_ts_61
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<number> {
        const n: number = s.length;
        let count: number = 0, sum: number = 0;
        const mp: { [key: number]: number } = {};
        mp[0] = 1;
        for (let i = 0; i < n; i++) {
            sum += s.charCodeAt(i) - '0'.charCodeAt(0);
            if (mp[sum - (i + 1)] === undefined) {
                mp[sum - (i + 1)] = 0;
            }
            count += mp[sum - (i + 1)];
            mp[sum - (i + 1)] += 1;
        }
        return count;
    }
  original_instructions: |-
    count the number of substrings with the sum of digits equal to their length
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(A: number[]): Promise<string> {
        return (A.every((_, i) => i === A.length - 1 || A[i] <= A[i + 1]) ||
                A.every((_, i) => i === A.length - 1 || A[i] >= A[i + 1]));
    }
  error: |-
    TS2322: Type 'boolean' is not assignable to type 'string'.
  explanation: |-
    The function `main` is declared to return a `Promise<string>`, but the actual return value is a boolean expression. TypeScript expects the return type to match the declared return type, which is `Promise<string>`. Since the return value is a boolean, it is not assignable to `Promise<string>`, resulting in a type error.
  id: |-
    hubfix_mbpp_ts_68
  lang: |-
    deno
  original_code: |-
    export async function main(A: number[]): Promise<boolean> {
        return (A.every((_, i) => i === A.length - 1 || A[i] <= A[i + 1]) ||
                A.every((_, i) => i === A.length - 1 || A[i] >= A[i + 1]));
    }
  original_instructions: |-
    check whether the given array is monotonic or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: any[], s: any[]): Promise<boolean> {
        let subSet: boolean = false;
        if (s.length === 0) {
            subSet = true;
        } else if (s === l) {
            subSet = true;
        } else if (s.length > l.length) {
            subSet = false;
        } else {
            for (let i = 0; i <= l.length - s.length; i++) {
                if (l[i] === s[0]) {
                    let n: number = 1;
                    while (n < s.length && l[i + n] === s[n]) {
                        n++;
                    }
                    if (n === s.length) {
                        subSet = true;
                        break;
                    }
                }
            }
        }
        return subset;
    }
  error: |-
    ReferenceError: subset is not defined
  explanation: |-
    The variable `subSet` is defined with a capital 'S', but the return statement incorrectly references `subset` with a lowercase 's'. Variable names in JavaScript and TypeScript are case-sensitive, so `subSet` and `subset` are treated as two different variables. Since `subset` (with a lowercase 's') is not defined anywhere in the code, trying to return it results in a `ReferenceError`.
  id: |-
    hubfix_mbpp_ts_69
  lang: |-
    deno
  original_code: |-
    export async function main(l: any[], s: any[]): Promise<boolean> {
        let subSet: boolean = false;
        if (s.length === 0) {
            subSet = true;
        } else if (s === l) {
            subSet = true;
        } else if (s.length > l.length) {
            subSet = false;
        } else {
            for (let i = 0; i <= l.length - s.length; i++) {
                if (l[i] === s[0]) {
                    let n: number = 1;
                    while (n < s.length && l[i + n] === s[n]) {
                        n++;
                    }
                    if (n === s.length) {
                        subSet = true;
                        break;
                    }
                }
            }
        }
        return subSet;
    }
  original_instructions: |-
    check whether a list contains the given sublist or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<boolean> {
        if (n % 4 !== 2) {
            return true;
        }
        return false;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The parameter `n` was changed from type `number` to type `string`. The modulus operator `%` is not applicable to strings, which is why TypeScript throws an error. The left-hand side of an arithmetic operation, such as `%`, must be of type 'any', 'number', 'bigint', or an enum type.
  id: |-
    hubfix_mbpp_ts_72
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n % 4 !== 2) {
            return true;
        }
        return false;
    }
  original_instructions: |-
    check whether the given number can be represented as the difference of two squares or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(colors: string[], patterns: number[]): Promise<boolean> {
        if (colors.length !== patterns.length) {
            return false;
        }
        const sdict: Record<string, string[]> = {};
        const pset: Set<number> = new Set();
        const sset: Set<string> = new Set();
        for (let i = 0; i < patterns.length; i++) {
            pset.add(patterns[i]);
            sset.add(colors[i]);
            if (!sdict[patterns[i]]) {
                sdict[patterns[i]] = [];
            }

            let keys = sdict[patterns[i]];
            keys.push(colors[i]);
        }

        if (pset.size !== sset.size) {
            return false;
        }

        for (let values of Object.values(sdict)) {
            for (let i = 0; i < values.length - 1; i++) {
                if (values[i] !== values[i + 1]) {
                    return false;
                }
            }
        }

        return true;
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The error occurs because the `patterns` parameter type was changed from `string[]` to `number[]`, but the `sdict` object is still declared as a `Record<string, string[]>`, which expects a string as the key. When trying to use `patterns[i]` (which is a number) as a key in `sdict`, TypeScript throws an error because it expects a string key, not a number.
  id: |-
    hubfix_mbpp_ts_74
  lang: |-
    deno
  original_code: |-
    export async function main(colors: string[], patterns: string[]): Promise<boolean> {
        if (colors.length !== patterns.length) {
            return false;
        }
        const sdict: Record<string, string[]> = {};
        const pset: Set<string> = new Set();
        const sset: Set<string> = new Set();
        for (let i = 0; i < patterns.length; i++) {
            pset.add(patterns[i]);
            sset.add(colors[i]);
            if (!sdict[patterns[i]]) {
                sdict[patterns[i]] = [];
            }

            let keys = sdict[patterns[i]];
            keys.push(colors[i]);
        }

        if (pset.size !== sset.size) {
            return false;
        }

        for (let values of Object.values(sdict)) {
            for (let i = 0; i < values.length - 1; i++) {
                if (values[i] !== values[i + 1]) {
                    return false;
                }
            }
        }

        return true;
    }
  original_instructions: |-
    check whether it follows the sequence given in the patterns array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: number): Promise<boolean> {
        const words = s.splits(' ');
        for (const word of words) {
            if (word.lengths % 2 !== 0) {
                return true;
            }
        }
        return false;
    }
  error: |-
    error TS2339: Property 'splits' does not exist on type 'number'.
    error TS2339: Property 'lengths' does not exist on type 'string'.
  explanation: |-
    The code is broken for two reasons:

    1. The `main` function now expects a parameter of type `number` instead of `string`. Since numbers do not have a `split` method, this will cause a runtime error when trying to call `s.splits(' ')`.

    2. The method `split` is misspelled as `splits`, and `length` is misspelled as `lengths`. These methods do not exist on the respective types (`string` for `split` and `string` for `length`), which will cause a compilation error.
  id: |-
    hubfix_mbpp_ts_79
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<boolean> {
        const words = s.split(' ');
        for (const word of words) {
            if (word.length % 2 !== 0) {
                return true;
            }
        }
        return false;
    }
  original_instructions: |-
    check whether the length of the word is odd or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(strr: number): Promise<number> {
        let summ: number = 0;
        for (let i = 0; i < strr.length; i++) {
            summ += (strr.charCodeAt(i) - 'a'.charCodeAt(0) + 1);
        }
        if (summ % 26 === 0) {
            return 'z';
        } else {
            summ = summ % 26;
            return String.fromCharCode('a'.charCodeAt(0) + summ - 1);
        }
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `strr` of the `main` function has been changed from `string` to `number`. This causes two issues:

    1. The `length` property does not exist on type `number`, so `strr.length` will cause an error.
    2. The `charCodeAt` method is called on `strr`, which is supposed to be a string method, not a number method.

    Additionally, the return type of the function has been changed to `Promise<number>`, but the function is still returning a string when it returns `'z'`. This is a type mismatch that will also cause a compilation error.
  id: |-
    hubfix_mbpp_ts_83
  lang: |-
    deno
  original_code: |-
    export async function main(strr: string): Promise<string> {
        let summ: number = 0;
        for (let i = 0; i < strr.length; i++) {
            summ += (strr.charCodeAt(i) - 'a'.charCodeAt(0) + 1);
        }
        if (summ % 26 === 0) {
            return 'z';
        } else {
            summ = summ % 26;
            return String.fromCharCode('a'.charCodeAt(0) + summ - 1);
        }
    }
  original_instructions: |-
    find the character made by adding the ASCII value of all the characters of the given string modulo 26
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n === '1' || n === '2') {
            return 1;
        } else {
            return (await main(await main(n - 1))) + (await main(n - (await main(n - 1))));
        }
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The function `main` has been modified to take a parameter `n` of type `string` instead of `number`. However, inside the function, the code attempts to perform arithmetic operations (`n - 1`) on `n`, which is not valid for strings in TypeScript. Additionally, the recursive calls to `main` pass a number as an argument, which is not compatible with the new parameter type `string`. This results in a type error because TypeScript expects a string argument for the `main` function, but a number is being passed.
  id: |-
    hubfix_mbpp_ts_84
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 1 || n === 2) {
            return 1;
        } else {
            return (await main(await main(n - 1))) + (await main(n - (await main(n - 1))));
        }
    }
  original_instructions: |-
    find the nth number in the newman conway sequence
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateSurfaceArea(radius: string): Promise<number> {
      const surfaceArea: number = 4 * Math.PI * radius * radius;
      return surfaceArea;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `calculateSurfaceArea` is expecting a parameter `radius` of type `string`, but it should be of type `number` because it is being used in a mathematical operation with `Math.PI`, which expects numeric operands. The multiplication operation `*` cannot be applied to a string and a number, hence the error.
  id: |-
    hubfix_mbpp_ts_85
  lang: |-
    deno
  original_code: |-
    export async function main(r: number): Promise<number> {
      const surfaceArea: number = 4 * Math.PI * r * r;
      return surfaceArea;
    }
  original_instructions: |-
    find the surface area of a sphere
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(N: string): Promise<number> {
      return (N - 1);
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The parameter `N` was changed from type `number` to `string`, which is not a valid type for arithmetic operations like subtraction in TypeScript. The subtraction operation `N - 1` is expecting `N` to be a number, but since it's a string, TypeScript throws an error.
  id: |-
    hubfix_mbpp_ts_89
  lang: |-
    deno
  original_code: |-
    export async function main(N: number): Promise<number> {
      return (N - 1);
    }
  original_instructions: |-
    find the closest smaller number than n
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return [...Array(n).keys()].map(i => i + 1).filter(i => n % i === 0).length;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is now expecting a parameter `n` of type `string` instead of `number`. The `Array` constructor expects a numeric argument, and the modulus operator `%` is not applicable to a string and a number. This results in a type error because TypeScript expects `n` to be a number, but it is declared as a string.
  id: |-
    hubfix_mbpp_ts_96
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        return [...Array(n).keys()].map(i => i + 1).filter(i => n % i === 0).length;
    }
  original_instructions: |-
    find the number of divisors of a given integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return n.toBinaryString();
    }
  error: |-
    error TS2339: Property 'toBinaryString' does not exist on type 'string'.
  explanation: |-
    The code is broken for two reasons:

    1. The `toBinaryString` method does not exist on the `string` type. The correct method to convert a number to its binary representation is `toString(2)`, which should be called on a number, not a string.

    2. The function `main` is declared to take a parameter `n` of type `string`, but it should be of type `number` to work with the `toString(2)` method. Additionally, the return type of the function is declared as `Promise<number>`, but it should be `Promise<string>` because the binary representation of a number is a string.
  id: |-
    hubfix_mbpp_ts_99
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<string> {
        return n.toString(2);
    }
  original_instructions: |-
    convert the given decimal number to its binary equivalent, represented as a string with no leading zeros
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(word: number): Promise<number> {
        return word.splits('_').map(x => x.charAt(0).toUpperCase() + x.slice(1)).join('');
    }
  error: |-
    TypeError: word.splits is not a function
  explanation: |-
    There are multiple issues with the broken code:

    1. The `main` function now expects a parameter of type `number` instead of `string`. This is incorrect because the method `split` is not available on type `number`.
    2. The method `split` is incorrectly written as `splits`, which is not a valid method on a string.
    3. The return type of the function is changed to `Promise<number>`, but the function is still returning a string, which is the result of the `join` method on an array of strings.
  id: |-
    hubfix_mbpp_ts_102
  lang: |-
    deno
  original_code: |-
    export async function main(word: string): Promise<string> {
        return word.split('_').map(x => x.charAt(0).toUpperCase() + x.slice(1)).join('');
    }
  original_instructions: |-
    convert a snake case string to camel case string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nestedList: Array<Array<any>>): Promise<Array<any>> {
        const result = Array.from(new Set(nestedList.reduce((a, b) => a.filter(c => new Set(b).has(d)))));
        return result;
    }
  error: |-
    error: TS2304 [ERROR]: Cannot find name 'd'. Did you mean 'b'?
        const result = Array.from(new Set(nestedList.reduce((a, b) => a.filter(c => new Set(b).has(d)))));
                                                                                                      ^
  explanation: |-
    The variable `d` is used inside the `has` method, but it is not defined anywhere in the scope. The correct variable to use in this context is `c`, which is the parameter of the `filter` method's callback function. By mistakenly using `d` instead of `c`, the code references an undefined variable, which causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_mbpp_ts_111
  lang: |-
    deno
  original_code: |-
    export async function main(nestedList: Array<Array<any>>): Promise<Array<any>> {
        const result = Array.from(new Set(nestedList.reduce((a, b) => a.filter(c => new Set(b).has(c)))));
        return result;
    }
  original_instructions: |-
    find the common elements in given nested lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number> {
        const result = parseInt(nums.flatten().join(''));
        return result;
    }
  error: |-
    error TS2339: Property 'flatten' does not exist on type 'string[]'.
  explanation: |-
    The code is attempting to call a method `flatten` on an array of strings (`nums`). However, the `flatten` method does not exist on the `Array` prototype in JavaScript or TypeScript. Additionally, the parameter type for `nums` was changed from `number[]` to `string[]`, which is incorrect given the context of the function, which is to join numbers into a string and then parse it into a number. The `parseInt` function expects a string argument, and the original code was correctly joining an array of numbers into a string before parsing it.
  id: |-
    hubfix_mbpp_ts_116
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        const result = parseInt(nums.join(''));
        return result;
    }
  original_instructions: |-
    convert a given tuple of positive integers into a single integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        const n = arr.length;
        let XOR = 0;
        for (let i = 0; i < n; i++) {
            XOR = XOR ^ arr[i].length;
        }
        return XOR;
    }
  error: |-
    TS2365: Operator '^' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The code is broken because the type of the `arr` parameter has been changed from `number[]` (an array of numbers) to `string[]` (an array of strings). The XOR operation is not defined for strings, which is why TypeScript throws an error when trying to apply the '^' operator between a number (`XOR`) and a string (`arr[i]`). Even though `arr[i].length` is a number, the XOR operation is still invalid because the type of `arr` is incorrect according to the function's original design.
  id: |-
    hubfix_mbpp_ts_119
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        const n = arr.length;
        let XOR = 0;
        for (let i = 0; i < n; i++) {
            XOR = XOR ^ arr[i];
        }
        return XOR;
    }
  original_instructions: |-
    find the element that appears only once in a sorted array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number, b: string): Promise<number> {
        let main_result = 0;
        for (let i = 1; i <= Math.min(a, b); i++) {
            if (a % i === 0 && b % i === 0) {
                main_result += i;
            }
        }
        return main_result;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `Math.min` function expects all of its arguments to be of type `number`, but the variable `b` has been changed to type `string`. This causes a type mismatch error because `Math.min` cannot take a `string` as an argument when it is expecting a `number`. Additionally, the modulo operator `%` is also not applicable to a `string` type, which would cause another error if the type mismatch with `Math.min` was resolved.
  id: |-
    hubfix_mbpp_ts_126
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number): Promise<number> {
        let main_result = 0;
        for (let i = 1; i <= Math.min(a, b); i++) {
            if (a % i === 0 && b % i === 0) {
                main_result += i;
            }
        }
        return main_result;
    }
  original_instructions: |-
    find the sum of common divisors of two given numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string, str: string): Promise<number[]> {
        let word_len: number[] = [];
        let txt = str.divide(" ");
        for (let x of txt) {
            if (x.length > n) {
                word_len.push(x);
            }
        }
        return word_len;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    TS2339: Property 'divide' does not exist on type 'String'.
    TS2365: Operator '>' cannot be applied to types 'number' and 'string'.
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    - The parameter `n` is changed from `number` to `string`, which is incorrect because the comparison `x.length > n` expects `n` to be a number.
    - The method `divide` is used instead of `split`, but `divide` does not exist on the `String` prototype in JavaScript/TypeScript.
    - The comparison `x.length > n` is incorrect because `x.length` returns a number and `n` is now a string. The '>' operator cannot be used to compare a number with a string.
    - The `word_len` array is changed to type `number[]`, but the code attempts to push strings into it (`word_len.push(x)`), which is a type mismatch.
  id: |-
    hubfix_mbpp_ts_128
  lang: |-
    deno
  original_code: |-
    export async function main(n: number, str: string): Promise<string[]> {
        let word_len: string[] = [];
        let txt = str.split(" ");
        for (let x of txt) {
            if (x.length > n) {
                word_len.push(x);
            }
        }
        return word_len;
    }
  original_instructions: |-
    find words that are longer than n characters from a given list of words
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(str1: number): Promise<number> {
        let vowels = "";
        for (const char of str1) {
            if ("aeiouAEIOU".includes(char)) {
                vowels += char;
            }
        }
        let resultString = "";
        for (const char of str1) {
            if ("aeiouAEIOU".includes(char)) {
                resultString += vowels[vowels.length - 1];
                vowels = vowels.slice(0, -1);
            } else {
                resultString += char;
            }
        }
        return resultString;
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string | String'.
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    The code is broken because of two main issues:

    1. The parameter `str1` is changed from `string` to `number`, which is incorrect because the function is designed to work with strings. The `for...of` loop and the `includes` method are used with the assumption that `str1` is a string. Numbers do not have an iterator, so the `for...of` loop will fail.

    2. The return type of the function is changed from `Promise<string>` to `Promise<number>`, but the function is still returning a string (`resultString`). TypeScript expects the function to return a number because of the declared return type, but it actually returns a string, which causes a type mismatch error.
  id: |-
    hubfix_mbpp_ts_131
  lang: |-
    deno
  original_code: |-
    export async function main(str1: string): Promise<string> {
        let vowels = "";
        for (const char of str1) {
            if ("aeiouAEIOU".includes(char)) {
                vowels += char;
            }
        }
        let resultString = "";
        for (const char of str1) {
            if ("aeiouAEIOU".includes(char)) {
                resultString += vowels[vowels.length - 1];
                vowels = vowels.slice(0, -1);
            } else {
                resultString += char;
            }
        }
        return resultString;
    }
  original_instructions: |-
    reverse only the vowels of a given string (where y is not a vowel)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(list1: number[], list2: number[], list3: string[]): Promise<number> {
        const result = list1.map((m, i) => m === list2[i] && m === list3[i] ? 1 : 0).reduce((a, b) => a + b, 0);
        return result;
    }
  error: |-
    TS2345: Argument of type 'string[]' is not assignable to parameter of type 'number[]'.
  explanation: |-
    The function `main` is expecting three parameters, all of which should be arrays of numbers (`number[]`). However, the third parameter `list3` has been changed to an array of strings (`string[]`). This causes a type mismatch error because TypeScript expects all three parameters to be of the same type, specifically `number[]`. The comparison `m === list3[i]` would also fail at runtime because it is comparing a number to a string, which is not the intended behavior of the original function.
  id: |-
    hubfix_mbpp_ts_142
  lang: |-
    deno
  original_code: |-
    export async function main(list1: number[], list2: number[], list3: number[]): Promise<number> {
        const result = list1.map((m, i) => m === list2[i] && m === list3[i] ? 1 : 0).reduce((a, b) => a + b, 0);
        return result;
    }
  original_instructions: |-
    count number items that are identical in the same position of three given lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        const n = arr.length;
        let minEle = arr[0];
        let maxEle = arr[0];
        for (let i = 1; i < n; i++) {
            minEle = Math.min(minEle, arr[i]);
            maxEle = Math.max(maxEle, arr[i]);
        }
        return (maxEle - minEle);
    }
  error: |-
    TS2345: Argument of type 'string | number' is not assignable to parameter of type 'number'.
      Type 'string' is not assignable to type 'number'.
  explanation: |-
    The code is trying to use `Math.min` and `Math.max` with a mix of `string` and `number` types. The `arr` parameter is declared as an array of `string`, but `Math.min` and `Math.max` expect numbers as arguments. Additionally, the subtraction operation `(maxEle - minEle)` is not valid for strings. To fix the code, the `arr` parameter should be of type `number[]` as in the original code, and the operations should only be performed on numbers.
  id: |-
    hubfix_mbpp_ts_145
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        const n = arr.length;
        let minEle = arr[0];
        let maxEle = arr[0];
        for (let i = 1; i < n; i++) {
            minEle = Math.min(minEle, arr[i]);
            maxEle = Math.max(maxEle, arr[i]);
        }
        return (maxEle - minEle);
    }
  original_instructions: |-
    find the maximum difference between any two elements in a given array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    function div_sum(n: number): number {
      let total = 1;
      let i = 2;

      while (i * i <= n) {
        if (n % i == 0) {
          total += i + Math.floor(n / i);
        }
        i += "1"; // Error introduced here
      }

      return total;
    }

    export async function main(num1: number, num2: number): Promise<boolean> {
      return div_sum(num1) === div_sum(num2);
    }
  error: |-
    error TS2365: Operator '+=' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The error is caused by trying to add a string "1" to a number `i` using the `+=` operator. In TypeScript, you cannot add a string to a number because they are different types. The `+=` operator expects both operands to be of the same type when used with numbers. To fix the error, the string "1" should be changed back to the number `1`.
  id: |-
    hubfix_mbpp_ts_164
  lang: |-
    deno
  original_code: |-
    function div_sum(n: number): number {
      let total = 1;
      let i = 2;

      while (i * i <= n) {
        if (n % i == 0) {
          total += i + Math.floor(n / i);
        }
        i += 1;
      }

      return total;
    }

    export async function main(num1: number, num2: number): Promise<boolean> {
      return div_sum(num1) === div_sum(num2);
    }
  original_instructions: |-
    determine if the sum of the divisors of two integers are the same
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(str1: string): Promise<number> {
        let count_chars: string = 0;
        for (let i = 0; i < str1.length; i++) {
            if ((i === str1.charCodeAt(i) - 'A'.charCodeAt(0)) ||
                (i === str1.charCodeAt(i) - 'a'.charCodeAt(0))) {
                count_chars += 1;
            }
        }
        return count_chars;
    }
  error: |-
    Type 'string' is not assignable to type 'number'.
  explanation: |-
    The variable `count_chars` is declared with the type `string`, but it is initialized with a number (`0`). This is a type mismatch according to TypeScript's static type checking. Additionally, the function is supposed to return a `Promise<number>`, but due to the incorrect type of `count_chars`, it would attempt to return a `Promise<string>`, which is another type mismatch. The correct code should have `count_chars` declared as a `number`.
  id: |-
    hubfix_mbpp_ts_165
  lang: |-
    deno
  original_code: |-
    export async function main(str1: string): Promise<number> {
        let count_chars: number = 0;
        for (let i = 0; i < str1.length; i++) {
            if ((i === str1.charCodeAt(i) - 'A'.charCodeAt(0)) ||
                (i === str1.charCodeAt(i) - 'a'.charCodeAt(0))) {
                count_chars += 1;
            }
        }
        return count_chars;
    }
  original_instructions: |-
    count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(A: number[]): Promise<string> {
      let count = 0;
      for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
          if (((A[i] ^ A[j]) % 2) === 0) {
            count += "1";
          }
        }
      }
      return count;
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    The error occurs because the variable `count` is initialized as a number (`let count = 0;`), but inside the nested loop, it is being incremented by a string (`count += "1";`). This causes a type mismatch because TypeScript expects `count` to always be a number, but the operation is trying to concatenate a string to it, which would result in a string. Additionally, the function is declared to return a `Promise<number>`, but due to the incorrect increment, it would actually return a `Promise<string>`, which is another type mismatch.
  id: |-
    hubfix_mbpp_ts_166
  lang: |-
    deno
  original_code: |-
    export async function main(A: number[]): Promise<number> {
      let count = 0;
      for (let i = 0; i < A.length; i++) {
        for (let j = i + 1; j < A.length; j++) {
          if (((A[i] ^ A[j]) % 2) === 0) {
            count += 1;
          }
        }
      }
      return count;
    }
  original_instructions: |-
    counts the number of pairs of integers in a list that xor to an even number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
      if (n && !(n & (n - 1))) {
        return n;
      }

      let count = 0;
      while (n !== 0) {
        n >>= 1;
        count += 1;
      }

      return 1 << count;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` was originally expecting a parameter of type `number`, but it has been changed to expect a parameter of type `string`. This is incorrect because the bitwise operations inside the function (`&`, `-`, `>>=`, `<<`) are only applicable to numbers, not strings. Additionally, the return statement `return n;` is also incorrect because the function is supposed to return a `number`, but `n` is a `string`. The TypeScript compiler will throw an error because of the type mismatch.
  id: |-
    hubfix_mbpp_ts_167
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
      if (n && !(n & (n - 1))) {
        return n;
      }

      let count = 0;
      while (n !== 0) {
        n >>= 1;
        count += 1;
      }

      return 1 << count;
    }
  original_instructions: |-
    find the smallest power of 2 greater than or equal to n
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number[], x: string): Promise<number> {
        let count = 0;
        for (let i of a) {
            if (i === y) {
                count += 1;
            }
        }
        return count;
    }
  error: |-
    error TS2304: Cannot find name 'y'.
  explanation: |-
    The variable `y` is used in the comparison `if (i === y)` but it is not defined anywhere in the code. The correct variable to use in the comparison is `x`, which is passed as a parameter to the function. Additionally, the type of the parameter `x` has been changed from `number` to `string`, which is inconsistent with the type of elements in the array `a` that are being compared against `x`. The parameter `x` should remain of type `number` to match the type of elements in the array `a`.
  id: |-
    hubfix_mbpp_ts_168
  lang: |-
    deno
  original_code: |-
    export async function main(a: number[], x: number): Promise<number> {
        let count = 0;
        for (let i of a) {
            if (i === x) {
                count += 1;
            }
        }
        return count;
    }
  original_instructions: |-
    count the number of occurrences of a number in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: string): Promise<number> {
      const perimeter: number = (5 * a);
      return perimeter;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting a parameter `a` of type `number`, but the type has been changed to `string`. TypeScript is a statically typed language, which means that types are checked at compile time. Multiplying a string with a number (`5 * a`) is not a valid operation in TypeScript, as the `*` operator is not defined for a combination of a number and a string. This results in a type error because TypeScript expects both operands of the multiplication to be of type `number`.
  id: |-
    hubfix_mbpp_ts_171
  lang: |-
    deno
  original_code: |-
    export async function main(a: number): Promise<number> {
      const perimeter: number = (5 * a);
      return perimeter;
    }
  original_instructions: |-
    find the perimeter of a regular pentagon from the length of its sides
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: number): Promise<number> {
      let count = 0;
      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === 's' && s[i + 1] === 't' && s[i + 2] === 'd') {
          count = count + 1;
        }
      }
      return count;
    }
  error: |-
    TypeError: s.length is not a property
  explanation: |-
    The code is broken because the parameter `s` is now of type `number`, but the code is trying to access `s.length` and `s[i]`, which are properties and indexing operations that only exist on strings, not numbers. Numbers in TypeScript do not have a `length` property or support indexing, so this will cause a runtime error.
  id: |-
    hubfix_mbpp_ts_172
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<number> {
      let count = 0;
      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === 's' && s[i + 1] === 't' && s[i + 2] === 'd') {
          count = count + 1;
        }
      }
      return count;
    }
  original_instructions: |-
    count the number of occurence of the string 'std' in a given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let count = 0;
        while (n) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
  error: |-
    error TS2365: Operator '&=' cannot be applied to types 'number' and 'string'.
    error TS2448: Block-scoped variable 'n' used before its declaration.
  explanation: |-
    The code is broken because the parameter `n` is changed from type `number` to `string`. The bitwise operations `&` and `>>=` are not valid when applied to a string. TypeScript expects both operands to be of type `number` for these operations. Additionally, the while loop attempts to use the variable `n` in a way that is only valid for numbers, not strings.
  id: |-
    hubfix_mbpp_ts_224
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let count = 0;
        while (n) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
  original_instructions: |-
    count the number of set bits (binary digits with value 1) in a given number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: number): Promise<number> {
      let result = 0;
      for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0) {
          result += s[i];
        }
      }
      return result;
    }
  error: |-
    TS2339: Property 'length' does not exist on type 'number'.
    TS2538: Type 'undefined' cannot be used as an index type.
    TS2365: Operator '+=' cannot be applied to types 'number' and 'undefined'.
  explanation: |-
    The code is broken because of the following reasons:
    - The parameter `s` is changed from `string` to `number`, but the method `length` does not exist on type `number`. In JavaScript and TypeScript, the `length` property is used with string or array types, not numbers.
    - The `result` variable is changed from `string` to `number`, but the code attempts to concatenate a string to it using `+=` with `s[i]`, which is invalid because `s` is now a number and does not support indexing.
    - Since `s` is a number, `s[i]` is `undefined`, and you cannot add `undefined` to a number with `+=`.
  id: |-
    hubfix_mbpp_ts_226
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<string> {
      let result = "";
      for (let i = 0; i < s.length; i++) {
        if (i % 2 === 0) {
          result += s[i];
        }
      }
      return result;
    }
  original_instructions: |-
    remove the characters which have odd index values of a given string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number, b: string, c: number): Promise<number> {
      let smallest: number;
      if (a <= b && a <= c) {
        smallest = a;
      } else if (b <= a && b <= c) {
        smallest = b;
      } else {
        smallest = c;
      }
      return smallest;
    }
  error: |-
    TS2365: Operator '<=' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The code is trying to compare a number (`a`) with a string (`b`) using the less than or equal to operator (`<=`). TypeScript does not allow comparison between values of different types in this way, which is why the error is thrown. The parameter `b` is declared as a `string`, but it should be a `number` to be comparable with `a` and `c`.
  id: |-
    hubfix_mbpp_ts_227
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
      let smallest: number;
      if (a <= b && a <= c) {
        smallest = a;
      } else if (b <= a && b <= c) {
        smallest = b;
      } else {
        smallest = c;
      }
      return smallest;
    }
  original_instructions: |-
    find minimum of three numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateLateralSurface(r: string, h: number): Promise<number> {
        const lateralsurface: number = 2 * Math.PI * parseInt(r) * h;
        return lateralsurface;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `calculateLateralSurface` is expecting the first parameter `r` to be of type `string`, which is incorrect because the original code expects a `number`. The `parseInt` function is used to convert the string to a number, but this is a workaround for a mistake in the function's parameter type. The correct approach would be to keep the parameter `r` as a number and not use `parseInt`.
  id: |-
    hubfix_mbpp_ts_233
  lang: |-
    deno
  original_code: |-
    export async function main(r: number, h: number): Promise<number> {
        const lateralsurface: number = 2 * 3.1415 * r * h;
        return lateralsurface;
    }
  original_instructions: |-
    find the lateral surface area of a cylinder
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(m: string, n: number): Promise<number> {
        let T: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) {
            for (let j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    T[i][j] = 0;
                } else if (i < j) {
                    T[i][j] = 0;
                } else if (j == 1) {
                    T[i][j] = i;
                } else {
                    T[i][j] = T[i - 1][j] + T[Math.floor(i / 2)][j - 1];
                }
            }
        }
        return T[m][n];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the type of the parameter `m` has been changed from `number` to `string`. The operations inside the function, such as `m + 1`, `i <= m`, and `T[m][n]`, expect `m` to be a number, not a string. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_239
  lang: |-
    deno
  original_code: |-
    export async function main(m: number, n: number): Promise<number> {
        let T: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) {
            for (let j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    T[i][j] = 0;
                } else if (i < j) {
                    T[i][j] = 0;
                } else if (j == 1) {
                    T[i][j] = i;
                } else {
                    T[i][j] = T[i - 1][j] + T[Math.floor(i / 2)][j - 1];
                }
            }
        }
        return T[m][n];
    }
  original_instructions: |-
    takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(str1: number): Promise<number> {
        let total = 0;
        for (const i of str1) {
            total = total + count;
        }
        return total;
    }
  error: |-
    TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.
    TS2304: Cannot find name 'count'.
  explanation: |-
    There are two errors in the modified code:

    1. The type of the parameter `str1` has been changed from `string` to `number`. In TypeScript, numbers are not iterable, which means you cannot use a `for...of` loop on them. This is why the error message states that the type 'number' must have a '[Symbol.iterator]()' method.

    2. The variable `count` is used in the expression `total = total + count;` but it has not been defined anywhere in the code. This is why the error message states that it cannot find the name 'count'.
  id: |-
    hubfix_mbpp_ts_242
  lang: |-
    deno
  original_code: |-
    export async function main(str1: string): Promise<number> {
        let total = 0;
        for (const i of str1) {
            total = total + 1;
        }
        return total;
    }
  original_instructions: |-
    count the total number of characters in a string
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(number: string): Promise<number> {
        if (number === 0) {
            return 0;
        }
        let g: number = number / 2.0;
        let g2: number = g + 1;
        while (g !== g2) {
            const n: number = number / g;
            g2 = g;
            g = (g + n) / 2;
        }
        return g;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `number` is now of type `string`, but it is being used in arithmetic operations as if it were a number. TypeScript expects the `number` parameter to be of type `number` to perform arithmetic operations like division. Additionally, the strict equality check `number === 0` is incorrect because `number` is a string and cannot be strictly equal to the number `0`.
  id: |-
    hubfix_mbpp_ts_246
  lang: |-
    deno
  original_code: |-
    export async function main(number: number): Promise<number> {
        if (number === 0) {
            return 0;
        }
        let g: number = number / 2.0;
        let g2: number = g + 1;
        while (g !== g2) {
            const n: number = number / g;
            g2 = g;
            g = (g + n) / 2;
        }
        return g;
    }
  original_instructions: |-
    Write a function for computing square roots using the babylonian method
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n < 2) {
            return 1.0;
        } else {
            return 1 / n + await main(n - 1);
        }
    }
  error: |-
    error TS2365: Operator '<' cannot be applied to types 'string' and 'number'.
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The code is broken because the parameter `n` is changed from type `number` to type `string`. TypeScript does not allow the use of the '<' operator between a string and a number, which causes the first error. Additionally, the recursive call to `main(n - 1)` is incorrect because `n - 1` results in a number, but the function now expects a string, causing the second error.
  id: |-
    hubfix_mbpp_ts_248
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n < 2) {
            return 1.0;
        } else {
            return 1 / n + await main(n - 1);
        }
    }
  original_instructions: |-
    takes in an integer n and calculates the harmonic sum of n-1
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(tup: any[], x: any): Promise<string> {
        let count = 0;
        for (const ele of tup) {
            if (ele === x) {
                count = count + 1;
            }
        }
        return count;
    }
  error: |-
    TS2322: Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function `main` is declared to return a `Promise<string>`, but the actual return value is a number (`count`). TypeScript expects the return type to match the declared return type, which is `string` in this case. To fix this error, the return type of the function should be changed to `Promise<number>` to match the type of `count`.
  id: |-
    hubfix_mbpp_ts_250
  lang: |-
    deno
  original_code: |-
    export async function main(tup: any[], x: any): Promise<number> {
        let count = 0;
        for (const ele of tup) {
            if (ele === x) {
                count = count + 1;
            }
        }
        return count;
    }
  original_instructions: |-
    takes in a tuple and an element and counts the occcurences of the element in the tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let ctr = 0;
        for (let num = 0; num < n; num++) {
            if (num <= 1) {
                continue;
            }
            let isPrime = true;
            for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {
                if (num % i === 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                ctr++;
            }
        }
        return ctr;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the parameter `n` is declared as a `string` type, but it is used in a numeric context (`num < n`). The `for` loop expects a number for its comparison, but it receives a string instead. TypeScript's type system catches this mismatch at compile time, resulting in the error message. The parameter `n` should remain as type `number` to match the expected usage within the loop.
  id: |-
    hubfix_mbpp_ts_256
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let ctr = 0;
        for (let num = 0; num < n; num++) {
            if (num <= 1) {
                continue;
            }
            let isPrime = true;
            for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {
                if (num % i === 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                ctr++;
            }
        }
        return ctr;
    }
  original_instructions: |-
    takes in a non-negative number and returns the number of prime numbers less than the given non-negative number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n === 0 || n === 1) {
            return 1;
        }
        return 2 * await main(n - 1) + await main(n - 2);
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The code is broken because the parameter `n` is changed from `number` to `string`. TypeScript expects arithmetic operations to be performed on numbers, not strings. Additionally, when the `main` function is recursively called with `n - 1` and `n - 2`, it expects a `string` as an argument, but `n - 1` and `n - 2` are numbers. This results in a type mismatch error because a `number` is being passed to a function that expects a `string`.
  id: |-
    hubfix_mbpp_ts_260
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 0 || n === 1) {
            return 1;
        }
        return 2 * await main(n - 1) + await main(n - 2);
    }
  original_instructions: "find the nth newman\u2013shanks\u2013williams prime number"
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(test_tup1: number[], test_tup2: string[]): Promise<number[]> {
        const res: number[] = test_tup1.map((ele1, index) => Math.floor(ele1 / test_tup2[index]));
        return res;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the `test_tup2` parameter is changed from `number[]` to `string[]`, which means that the array is expected to contain strings instead of numbers. However, inside the `map` function, the code attempts to divide `ele1` (which is a number) by `test_tup2[index]` (which is now a string). The division operation is not defined for a number divided by a string, hence TypeScript throws an error indicating that a string cannot be assigned to a parameter that is expected to be a number.
  id: |-
    hubfix_mbpp_ts_261
  lang: |-
    deno
  original_code: |-
    export async function main(test_tup1: number[], test_tup2: number[]): Promise<number[]> {
        const res: number[] = test_tup1.map((ele1, index) => Math.floor(ele1 / test_tup2[index]));
        return res;
    }
  original_instructions: |-
    takes in two tuples and performs mathematical division operation element-wise across the given tuples
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(h_age: string): Promise<number> {
        if (h_age < 0) {
            process.exit();
        }

        let d_age: number;
        if (h_age <= 2) {
            d_age = h_age * 10.5;
        } else {
            d_age = 21 + (h_age - 2) * 4;
        }

        return d_age;
    }
  error: |-
    error TS2365: Operator '<' cannot be applied to types 'string' and 'number'.
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is broken because the parameter `h_age` is now of type `string`, but it is being used in arithmetic operations and comparisons that are only valid for numbers. TypeScript expects both operands in arithmetic operations and comparisons to be of type `number`, `any`, `bigint`, or an enum type. Since `h_age` is a string, the operations `<`, `<=`, `*`, and `-` are invalid when applied to a string and a number.
  id: |-
    hubfix_mbpp_ts_264
  lang: |-
    deno
  original_code: |-
    export async function main(h_age: number): Promise<number> {
        if (h_age < 0) {
            process.exit();
        }

        let d_age: number;
        if (h_age <= 2) {
            d_age = h_age * 10.5;
        } else {
            d_age = 21 + (h_age - 2) * 4;
        }

        return d_age;
    }
  original_instructions: |-
    calculate a dog's age in dog's years
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        let sum = 0;
        for (let i = 0; i < arr.length; i += 2) {
            if (arr[i] % 2 === 0) {
                sum += arr[i];
            }
        }
        return sum;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the type of the elements in the array `arr` has been changed from `number[]` to `string[]`. This causes two types of errors:

    1. The modulo operation (`%`) is not valid for strings, which is why the error message complains about the left-hand side of an arithmetic operation needing to be a number, bigint, or enum.
    2. The addition operation (`+=`) is also not valid when trying to add a string to a number, which is why the error message indicates that a string cannot be assigned to a number parameter.
  id: |-
    hubfix_mbpp_ts_270
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let sum = 0;
        for (let i = 0; i < arr.length; i += 2) {
            if (arr[i] % 2 === 0) {
                sum += arr[i];
            }
        }
        return sum;
    }
  original_instructions: |-
    find the sum of even numbers at even positions of a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return (1 << (n - 1));
    }
  error: |-
    error TS2365: Operator '-' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The error occurs because the minus operator ('-') is used between a string and a number, which is not allowed in TypeScript. The parameter `n` is declared as a string, but it should be a number to perform arithmetic operations. The code is trying to subtract 1 from `n`, which is not a valid operation for a string.
  id: |-
    hubfix_mbpp_ts_274
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        return (1 << (n - 1));
    }
  original_instructions: |-
    takes in a positive integer n and finds the sum of even index binomial coefficients
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateVolume(r: string, h: number): Promise<number> {
      const volume: number = 3.1415 * r * r * h;
      return volume;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `calculateVolume` is expecting the first parameter `r` to be of type `string`, but it should be a `number` to perform arithmetic operations. Multiplying a string with a number is not a valid operation in TypeScript, which causes the type error.
  id: |-
    hubfix_mbpp_ts_276
  lang: |-
    deno
  original_code: |-
    export async function main(r: number, h: number): Promise<number> {
      const volume: number = 3.1415 * r * r * h;
      return volume;
    }
  original_instructions: |-
    takes in the radius and height of a cylinder and returns the the volume
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(test_tup: any[]): Promise<string> {
        let count: number = 0;
        for (const ele of test_tup) {
            if (ele instanceof Array) {
                break;
            }
            count++;
        }
        return count.toString().repeat();
    }
  error: |-
    TS2554: Expected 1 arguments, but got 0.
  explanation: |-
    The `repeat()` method is called without any arguments, but it requires one argument which is the number of times to repeat the string. Since no argument is provided, TypeScript throws an error indicating that it expected 1 argument but got 0.

    Additionally, the return type of the function is declared as `Promise<string>`, but the original function was correctly returning `Promise<number>`. This change in return type is not an error by itself, but it is inconsistent with the original function's intent and could lead to errors if the function is expected to return a number elsewhere in the code.
  id: |-
    hubfix_mbpp_ts_278
  lang: |-
    deno
  original_code: |-
    export async function main(test_tup: any[]): Promise<number> {
        let count: number = 0;
        for (const ele of test_tup) {
            if (ele instanceof Array) {
                break;
            }
            count++;
        }
        return count;
    }
  original_instructions: |-
    find the number of elements that occurs before the tuple element in the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return 4 * n * n - 3 * n;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The function `main` is expecting a parameter `n` of type `string`, but it is being used in an arithmetic operation, which requires operands to be of type 'any', 'number', 'bigint', or an enum type. Since `n` is a string, the multiplication and subtraction operations are invalid, causing the TypeScript compiler to throw an error.
  id: |-
    hubfix_mbpp_ts_279
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        return 4 * n * n - 3 * n;
    }
  original_instructions: |-
    find the nth decagonal number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(test_list: any[]): Promise<string> {
        if (test_list.length > new Set(test_list).size) {
            return "false";
        }
        return true;
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'Promise<boolean>'.
  explanation: |-
    The function `main` is declared to return a `Promise<boolean>`, but the return statement inside the `if` block is returning a string `"false"` instead of a boolean `false`. The return type of the function must match the declared return type, which is `Promise<boolean>`. To fix this, the string `"false"` should be changed back to the boolean `false`.
  id: |-
    hubfix_mbpp_ts_281
  lang: |-
    deno
  original_code: |-
    export async function main(test_list: any[]): Promise<boolean> {
        if (test_list.length > new Set(test_list).size) {
            return false;
        }
        return true;
    }
  original_instructions: |-
    check if the elements of a given list are unique or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<boolean> {
        for (let i = 0; i < 10; i++) {
            let temp = n;
            let count = 0;
            while (temp) {
                if (parseInt(temp) % 10 === i) {
                    count += 1;
                }
                if (count > i) {
                    return false;
                }
                temp = Math.floor(parseInt(temp) / 10);
            }
        }
        return true;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the `parseInt` function is being used on a string `temp` and the result is passed to `Math.floor`, which expects a number as its argument. However, the type of `temp` was changed from `number` to `string` in the function parameter, which is not compatible with the operations being performed on it that expect a number. The `parseInt` function is used to convert strings to numbers, but the way it's being used here is incorrect because `temp` should remain a number throughout the function. The correct approach would be to keep the parameter `n` as a number and not change it to a string.
  id: |-
    hubfix_mbpp_ts_283
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        for (let i = 0; i < 10; i++) {
            let temp = n;
            let count = 0;
            while (temp) {
                if (temp % 10 === i) {
                    count += 1;
                }
                if (count > i) {
                    return false;
                }
                temp = Math.floor(temp / 10);
            }
        }
        return true;
    }
  original_instructions: |-
    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number[], n: number, k: string): Promise<number> {
        let max_so_far: number = -2147483648;
        let max_ending_here: number = 0;
        for (let i = 0; i < n * k; i++) {
            max_ending_here = max_ending_here + a[i % n];
            if (max_so_far < max_ending_here) {
                max_so_far = max_ending_here;
            }
            if (max_ending_here < 0) {
                max_ending_here = 0;
            }
        }
        return max_so_far;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the type of the parameter `k` has been changed from `number` to `string`. The operation `n * k` expects both `n` and `k` to be numbers, but since `k` is now a string, TypeScript throws an error indicating that a string cannot be used in a multiplication operation with a number.
  id: |-
    hubfix_mbpp_ts_286
  lang: |-
    deno
  original_code: |-
    export async function main(a: number[], n: number, k: number): Promise<number> {
        let max_so_far: number = -2147483648;
        let max_ending_here: number = 0;
        for (let i = 0; i < n * k; i++) {
            max_ending_here = max_ending_here + a[i % n];
            if (max_so_far < max_ending_here) {
                max_so_far = max_ending_here;
            }
            if (max_ending_here < 0) {
                max_ending_here = 0;
            }
        }
        return max_so_far;
    }
  original_instructions: |-
    find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string, k: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        const total: number = k;
        const mod: number = 1000000007;
        dp[1] = k;
        dp[2] = k * k;
        for (let i = 3; i <= n; i++) {
            dp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod;
        }
        return dp[n];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the type of the parameter `n` has been changed from `number` to `string`. The `Array` constructor expects a number argument for the array size, but it is being passed a string instead. Additionally, the operations inside the loop such as `i <= n`, `dp[i - 1]`, and `dp[i - 2]` are not valid when `n` is a string, as these operations require `n` to be a number.
  id: |-
    hubfix_mbpp_ts_291
  lang: |-
    deno
  original_code: |-
    export async function main(n: number, k: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        const total: number = k;
        const mod: number = 1000000007;
        dp[1] = k;
        dp[2] = k * k;
        for (let i = 3; i <= n; i++) {
            dp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod;
        }
        return dp[n];
    }
  original_instructions: |-
    find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string, m: number): Promise<number> {
        let q = Math.floor(n / m);
        return q;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The error occurs because the function `main` is trying to perform an arithmetic division operation (`n / m`) where `n` is of type `string` and `m` is of type `number`. In TypeScript, you cannot divide a string by a number directly, as the `/` operator is not defined for a combination of `string` and `number` types. The left-hand operand of the division must be of type `any`, `number`, `bigint`, or an enum type, but not `string`.
  id: |-
    hubfix_mbpp_ts_292
  lang: |-
    deno
  original_code: |-
    export async function main(n: number, m: number): Promise<number> {
        let q = Math.floor(n / m);
        return q;
    }
  original_instructions: |-
    find quotient of two numbers (rounded down to the nearest integer)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(w: number, h: string): Promise<number> {
      const s: number = Math.sqrt((w * w) + (h * h));
      return s;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting two parameters of type `number`, but the second parameter `h` has been changed to type `string`. The `Math.sqrt` function expects a number as its argument, but because `h` is a string, the expression `(w * w) + (h * h)` is invalid as it tries to perform arithmetic operations with a number and a string. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_293
  lang: |-
    deno
  original_code: |-
    export async function main(w: number, h: number): Promise<number> {
      const s: number = Math.sqrt((w * w) + (h * h));
      return s;
    }
  original_instructions: |-
    find the third side of a right angled triangle
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(listval: Array<number>): Promise<number> {
        const result = Math.maximum(...listval.filter(i => typeof i === 'number'));
        return result;
    }
  error: |-
    error TS2339: Property 'maximum' does not exist on type 'Math'.
  explanation: |-
    The code is attempting to call a method `maximum` on the global `Math` object, which does not exist. The correct method for finding the maximum value in JavaScript is `Math.max`. By changing `max` to `maximum`, the code is now referencing a non-existent method, which causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_mbpp_ts_294
  lang: |-
    deno
  original_code: |-
    export async function main(listval: Array<number>): Promise<number> {
        const main = Math.max(...listval.filter(i => typeof i === 'number'));
        return main;
    }
  original_instructions: |-
    find the maximum value in a given heterogeneous list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        let inv_count = 0;
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    inv_count++;
                }
            }
        }
        return inv_count;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` was originally designed to take an array of numbers (`number[]`) as its parameter. The code has been changed to expect an array of strings (`string[]`) instead. This is a type mismatch because the function logic is written to compare numerical values with the `>` operator, which does not make sense for string types in the context of this function. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_296
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let inv_count = 0;
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    inv_count++;
                }
            }
        }
        return inv_count;
    }
  original_instructions: |-
    count inversions in an array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let nCr: number = 1;
        let res: number = 1;
        for (let r = 1; r <= n; r++) {
            nCr = (nCr * (n + 1 - r)) / r;
            res += nCr * nCr;
        }
        return res;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` was originally expecting a parameter `n` of type `number`, but the type has been changed to `string`. This causes a type mismatch because the operations inside the function are arithmetic operations that are only valid for numbers, not strings. Additionally, the loop condition `r <= n` and the expression `(n + 1 - r)` are not valid when `n` is a string. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_300
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let nCr: number = 1;
        let res: number = 1;
        for (let r = 1; r <= n; r++) {
            nCr = (nCr * (n + 1 - r)) / r;
            res += nCr * nCr;
        }
        return res;
    }
  original_instructions: |-
    find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: number[], ranges: [number, number][], rotations: string, index: number): Promise<number> {
        for (let i = rotations - 1; i >= 0; i--) {
            const [left, right] = ranges[i];
            if (left <= index && right >= index) {
                if (index === left) {
                    index = right;
                } else {
                    index -= 1;
                }
            }
        }
        return arr[index];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `rotations` parameter type was changed from `number` to `string`, which is incorrect because the script expects a number to be able to perform arithmetic operations like subtraction and comparison. TypeScript throws an error because you cannot subtract a number from a string or compare a string with a number in the for loop condition.
  id: |-
    hubfix_mbpp_ts_304
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[], ranges: [number, number][], rotations: number, index: number): Promise<number> {
        for (let i = rotations - 1; i >= 0; i--) {
            const [left, right] = ranges[i];
            if (left <= index && right >= index) {
                if (index === left) {
                    index = right;
                } else {
                    index -= 1;
                }
            }
        }
        return arr[index];
    }
  original_instructions: |-
    find element at a given index after number of rotations
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number[], n: number, index: number, k: string): Promise<number> {
        const dp: number[][] = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            if (a[i] > a[0]) {
                dp[0][i] = a[i] + a[0];
            } else {
                dp[0][i] = a[i];
            }
        }
        for (let i = 1; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (a[j] > a[i] && j > i) {
                    if (dp[i - 1][i] + a[j] > dp[i - 1][j]) {
                        dp[i][j] = dp[i - 1][i] + a[j];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[index][k];
    }
  error: |-
    Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error is caused by changing the type of the parameter `k` from `number` to `string`. The `dp` array is a two-dimensional array of numbers, and when accessing an element of this array, the indices must be numbers. By changing the type of `k` to `string`, TypeScript will throw an error because it expects a number for the index, not a string.
  id: |-
    hubfix_mbpp_ts_306
  lang: |-
    deno
  original_code: |-
    export async function main(a: number[], n: number, index: number, k: number): Promise<number> {
        const dp: number[][] = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            if (a[i] > a[0]) {
                dp[0][i] = a[i] + a[0];
            } else {
                dp[0][i] = a[i];
            }
        }
        for (let i = 1; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (a[j] > a[i] && j > i) {
                    if (dp[i - 1][i] + a[j] > dp[i - 1][j]) {
                        dp[i][j] = dp[i - 1][i] + a[j];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[index][k];
    }
  original_instructions: "find the maximum sum of increasing subsequence from prefix\
    \ until ith index and also including a given kth element which is after i, i.e.,\
    \ k > i "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateVolume(r: number, h: string): Promise<number> {
      const volume: number = (1.0 / 3) * Math.PI * r * r * h;
      return volume;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is trying to multiply a number (`r * r`) with a string (`h`), which is not a valid operation in TypeScript. The parameter `h` is declared as a `string` type, but it should be a `number` type to correctly calculate the volume of a cone. Additionally, the function `main` was renamed to `calculateVolume`, which could be a breaking change if other parts of the codebase are expecting a function named `main`.
  id: |-
    hubfix_mbpp_ts_312
  lang: |-
    deno
  original_code: |-
    export async function main(r: number, h: number): Promise<number> {
      const volume: number = (1.0 / 3) * Math.PI * r * r * h;
      return volume;
    }
  original_instructions: |-
    find the volume of a cone
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n === 'zero') {
            return 2;
        }
        if (n === 'one') {
            return 1;
        }
        return (await main(n - 1)) + (await main(n - 2));
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The function `main` has been modified to take a parameter `n` of type `string` instead of `number`. However, the recursive calls to `main` are passing `n - 1` and `n - 2`, which are arithmetic operations that result in `number` types, not `string` types. TypeScript throws an error because it expects a `string` as an argument for the `main` function, but a `number` is being passed instead.
  id: |-
    hubfix_mbpp_ts_389
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 0) {
            return 2;
        }
        if (n === 1) {
            return 1;
        }
        return (await main(n - 1)) + (await main(n - 2));
    }
  original_instructions: |-
    find the n'th lucas number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        const res: number[] = [];
        res.push(0);
        res.push(1);
        let i = 2;
        while (i < n + 1) {
            res.push(Math.max(i, (res[Math.floor(i / 2)]
                                + res[Math.floor(i / 3)] +
                                    res[Math.floor(i / 4)]
                                + res[Math.floor(i / 5)])));
            i = i + 1;
        }
        return res[n];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `n` of the `main` function has been changed from `number` to `string`. This causes two issues:

    1. The comparison `i < n + 1` is invalid because you cannot use the `<` operator to compare a `number` (`i`) with a `string` (`n`).
    2. The expression `res[n]` is invalid because `n` is a `string` and cannot be used as an index for an array of numbers.

    Additionally, the return type of the function is `Promise<number>`, but `res[n]` would return a `number` if `n` were a valid index, which it is not in this case because it's a string. The TypeScript compiler will throw an error because the types are not compatible.
  id: |-
    hubfix_mbpp_ts_392
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        const res: number[] = [];
        res.push(0);
        res.push(1);
        let i = 2;
        while (i < n + 1) {
            res.push(Math.max(i, (res[Math.floor(i / 2)]
                                + res[Math.floor(i / 3)] +
                                    res[Math.floor(i / 4)]
                                + res[Math.floor(i / 5)])));
            i = i + 1;
        }
        return res[n];
    }
  original_instructions: |-
    find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(string: number): Promise<string> {
        const regex = /^[a-z]$|^([a-z]).*\1$/;
        if (regex.test(string)) {
            return "Valid";
        } else {
            return "Invalid";
        }
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `regex.test` method expects a string as its argument, but the modified code is passing a number to it because the `main` function's parameter `string` was changed to type `number`. This is a type mismatch and TypeScript will throw an error because the `test` method cannot be called on a number.
  id: |-
    hubfix_mbpp_ts_396
  lang: |-
    deno
  original_code: |-
    export async function main(string: string): Promise<string> {
        const regex = /^[a-z]$|^([a-z]).*\1$/;
        if (regex.test(string)) {
            return "Valid";
        } else {
            return "Invalid";
        }
    }
  original_instructions: |-
    check whether the given string starts and ends with the same character or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number, b: string): Promise<number> {
        if (a <= b) {
            return a;
        } else {
            return b;
        }
    }
  error: |-
    error TS2365: Operator '<=' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The code is trying to compare a number (`a`) with a string (`b`) using the less than or equal to operator (`<=`), which is not allowed in TypeScript because it is a statically typed language that requires both operands in a comparison to be of the same type or types that can be compared with each other. Additionally, the function promises to return a number, but in the `else` block, it attempts to return `b`, which is a string. This is another type error because the return type of the function must be consistent with the declared return type `Promise<number>`.
  id: |-
    hubfix_mbpp_ts_404
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number): Promise<number> {
        if (a <= b) {
            return a;
        } else {
            return b;
        }
    }
  original_instructions: |-
    find the minimum of two numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(x: string): Promise<boolean> {
        let y = x ^ (x >> 1);
        y = y ^ (y >> 2);
        y = y ^ (y >> 4);
        y = y ^ (y >> 8);
        y = y ^ (y >> 16);
        return (y & 1) === 1;
    }
  error: |-
    TS2365: Operator '^' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The code is attempting to use bitwise operators on a string, which is not valid in TypeScript. Bitwise operators like '^' (XOR) and '>>' (right shift) are only applicable to numbers. The parameter `x` was changed from `number` to `string`, which is not compatible with these operators. To fix the error, the type of `x` should be reverted back to `number`.
  id: |-
    hubfix_mbpp_ts_406
  lang: |-
    deno
  original_code: |-
    export async function main(x: number): Promise<boolean> {
        let y = x ^ (x >> 1);
        y = y ^ (y >> 2);
        y = y ^ (y >> 4);
        y = y ^ (y >> 8);
        y = y ^ (y >> 16);
        return (y & 1) === 1;
    }
  original_instructions: |-
    find whether the parity of a given number is odd
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += Math.cube(2 * i);
        }
        return sum;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    TS2339: Property 'cube' does not exist on type 'Math'.
  explanation: |-
    There are two errors in the modified code:

    1. The parameter `n` is changed from `number` to `string`, which is incorrect because the loop condition `i <= n` expects `n` to be a number, not a string.

    2. The function `Math.cube` does not exist in the standard JavaScript Math object. The correct function to use is `Math.pow`, which was originally used to calculate the cube by raising the number to the power of 3.
  id: |-
    hubfix_mbpp_ts_420
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += Math.pow(2 * i, 3);
        }
        return sum;
    }
  original_instructions: |-
    find the cube sum of first n even natural numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: string, b: number, c: number): Promise<number> {
        const directrix: number = Math.floor(c - ((b * b) + 1) * 4 * a);
        return directrix;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting its first parameter `a` to be of type `number`, but it has been changed to type `string`. The multiplication operation `4 * a` is invalid because `a` is a string and cannot be multiplied by a number. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_430
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
        const directrix: number = Math.floor(c - ((b * b) + 1) * 4 * a);
        return directrix;
    }
  original_instructions: |-
    find the directrix of a parabola
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: number[], num: string): Promise<number> {
      arr.sort((a, b) => a - b);
      return num > arr[arr.length - 1];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `num` is declared as a `string` type, but it should be a `number` type to be comparable with the elements of the `arr` array. Additionally, the function is supposed to return a `Promise<boolean>`, but the return type has been changed to `Promise<number>`, which is incorrect. The comparison `num > arr[arr.length - 1]` is also invalid because you cannot compare a string with a number using the `>` operator.
  id: |-
    hubfix_mbpp_ts_433
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[], number: number): Promise<boolean> {
      arr.sort((a, b) => a - b);
      return number > arr[arr.length - 1];
    }
  original_instructions: |-
    check whether the entered number is greater than the elements of the given array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return (n % 10);
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is attempting to use the modulus operator (%) on a string (`n`), which is not allowed in TypeScript. The modulus operator is only applicable to numbers, bigints, or enum types. By changing the type of the parameter `n` from `number` to `string`, the operation becomes invalid, causing the TypeScript compiler to throw an error.
  id: |-
    hubfix_mbpp_ts_435
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        return (n % 10);
    }
  original_instructions: |-
    find the last digit of a given number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(L: number[]): Promise<string> {
      const x: string = parseInt(L.map(String).join(""));
      return x;
    }
  error: |-
    TS2322: Type 'number' is not assignable to type 'string'.
  explanation: |-
    The variable `x` is declared with a type of `string`, but the `parseInt` function returns a `number`. This causes a type mismatch because TypeScript expects `x` to be a string as per its type annotation, but it's being assigned a number. Additionally, the function `main` is declared to return a `Promise<string>`, but it actually returns a `Promise<number>` because `parseInt` returns a number. The return type of the function should match the type of the value being returned.
  id: |-
    hubfix_mbpp_ts_439
  lang: |-
    deno
  original_code: |-
    export async function main(L: number[]): Promise<number> {
      const x: number = parseInt(L.map(String).join(""));
      return x;
    }
  original_instructions: |-
    join a list of multiple integers into a single integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateSurfaceArea(sideLength: string): Promise<number> {
      const surfaceArea: number = 6 * sideLength * sideLength;
      return surfaceArea;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `calculateSurfaceArea` expects a parameter `sideLength` of type `string`, but it should be of type `number` because it is used in a mathematical operation to calculate the surface area of a cube. The multiplication operator `*` is not defined for the combination of a number and a string, which leads to a type error. The parameter type should be changed back to `number` to fix the error.
  id: |-
    hubfix_mbpp_ts_441
  lang: |-
    deno
  original_code: |-
    export async function main(l: number): Promise<number> {
      const surfacearea: number = 6 * l * l;
      return surfacearea;
    }
  original_instructions: |-
    find the surface area of a cube of a given size
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number> {
        const n = nums.length;
        let n1 = 0;
        for (const x of nums) {
            if (x > 0) {
                n1 += 1;
            }
        }
        return parseFloat((n1 / n).toFixed(2));
    }
  error: |-
    error TS2365: Operator '>' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The code is broken because the type of the `nums` parameter has been changed from `number[]` to `string[]`. The comparison `x > 0` is invalid because `x` is now a string, and the '>' operator cannot be applied to a string and a number. TypeScript expects both operands to be of comparable types, such as both numbers or both strings, but not a mix of the two.
  id: |-
    hubfix_mbpp_ts_442
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        const n = nums.length;
        let n1 = 0;
        for (const x of nums) {
            if (x > 0) {
                n1 += 1;
            }
        }
        return parseFloat((n1 / n).toFixed(2));
    }
  original_instructions: |-
    find the ration of positive numbers in an array of integers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number[]> {
        const results: number[] = nums.map(x => x ** 3);
        return results;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is trying to perform a mathematical operation (exponentiation) on a string, which is not possible. The `map` function is being called on an array of strings (`nums: string[]`), and the callback function is trying to raise each string to the power of 3 (`x ** 3`). However, exponentiation can only be performed on numbers, not strings. To fix this, the type of `nums` should be `number[]` instead of `string[]`.
  id: |-
    hubfix_mbpp_ts_447
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        const main: number[] = nums.map(x => x ** 3);
        return main;
    }
  original_instructions: |-
    find cubes of individual elements in a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let a: number = 3;
        let b: number = 0;
        let c: number = 2;
        if (n === 0) {
            return 3;
        }
        if (n === 1) {
            return 3;
        }
        if (n === 2) {
            return 5;
        }
        let sum: number = 5;
        while (n > 2) {
            let d: number = a + b;
            sum = sum + d;
            a = b;
            b = c;
            c = d;
            n = n - 1;
        }
        return sum;
    }
  error: |-
    Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting a parameter of type `number`, but the type of the parameter `n` has been changed to `string`. TypeScript is a statically typed language, which means that the types of variables, parameters, and return values are checked at compile time. By changing the type of `n` to `string`, the code will no longer compile because the operations performed on `n` (such as comparison with numbers and subtraction) are not valid for strings.
  id: |-
    hubfix_mbpp_ts_448
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let a: number = 3;
        let b: number = 0;
        let c: number = 2;
        if (n === 0) {
            return 3;
        }
        if (n === 1) {
            return 3;
        }
        if (n === 2) {
            return 5;
        }
        let sum: number = 5;
        while (n > 2) {
            let d: number = a + b;
            sum = sum + d;
            a = b;
            b = c;
            c = d;
            n = n - 1;
        }
        return sum;
    }
  original_instructions: |-
    calculate the sum of perrin numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n % 2 !== 0) {
            return 0;
        }
        let res = 1;
        for (let i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {
            let count = 0;
            let curr_sum = 1;
            let curr_term = 1;
            while (n % i === 0) {
                count++;
                n = Math.floor(n / i).toString();
                if (i === 2 && count === 1) {
                    curr_sum = 0;
                }
                curr_term *= i;
                curr_sum += curr_term;
            }
            res *= curr_sum;
        }
        if (n >= 2) {
            res *= (1 + n);
        }
        return res;
    }
  error: |-
    error TS2365: Operator '%' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The code is broken because the parameter `n` is changed from type `number` to type `string`. The modulo operator `%` and the division `/` are not defined for a string and a number in TypeScript, which causes the error. Additionally, the `Math.sqrt` function expects a number argument, not a string. The comparison `n >= 2` is also invalid because `n` is a string and `2` is a number. The code attempts to perform arithmetic operations on a string as if it were a number, which is not allowed in TypeScript.
  id: |-
    hubfix_mbpp_ts_453
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n % 2 !== 0) {
            return 0;
        }
        let res = 1;
        for (let i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {
            let count = 0;
            let curr_sum = 1;
            let curr_term = 1;
            while (n % i === 0) {
                count++;
                n = Math.floor(n / i);
                if (i === 2 && count === 1) {
                    curr_sum = 0;
                }
                curr_term *= i;
                curr_sum += curr_term;
            }
            res *= curr_sum;
        }
        if (n >= 2) {
            res *= (1 + n);
        }
        return res;
    }
  original_instructions: |-
    find the sum of even factors of a number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(text: number): Promise<boolean> {
        const patterns = '\\w*z.\\w*';
        return new RegExp(patterns).test(text);
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `test` method of the `RegExp` object expects a string as its parameter, but the modified code is passing a number to it because the `text` parameter type was changed from `string` to `number`. This type mismatch causes TypeScript to throw an error.
  id: |-
    hubfix_mbpp_ts_454
  lang: |-
    deno
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = '\\w*z.\\w*';
        return new RegExp(patterns).test(text);
    }
  original_instructions: |-
    matches a word containing 'z'
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: number[]): Promise<string> {
      const n: number = arr.length;
      const mpis: number[] = arr.slice();
      for (let i = 0; i < n; i++) {
        let current_prod: number = arr[i];
        let j: number = i + 1;
        while (j < n) {
          if (arr[j - 1] > arr[j]) {
            break;
          }
          current_prod *= arr[j];
          if (current_prod > mpis[j]) {
            mpis[j] = current_prod;
          }
          j++;
        }
      }
      return Math.max(...mpis).toString();
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'Promise<number>'.
  explanation: |-
    The function `main` is declared to return a `Promise<number>`, but the actual return statement is returning a `string` because of the `.toString()` method applied to the result of `Math.max(...mpis)`. This is a type mismatch error because TypeScript expects the function to return a `Promise<number>`, not a `Promise<string>`.
  id: |-
    hubfix_mbpp_ts_468
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
      const n: number = arr.length;
      const mpis: number[] = arr.slice();
      for (let i = 0; i < n; i++) {
        let current_prod: number = arr[i];
        let j: number = i + 1;
        while (j < n) {
          if (arr[j - 1] > arr[j]) {
            break;
          }
          current_prod *= arr[j];
          if (current_prod > mpis[j]) {
            mpis[j] = current_prod;
          }
          j++;
        }
      }
      return Math.max(...mpis);
    }
  original_instructions: |-
    find the maximum product formed by multiplying numbers of an increasing subsequence of that array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(test_tup: number[]): Promise<string[]> {
        const res = test_tup.slice(0, -1).map((value, index) => value + test_tup[index + 1]);
        return res;
    }
  error: |-
    TS2322: Type 'number[]' is not assignable to type 'string[]'.
      Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function `main` is declared to return a `Promise<string[]>`, which means it should resolve to an array of strings. However, the actual implementation returns `res`, which is an array of numbers (`number[]`) as a result of adding two numbers together. This type mismatch between the return type of the function and the actual type of the returned value causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_mbpp_ts_470
  lang: |-
    deno
  original_code: |-
    export async function main(test_tup: number[]): Promise<number[]> {
        const res = test_tup.slice(0, -1).map((value, index) => value + test_tup[index + 1]);
        return res;
    }
  original_instructions: |-
    find the pairwise addition of the neighboring elements of the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: number[]): Promise<boolean> {
        const sortedList = [...l].sort((a, b) => a - b);
        const rangeList = Array.from({ length: Math.max(...l) - Math.min(...l) + 1 }, (_, i) => i + Math.min(...k));
        return JSON.stringify(sortedList) === JSON.stringify(rangeList);
    }
  error: |-
    ReferenceError: k is not defined
  explanation: |-
    In the modified code, the variable `k` is used inside the `Array.from` method, but it has not been defined anywhere in the code. The original code uses `Math.min(...l)` to calculate the starting value of the range, but the broken code incorrectly attempts to use `Math.min(...k)`, which fails because `k` does not exist. The correct variable to use is `l`, which is the parameter of the `main` function representing the list of numbers.
  id: |-
    hubfix_mbpp_ts_472
  lang: |-
    deno
  original_code: |-
    export async function main(l: number[]): Promise<boolean> {
        const sortedList = [...l].sort((a, b) => a - b);
        const rangeList = Array.from({ length: Math.max(...l) - Math.min(...l) + 1 }, (_, i) => i + Math.min(...l));
        return JSON.stringify(sortedList) === JSON.stringify(rangeList);
    }
  original_instructions: |-
    check whether the given list contains consecutive numbers or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: Array<number>): Promise<string> {
        const sumValue: number = Math.maximum(...nums) + Math.minimum(...nums);
        return sumValue;
    }
  error: |-
    TS2322: Type 'number' is not assignable to type 'string'.
    TS2339: Property 'maximum' does not exist on type 'Math'.
    TS2339: Property 'minimum' does not exist on type 'Math'.
  explanation: |-
    There are multiple issues with the modified code:

    1. The return type of the function `main` has been changed from `Promise<number>` to `Promise<string>`, but the function still returns a number. This causes a type mismatch error because TypeScript expects a string to be returned based on the function signature.

    2. The `Math.max` function has been incorrectly renamed to `Math.maximum`, and `Math.min` has been renamed to `Math.minimum`. These functions do not exist on the `Math` object, which leads to an error because TypeScript cannot find these properties on the `Math` object.
  id: |-
    hubfix_mbpp_ts_476
  lang: |-
    deno
  original_code: |-
    export async function main(nums: Array<number>): Promise<number> {
        const sumValue: number = Math.max(...nums) + Math.min(...nums);
        return sumValue;
    }
  original_instructions: |-
    find the sum of the largest and smallest value in a given array
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(numbers: string[]): Promise<number[]> {
        let od_li: number[] = [];
        for (let i of numbers) {
            if (i.isOdd()) {
                od_li.push(i);
            }
        }
        return od_li;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because of two main issues:

    1. The `main` function now expects an array of strings (`string[]`) as its parameter instead of an array of numbers (`number[]`). This is incorrect because the function logic is designed to work with numbers (checking if a number is odd).

    2. Inside the loop, the code attempts to call `isOdd()` on a string (`i`). The `isOdd()` method does not exist on the string type, and even if it did, it would not be appropriate to call it on a string when we are expecting a number. Additionally, `push(i)` is trying to push a string into an array of numbers (`od_li`), which is a type mismatch.

    To fix the code, the parameter type should be reverted to `number[]`, and the check for odd numbers should use `i % 2 !== 0` as it was originally. Also, the `push` method should only accept numbers, not strings.
  id: |-
    hubfix_mbpp_ts_554
  lang: |-
    deno
  original_code: |-
    export async function main(numbers: number[]): Promise<number[]> {
        let od_li: number[] = [];
        for (let i of numbers) {
            if (i % 2 !== 0) {
                od_li.push(i);
            }
        }
        return od_li;
    }
  original_instructions: |-
    Write a python function which takes a list of integers and only returns the odd ones
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
      if (n === 0) {
        return 0;
      } else {
        return n % 10 + await main(Math.floor(n / 10));
      }
    }
  error: |-
    error TS2365: Operator '===' cannot be applied to types 'string' and 'number'.
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The code is broken due to the following reasons:

    1. The parameter `n` is changed from `number` to `string`, which is incorrect because the function is performing arithmetic operations that are only valid for numbers.
    2. The strict equality check `n === 0` is invalid because `n` is now a string and `0` is a number, and TypeScript does not allow comparison between these two different types without explicit conversion.
    3. The modulus operator `%` is used on a string (`n % 10`), which is not valid because this operator is only defined for numbers.
    4. The `Math.floor(n / 10)` operation is invalid because `n` is a string and division is not defined for strings.
    5. The recursive call to `main` is passing a number (`Math.floor(n / 10)`) to a function that now expects a string, which is a type mismatch.
  id: |-
    hubfix_mbpp_ts_566
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
      if (n === 0) {
        return 0;
      } else {
        return n % 10 + await main(Math.floor(n / 10));
      }
    }
  original_instructions: |-
    get the sum of the digits of a non-negative integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(list1: string[]): Promise<number> {
        const result = list1.every((value, index, array) => index === 0 || array[index - 1] <= value);
        return result;
    }
  error: |-
    TS2322: Type 'boolean' is not assignable to type 'number'.
  explanation: |-
    The function is declared to return a `Promise<number>`, but the actual return value is a `boolean` because the `every` method returns a boolean value. The type of `list1` parameter is also changed from `number[]` to `string[]`, which is incorrect because the comparison `array[index - 1] <= value` is not valid for strings in the context of the original function's logic. The `<=` operator is used for comparing numbers, not strings, in the context of checking if the array is sorted.
  id: |-
    hubfix_mbpp_ts_567
  lang: |-
    deno
  original_code: |-
    export async function main(list1: number[]): Promise<boolean> {
        const result = list1.every((value, index, array) => index === 0 || array[index - 1] <= value);
        return result;
    }
  original_instructions: |-
    check whether a specified list is sorted or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(length: string): Promise<Record<string, any>[]> {
        const mainList: Record<string, any>[] = Array.from({ length }, () => ({}));
        return mainList;
    }
  error: |-
    Argument of type '{ length: string; }' is not assignable to parameter of type 'Iterable<unknown>' or 'ArrayLike<unknown>'.
      Object literal may only specify known properties, and 'length' does not exist in type 'Iterable<unknown>' or 'ArrayLike<unknown>'.
  explanation: |-
    The `Array.from` method expects an object with a `length` property that is a number, or an iterable object to create a new array from. In the broken code, the `length` parameter of the `main` function is changed to a string type, which is not compatible with the expected number type for the `length` property in the object passed to `Array.from`. This causes TypeScript to throw an error because the `length` property must be a number when used in this context.
  id: |-
    hubfix_mbpp_ts_568
  lang: |-
    deno
  original_code: |-
    export async function main(length: number): Promise<Record<string, any>[]> {
        const main: Record<string, any>[] = Array.from({ length }, () => ({}));
        return main;
    }
  original_instructions: |-
    create a list of N empty dictionaries
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        return nums.filter(i => nums.find(num => num === i).length === 1);
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'length')
  explanation: |-
    The code is attempting to use the `.length` property on the result of `nums.find(...)`. The `find` method returns the first element in the array that satisfies the provided testing function, or `undefined` if no elements match. Since `find` returns a single element, not an array, it does not have a `length` property. Attempting to access `length` on a non-array (or `undefined` if no element is found) results in a `TypeError`.
  id: |-
    hubfix_mbpp_ts_572
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number[]> {
        return nums.filter(i => nums.filter(num => num === i).length === 1);
    }
  original_instructions: |-
    remove duplicate numbers from a given number of lists
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(A: number[], B: string[]): Promise<boolean> {
        let n: number = A.length;
        let m: number = B.length;
        let i: number = 0;
        let j: number = 0;
        while (i < n && j < m) {
            if (A[i] === B[j]) {
                i += 1;
                j += 1;
                if (j === m) {
                    return true;
                }
            } else {
                i = i - j + 1;
                j = 0;
            }
        }
        return false;
    }
  error: |-
    TS2365: Operator '===' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The error occurs because the function `main` is trying to compare elements of array `A` (which are of type `number`) with elements of array `B` (which have been changed to type `string`). The strict equality operator `===` cannot be used to compare values of different types without explicit type conversion. In TypeScript, comparing a number to a string without converting one of them to the other's type is a type error.
  id: |-
    hubfix_mbpp_ts_576
  lang: |-
    deno
  original_code: |-
    export async function main(A: number[], B: number[]): Promise<boolean> {
        let n: number = A.length;
        let m: number = B.length;
        let i: number = 0;
        let j: number = 0;
        while (i < n && j < m) {
            if (A[i] === B[j]) {
                i += 1;
                j += 1;
                if (j === m) {
                    return true;
                }
            } else {
                i = i - j + 1;
                j = 0;
            }
        }
        return false;
    }
  original_instructions: |-
    check whether a list is sublist of another or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n === 0) return 1;
        else if (n <= 2) return n;
        else if (n === 3) return 6;
        else if (n === 4) return 4;
        else return 0;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting a parameter of type `number`, but the type has been changed to `string`. TypeScript is a statically typed language, which means that the types of variables, parameters, and return values are checked at compile time. By changing the parameter type to `string`, the code is now trying to compare a string with numbers using `===` and `<=`, which is not valid in TypeScript. The compiler will throw an error because the types are not compatible.
  id: |-
    hubfix_mbpp_ts_577
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 0) return 1;
        else if (n <= 2) return n;
        else if (n === 3) return 6;
        else if (n === 4) return 4;
        else return 0;
    }
  original_instructions: |-
    find the last digit in factorial of a given number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(b: number, s: string): Promise<number> {
        return 2 * b * s + Math.pow(b, 2);
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The function `main` is trying to multiply a number (`b`) with a string (`s`), which is not a valid operation in TypeScript. The type of `s` is declared as `string`, but it should be `number` to allow for multiplication. TypeScript's type system does not allow arithmetic operations between numbers and strings, hence the error.
  id: |-
    hubfix_mbpp_ts_581
  lang: |-
    deno
  original_code: |-
    export async function main(b: number, s: number): Promise<number> {
        return 2 * b * s + Math.pow(b, 2);
    }
  original_instructions: |-
    find the surface area of a square pyramid with a given base edge and height
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(num: string): Promise<number> {
        if (num <= 1) {
            return 1;
        }
        let res_num = 0;
        for (let i = 0; i < num; i++) {
            res_num += await main(i) * await main(num - i - 1);
        }
        return res_num;
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The function `main` has been modified to take a parameter of type `string` instead of `number`. However, inside the function, the parameter `num` is still being used in arithmetic operations and comparisons as if it were a number. TypeScript expects `num` to be a string, and therefore the operations `num <= 1`, `i < num`, and `num - i - 1` are invalid because they involve a mix of strings and numbers. Additionally, the recursive calls to `main(i)` and `main(num - i - 1)` are passing numbers instead of strings, which is not compatible with the modified function signature that expects a string argument.
  id: |-
    hubfix_mbpp_ts_583
  lang: |-
    deno
  original_code: |-
    export async function main(num: number): Promise<number> {
        if (num <= 1) {
            return 1;
        }
        let res_num = 0;
        for (let i = 0; i < num; i++) {
            res_num += await main(i) * await main(num - i - 1);
        }
        return res_num;
    }
  original_instructions: |-
    Write a function which returns nth catalan number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number> {
        const diff = Math.max(...nums) - Math.min(...nums);
        return diff;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `Math.max` and `Math.min` functions expect arguments of type `number`, but the modified code is attempting to spread an array of `string` (`...nums`) into these functions. Since `nums` is now declared as an array of `string`, TypeScript throws an error because it expects an array of `number`.
  id: |-
    hubfix_mbpp_ts_588
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        const diff = Math.max(...nums) - Math.min(...nums);
        return diff;
    }
  original_instructions: |-
    find the difference between largest and smallest value in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number, b: string): Promise<number[]> {
        const lists: number[] = [];
        for (let i = a; i <= b; i++) {
            let j = 1;
            while (j * j <= i) {
                if (j * j === i) {
                    lists.push(i);
                }
                j = j + 1;
            }
        }
        return lists;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the type of the parameter `b` has been changed from `number` to `string`. The `<=` operator in the for loop condition `i <= b` expects both operands to be of the same type, specifically a `number` in this case, but `b` is now a `string`. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_589
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number): Promise<number[]> {
        const lists: number[] = [];
        for (let i = a; i <= b; i++) {
            let j = 1;
            while (j * j <= i) {
                if (j * j === i) {
                    lists.push(i);
                }
                j = j + 1;
            }
        }
        return lists;
    }
  original_instructions: |-
    find perfect squares between two given numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size];
        newList[size - 1] = temp;
        return newList;
    }
  error: |-
    TypeError: Cannot set property 'undefined' of undefined
  explanation: |-
    The error occurs because the code is trying to access `newList[size]`, which is out of bounds of the array. Arrays in JavaScript and TypeScript are zero-indexed, so the last element is at the index `size - 1`. By trying to access `newList[size]`, the code is attempting to access an index one past the end of the array, which is `undefined`. When it then tries to assign a value to this undefined index, it results in a TypeError because you cannot set a property on `undefined`.
  id: |-
    hubfix_mbpp_ts_591
  lang: |-
    deno
  original_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return newList;
    }
  original_instructions: |-
    interchange the first and last elements in a list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(list1: string[]): Promise<number> {
        const first_even = list1.find(el => el % 2 === 0) ?? -1;
        const first_odd = list1.find(el => el % 2 !== 0) ?? -1;
        return first_even - first_odd;
    }
  error: |-
    error TS2365: Operator '%' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The code is broken because the parameter `list1` is now expected to be an array of strings (`string[]`) instead of an array of numbers (`number[]`). The modulus operator `%` is used to find the remainder of division, which is an operation that only makes sense for numbers, not strings. Therefore, TypeScript throws an error because you cannot use the modulus operator on a string.
  id: |-
    hubfix_mbpp_ts_594
  lang: |-
    deno
  original_code: |-
    export async function main(list1: number[]): Promise<number> {
        const first_even = list1.find(el => el % 2 === 0) ?? -1;
        const first_odd = list1.find(el => el % 2 !== 0) ?? -1;
        return first_even - first_odd;
    }
  original_instructions: |-
    find the difference of the first even and first odd number of a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr1: number[], arr2: number[], k: number): Promise<string> {
        const m: number = arr1.length;
        const n: string = arr2.length; // Error introduced here
        const sorted1: number[] = new Array(m + n);
        let i: number = 0;
        let j: number = 0;
        let d: number = 0;

        while (i < m && j < n) {
            if (arr1[i] < arr2[j]) {
                sorted1[d] = arr1[i];
                i += 1;
            } else {
                sorted1[d] = arr2[j];
                j += 1;
            }
            d += 1;
        }

        while (i < m) {
            sorted1[d] = arr1[i];
            d += 1;
            i += 1;
        }

        while (j < n) {
            sorted1[d] = arr2[j];
            d += 1;
            j += 1;
        }

        return sorted1[k - 1].toString(); // Error introduced here
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'number'.
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    Two errors have been introduced in the code:

    1. The type of `n` has been changed from `number` to `string`. The `length` property of an array is always a number, so assigning it to a string variable is incorrect. This causes the first error message.

    2. The return type of the function has been changed from `Promise<number>` to `Promise<string>`. However, the function is still returning a number with `sorted1[k - 1].toString()`. This causes the second error message because the `toString()` method is being called on a number, which is valid, but the return type of the function is not consistent with the actual return value.
  id: |-
    hubfix_mbpp_ts_597
  lang: |-
    deno
  original_code: |-
    export async function main(arr1: number[], arr2: number[], k: number): Promise<number> {
        const m: number = arr1.length;
        const n: number = arr2.length;
        const sorted1: number[] = new Array(m + n);
        let i: number = 0;
        let j: number = 0;
        let d: number = 0;

        while (i < m && j < n) {
            if (arr1[i] < arr2[j]) {
                sorted1[d] = arr1[i];
                i += 1;
            } else {
                sorted1[d] = arr2[j];
                j += 1;
            }
            d += 1;
        }

        while (i < m) {
            sorted1[d] = arr1[i];
            d += 1;
            i += 1;
        }

        while (j < n) {
            sorted1[d] = arr2[j];
            d += 1;
            j += 1;
        }

        return sorted1[k - 1];
    }
  original_instructions: |-
    find kth element from the given two sorted arrays
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(number: string): Promise<boolean> {
        let sum: number = 0;
        let times: number = 0;
        let temp: number = parseInt(number);
        while (temp > 0) {
            times = times + 1;
            temp = Math.floor(temp / 10);
        }
        temp = parseInt(number);
        while (temp > 0) {
            const reminder: number = temp % 10;
            sum = sum + Math.pow(reminder, times);
            temp = Math.floor(temp / 10);
        }
        if (number === sum) {
            return true;
        } else {
            return false;
        }
    }
  error: |-
    TS2365: Operator '===' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The error occurs because the type of the parameter `number` was changed from `number` to `string`, but the comparison in the `if` statement is still using the strict equality operator `===` to compare `number` (which is now a string) to `sum` (which is a number). In TypeScript, the strict equality operator does not allow comparison between different types without explicit type conversion. To fix this, the parameter type should remain `number`, or the comparison should be adjusted to convert the types appropriately before comparing.
  id: |-
    hubfix_mbpp_ts_598
  lang: |-
    deno
  original_code: |-
    export async function main(number: number): Promise<boolean> {
        let sum: number = 0;
        let times: number = 0;
        let temp: number = number;
        while (temp > 0) {
            times = times + 1;
            temp = Math.floor(temp / 10);
        }
        temp = number;
        while (temp > 0) {
            const reminder: number = temp % 10;
            sum = sum + Math.pow(reminder, times);
            temp = Math.floor(temp / 10);
        }
        if (number === sum) {
            return true;
        } else {
            return false;
        }
    }
  original_instructions: |-
    check whether the given number is armstrong or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(number: string): Promise<[number, number]> {
        let total = 0;
        for (let value = 1; value <= number; value++) {
            total += value;
        }
        const average = total / number;
        return [total, average];
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is now expecting a parameter of type `string` instead of `number`. The loop condition `value <= number` and the division `total / number` are both invalid because you cannot use the less than or equal operator (`<=`) or division (`/`) with a `number` on the left side and a `string` on the right side. TypeScript expects both operands to be of type `number` for these operations.
  id: |-
    hubfix_mbpp_ts_599
  lang: |-
    deno
  original_code: |-
    export async function main(number: number): Promise<[number, number]> {
        let total = 0;
        for (let value = 1; value <= number; value++) {
            total += value;
        }
        const average = total / number;
        return [total, average];
    }
  original_instructions: |-
    find sum and average of first n natural numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number[]> {
        const ludics: number[] = [];
        for (let i = 1; i <= n; i++) {
            ludics.push(i);
        }
        let index = 1;
        while (index !== ludics.length) {
            const first_ludic = ludics[index];
            let remove_index = index + first_ludic;
            while (remove_index < ludics.length) {
                ludics.splice(remove_index, 1);
                remove_index = remove_index + first_ludic - 1;
            }
            index += 1;
        }
        return ludics;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the parameter `n` is changed from type `number` to type `string`. The `<=` operator in the for loop expects a number on both sides, but it receives a string for `n`, which is not assignable to a number. TypeScript is a statically typed language, and it enforces type correctness at compile time. To fix this error, the type of `n` should remain `number`.
  id: |-
    hubfix_mbpp_ts_603
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        const ludics: number[] = [];
        for (let i = 1; i <= n; i++) {
            ludics.push(i);
        }
        let index = 1;
        while (index !== ludics.length) {
            const first_ludic = ludics[index];
            let remove_index = index + first_ludic;
            while (remove_index < ludics.length) {
                ludics.splice(remove_index, 1);
                remove_index = remove_index + first_ludic - 1;
            }
            index += 1;
        }
        return ludics;
    }
  original_instructions: |-
    get all lucid numbers smaller than or equal to a given integer
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(num: string): Promise<boolean> {
        if (num > 1) {
            for (let i = 2; i <= Math.floor(num / 2); i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }
  error: |-
    error TS2365: Operator '>' cannot be applied to types 'string' and 'number'.
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is broken because the parameter `num` is now of type `string`, but it is being used in arithmetic operations and comparisons that require a `number` type. The `>` operator cannot be used to compare a `string` with a `number`, and the arithmetic operations `/` and `%` cannot be performed on a `string`. The `Math.floor` function also expects a `number` as its argument, not a `string`.
  id: |-
    hubfix_mbpp_ts_605
  lang: |-
    deno
  original_code: |-
    export async function main(num: number): Promise<boolean> {
        if (num > 1) {
            for (let i = 2; i <= Math.floor(num / 2); i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }
  original_instructions: |-
    check if the given integer is a prime number
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculate(degree: string): Promise<number> {
        const radian = degree * (Math.PI / 180);
        return radian;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because of the following reasons:
    - The function name has been changed from `main` to `calculate`, which might be an issue if the function is being called from somewhere else expecting the name `main`.
    - The parameter `degree` is now expected to be a `string` instead of a `number`, which is incorrect because the mathematical operation inside the function requires a number.
    - The multiplication operation `degree * (Math.PI / 180)` will cause a TypeScript error because you cannot multiply a string by a number.
  id: |-
    hubfix_mbpp_ts_606
  lang: |-
    deno
  original_code: |-
    export async function main(degree: number): Promise<number> {
        const radian = degree * (Math.PI / 180);
        return radian;
    }
  original_instructions: |-
    convert degrees to radians
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr1: number[], arr2: number[], n: number): Promise<string> {
      let i = 0;
      let j = 0;
      let m1 = -1;
      let m2 = -1;
      let count = 0;
      while (count < n + 1) {
        count += 1;
        if (i === n) {
          m1 = m2;
          m2 = arr2[0];
          break;
        } else if (j === n) {
          m1 = m2;
          m2 = arr1[0];
          break;
        }
        if (arr1[i] <= arr2[j]) {
          m1 = m2; // Error here
          m2 = arr1[i];
          i += 1;
        } else {
          m1 = m2;
          m2 = arr2[j];
          j += 1;
        }
      }
      return (m1 + m2) / 2;
    }
  error: |-
    Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function is declared to return a `Promise<string>`, but the actual return statement returns a number, which is the result of `(m1 + m2) / 2`. The return type of the function should be `Promise<number>` to match the type of the returned value.
  id: |-
    hubfix_mbpp_ts_622
  lang: |-
    deno
  original_code: |-
    export async function main(arr1: number[], arr2: number[], n: number): Promise<number> {
      let i = 0;
      let j = 0;
      let m1 = -1;
      let m2 = -1;
      let count = 0;
      while (count < n + 1) {
        count += 1;
        if (i === n) {
          m1 = m2;
          m2 = arr2[0];
          break;
        } else if (j === n) {
          m1 = m2;
          m2 = arr1[0];
          break;
        }
        if (arr1[i] <= arr2[j]) {
          m1 = m2;
          m2 = arr1[i];
          i += 1;
        } else {
          m1 = m2;
          m2 = arr2[j];
          j += 1;
        }
      }
      return (m1 + m2) / 2;
    }
  original_instructions: |-
    find the median of two sorted lists of same size
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(newList: any[]): Promise<number> {
        const size = newList.size;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return size;
    }
  error: |-
    TypeError: Cannot read property 'size' of undefined
  explanation: |-
    The code is trying to access a property `size` on the array `newList`, which does not exist. Arrays in JavaScript and TypeScript have a `length` property, not `size`. Additionally, the function is supposed to return an array (`Promise<any[]>`), but the broken code is returning a number (`Promise<number>`), which is the length of the array, not the array itself. This would also cause a type error if TypeScript's type checking were enforced.
  id: |-
    hubfix_mbpp_ts_625
  lang: |-
    deno
  original_code: |-
    export async function main(newList: any[]): Promise<any[]> {
        const size = newList.length;
        const temp = newList[0];
        newList[0] = newList[size - 1];
        newList[size - 1] = temp;
        return newList;
    }
  original_instructions: |-
    interchange the first and last element in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateSquare(r: string): Promise<number | null> {
        if (r < 0) {
            return null;
        }
        return r * r;
    }
  error: |-
    error TS2365: Operator '<' cannot be applied to types 'string' and 'number'.
    error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    There are two errors in the broken code:

    1. The parameter `r` is now of type `string`, but the function is trying to compare it with a number using the `<` operator, which is not valid in TypeScript because you cannot compare a string with a number using this operator.

    2. The multiplication operation `r * r` is invalid because `r` is a string, and you cannot multiply strings in TypeScript. The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint', or an enum type.
  id: |-
    hubfix_mbpp_ts_626
  lang: |-
    deno
  original_code: |-
    export async function main(r: number): Promise<number | null> {
        if (r < 0) {
            return null;
        }
        return r * r;
    }
  original_instructions: |-
    find the area of the largest triangle that can be inscribed in a semicircle with a given radius
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(text: number): Promise<string> {
        const regex = /\Bz\B/;
        return regex.test(text);
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `regex.test` function expects a string as its parameter, but the modified `main` function now takes a `number` as its parameter. This causes a type mismatch when `regex.test` is called with `text`, which is now a number. Additionally, the return type of the function has been changed from `Promise<boolean>` to `Promise<string>`, which is incorrect because `regex.test` returns a boolean, not a string.
  id: |-
    hubfix_mbpp_ts_643
  lang: |-
    deno
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const regex = /\Bz\B/;
        return regex.test(text);
    }
  original_instructions: |-
    checks if a strings contains 'z', except at the start and end of the word
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(cost: number[][]): Promise<number> {
      const N = cost.length;
      const dp: number[][] = Array.from({ length: N + 1 }, () => Array(N + 1).fill(0));
      dp[0][0] = cost[0][0];
      for (let i = 1; i < N; i++) {
        dp[i][0] = dp[i - 1][0] + cost[i][0];
      }
      for (let j = 1; j < N; j++) {
        dp[0][j] = dp[0][j - 1] + cost[0][j];
      }
      for (let i = 1; i < N; i++) {
        for (let j = 1; j < N; j++) {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];
        }
      }
      return dp[N - 1][N - 1] / (2 * M - 1);
    }
  error: |-
    ReferenceError: M is not defined
  explanation: |-
    In the last line of the function, `M` is used in the expression `(2 * M - 1)`, but `M` is not defined anywhere in the code. The correct variable should be `N`, which is defined as the length of the `cost` array.
  id: |-
    hubfix_mbpp_ts_721
  lang: |-
    deno
  original_code: |-
    export async function main(cost: number[][]): Promise<number> {
      const N = cost.length;
      const dp: number[][] = Array.from({ length: N + 1 }, () => Array(N + 1).fill(0));
      dp[0][0] = cost[0][0];
      for (let i = 1; i < N; i++) {
        dp[i][0] = dp[i - 1][0] + cost[i][0];
      }
      for (let j = 1; j < N; j++) {
        dp[0][j] = dp[0][j - 1] + cost[0][j];
      }
      for (let i = 1; i < N; i++) {
        for (let j = 1; j < N; j++) {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];
        }
      }
      return dp[N - 1][N - 1] / (2 * N - 1);
    }
  original_instructions: |-
    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums1: number[], nums2: number[]): Promise<string> {
        const result = nums1.reduce((acc, num, index) => acc + (num === nums2[index] ? 1 : 0), 0);
        return result;
    }
  error: |-
    TS2322: Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function `main` is declared to return a `Promise<string>`, but the actual return value is a `number`. The `reduce` method is used to accumulate a numerical result, and the initial value provided to `reduce` is `0`, which is a number. Therefore, the return type of the function should be `Promise<number>` to match the type of the result being returned.
  id: |-
    hubfix_mbpp_ts_723
  lang: |-
    deno
  original_code: |-
    export async function main(nums1: number[], nums2: number[]): Promise<number> {
        const result = nums1.reduce((acc, num, index) => acc + (num === nums2[index] ? 1 : 0), 0);
        return result;
    }
  original_instructions: |-
    The input is defined as two lists of the same length. count indices where the lists have the same values
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        let ans = 0;
        let res = 0;
        let i = arr.length - 1;
        while (i >= 0) {
            const incr = arr[i] * (1 + res);
            ans += incr;
            res = incr;
            i -= 1;
        }
        return ans;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is trying to multiply a string (`arr[i]`) with a number (`1 + res`), which is not allowed in TypeScript. TypeScript enforces type safety, and the multiplication operator can only be used with numeric types. The parameter `arr` is declared as an array of strings (`string[]`), so attempting to multiply its elements with a number results in a type error.
  id: |-
    hubfix_mbpp_ts_734
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ans = 0;
        let res = 0;
        let i = arr.length - 1;
        while (i >= 0) {
            const incr = arr[i] * (1 + res);
            ans += incr;
            res = incr;
            i -= 1;
        }
        return ans;
    }
  original_instructions: |-
    find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    function setMiddleBits(n: number): number {
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return (n >> 1) ^ '1';
    }

    export async function main(n: number): Promise<number> {
        if (n === 1) {
            return '1';
        }
        return n ^ setMiddleBits(n);
    }
  error: |-
    TS2365: Operator '^' cannot be applied to types 'number' and 'string'.
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    In the `setMiddleBits` function, the return statement attempts to perform a bitwise XOR operation between a number and a string, which is not allowed in TypeScript. The XOR operator '^' can only be applied to operands of the same type, and in this case, both operands should be of type 'number'.

    In the `main` function, the return statement inside the `if` block is returning a string '1' instead of a number 1. The return type of the function is declared as `Promise<number>`, so it must return a number, not a string.
  id: |-
    hubfix_mbpp_ts_735
  lang: |-
    deno
  original_code: |-
    function setMiddleBits(n: number): number {
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return (n >> 1) ^ 1;
    }

    export async function main(n: number): Promise<number> {
        if (n === 1) {
            return 1;
        }
        return n ^ setMiddleBits(n);
    }
  original_instructions: |-
    toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Match = RegExpMatchArray | null;

    const regex: RegExp = /^[aeiouAEIOU][A-Za-z0-9_]*/;

    export async function main(string: number): Promise<Match> {
        return string.match(regex);
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `main` function has been modified to take a parameter of type `number` instead of `string`. The `match` method is a method of the `String` prototype, and it expects the object it is called on to be a string. Since `string` is now a number, TypeScript throws an error because the `match` method does not exist on type `number`.
  id: |-
    hubfix_mbpp_ts_737
  lang: |-
    deno
  original_code: |-
    type Match = RegExpMatchArray | null;

    const regex: RegExp = /^[aeiouAEIOU][A-Za-z0-9_]*/;

    export async function main(string: string): Promise<Match> {
        return string.match(regex);
    }
  original_instructions: |-
    check whether the given string is starting with a vowel or not using regex
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        const x = Math.sqrt(2 * Math.pow(10, (n - 1)));
        return Math.round(x);
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting a parameter `n` of type `number`, but it has been changed to type `string`. The `Math.pow` function expects its arguments to be of type `number`, but since `n` is now a string, TypeScript throws an error because a string cannot be used as a number in arithmetic operations.
  id: |-
    hubfix_mbpp_ts_739
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        const x = Math.sqrt(2 * Math.pow(10, (n - 1)));
        return Math.round(x);
    }
  original_instructions: |-
    find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: number): Promise<boolean> {
        const n: number = s.length;
        for (let i = 1; i < n; i++) {
            if (s[i] !== s[0]) {
                return false;
            }
        }
        return true;
    }
  error: |-
    error TS2339: Property 'length' does not exist on type 'number'.
  explanation: |-
    The code is attempting to access the `length` property on a variable `s` that has been declared as a `number` type. Numbers in TypeScript do not have a `length` property, which is typically a property of strings or arrays. This results in a type error because the `length` property does not exist on the `number` type.
  id: |-
    hubfix_mbpp_ts_741
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<boolean> {
        const n: number = s.length;
        for (let i = 1; i < n; i++) {
            if (s[i] !== s[0]) {
                return false;
            }
        }
        return true;
    }
  original_instructions: |-
    check whether all the characters are same or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        dp[0] = 0;
        dp[1] = 1;
        for (let i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + 2 * dp[i - 2];
        }
        return dp[n];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expecting a parameter `n` of type `number`, but it has been changed to type `string`. This causes a type mismatch error because the rest of the code is written with the assumption that `n` is a number, such as using it in arithmetic operations and as an array index. TypeScript's static type checking will catch this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_752
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        const dp: number[] = new Array(n + 1).fill(0);
        dp[0] = 0;
        dp[1] = 1;
        for (let i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + 2 * dp[i - 2];
        }
        return dp[n];
    }
  original_instructions: |-
    find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ..
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(text: number): Promise<number> {
        const patterns = /ab+?/;
        return patterns.test(text);
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
    TS2322: Type 'boolean' is not assignable to type 'number'.
  explanation: |-
    There are two errors in the modified code:

    1. The `main` function now expects a parameter of type `number` instead of `string`. The `RegExp.test()` method expects a string argument, so passing a number to it will cause a type error.

    2. The return type of the `main` function has been changed from `Promise<boolean>` to `Promise<number>`. However, the `patterns.test(text)` call returns a boolean, not a number, which causes a type mismatch error.
  id: |-
    hubfix_mbpp_ts_756
  lang: |-
    deno
  original_code: |-
    export async function main(text: string): Promise<boolean> {
        const patterns = /ab+?/;
        return patterns.test(text);
    }
  original_instructions: |-
    matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(num: number): Promise<boolean> {
        const dnumre: RegExp = /^[0-9]+(\.[0-9]{1,2})?$/;
        const result: RegExpExecArray | null = dnumre.exec(num);
        return Boolean(result);
    }
  error: |-
    Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `exec` method of the `RegExp` object expects a string as its parameter, but the modified code is passing a number to it because the `num` parameter type was changed from `string` to `number`. This is a type mismatch and TypeScript will throw an error because the `exec` method cannot be called with a number.
  id: |-
    hubfix_mbpp_ts_759
  lang: |-
    deno
  original_code: |-
    export async function main(num: string): Promise<boolean> {
        const dnumre: RegExp = /^[0-9]+(\.[0-9]{1,2})?$/;
        const result: RegExpExecArray | null = dnumre.exec(num);
        return Boolean(result);
    }
  original_instructions: |-
    check whether a given string is a decimal number with a precision of 2
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        const s = new Set(arr);
        return s.size === 1;
    }
  error: |-
    TS2322: Type 'boolean' is not assignable to type 'number'.
  explanation: |-
    The function is expected to return a `Promise<number>` according to its signature, but the actual return value is a `boolean` expression (`s.size === 1`). The type of the returned value must match the type specified in the function's return type annotation.
  id: |-
    hubfix_mbpp_ts_760
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<boolean> {
        const s = new Set(arr);
        return s.size === 1;
    }
  original_instructions: |-
    check whether a list of numbers contains only one distinct element or not
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(monthnum3: string): Promise<boolean> {
      return monthnum3 === 4 || monthnum3 === 6 || monthnum3 === 9 || monthnum3 === 11;
    }
  error: |-
    TS2365: Operator '===' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The parameter `monthnum3` was changed from type `number` to type `string`, but the function body still attempts to compare it with numbers using the strict equality operator `===`. TypeScript's type system does not allow a comparison between a string and a number with `===` because they are different types and it can never be true. This results in a type error.
  id: |-
    hubfix_mbpp_ts_762
  lang: |-
    deno
  original_code: |-
    export async function main(monthnum3: number): Promise<boolean> {
      return monthnum3 === 4 || monthnum3 === 6 || monthnum3 === 9 || monthnum3 === 11;
    }
  original_instructions: |-
    check whether the given month number contains 30 days or not. Months are given as number from 1 to 12
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: number[], n: string): Promise<number> {
        arr = arr.sort((a, b) => a - b);
        let diff: number = 10 ** 20;
        for (let i = 0; i < n - 1; i++) {
            if (arr[i + 1] - arr[i] < diff) {
                diff = arr[i + 1] - arr[i];
            }
        }
        return diff;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the type of the parameter `n` has been changed from `number` to `string`. The `for` loop expects a number for its comparison operation (`i < n - 1`), but since `n` is now a string, the operation is invalid. TypeScript's type system catches this error at compile time, preventing the code from running.
  id: |-
    hubfix_mbpp_ts_763
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[], n: number): Promise<number> {
        arr = arr.sort((a, b) => a - b);
        let diff: number = 10 ** 20;
        for (let i = 0; i < n - 1; i++) {
            if (arr[i + 1] - arr[i] < diff) {
                diff = arr[i + 1] - arr[i];
            }
        }
        return diff;
    }
  original_instructions: |-
    find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<boolean> {
        return nums.every((num, i) => num % 2 === i % 2);
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The function `main` now expects an array of strings (`nums: string[]`) instead of an array of numbers (`nums: number[]`). The `every` method is called on this array, and inside the callback function, there is an attempt to perform a modulus operation (`num % 2`) on a string (`num`), which is not allowed in TypeScript. The modulus operation is only defined for numeric types.
  id: |-
    hubfix_mbpp_ts_775
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<boolean> {
        return nums.every((num, i) => num % 2 === i % 2);
    }
  original_instructions: |-
    check whether every odd index contains odd numbers of a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        arr.sort((a, b) => a - b);
        let sum = arr[0];
        for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] !== arr[i + 1]) {
                sum += arr[i + 1];
            }
        }
        return sum;
    }
  error: |-
    TS2345: Argument of type '(a: string, b: string) => number' is not assignable to parameter of type '(a: string, b: string) => number'.
      Type 'number' is not assignable to type 'string'.
  explanation: |-
    The code is broken because the `arr` parameter is now of type `string[]`, but the sort function and the rest of the code are still treating the elements as if they were numbers. Specifically, the sort function's comparison callback `(a, b) => a - b` is invalid for strings, as the `-` operator cannot be applied to strings. Additionally, the variable `sum` is initialized with the first element of the array, which is a string, and then the code attempts to use the `+=` operator to add other strings to it, which is not valid when the expected return type is `number`. The TypeScript compiler will throw an error because the operations and types used are not compatible with strings.
  id: |-
    hubfix_mbpp_ts_777
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        arr.sort((a, b) => a - b);
        let sum = arr[0];
        for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] !== arr[i + 1]) {
                sum += arr[i + 1];
            }
        }
        return sum;
    }
  original_instructions: |-
    find the sum of non-repeated elements in a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(list1: string[]): Promise<number> {
        const firstEven = list1.find(el => el % 2 === 0) ?? -1;
        const firstOdd = list1.find(el => el % 2 !== 0) ?? -1;
        return firstEven * firstOdd;
    }
  error: |-
    error TS2345: Argument of type '(el: string) => boolean' is not assignable to parameter of type '(value: string, index: number, obj: string[]) => unknown'.
      Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the `find` method is being used on an array of strings (`list1: string[]`), but the callback function provided to `find` is performing a modulo operation (`el % 2 === 0` and `el % 2 !== 0`), which is only valid for numbers, not strings. The TypeScript compiler throws an error because it expects the callback function to accept a `string` type parameter, but the code is trying to treat it as a `number`. Additionally, the multiplication operation (`firstEven * firstOdd`) is also invalid because even if `find` did not throw an error, the result of `find` would be a string or `-1`, and you cannot multiply strings by numbers in TypeScript.
  id: |-
    hubfix_mbpp_ts_784
  lang: |-
    deno
  original_code: |-
    export async function main(list1: number[]): Promise<number> {
        const firstEven = list1.find(el => el % 2 === 0) ?? -1;
        const firstOdd = list1.find(el => el % 2 !== 0) ?? -1;
        return firstEven * firstOdd;
    }
  original_instructions: |-
    find the product of first even and odd number of a given list
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(test_str: string): Promise<tuple> {
        const res: number[] = test_str.replace('(', '').replace(')', '').replace('...', '').split(', ').map(num => parseInteger(num));
        return res as unknown as tuple;
    }
  error: |-
    TS2304: Cannot find name 'parseInteger'.
  explanation: |-
    The function `parseInteger` does not exist in JavaScript or TypeScript. The correct function name is `parseInt`. This is a common mistake where a developer might confuse the function name with a similar-sounding one or a function from another language.
  id: |-
    hubfix_mbpp_ts_785
  lang: |-
    deno
  original_code: |-
    export async function main(test_str: string): Promise<tuple> {
        const res: number[] = test_str.replace('(', '').replace(')', '').replace('...', '').split(', ').map(num => parseInt(num));
        return res as unknown as tuple;
    }
  original_instructions: |-
    convert tuple string to integer tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(test_tup: any[]): Promise<number[]> {
        let res: number[] = [];
        for (let count = 0; count < test_tup.length; count++) {
            const ele = test_tup[count];
            if (!(ele instanceof Array)) {
                res.push(ele.length);
            }
        }
        return res;
    }
  error: |-
    TypeError: Cannot read property 'length' of undefined
  explanation: |-
    The code is attempting to push `ele.length` onto the `res` array. However, `ele` could be any type since `test_tup` is an array of `any` type. If `ele` is not an object with a `length` property (for example, if it's a number or boolean), trying to access `ele.length` will result in a `TypeError` because `length` is not a valid property on those types. Additionally, the function is declared to return a `Promise<number[]>`, but since `ele` can be any type, pushing `ele.length` (even if it exists) into `res` might not always result in an array of numbers, which would be a type error at compile time.
  id: |-
    hubfix_mbpp_ts_791
  lang: |-
    deno
  original_code: |-
    export async function main(test_tup: any[]): Promise<any[]> {
        let res: any[] = [];
        for (let count = 0; count < test_tup.length; count++) {
            const ele = test_tup[count];
            if (!(ele instanceof Array)) {
                res.push(ele);
            }
        }
        return res;
    }
  original_instructions: |-
    remove tuples from the given tuple
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(dict: Record<string, number>): Promise<string> {
      let sum = 0;
      for (const i of Object.values(dicts)) {
        sum = sum + i;
      }
      return sum.toString();
    }
  error: |-
    error: TS2552 [ERROR]: Cannot find name 'dicts'. Did you mean 'dict'?
      for (const i of Object.values(dicts)) {
                                   ~~~~~
        at file:///path/to/script.ts:4:32

    TS2322 [ERROR]: Type 'string' is not assignable to type 'number'.
      return sum.toString();
             ~~~~~~~~~~~~~
        at file:///path/to/script.ts:7:10
  explanation: |-
    There are two errors in the code:

    1. The variable `dicts` is used in the `for` loop, but it does not exist. The correct variable name is `dict`, as defined in the function's parameter.

    2. The function's return type is declared as `Promise<number>`, but the actual return statement is returning a `string` because of the `.toString()` method. The return type should match the declared return type of the function.
  id: |-
    hubfix_mbpp_ts_796
  lang: |-
    deno
  original_code: |-
    export async function main(dict: Record<number, number>): Promise<number> {
      let sum = 0;
      for (const i of Object.values(dict)) {
        sum = sum + i;
      }
      return sum;
    }
  original_instructions: |-
    Write function to find the sum of all items in the given dictionary
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string, d: number): Promise<number> {
        const INT_BITS: number = 32;
        return (n << d) | (n >>> (INT_BITS - d));
    }
  error: |-
    error TS2365: Operator '<<' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The code is attempting to use the bitwise left shift operator (`<<`) on a string and a number, which is not valid in TypeScript. Bitwise operations can only be applied to operands of type `number` or `bigint`. The parameter `n` was changed from `number` to `string`, which is causing the error.
  id: |-
    hubfix_mbpp_ts_799
  lang: |-
    deno
  original_code: |-
    export async function main(n: number, d: number): Promise<number> {
        const INT_BITS: number = 32;
        return (n << d) | (n >>> (INT_BITS - d));
    }
  original_instructions: |-
    that rotate left bits by d bits a given number. We assume that the number is 32 bit
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(x: number, y: string, z: number): Promise<number> {
      const result = new Set([x, y, z]);
      if (result.size === 3) {
        return "0";
      } else {
        return 4 - result.size;
      }
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'number'.
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number | undefined'.
    TS2322: Type 'string' is not assignable to type 'Promise<number>'.
  explanation: |-
    There are multiple issues with the code:

    1. The parameter `y` is changed from `number` to `string`, which is not consistent with the function's signature that expects all parameters to be numbers.
    2. The function is supposed to return a `Promise<number>`, but in the `if` branch, it returns a string `"0"` instead of a number.
    3. The `Set` constructor is being passed a string as one of its elements, which is not an error by itself, but it is inconsistent with the expected usage of the function where all elements should be numbers.
  id: |-
    hubfix_mbpp_ts_801
  lang: |-
    deno
  original_code: |-
    export async function main(x: number, y: number, z: number): Promise<number> {
      const result = new Set([x, y, z]);
      if (result.size === 3) {
        return 0;
      } else {
        return 4 - result.size;
      }
    }
  original_instructions: |-
    count the number of equal numbers from three given integers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<boolean> {
        let i = 1;
        while (i * i <= n) {
            if ((n % i == 0) && (n / i == i)) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
  error: |-
    error TS2365: Operator '<=' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The code is broken because the parameter `n` is expected to be a number as per the original function, but it has been changed to a string. The arithmetic operations and comparisons inside the function are not valid when applied to a string, which causes TypeScript to throw an error. Specifically, the '<=' operator cannot be applied to a 'number' and 'string' as it is in the `while` loop condition, and the '%' and '/' operators are also not applicable to a string in the `if` statement.
  id: |-
    hubfix_mbpp_ts_803
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        let i = 1;
        while (i * i <= n) {
            if ((n % i == 0) && (n / i == i)) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
  original_instructions: |-
    check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number> {
      const result = nums.find(el => el % 2 !== 0) ?? -1;
      return result;
    }
  error: |-
    error TS2345: Argument of type '(el: string) => boolean' is not assignable to parameter of type '(value: string, index: number, obj: string[]) => unknown'.
      Types of parameters 'el' and 'value' are incompatible.
        Type 'string' is not assignable to type 'number'.
  explanation: |-
    The code is trying to find an element in an array of strings (`nums: string[]`) using a numeric operation (`el % 2 !== 0`). The modulus operator `%` is not applicable to strings, and TypeScript is throwing an error because the callback function provided to the `find` method expects a string as its parameter, not a number. The type of the `nums` parameter should remain `number[]` to match the logic inside the function.
  id: |-
    hubfix_mbpp_ts_807
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
      const main = nums.find(el => el % 2 !== 0) ?? -1;
      return main;
    }
  original_instructions: |-
    find the first odd number in a given list of numbers
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import os
    import json
    from typing import TypedDict, Any
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack_resource(TypedDict):  # Changed class name from 'slack' to 'slack_resource'
        token: str

    def format_error(error: Any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        error_started_at: str,
        success_times: int,
        success_result: dict,
        slack: slack_resource,  # Changed the type hint to 'slack_resource'
        channel: str,
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}{'/flows/get/' if is_flow else '/scripts/get/'}{path}"
        web = WebClient(token=slack['token'])

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} recovered {success_times > 1 and (str(success_times) + ' times in a row') or ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> recovered*{success_times > 1 and (' ' + str(success_times) + ' times in a row') or ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                    },
                },
            ],
            attachments=[
                {
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"Last failure at: {datetime.fromisoformat(error_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                            },
                        },
                    ],
                },
                {
                    "color": "#00ff00",
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"Last success at: {datetime.fromisoformat(success_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n```\n{json.dumps(success_result, indent=2)}\n```",
                            },
                        },
                    ],
                },
            ],
        )
  error: |-
    TypeError: TypedDict "slack" has no key 'token'
  explanation: |-
    The TypedDict class was renamed from `slack` to `slack_resource`, but the type hint in the `main` function's parameters was not updated accordingly. This causes a mismatch between the expected type and the actual type used in the function. When the `main` function tries to access `slack['token']`, it will raise a TypeError because the TypedDict `slack` does not exist anymore, and `slack_resource` should be used instead.
  id: |-
    hubfix_hub_1031
  lang: |-
    python
  original_code: |-
    import os
    import json
    from typing import TypedDict, Any
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack(TypedDict):
        token: str

    def format_error(error: Any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        error_started_at: str,
        success_times: int,
        success_result: dict,
        success_started_at: str,
        slack: slack,
        channel: str,
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}{'/flows/get/' if is_flow else '/scripts/get/'}{path}"
        web = WebClient(token=slack['token'])

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} recovered {success_times > 1 and (str(success_times) + ' times in a row') or ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> recovered*{success_times > 1 and (' ' + str(success_times) + ' times in a row') or ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                    },
                },
            ],
            attachments=[
                {
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"Last failure at: {datetime.fromisoformat(error_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                            },
                        },
                    ],
                },
                {
                    "color": "#00ff00",
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"Last success at: {datetime.fromisoformat(success_started_at).astimezone(pytz.utc).strftime('%d.%m.%Y %H:%M (%Z)')}\n```\n{json.dumps(success_result, indent=2)}\n```",
                            },
                        },
                    ],
                },
            ],
        )
  original_instructions: |-
    Schedule recovery handler in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import boto3
    from typing import TypedDict

    class s3(TypedDict):
        endPoint: str
        port: str  # Changed the type from int to str
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, path: str):
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )
        response = s3_client.get_object(Bucket=s3_config['bucket'], Key=path)
        return response['Body'].read().decode('utf-8')

    main({'endPoint': 'localhost', 'port': '8080', 'useSSL': False, 'pathStyle': True, 'bucket': 'mybucket', 'accessKey': 'AKIAIOSFODNN7EXAMPLE', 'secretKey': 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY', 'region': 'us-west-2'}, 'some/path/to/object')
  error: |-
    TypeError: 'port' must be an instance of int, not str
  explanation: |-
    The TypedDict `s3` originally specified the `port` as an `int`, but it was changed to `str`. When the `main` function is called with a dictionary that has the `port` value as a string ('8080'), it violates the type contract of the `s3` TypedDict, which expects an integer for the `port`. This would cause a type error if type checking is enforced, although in runtime Python does not enforce type annotations. However, if the port is used in a context that strictly requires an integer (e.g., a socket connection), this could lead to a runtime error.
  id: |-
    hubfix_hub_392
  lang: |-
    python
  original_code: |-
    import boto3
    from typing import TypedDict

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, path: str):
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )
        response = s3_client.get_object(Bucket=s3_config['bucket'], Key=path)
        return response['Body'].read().decode('utf-8')
  original_instructions: |-
    Get object in bucket as text in s3
  resource_type: |-
    s3
  resource_type_def: |-
    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str
- broken_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: Optional[str] = None,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        if collection_id is None:
            collection_id = client.call('utils', 'generate_id')

        response = db.create_collection(
            database_id=database_id,
            collection_id=collection_id,
            name=collection_name,
            read=collection_permissions or [],
            write=collection_permissions or [],
            document_security=collection_document_security or False
        )

        return response
  error: |-
    AttributeError: 'Client' object has no attribute 'call'
  explanation: |-
    The code attempts to call a method `call` on the `client` object with the parameters `'utils'` and `'generate_id'`. However, the `Client` class from the Appwrite SDK does not have a method named `call`. This results in an `AttributeError` because the `call` method does not exist on the `Client` object.
  id: |-
    hubfix_hub_329
  lang: |-
    python
  original_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: Optional[str] = None,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        if collection_id is None:
            collection_id = client.call('utils', 'id')

        response = db.create_collection(
            database_id=database_id,
            collection_id=collection_id,
            name=collection_name,
            read=collection_permissions or [],
            write=collection_permissions or [],
            document_security=collection_document_security or False
        )

        return response
  original_instructions: |-
    Create Collection in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    from typing import TypedDict, Any

    class error_details(TypedDict):
        message: str
        code: int

    class success_result_type(TypedDict):
        data: Any
        status: str

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: error_details,
        error_started_at: str,
        success_times: int,
        success_result: success_result_type,
        success_started_at: str,
    ) -> error_details:
        print(
            f"Schedule {schedule_path} recovered "
            f"{success_times > 1 and (str(success_times) + ' times in a row') or ''}\n"
            f"{'Flow' if is_flow else 'Script'}: {path}"
        )
        print(f"Last failure at {error_started_at}:", error)
        print(f"Last success at {success_started_at}:", success_result)
        return error

    main(42, 'yes', 3.14, {'message': 'Error occurred', 'code': 'E42'}, '2023-04-01', 'five', {'data': 'Result', 'status': 200}, '2023-04-02')
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 24, in <module>
    TypeError: main() argument after ** must be a mapping, not int
  explanation: |-
    The broken code introduces several issues:

    1. The `main` function is called with incorrect types for the parameters. The `path` parameter is expected to be a `str`, but an `int` (42) is passed. The `is_flow` parameter is expected to be a `bool`, but a `str` ('yes') is passed. The `schedule_path` parameter is expected to be a `str`, but a `float` (3.14) is passed.

    2. The `error` parameter is a dictionary with a `str` type for the 'code' key, but it should be an `int`.

    3. The `success_times` parameter is expected to be an `int`, but a `str` ('five') is passed.

    4. The `success_result` parameter is a dictionary with an `int` type for the 'status' key, but it should be a `str`.

    These type mismatches between the expected types of the function parameters and the types of the arguments passed to the function call cause a `TypeError` to be raised when the script is run.
  id: |-
    hubfix_hub_1028
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Any

    class error_details(TypedDict):
        # Define the structure of the error details as per your requirements
        message: str
        code: int
        # Add more fields as needed

    class success_result_type(TypedDict):
        # Define the structure of the success result as per your requirements
        data: Any
        status: str
        # Add more fields as needed

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: error_details,
        error_started_at: str,
        success_times: int,
        success_result: success_result_type,
        success_started_at: str,
    ) -> error_details:
        print(
            f"Schedule {schedule_path} recovered "
            f"{success_times > 1 and (str(success_times) + ' times in a row') or ''}\n"
            f"{'Flow' if is_flow else 'Script'}: {path}"
        )
        print(f"Last failure at {error_started_at}:", error)
        print(f"Last success at {success_started_at}:", success_result)
        return error
  original_instructions: |-
    Schedule recovery handler template in windmill
  resource_type: |-
    error_details
  resource_type_def: |-
    class error_details(TypedDict):
        # Define the structure of the error details as per your requirements
        message: str
        code: int
        # Add more fields as needed
- broken_code: |-
    from typing import TypedDict, Optional
    from nonexistentlibrary import HubSpot

    class hubspot(TypedDict):
        token: str

    def main(
        auth: hubspot,
        file_id: str,
        size: Optional[str] = None,
        expiration_seconds: Optional[int] = None,
        upscale: Optional[bool] = None
    ):
        client = HubSpot(api_key=auth['api_key'])

        try:
            return client.files.get_nonexistent_method(
                file_id,
                size,
                expiration_seconds,
                upscale
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")

    main({'token': 'fake_token'}, '12345')
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import `HubSpot` from a module named `nonexistentlibrary`, which does not exist. Additionally, within the `main` function, `auth['api_key']` is used, but the `hubspot` TypedDict only defines a `token` key, not an `api_key`. Lastly, the method `get_nonexistent_method` is called on the `client.files` object, but this method does not exist in the HubSpot API client.
  id: |-
    hubfix_hub_231
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot

    class hubspot(TypedDict):
        token: str

    def main(
        auth: hubspot,
        file_id: str,
        size: Optional[str] = None,
        expiration_seconds: Optional[int] = None,
        upscale: Optional[bool] = None
    ):
        client = HubSpot(api_key=auth['token'])

        try:
            return client.files.get_signed_url(
                file_id,
                size,
                expiration_seconds,
                upscale
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")
  original_instructions: |-
    Get File Public URL in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional, Dict, Any

    class faunadb(TypedDict):
        region: str
        secret: str

    def broken_function(auth: faunadb, query: str, variables: Optional[Dict[str, Any]] = None, operationName: Optional[str] = None):
        region = auth['area'] if auth['area'] in ["us", "eu"] else ""
        response = nonexistentlibrary.post(f'https://graphql.{region}.fauna.com/graphql', headers={
            'Authorization': 'Bearer ' + auth['secret'],
        }, json={
            'query': query,
            'variables': variables or {},
            'operationName': operationName or None,
        })
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the function `broken_function` is trying to access `auth['area']`, which is not a valid key in the `faunadb` TypedDict (it should be `auth['region']`). Lastly, it attempts to use `nonexistentlibrary.post`, which is not a valid function because the library does not exist.
  id: |-
    hubfix_hub_263
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional, Dict, Any

    class faunadb(TypedDict):
        region: str
        secret: str

    def main(auth: faunadb, query: str, variables: Optional[Dict[str, Any]] = None, operationName: Optional[str] = None):
        region = auth['region'] if auth['region'] in ["us", "eu"] else ""
        response = requests.post(f'https://graphql.{region}.fauna.com/graphql', headers={
            'Authorization': 'Bearer ' + auth['secret'],
        }, json={
            'query': query,
            'variables': variables or {},
            'operationName': operationName or None,
        })
        return response.json()
  original_instructions: |-
    Execute GraphQL Query in faunadb
  resource_type: |-
    faunadb
  resource_type_def: |-
    class faunadb(TypedDict):
        region: str
        secret: str
- broken_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str

    def launch(auth: slack_resource, chat_id: str):
        client = TeleBot(auth['token'])
        return client.get_chat_members_count(chat_id)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 9, in <module>
        launch({'api_key': '12345'}, 'chat_id')
      File "script.py", line 7, in launch
        client = TeleBot(auth['token'])
    KeyError: 'token'
  explanation: |-
    There are multiple issues with the code:

    1. The TypedDict class has been renamed from `telegram` to `slack_resource`, and the key has been changed from `token` to `api_key`. This will cause a KeyError when `auth['token']` is accessed because the key 'token' does not exist in the `auth` dictionary.

    2. The main function has been renamed to `launch`, which by itself is not an error, but if there is code elsewhere expecting a function named `main`, this will cause an issue.

    3. The method `get_chat_members_count` is being called on the `client` object, which is not the method that was originally used (`export_chat_invite_link`). If `get_chat_members_count` does not exist in the TeleBot class, this will raise an AttributeError. However, without knowing the exact version of the `telebot` library, we cannot be certain if this method exists or not.

    4. The error message provided assumes that the `launch` function is being called with a dictionary containing the key `api_key` instead of `token`, which is not shown in the code block but is implied by the error message.
  id: |-
    hubfix_hub_233
  lang: |-
    python
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str):
        client = TeleBot(auth['token'])
        return client.export_chat_invite_link(chat_id)
  original_instructions: |-
    Export Chat Invite Link in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class slack_resource(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> list:
        return [k for k, v in d.items() if v is not None]

    def main(auth: slack_resource, start_cursor: Optional[str] = None, page_size: Optional[int] = None):
        client = Client(auth=auth['api_key'])
        args = remove_empty_fields({
            'page_size': page_size,
            'start_cursor': start_cursor,
        })
        return client.users.fetch(**args)
  error: |-
    TypeError: Client() got an unexpected keyword argument 'auth'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` was renamed from `notion` to `slack_resource`, but the `main` function still expects a `notion` TypedDict. This will cause a type error if type checking is enforced.

    2. The `remove_empty_fields` function was changed to return a list instead of a dictionary. This will cause a type error because the `client.users.list` (or `client.users.fetch` in the broken code) method expects a dictionary of arguments, not a list.

    3. The `auth` dictionary is being accessed with a key `'api_key'` which does not exist in the `slack_resource` TypedDict. The correct key should be `'token'`.

    4. The `Client` class is being incorrectly instantiated with a keyword argument `auth`. The `Client` class from the `notion_client` library expects the token to be passed directly as a positional argument, not as a keyword argument.

    5. The `client.users.fetch` method does not exist in the `notion_client` library. The correct method should be `client.users.list`.

    6. The `**args` unpacking will fail because `args` is a list, not a dictionary, due to the change in the `remove_empty_fields` function.

    Running this code would result in a TypeError because the `Client` class is not being instantiated correctly, and this would be the first error encountered.
  id: |-
    hubfix_hub_349
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: notion, start_cursor: Optional[str] = None, page_size: Optional[int] = None):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'page_size': page_size,
            'start_cursor': start_cursor,
        })
        return client.users.list(**args)
  original_instructions: |-
    List Users in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        token: str

    def broken_function(slack_auth: slack_resource, fileId: str):
        supportsAllDrives = "maybe"
        DELETE_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/?supportsAllDrives={supportsAllDrives}"

        token = slack_auth["access_token"]

        response = nonexistentlibrary.delete(DELETE_FILE_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        return response.status
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken due to several reasons:
    1. The import statement `import nonexistentlibrary` tries to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `gdrive` to `slack_resource`, but the function parameter `slack_auth` is still expected to be of type `gdrive`.
    3. The `supportsAllDrives` variable is set to the string "maybe" instead of a boolean value, which is not a valid value for the `supportsAllDrives` parameter in the Google Drive API.
    4. The `token` is being accessed with the key `"access_token"` which does not exist in the `slack_resource` TypedDict; it should be `"token"`.
    5. The function `nonexistentlibrary.delete` is called, but `nonexistentlibrary` does not exist, which would raise a `NameError` if the import error was not raised first.
    6. The function is renamed from `main` to `broken_function`, which by itself is not an error, but if there is code expecting a function named `main`, this would cause an issue.
    7. The return statement `return response.status` is incorrect because the `requests` library's response object does not have a `status` attribute; it should be `response.status_code` or `response.text`.
  id: |-
    hubfix_hub_49
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        supportsAllDrives = True
        DELETE_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/?supportsAllDrives={supportsAllDrives}"

        token = gdrive_auth["token"]

        response = requests.delete(DELETE_FILE_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        return response.text
  original_instructions: |-
    Delete File in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    import os
    import json
    from typing import TypedDict
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack_resource(TypedDict):  # Changed class name from 'slack' to 'slack_resource'
        token: str

    def format_error(error: any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        started_at: str,
        failed_times: int,
        slack: slack_resource,  # Changed the type hint to 'slack_resource'
        channel: str,
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}/{'flows/get' if is_flow else 'scripts/get'}/{path}"
        web = WebClient(token=slack['token'])

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} failed {failed_times if failed_times > 1 else ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> failed*{f' {failed_times} times in a row' if failed_times > 1 else ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                    },
                },
            ],
            attachments=[
                {
                    "color": "#ff0000",
                    "blocks": [{
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"Last failure at: {datetime.fromisoformat(started_at).astimezone(pytz.UTC).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                        },
                    }],
                },
            ],
        )
  error: |-
    NameError: name 'slack' is not defined
  explanation: |-
    The TypedDict class name was changed from `slack` to `slack_resource`, but the type hint in the `main` function's parameters was not updated accordingly. The parameter `slack: slack` should be changed to `slack: slack_resource` to match the new class name. Additionally, the type hint for the `slack` parameter in the `main` function was changed to `slack_resource`, but the actual argument passed to the function is still expected to be of the original `slack` TypedDict type. This inconsistency will cause a NameError because the `slack` type is no longer defined.
  id: |-
    hubfix_hub_1030
  lang: |-
    python
  original_code: |-
    import os
    import json
    from typing import TypedDict
    from slack_sdk import WebClient
    from datetime import datetime
    import pytz

    class slack(TypedDict):
        token: str

    def format_error(error: any) -> str:
        if 'stack' in error and 'name' in error and 'message' in error:
            return f"*{error['name']}: {error['message']}*\n```\n{error['stack']}\n```"
        else:
            return f"```\n{json.dumps(error, indent=2)}\n```"

    def main(
        path: str,
        is_flow: bool,
        schedule_path: str,
        error: dict,
        started_at: str,
        failed_times: int,
        slack: slack,
        channel: str,
    ):
        base_url = os.getenv("WM_BASE_URL")
        schedule_url = f"{base_url}/runs?schedule_path={schedule_path}"
        runnable_url = f"{base_url}/{'flows/get' if is_flow else 'scripts/get'}/{path}"
        web = WebClient(token=slack['token'])

        web.chat_postMessage(
            channel=channel,
            text=f"Schedule {schedule_path} failed {failed_times if failed_times > 1 else ''}",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Schedule <{schedule_url}|{schedule_path}> failed*{f' {failed_times} times in a row' if failed_times > 1 else ''}:\n- {'Flow' if is_flow else 'Script'}: <{runnable_url}|{path}>",
                    },
                },
            ],
            attachments=[
                {
                    "color": "#ff0000",
                    "blocks": [{
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"Last failure at: {datetime.fromisoformat(started_at).astimezone(pytz.UTC).strftime('%d.%m.%Y %H:%M (%Z)')}\n{format_error(error)}",
                        },
                    }],
                },
            ],
        )
  original_instructions: |-
    Schedule error handler in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary  # This library does not exist

    class faunadb(TypedDict):
        region: str
        secret: str

    def main(auth: faunadb, schema: str, mode: str = "merge"):
        region = auth['area'] if auth['area'] in ["us", "eu"] else ""  # 'area' is not a valid key
        response = nonexistentlibrary.post(  # This function does not exist
            f"https://graphql.{region}.fauna.com/import?mode={mode}",
            headers={
                "Authorization": "Bearer " + auth['secret'],
            },
            data=schema,
        )
        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist in the Python standard library or third-party packages. Additionally, within the `main` function, `auth['area']` is used, but 'area' is not a valid key in the `faunadb` TypedDict; the correct key should be 'region'. Lastly, the `nonexistentlibrary.post` function is called, but since the library does not exist, neither does the function, which would result in an AttributeError if the ModuleNotFoundError were resolved.
  id: |-
    hubfix_hub_264
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import requests

    class faunadb(TypedDict):
        region: str
        secret: str

    def main(auth: faunadb, schema: str, mode: str = "merge"):
        region = auth['region'] if auth['region'] in ["us", "eu"] else ""
        response = requests.post(
            f"https://graphql.{region}.fauna.com/import?mode={mode}",
            headers={
                "Authorization": "Bearer " + auth['secret'],
            },
            data=schema,
        )
        return response.text
  original_instructions: |-
    Import GraphQL schema in faunadb
  resource_type: |-
    faunadb
  resource_type_def: |-
    class faunadb(TypedDict):
        region: str
        secret: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Any

    class resource(TypedDict):
        resources: List[Any]

    def main() -> resource:
        url = "https://hub.windmill.dev/searchResourceData"
        response = nonexistentlibrary.get(url)
        return response.jsonify()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find the specified module. Additionally, the `response` object is calling a method `jsonify()` which does not exist; the correct method is `json()`. However, the primary error that will be encountered first is the missing library.
  id: |-
    hubfix_hub_168
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class resource(TypedDict):
        resources: List[Any]

    def main() -> resource:
        url = "https://hub.windmill.dev/searchResourceData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List Resource Types in windmillhub
  resource_type: |-
    resource
  resource_type_def: |-
    class resource(TypedDict):
        resources: List[Any]
- broken_code: |-
    from typing import TypedDict, Optional
    import nonexistentlibrary  # This library does not exist

    class slack_resource(TypedDict):  # Renamed the TypedDict
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: slack_resource, cursor: Optional[str] = None, limit: Optional[int] = None):
        client = auth['api_key']  # Changed the key to a non-existent one
        params = remove_empty_fields({'cursor': cursor, 'limit': limit})
        response = nonexistentlibrary.get('https://slack.com/api/users.list', headers={'Authorization': f'Bearer {client}'}, params=params)  # Using the nonexistent library
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:

    1. The import statement `import nonexistentlibrary` is trying to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` class was renamed from `slack` to `slack_resource`, but the `main` function still expects the original `slack` type for its `auth` parameter.
    3. Inside the `main` function, `auth['api_key']` is used, but `api_key` is not a defined property of the `slack_resource` TypedDict. The original property was `token`.
    4. The `nonexistentlibrary.get` function is called, but `nonexistentlibrary` does not exist as it was not successfully imported (and does not exist in the first place), which would also raise a `NameError` if the import error was ignored.
  id: |-
    hubfix_hub_299
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    import requests

    class slack(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: slack, cursor: Optional[str] = None, limit: Optional[int] = None):
        client = auth['token']
        params = remove_empty_fields({'cursor': cursor, 'limit': limit})
        response = requests.get('https://slack.com/api/users.list', headers={'Authorization': f'Bearer {client}'}, params=params)
        return response.json()
  original_instructions: |-
    List Users in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary  # This library does not exist

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: str):
        session = nonexistentlibrary.Session()  # This will fail because the library does not exist
        session.headers.update({
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        })

        if auth['self_signed']:
            session.verify = False

        response = session.delete(f"{auth['endpoint']}/users/{id}")
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the `Session` class is being called from this non-existent library, which would also cause an error if the import statement did not already fail.
  id: |-
    hubfix_hub_325
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import requests

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: str):
        session = requests.Session()
        session.headers.update({
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        })

        if auth['self_signed']:
            session.verify = False

        response = session.delete(f"{auth['endpoint']}/users/{id}")
        return response.json()
  original_instructions: |-
    Delete User in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import openai
    from typing import TypedDict, Optional, Dict, Any

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def remove_object_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: openai_typeddict,
        model: str = "text-davinci-003",
        prompt: Optional[str] = None,
        suffix: Optional[str] = None,
        max_tokens: Optional[int] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        n: Optional[int] = None,
        stream: Optional[bool] = None,
        logprobs: Optional[int] = None,
        echo: Optional[bool] = None,
        stop: Optional[str] = None,
        presence_penalty: Optional[float] = None,
        frequency_penalty: Optional[float] = None,
        best_of: Optional[int] = None,
        logit_bias: Optional[Dict[str, float]] = None,
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        request = remove_object_empty_fields({
            "model": model,
            "prompt": prompt,
            "suffix": suffix,
            "max_tokens": max_tokens,
            "temperature": temperature,
            "top_p": top_p,
            "n": n,
            "stream": stream,
            "logprobs": logprobs,
            "echo": echo,
            "stop": stop,
            "presence_penalty": presence_penalty,
            "frequency_penalty": frequency_penalty,
            "best_of": best_of,
            "logit_bias": logit_bias,
        })
        response = openai.Completion.create(**request, unexpected_argument=True)
        return response
  error: |-
    TypeError: create() got an unexpected keyword argument 'unexpected_argument'
  explanation: |-
    The error occurs because the `openai.Completion.create()` method is called with an argument `unexpected_argument` that does not exist in the method's signature. The `openai.Completion.create()` method expects specific parameters, and passing an undefined or unexpected parameter will result in a `TypeError`.
  id: |-
    hubfix_hub_245
  lang: |-
    python
  original_code: |-
    import openai
    from typing import TypedDict, Optional, Dict, Any

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def remove_object_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: openai_typeddict,
        model: str = "text-davinci-003",
        prompt: Optional[str] = None,
        suffix: Optional[str] = None,
        max_tokens: Optional[int] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        n: Optional[int] = None,
        stream: Optional[bool] = None,
        logprobs: Optional[int] = None,
        echo: Optional[bool] = None,
        stop: Optional[str] = None,
        presence_penalty: Optional[float] = None,
        frequency_penalty: Optional[float] = None,
        best_of: Optional[int] = None,
        logit_bias: Optional[Dict[str, float]] = None,
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        request = remove_object_empty_fields({
            "model": model,
            "prompt": prompt,
            "suffix": suffix,
            "max_tokens": max_tokens,
            "temperature": temperature,
            "top_p": top_p,
            "n": n,
            "stream": stream,
            "logprobs": logprobs,
            "echo": echo,
            "stop": stop,
            "presence_penalty": presence_penalty,
            "frequency_penalty": frequency_penalty,
            "best_of": best_of,
            "logit_bias": logit_bias,
        })
        response = openai.Completion.create(**request)
        return response
  original_instructions: |-
    Create Completion in openai
  resource_type: |-
    openai_typeddict
  resource_type_def: |-
    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: str,  # Changed the type from int to str
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        DELETE_COLUMN_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "deleteDimension": {
                        "range": {
                            "sheetId": sheetId,
                            "dimension": "COLUMNS",
                            "startIndex": start_index,
                            "endIndex": end_index,
                        },
                    },
                },
            ],
        }
        response = nonexistentlibrary.post(  # Changed requests to nonexistentlibrary
            DELETE_COLUMN_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()

        return "Columns deleted."
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find the specified module. Additionally, the function `nonexistentlibrary.post` is called instead of `requests.post`, which will also break the code because `nonexistentlibrary` does not have a `post` method. Furthermore, the type of the `sheetId` parameter in the `broken_function` has been changed from `int` to `str`, which could cause issues if the API expects an integer value for the sheet ID.
  id: |-
    hubfix_hub_70
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: int,
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        DELETE_COLUMN_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "deleteDimension": {
                        "range": {
                            "sheetId": sheetId,
                            "dimension": "COLUMNS",
                            "startIndex": start_index,
                            "endIndex": end_index,
                        },
                    },
                },
            ],
        }
        response = requests.post(
            DELETE_COLUMN_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return "Columns deleted."
  original_instructions: |-
    Clear Columns in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def broken_function(glab: gitlab, projectId: str, releaseTag: str):
        url = f"{glab['baseURL']}/api/v4/projects/{projectId}/releases/{releaseTag}"
        response = nonexistentlibrary.get(url, headers={"PRIVATE-TOKEN": glab['token']})
        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the function `broken_function` is trying to use a method `get` from this non-existent library, which would also cause an AttributeError if the import statement didn't already fail. Furthermore, the TypedDict `gitlab` has a key 'baseUrl', but the code incorrectly references 'baseURL' (case-sensitive issue). Lastly, the parameter `projectId` is expected to be an `int` as per the original code, but it has been changed to `str`, which could cause issues if the API expects an integer.
  id: |-
    hubfix_hub_414
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: int, releaseTag: str):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/releases/{releaseTag}"
        response = requests.get(url, headers={"PRIVATE-TOKEN": glab['token']})
        return response.json()
  original_instructions: |-
    Get release in gitlab
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import json
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict

    class sql(TypedDict):
        statement: str
        timeout: int
        database: str
        schema: str

    def main(token: str, account_id: str, database: str, schema: str, sql_query: sql):
        POST_URL = f'https://{account_id}.snowflakecomputing.com/api/statements'

        body = {
            'statement': sql_query['statement'],
            'timeout': 60,
            'database': database,
            'schema': schema,
        }

        response = requests.post(POST_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. To fix this error, you would need to remove the import statement for `nonexistentlibrary` or replace it with a valid library name.
  id: |-
    hubfix_hub_112
  lang: |-
    python
  original_code: |-
    import json
    import requests
    from typing import TypedDict

    class sql(TypedDict):
        statement: str
        timeout: int
        database: str
        schema: str

    def main(token: str, account_id: str, database: str, schema: str, sql: sql):
        POST_URL = f'https://{account_id}.snowflakecomputing.com/api/statements'

        body = {
            'statement': sql['statement'],
            'timeout': 60,
            'database': database,
            'schema': schema,
        }

        response = requests.post(POST_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        return response.json()
  original_instructions: |-
    Execute Query & Return Results in snowflake
  resource_type: |-
    sql
  resource_type_def: |-
    class sql(TypedDict):
        statement: str
        timeout: int
        database: str
        schema: str
- broken_code: |-
    import nonexistentlibrary

    def broken_function(password: str, salt_num: str) -> int:
        salt = bcrypt.gensalt(rounds=salt_num)
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The import statement tries to import a library named 'nonexistentlibrary', which does not exist.
    2. The function has been renamed from `main` to `broken_function`, which would cause an issue if other parts of the code expect a function named `main`.
    3. The `salt_num` parameter is expected to be an integer, but the type hint has been changed to `str`, which would cause an error if a string is passed to `bcrypt.gensalt`.
    4. The return type of the function has been changed from `str` to `int`, but the function still returns a byte string decoded to UTF-8, which is a string, not an integer.
  id: |-
    hubfix_hub_85
  lang: |-
    python
  original_code: |-
    import bcrypt

    def main(password: str, salt_num: int) -> str:
        salt = bcrypt.gensalt(rounds=salt_num)
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass.decode('utf-8')
  original_instructions: |-
    Hash Password with Manual Salt in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        api_key: str  # Changed apiKey to api_key

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: str, new_record: dict):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])  # Still using 'apiKey' instead of 'api_key'
        update_single_record = table.update(record_id, new_record, extra_param=123)  # Added non-existent parameter 'extra_param'
        return update_single_record
  error: |-
    KeyError: 'apiKey'
  explanation: |-
    The code is broken because the key 'apiKey' was changed to 'api_key' in the `airtable` TypedDict, but the `main` function still tries to access the old key 'apiKey' which no longer exists. Additionally, the `table.update` method is called with a non-existent parameter 'extra_param', which would cause an error if the KeyError was not encountered first.
  id: |-
    hubfix_hub_1022
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: str, new_record: dict):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        update_single_record = table.update(record_id, new_record)
        return update_single_record
  original_instructions: |-
    Update record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- broken_code: |-
    from typing import TypedDict, Literal
    import nonexistentlibrary

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def main(
        auth: openai_typeddict,
        prompt: str,
        number_of_images: Literal["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"] = "1",
        size: Literal["256x256", "512x512", "1024x1024"] = "1024x1024",
        response_format: Literal["url", "b64_json"] = "url",
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Image.generate(
            prompt=prompt,
            n=int(number_of_images),
            size=size,
            response_format=response_format,
        )
        return response['data']
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the method `openai.Image.generate` does not exist; the correct method is `openai.Image.create`. This would also cause an AttributeError if the import error was fixed.
  id: |-
    hubfix_hub_244
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Literal
    import openai

    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str

    def main(
        auth: openai_typeddict,
        prompt: str,
        number_of_images: Literal["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"] = "1",
        size: Literal["256x256", "512x512", "1024x1024"] = "1024x1024",
        response_format: Literal["url", "b64_json"] = "url",
    ):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Image.create(
            prompt=prompt,
            n=int(number_of_images),
            size=size,
            response_format=response_format,
        )
        return response['data']
  original_instructions: |-
    Generate Image in openai
  resource_type: |-
    openai_typeddict
  resource_type_def: |-
    class openai_typeddict(TypedDict):
        api_key: str
        organization_id: str
- broken_code: |-
    from typing import TypedDict, Optional, Dict, Any
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: notion,
        query: Optional[str] = None,
        filter: Optional[Dict[str, str]] = None,
        sort: Optional[Dict[str, str]] = None,
        start_cursor: Optional[str] = None,
        page_size: Optional[int] = None,
    ) -> Any:
        client = Client(auth=auth['api_key'])  # Changed 'token' to 'api_key'
        args = remove_empty_fields({
            'query': query,
            'filter': filter,
            'sort': sort,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        return client.search(**args)
  error: |-
    KeyError: 'api_key'
  explanation: |-
    The code is trying to access a key 'api_key' in the 'auth' dictionary, which is of type 'notion'. However, the 'notion' TypedDict is defined with only a 'token' key, and 'api_key' does not exist. This results in a KeyError when the non-existent key 'api_key' is accessed.
  id: |-
    hubfix_hub_353
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, Dict, Any
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: notion,
        query: Optional[str] = None,
        filter: Optional[Dict[str, str]] = None,
        sort: Optional[Dict[str, str]] = None,
        start_cursor: Optional[str] = None,
        page_size: Optional[int] = None,
    ) -> Any:
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'query': query,
            'filter': filter,
            'sort': sort,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        return client.search(**args)
  original_instructions: |-
    Search by Title in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class slack_resource(TypedDict):
        token_key: str

    def remove_empty_fields(d: dict) -> list:
        return [k for k, v in d.items() if v is not None]

    def main(auth: slack_resource, block_id: str, start_cursor: Optional[str] = None, page_size: Optional[int] = None):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'block_id': block_id,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        return client.blocks.children.retrieve(**args)
  error: |-
    TypeError: Client() got an unexpected keyword argument 'auth'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` was renamed from `notion` to `slack_resource`, and the key was changed from `token` to `token_key`. This will cause an error when trying to access `auth['token']` because the key does not exist in the `auth` dictionary.

    2. The `remove_empty_fields` function was changed to return a list instead of a dictionary. This will cause an error when trying to unpack the list as keyword arguments in the `client.blocks.children.retrieve(**args)` call.

    3. The `Client` class is being instantiated with a keyword argument `auth`, which is not a valid parameter for the `Client` constructor. The correct way to instantiate the client would be `Client(auth['token_key'])` assuming that the `token_key` is the correct key in the `auth` dictionary.

    4. The `client.blocks.children.retrieve` method is being called, but this method does not exist in the `notion_client` library. The correct method to call would be `client.blocks.children.list` if the intention is to list the children of a block.

    5. The `TypedDict` definition should match the expected structure of the `auth` dictionary. If the `auth` dictionary is expected to have a `token` key, the `TypedDict` should be defined with a `token` key, not `token_key`.
  id: |-
    hubfix_hub_354
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from notion_client import Client

    class notion(TypedDict):
        token: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: notion, block_id: str, start_cursor: Optional[str] = None, page_size: Optional[int] = None):
        client = Client(auth=auth['token'])
        args = remove_empty_fields({
            'block_id': block_id,
            'start_cursor': start_cursor,
            'page_size': page_size,
        })
        return client.blocks.children.list(**args)
  original_instructions: |-
    Retrieve Block Children in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, spreadsheetId: str, range: str):
        token = gsheets_auth["token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{range}"

        response = nonexistentlibrary.get(
            GET_VALUES_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `nonexistentlibrary.get` is called, which would also break the code because `nonexistentlibrary` is not a valid module and therefore does not have a `get` method.
  id: |-
    hubfix_hub_52
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, range: str):
        token = gsheets_auth["token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{range}"

        response = requests.get(
            GET_VALUES_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Get Values in Range in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    from openai import OpenAI, ModerationCreateResponse

    class slack_resource(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: slack_resource, prompt: str, model: str = "text-moderation-latest") -> ModerationCreateResponse:
        openai_api = OpenAI(api_key=auth['api_key'], organization=auth['organization_id'])

        response = openai_api.Moderation.create(
            input_text=prompt,
            model_name=model
        )
        return response
  error: |-
    TypeError: 'TypedDict' object is not subscriptable
  explanation: |-
    The code is broken because of the following reasons:

    1. The `TypedDict` named `openai` was changed to `slack_resource`, which is not used anywhere in the code. The `auth` parameter in the `main` function is still expecting a `TypedDict` named `openai`, but it is being passed a `TypedDict` named `slack_resource`. This will cause a type error because the `auth` parameter is expecting a different type.

    2. The `OpenAI` class method `Moderation.create` is called with incorrect parameter names: `input_text` and `model_name`. The correct parameter names should be `input` and `model` as per the original script.

    The error message provided is for the first issue, which is a TypeError indicating that the 'TypedDict' object is not subscriptable. This error would occur if the Python version being used does not support the subscripting of TypedDict, which is a feature introduced in Python 3.8. If the Python version is 3.8 or later, the error message would instead be related to the incorrect parameter names passed to the `Moderation.create` method.
  id: |-
    hubfix_hub_246
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from openai import OpenAI, ModerationCreateResponse

    class openai(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai, prompt: str, model: str = "text-moderation-latest") -> ModerationCreateResponse:
        openai_api = OpenAI(api_key=auth['api_key'], organization=auth['organization_id'])

        response = openai_api.Moderation.create(
            input=prompt,
            model=model
        )
        return response
  original_instructions: |-
    Create Moderation in openai
  resource_type: |-
    openai
  resource_type_def: |-
    class openai(TypedDict):
        api_key: str
        organization_id: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class windmill(TypedDict):
        message: str
        flow_id: str

    def main_flow(message: int, name: str) -> windmill:
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        print("message", message)
        print("name", name)
        return {"message": message, "flow_identifier": flow_id}
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, there are other issues in the code:
    - The `main` function has been renamed to `main_flow`, which would cause an issue if the script relies on a function named `main`.
    - The `message` parameter type in the `main_flow` function has been changed from `str` to `int`, which could cause a type mismatch if the function is called with a string argument.
    - The `windmill` TypedDict specifies a key `flow_id`, but the return statement uses a non-existent key `flow_identifier`, which would result in a `TypeError` if the code were to execute past the import error.
  id: |-
    hubfix_hub_158
  lang: |-
    python
  original_code: |-
    import os
    from typing import TypedDict

    class windmill(TypedDict):
        message: str
        flow_id: str

    def main(message: str, name: str) -> windmill:
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        print("message", message)
        print("name", name)
        return {"message": message, "flow_id": flow_id}
  original_instructions: |-
    Log error in windmill
  resource_type: |-
    windmill
  resource_type_def: |-
    class windmill(TypedDict):
        message: str
        flow_id: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, title: int):
        supports_all_drives = "yes"
        create_folder_url = f"https://www.googleapis.com/drive/v3/files/?supportsAllDrives={supports_all_drives}"

        token = gdrive_auth["access_token"]
        body = {
            "name": title,
            "mimeType": "application/vnd.google-apps.folder",
        }
        response = nonexistentlibrary.post(create_folder_url, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        })

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `title` parameter type has been changed from `str` to `int`, which is incorrect for the intended use. The `supports_all_drives` variable is set to a string `"yes"` instead of a boolean value. The `token` is being accessed with the wrong key `"access_token"` instead of `"token"`. Lastly, the `response.json()` method is called, but the `response` object is not defined because the `nonexistentlibrary.post` call will fail due to the non-existent library.
  id: |-
    hubfix_hub_58
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, title: str):
        supports_all_drives = True
        create_folder_url = f"https://www.googleapis.com/drive/v3/files/?supportsAllDrives={supports_all_drives}"

        token = gdrive_auth["token"]
        body = {
            "name": title,
            "mimeType": "application/vnd.google-apps.folder",
        }
        response = requests.post(create_folder_url, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        })

        return response.text
  original_instructions: |-
    Create Folder in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, List
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_list: List[dict]):
        table = Table(at_con['api_Key'], at_table['base_Id'], at_table['table_Name'])
        create_multiple = table.batch_create(record_list)
        return create_multiple

    main({'api_key': 'key'}, {'base_id': 'app', 'table_name': 'Table 1'}, [{'Name': 'Alice'}])
  error: |-
    Traceback (most recent call last):
      File "script.py", line 14, in <module>
        main({'api_key': 'key'}, {'base_id': 'app', 'table_name': 'Table 1'}, [{'Name': 'Alice'}])
      File "script.py", line 10, in main
        table = Table(at_con['api_Key'], at_table['base_Id'], at_table['table_Name'])
    KeyError: 'api_Key'
  explanation: |-
    The code is broken because the keys used to access the dictionary values in the `main` function are incorrect. The keys in the `at_con` and `at_table` dictionaries are case-sensitive and must match exactly how they were defined in the `airtable` and `airtableTable` TypedDict classes. The correct keys are 'apiKey', 'baseId', and 'tableName', but the code uses 'api_Key', 'base_Id', and 'table_Name', which do not exist in the provided dictionaries, leading to a KeyError.
  id: |-
    hubfix_hub_1025
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, List
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_list: List[dict]):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        create_multiple = table.batch_create(record_list)
        return create_multiple
  original_instructions: |-
    Create Multiple Records in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary  # This library does not exist

    class github(TypedDict):
        token: str

    def broken_function(gh_auth: github, owner: str, repo: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}"
        response = nonexistentlibrary.get(url, headers=headers)  # nonexistentlibrary.get does not exist
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, it tries to use a `get` method from this non-existent library to make an HTTP request, which will also fail because the library and its methods are not defined. The `broken_function` name change does not directly cause an error, but it would cause an error if another part of the code expects a function named `main`.
  id: |-
    hubfix_hub_313
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import requests

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}"
        response = requests.get(url, headers=headers)
        return response.json()
  original_instructions: |-
    Get Repo in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import List, Optional, Union, TypedDict

    class github(TypedDict):
        token: str

    def broken_function(
        gh_auth: github,
        owner: str,
        repo: str,
        title: str,
        body: str,
        assignees: Optional[List[str]] = None,
        milestone: Optional[Union[str, int]] = None,
        labels: Optional[List[str]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json"
        }
        data = {
            "title": title,
            "body": body,
            "assignees": assignees or [],
            "milestone": milestone,
            "labels": labels
        }
        # Filter out None values
        data = {k: v for k, v in data.items() if v is not None}

        response = nonexistentlibrary.post(
            f"https://api.github.com/repos/{owner}/{repo}/issues",
            headers=headers,
            json=data
        )
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `requests.post` function call has been changed to `nonexistentlibrary.post`, which will also fail because `nonexistentlibrary` is not a valid module and does not have a `post` method. The `main` function has been renamed to `broken_function`, which would cause an error if code elsewhere in the program expects a function named `main`.
  id: |-
    hubfix_hub_315
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, Optional, Union, TypedDict

    class github(TypedDict):
        token: str

    def main(
        gh_auth: github,
        owner: str,
        repo: str,
        title: str,
        body: str,
        assignees: Optional[List[str]] = None,
        milestone: Optional[Union[str, int]] = None,
        labels: Optional[List[str]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json"
        }
        data = {
            "title": title,
            "body": body,
            "assignees": assignees or [],
            "milestone": milestone,
            "labels": labels
        }
        # Filter out None values
        data = {k: v for k, v in data.items() if v is not None}

        response = requests.post(
            f"https://api.github.com/repos/{owner}/{repo}/issues",
            headers=headers,
            json=data
        )
        return response.json()
  original_instructions: |-
    Create Issue in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import List, Any, TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(
        gsheets_auth: gsheets,
        sheet_id: str,
        values: List[List[Any]],
        range: str = "Sheet1"
    ):
        body = {
            'values': values,
        }

        valueInputOption = "USER_ENTERED"
        insertDataOption = "INSERT_ROWS"
        includeValuesInResponse = True
        APPEND_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{sheet_id}/values/{range}:append/?valueInputOption={valueInputOption}&insertDataOption={insertDataOption}&includeValuesInResponse={includeValuesInResponse}"

        token = gsheets_auth["nonexistent_property"]

        response = requests.post(
            APPEND_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return {'result': result}
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the function `main` has been renamed to `broken_function`, which would cause an issue if another part of the code expects a function named `main`. Lastly, the code tries to access a property `nonexistent_property` on the `gsheets_auth` TypedDict, which does not exist in the defined `gsheets` TypedDict, leading to a `KeyError` if the import error is fixed and the code is executed.
  id: |-
    hubfix_hub_37
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, Any, TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        sheet_id: str,
        values: List[List[Any]],
        range: str = "Sheet1"
    ):
        body = {
            'values': values,
        }

        valueInputOption = "USER_ENTERED"
        insertDataOption = "INSERT_ROWS"
        includeValuesInResponse = True
        APPEND_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{sheet_id}/values/{range}:append/?valueInputOption={valueInputOption}&insertDataOption={insertDataOption}&includeValuesInResponse={includeValuesInResponse}"

        token = gsheets_auth["token"]

        response = requests.post(
            APPEND_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return {'result': result}
  original_instructions: |-
    Add Rows in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gitlab(TypedDict):
        base_url: str
        token: str

    def main(glab: gitlab, projectId: str, issueId: int):
        url = f"{glab['baseURL']}/api/v4/projects/{projectId}/issues/{issueId}"
        headers = {'Authorization': f'Bearer: {glab["token"]}'}
        response = nonexistentlibrary.get(url, headers=headers)
        return response.text()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, there are other issues in the code:
    - The TypedDict `gitlab` has a property `base_url` which is not used in the function; instead, it incorrectly tries to access `glab['baseURL']` which does not exist.
    - The `projectId` parameter type in the function signature has been changed from `int` to `str`, which may not be an error per se but could lead to issues if the API expects an integer.
    - The `requests.get` function has been replaced with `nonexistentlibrary.get`, which does not exist.
    - The method `response.text()` should be `response.text` if the intention is to get the raw text response, or `response.json()` if the intention is to parse the response as JSON.
  id: |-
    hubfix_hub_146
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: int, issueId: int):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/issues/{issueId}"
        headers = {'Authorization': f'Bearer: {glab["token"]}'}
        response = requests.get(url, headers=headers)
        return response.json()
  original_instructions: |-
    Get Issue in gitlab
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    from typing import TypedDict
    import time
    import stripe as stripe_module

    def getState():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def setState(value):
        with open('state.txt', 'w') as file:
            file.write(str(value))

    class stripe(TypedDict):
        token: str

    def main(auth: stripe):
        stripe_client = stripe_module.Stripe(auth['api_key'])
        lastCheck = getState()
        setState(int(time.time()))
        customers = stripe_client.Customer.list(created={'gt': lastCheck})
        return [customer for customer in customers.auto_paging_iter()]

    main({'token': 'sk_test_4eC39HqLyjWDarjtT1zdp7dc'})
  error: |-
    AttributeError: 'Stripe' object has no attribute 'Customer'
  explanation: |-
    The error occurs because the `stripe_client` object does not have an attribute `Customer`. The correct attribute should be `Customer` with a lowercase 'c' (i.e., `stripe_client.customer`). The Stripe client object methods and properties are case-sensitive, and using the incorrect case will result in an AttributeError because the Python interpreter cannot find the attribute with the specified name.
  id: |-
    hubfix_hub_265
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import time
    import stripe as stripe_module

    # Assuming getState and setState are functions that need to be implemented
    # to get and set the last checked timestamp in a persistent storage.
    # For the sake of this example, we'll use a simple file-based approach.

    def getState():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def setState(value):
        with open('state.txt', 'w') as file:
            file.write(str(value))

    class stripe(TypedDict):
        token: str

    def main(auth: stripe):
        stripe_client = stripe_module.Stripe(auth['token'])
        lastCheck = getState()
        setState(int(time.time()))
        customers = stripe_client.Customer.list(created={'gt': lastCheck})
        return [customer for customer in customers.auto_paging_iter()]
  original_instructions: |-
    Get recently added customers in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Any

    class windmillhub(TypedDict):
        asks: List[Any]

    def broken_function() -> windmillhub:
        url = "https://hub.windmill.dev/searchData"
        response = nonexistentlibrary.get(url)
        return response.jsonify()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `requests.get` method is replaced with `nonexistentlibrary.get`, which is not a valid method since the library does not exist. Finally, `response.jsonify()` is incorrect because the correct method to parse the JSON response is `response.json()`, not `response.jsonify()`.
  id: |-
    hubfix_hub_170
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class windmillhub(TypedDict):
        asks: List[Any]

    def main() -> windmillhub:
        url = "https://hub.windmill.dev/searchData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List suggestions in windmillhub
  resource_type: |-
    windmillhub
  resource_type_def: |-
    class windmillhub(TypedDict):
        asks: List[Any]
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        apiUrl: str
        xc_token: str
        table: str
        workspace: str

    def broken_function(slack_resource: slack_resource, limit: str):
        # request from nocodb
        res = nonexistentlibrary.get(
            f"{slack_resource['apiUrl']}/api/v1/db/data/v1/{slack_resource['workspace']}/{slack_resource['table']}?limit={limit}",
            headers={
                "Content-Type": "application/json",
                "xc-token": slack_resource['xc_token'],
            },
        )
        data = res.jsonify()
        return data
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The function `broken_function` is expecting a parameter of type `slack_resource`, which is a TypedDict that has been incorrectly renamed from `nocodb`. This change doesn't directly cause an error but will cause confusion and potential misuse of the function.
    3. The parameter `limit` is changed to type `str`, which should be an `int` based on the original code's context.
    4. The function `nonexistentlibrary.get` is called, which doesn't exist because the library `nonexistentlibrary` doesn't exist.
    5. The method `res.jsonify()` is incorrect; the correct method to parse the JSON response is `res.json()`.
  id: |-
    hubfix_hub_369
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class nocodb(TypedDict):
        apiUrl: str
        xc_token: str
        table: str
        workspace: str

    def main(nocodb: nocodb, limit: int):
        # request from nocodb
        res = requests.get(
            f"{nocodb['apiUrl']}/api/v1/db/data/v1/{nocodb['workspace']}/{nocodb['table']}?limit={limit}",
            headers={
                "Content-Type": "application/json",
                "xc-token": nocodb['xc_token'],
            },
        )
        data = res.json()
        return data
  original_instructions: |-
    Get item list from a NocoDb table in nocodb
  resource_type: |-
    nocodb
  resource_type_def: |-
    class nocodb(TypedDict):
        apiUrl: str
        xc_token: str
        table: str
        workspace: str
- broken_code: |-
    from typing import TypedDict
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: str  # Changed the type from int to str
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, path: str, content: str):
        session = boto3.session.Session()
        client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        try:
            client.upload_file(Bucket=s3_config['bucket'], Key=path, Body=content)  # Changed put_object to upload_file
        except NoCredentialsError:
            print("Credentials not available")
  error: |-
    TypeError: 'port' must be an instance of int, not str
  explanation: |-
    The code is broken because the type of the 'port' field in the 's3' TypedDict was changed from 'int' to 'str'. The 'port' field should be an integer as it represents the port number for the connection. Additionally, the 'client.put_object' method was incorrectly changed to 'client.upload_file', which is not a method of the 'client' object created by 'session.client'. The correct method to use is 'put_object' for uploading content to an S3 bucket.
  id: |-
    hubfix_hub_108
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def main(s3_config: s3, path: str, content: str):
        session = boto3.session.Session()
        client = session.client(
            service_name='s3',
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            endpoint_url=f"http{'s' if s3_config['useSSL'] else ''}://{s3_config['endPoint']}:{s3_config['port']}",
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        try:
            client.put_object(Bucket=s3_config['bucket'], Key=path, Body=content)
        except NoCredentialsError:
            print("Credentials not available")
  original_instructions: |-
    Upload text in bucket in s3
  resource_type: |-
    s3
  resource_type_def: |-
    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str
- broken_code: |-
    import base64
    import nonexistentlibrary
    from typing import TypedDict

    class nextcloud_resource(TypedDict):
        base_url: str
        user_name: str
        pass_word: str

    def main(nextcloud_res: nextcloud_resource) -> int:
        url = f"{nextcloud_res['base_url']}/ocs/v1.php/cloud/users"
        credentials = base64.b64encode(f"{nextcloud_res['user_name']}:{nextcloud_res['pass_word']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {credentials}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, there are other issues in the code, such as changing the TypedDict class name from `nextcloud` to `nextcloud_resource` and the keys within it, which would cause the function to fail if it were to run. The return type of the function has also been changed from `str` to `int`, which is incorrect because the function returns `resp.text`, which is a string.
  id: |-
    hubfix_hub_163
  lang: |-
    python
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str

    def main(nextcloud_res: nextcloud) -> str:
        url = f"{nextcloud_res['baseUrl']}/ocs/v1.php/cloud/users"
        credentials = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['password']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {credentials}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_instructions: |-
    List user IDs in ocs
  resource_type: |-
    nextcloud
  resource_type_def: |-
    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str
- broken_code: |-
    from typing import TypedDict, Optional
    from firebase_admin import credentials, firestore, initialize_app
    from google.cloud.firestore_v1 import Client, CollectionReference, Query

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        order_by: Optional[str] = None,
        order_direction: str = "asc",
        start_at: Optional[str] = None,
        end_at: Optional[str] = None,
        limit: Optional[int] = None,
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['private_key_id'],
            "private_key": auth['private_key'],
            "client_email": auth['client_email'],
            "client_id": auth['client_id'],
            "auth_uri": auth['auth_uri'],
            "token_uri": auth['token_uri'],
            "auth_provider_x509_cert_url": auth['auth_provider_x509_cert_url'],
            "client_x509_cert_url": auth['client_x509_cert_url']
        })
        app = initialize_app(cred)
        store: Client = firestore.client(app)

        col_ref: CollectionReference = store.collection(collection_id)
        constraints = []

        if order_by:
            constraints.append(Query(col_ref).order_by(order_by, direction=order_direction))
        if start_at:
            constraints.append(Query(col_ref).start_at([start_at]))
        if end_at:
            constraints.append(Query(col_ref).end_at([end_at]))
        if limit:
            constraints.append(Query(col_ref).limit(limit))

        query_ref = col_ref
        for constraint in constraints:
            query_ref = constraint

        snapshot = query_ref.stream()
        list = [doc.to_dict() for doc in snapshot]

        return list

    main({
        "apiKey": "some-api-key",
        "authDomain": "some-auth-domain",
        "projectId": "some-project-id",
        "storageBucket": "some-storage-bucket",
        "messagingSenderId": "some-messaging-sender-id",
        "appId": "some-app-id",
        "measurementId": "some-measurement-id",
        "private_key_id": "some-private-key-id",
        "private_key": "some-private-key",
        "client_email": "some-client-email",
        "client_id": "some-client-id",
        "auth_uri": "some-auth-uri",
        "token_uri": "some-token-uri",
        "auth_provider_x509_cert_url": "some-auth-provider-x509-cert-url",
        "client_x509_cert_url": "some-client-x509-cert-url"
    }, "collection_id", limit="10")
  error: |-
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The error occurs because the `limit` parameter is expected to be an `Optional[int]`, but in the call to `main` at the end of the script, it is provided as a string (`limit="10"`). To fix this error, the `limit` should be passed as an integer (`limit=10`) or not provided at all, allowing it to default to `None`.
  id: |-
    hubfix_hub_356
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from firebase_admin import credentials, firestore, initialize_app
    from google.cloud.firestore_v1 import Client, CollectionReference, Query

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        order_by: Optional[str] = None,
        order_direction: str = "asc",
        start_at: Optional[str] = None,
        end_at: Optional[str] = None,
        limit: Optional[int] = None,
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['private_key_id'],
            "private_key": auth['private_key'],
            "client_email": auth['client_email'],
            "client_id": auth['client_id'],
            "auth_uri": auth['auth_uri'],
            "token_uri": auth['token_uri'],
            "auth_provider_x509_cert_url": auth['auth_provider_x509_cert_url'],
            "client_x509_cert_url": auth['client_x509_cert_url']
        })
        app = initialize_app(cred)
        store: Client = firestore.client(app)

        col_ref: CollectionReference = store.collection(collection_id)
        constraints = []

        if order_by:
            constraints.append(Query(col_ref).order_by(order_by, direction=order_direction))
        if start_at:
            constraints.append(Query(col_ref).start_at([start_at]))
        if end_at:
            constraints.append(Query(col_ref).end_at([end_at]))
        if limit:
            constraints.append(Query(col_ref).limit(limit))

        query_ref = col_ref
        for constraint in constraints:
            query_ref = constraint

        snapshot = query_ref.stream()
        list = [doc.to_dict() for doc in snapshot]

        return list
  original_instructions: |-
    List Documents in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- broken_code: |-
    from typing import TypedDict
    import telebot

    class slack_resource(TypedDict):
        api_key: str

    def secondary(auth: slack_resource, chat_id: str, message_id: str):
        client = telebot.TeleBot(auth['token'])
        return client.pin_chat_message(chat_identifier, message_identifier)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 9, in <module>
        secondary(...)
      File "script.py", line 7, in secondary
        client = telebot.TeleBot(auth['token'])
    KeyError: 'token'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict is renamed from `telegram` to `slack_resource`, and the field is changed from `token` to `api_key`. This will cause a KeyError when `auth['token']` is accessed because the key 'token' does not exist in the `auth` dictionary.

    2. The `main` function is renamed to `secondary`, which by itself is not an error, but if the expectation is to call `main`, this would break the code.

    3. The `message_id` parameter type is changed from `int` to `str`, which could cause an issue if the `pin_chat_message` method expects an integer.

    4. The variables `chat_identifier` and `message_identifier` are used in the `pin_chat_message` method call, but they are not defined anywhere in the code. This will raise a NameError.

    5. The `pin_chat_message` method is called with `chat_identifier` and `message_identifier` instead of `chat_id` and `message_id`. Even if the variables were correctly named, this would still be incorrect because `message_id` is now a string instead of an integer, which is likely the expected type for the `pin_chat_message` method.
  id: |-
    hubfix_hub_239
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import telebot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message_id: int):
        client = telebot.TeleBot(auth['token'])
        return client.pin_chat_message(chat_id, message_id)
  original_instructions: |-
    Pin a Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlib
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: int):
        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{nonexistentlib.utils.quote(room_id)}/state"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return resp.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlib`, which does not exist. Additionally, there are other issues:
    - The `room_id` parameter type has been changed from `str` to `int`, which could cause issues if the `requests.utils.quote` function expects a string.
    - The `matrix_res['baseURL']` is incorrect because the correct key is `baseUrl` (case-sensitive).
    - The `nonexistentlib.utils.quote(room_id)` will fail because `nonexistentlib` does not exist, and even if it did, it might not have a `utils.quote` method.
    - The return type of the function has been changed from a dictionary to a string (`resp.text`), which may not be the intended return type.
  id: |-
    hubfix_hub_160
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return {
            'events': resp.json(),
        }
  original_instructions: |-
    Get entire room state in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, spreadsheetId: str, sheetId: str):
        token = gsheets_auth["token"]

        DELETE_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            'requests': [
                {
                    'deleteSheet': {
                        'sheetId': sheetId,
                    },
                },
            ],
        }

        response = nonexistentlibrary.post(
            DELETE_WORKSHEET_URL,
            json=body,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module. Additionally, the function `broken_function` is trying to use `nonexistentlibrary.post`, which would also fail even if the import statement was corrected, because the correct library `requests` should be used instead.
  id: |-
    hubfix_hub_67
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, sheetId: int):
        token = gsheets_auth["token"]

        DELETE_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            'requests': [
                {
                    'deleteSheet': {
                        'sheetId': sheetId,
                    },
                },
            ],
        }

        response = requests.post(
            DELETE_WORKSHEET_URL,
            json=body,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            },
        )

        return response.text
  original_instructions: |-
    Delete Worksheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, messageId: str, newMessageContent: str):
        webhook_url = discord_webhook['webhook_url']
        edit_url = f"{webhook_url}/messages/{messageId}"
        payload = {
            "content": newMessageContent
        }
        headers = {
            "Content-Type": "application/json"
        }
        ret = nonexistentlibrary.post(edit_url, json=payload, headers=headers)
        return ret.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist in the Python standard library or in the list of installed third-party libraries. This causes a `ModuleNotFoundError` when Python cannot find the module to import. Additionally, the `requests.patch` method has been incorrectly changed to `nonexistentlibrary.post`, which would also cause an error if the import statement were correct, because `nonexistentlibrary` does not exist and therefore does not have a `post` method.
  id: |-
    hubfix_hub_132
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, messageId: str, newMessageContent: str):
        webhook_url = discord_webhook['webhook_url']
        edit_url = f"{webhook_url}/messages/{messageId}"
        payload = {
            "content": newMessageContent
        }
        headers = {
            "Content-Type": "application/json"
        }
        ret = requests.patch(edit_url, json=payload, headers=headers)
        return ret.json()
  original_instructions: |-
    Edit message in discord
  resource_type: |-
    discordwebhook
  resource_type_def: |-
    class discordwebhook(TypedDict):
        webhook_url: str
- broken_code: |-
    import json
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        api_key: str  # Changed from 'token' to 'api_key'

    def main(api_token: sendgrid, page_size: Optional[int] = None, page_token: Optional[int] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}"  # 'token' key does not exist in sendgrid TypedDict
        }
        params = {
            "page_size": page_size,
            "page_token": page_token
        }
        url = "https://api.sendgrid.com/v3/marketing/lists"

        response = nonexistentlibrary.post(url, headers=headers, params=params)  # 'post' method is called on a nonexistent library

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + json.dumps(response.json()))
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        import nonexistentlibrary  # This library does not exist
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The script attempts to import a library named `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError`.
    - The `sendgrid` TypedDict has been changed to have an `api_key` key instead of `token`, but the `main` function still tries to access `api_token['token']`, which will raise a `KeyError` because 'token' is no longer a valid key in the `sendgrid` TypedDict.
    - The `response` variable is assigned the result of calling `nonexistentlibrary.post(...)`, but since `nonexistentlibrary` does not exist, this will raise a `NameError`.
  id: |-
    hubfix_hub_223
  lang: |-
    python
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, page_size: Optional[int] = None, page_token: Optional[int] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}"
        }
        params = {
            "page_size": page_size,
            "page_token": page_token
        }
        url = "https://api.sendgrid.com/v3/marketing/lists"

        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + json.dumps(response.json()))
  original_instructions: |-
    Get Contact Lists in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- broken_code: |-
    from notion_client import Client
    from typing import List, TypedDict, Optional

    class slack_resource(TypedDict):
        token: str

    def main(auth: slack_resource, page_id: str, filter_properties: Optional[List[str]] = None):
        client = Client(auth=auth['api_key'])
        if not filter_properties or not any(filter_properties):
            filter_properties = None
        return client.pages.fetch({
            "page_id": page_id,
            "filter_properties": filter_properties,
        })
  error: |-
    KeyError: 'api_key'
  explanation: |-
    The code is trying to access a key 'api_key' in the 'auth' dictionary which does not exist. The correct key as per the original 'notion' TypedDict is 'token'. Additionally, the method 'fetch' is being called on 'client.pages', which is not a valid method in the notion-client library; the correct method is 'retrieve'. The TypedDict was also renamed from 'notion' to 'slack_resource', which is not an error by itself, but it could lead to confusion if the TypedDict is meant to represent authentication for the Notion API specifically.
  id: |-
    hubfix_hub_351
  lang: |-
    python
  original_code: |-
    from notion_client import Client
    from typing import List, TypedDict, Optional

    class notion(TypedDict):
        token: str

    def main(auth: notion, page_id: str, filter_properties: Optional[List[str]] = None):
        client = Client(auth=auth['token'])
        if not filter_properties or not any(filter_properties):
            filter_properties = None
        return client.pages.retrieve({
            "page_id": page_id,
            "filter_properties": filter_properties,
        })
  original_instructions: |-
    Retrieve Page in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional, List

    class zammad(TypedDict, total=False):
        zammad_host: str
        zammad_token: str
        user_agent: Optional[str]
        firstname: str
        lastname: str
        email: str
        login: Optional[str]
        organisation: Optional[str]
        roles: Optional[List[str]]

    def main(zammad_data: zammad):
        user_agent = zammad_data.get('user_agent', "Public windmill.dev script")
        headers = {
            'Authorization': f"Bearer {zammad_data['zammad_token']}",
            'User-Agent': user_agent,
        }
        payload = {
            'firstname': zammad_data['firstname'],
            'lastname': zammad_data['lastname'],
            'email': zammad_data['email'],
        }
        if 'login' in zammad_data:
            payload['login'] = zammad_data['login']
        if 'organisation' in zammad_data:
            payload['organisation'] = zammad_data['organisation']
        if 'roles' in zammad_data:
            payload['roles'] = zammad_data['roles']

        response = requests.post(f"{zammad_data['zammad_host']}/api/v1/users", headers=headers, json=payload)

        if not response.ok and response.status_code != 422:
            raise Exception(f"Failed to create user: Error HTTP{response.status_code}")

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name in the Python package index or the local environment.
  id: |-
    hubfix_hub_155
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional, List

    class zammad(TypedDict, total=False):
        zammad_host: str
        zammad_token: str
        user_agent: Optional[str]
        firstname: str
        lastname: str
        email: str
        login: Optional[str]
        organisation: Optional[str]
        roles: Optional[List[str]]

    def main(zammad_data: zammad):
        user_agent = zammad_data.get('user_agent', "Public windmill.dev script")
        headers = {
            'Authorization': f"Bearer {zammad_data['zammad_token']}",
            'User-Agent': user_agent,
        }
        payload = {
            'firstname': zammad_data['firstname'],
            'lastname': zammad_data['lastname'],
            'email': zammad_data['email'],
        }
        if 'login' in zammad_data:
            payload['login'] = zammad_data['login']
        if 'organisation' in zammad_data:
            payload['organisation'] = zammad_data['organisation']
        if 'roles' in zammad_data:
            payload['roles'] = zammad_data['roles']

        response = requests.post(f"{zammad_data['zammad_host']}/api/v1/users", headers=headers, json=payload)

        if not response.ok and response.status_code != 422:
            raise Exception(f"Failed to create user: Error HTTP{response.status_code}")

        return response.json()
  original_instructions: |-
    Create user in zammad
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from appwrite.client import Client
    from appwrite.services.databases import Databases
    from typing import TypedDict

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, document_id: str):
        client = Client()
        client.set_endpoint(auth['end_point'])  # Incorrect key
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)
        return db.delete_document(database_id, collection_id, document_id, "extra_argument")  # Extra argument
  error: |-
    KeyError: 'end_point'

    TypeError: delete_document() takes 4 positional arguments but 5 were given
  explanation: |-
    The code is broken because of two reasons:

    1. The dictionary key 'end_point' does not exist in the 'auth' TypedDict. The correct key is 'endpoint'.
    2. An extra argument "extra_argument" is passed to the `delete_document` method, which only accepts 4 positional arguments.
  id: |-
    hubfix_hub_338
  lang: |-
    python
  original_code: |-
    from appwrite.client import Client
    from appwrite.services.databases import Databases
    from typing import TypedDict

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, document_id: str):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)
        return db.delete_document(database_id, collection_id, document_id)
  original_instructions: |-
    Delete Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import bcrypt

    def broken_function(password: int) -> int:
        salt = bcrypt.gensalt()
        hash_pass = bcrypt.hashpw(password, salt)
        return hash_pass
  error: |-
    TypeError: a bytes-like object is required, not 'int'
  explanation: |-
    The code is broken because of the following reasons:
    - The `password` parameter type has been changed from `str` to `int`, which is incorrect because `bcrypt.hashpw` expects a bytes-like object, which can be obtained by encoding a string, not an integer.
    - The `hash_pass` is returned as a bytes object, but the return type of the function is declared as `int`, which is incorrect. The `hash_pass` should be decoded to a string before returning if the return type is meant to be a string.
    - The `main` function has been renamed to `broken_function`, which by itself does not cause a runtime error but would cause an issue if another part of the code expects a function named `main`.
  id: |-
    hubfix_hub_86
  lang: |-
    python
  original_code: |-
    import bcrypt

    def main(password: str) -> str:
        salt = bcrypt.gensalt()
        hash_pass = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hash_pass.decode('utf-8')
  original_instructions: |-
    Hash Password with Random Salt in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Any, Optional, Dict

    class surrealdb(TypedDict):
        url: str
        token: str

    def broken_function(auth: surrealdb, namespace: str, database: str, query: str, variables: Optional[Dict[str, Any]] = None) -> Any:
        headers = {
            'Authorization': f'Bearer {auth["token"]}',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        }
        use_query = f'USE {namespace}::{database};'
        full_query = use_query + query
        payload = {'query': full_query}
        if variables:
            payload['variables'] = variables
        response = nonexistentlibrary.post(auth['url'], json=payload, headers=headers)
        if response.status_code != 200:
            raise Exception(f"Error: {response.text}")
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `requests.post` has been incorrectly replaced with `nonexistentlibrary.post`, which would also cause an error if the import statement did not already break the script.
  id: |-
    hubfix_hub_319
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Any, Optional, Dict

    class surrealdb(TypedDict):
        url: str
        token: str

    def main(auth: surrealdb, namespace: str, database: str, query: str, variables: Optional[Dict[str, Any]] = None) -> Any:
        headers = {
            'Authorization': f'Bearer {auth["token"]}',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        }
        use_query = f'USE {namespace}::{database};'
        full_query = use_query + query
        payload = {'query': full_query}
        if variables:
            payload['variables'] = variables
        response = requests.post(auth['url'], json=payload, headers=headers)
        if response.status_code != 200:
            raise Exception(f"Error: {response.text}")
        return response.json()
  original_instructions: |-
    Run Arbitrary Query in surrealdb
  resource_type: |-
    surrealdb
  resource_type_def: |-
    class surrealdb(TypedDict):
        url: str
        token: str
- broken_code: |-
    from typing import TypedDict
    import telebot

    class telegram_resource(TypedDict):
        api_key: str

    def start(auth: telegram_resource, chat_id: str, message_id: str):
        client = telebot.TeleBot(auth['token'])
        return client.remove_chat_message(chat_id, message_id)
  error: |-
    AttributeError: 'TeleBot' object has no attribute 'remove_chat_message'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict class name was changed from `telegram` to `telegram_resource`, which is not used anywhere else in the code.
    2. The `auth` parameter in the `start` function is expecting a `telegram_resource` TypedDict, but the code is trying to access `auth['token']`, which does not exist in the `telegram_resource` TypedDict (it has `api_key` instead).
    3. The `message_id` parameter type was changed from `int` to `str`, which may not be compatible with the `unpin_chat_message` method that expects an integer message ID.
    4. The function name was changed from `main` to `start`, which by itself is not an error but could be a problem if the function is expected to be named `main` elsewhere in the code.
    5. The method `remove_chat_message` does not exist in the `telebot.TeleBot` class. The correct method name is `unpin_chat_message`.
    6. The return type of the function is not specified, and it was mentioned in the original script that it could be changed as a breaking change, but without knowing the expected return type, this cannot be confirmed as an error.
  id: |-
    hubfix_hub_240
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import telebot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, message_id: int):
        client = telebot.TeleBot(auth['token'])
        return client.unpin_chat_message(chat_id, message_id)
  original_instructions: |-
    Unpin a Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room: str) -> None:
        if not matrix_res['access_token']:
            raise ValueError("Joining a room requires an access token.")

        url = f"{matrix_res['baseURL']}/_matrix/client/v3/join/{nonexistentlibrary.utils.quote(room)}"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        resp = nonexistentlibrary.post(url, headers=headers)

        if not resp.ok:
            raise ValueError(f"Failed to join room: Error HTTP{resp.status_code}")
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a module named `nonexistentlibrary`, which does not exist in the Python standard library or as a third-party package. This causes a `ModuleNotFoundError` when Python cannot find the module to import. Additionally, the code references `nonexistentlibrary.utils.quote(room)` and `nonexistentlibrary.post(url, headers=headers)`, which would also fail even if the import statement was corrected, because `requests` should be used instead of `nonexistentlibrary`. Furthermore, `matrix_res['access_token']` and `matrix_res['baseURL']` are incorrect keys for the `matrix` TypedDict, which defines `baseUrl` and `token` as the correct keys.
  id: |-
    hubfix_hub_97
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room: str):
        if not matrix_res['token']:
            raise ValueError("Joining a room requires an access token.")

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/join/{requests.utils.quote(room)}"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        resp = requests.post(url, headers=headers)

        if not resp.ok:
            raise ValueError(f"Failed to join room: Error HTTP{resp.status_code}")
  original_instructions: |-
    Join room in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlib
    from typing import TypedDict, Optional

    class windmill(TypedDict):
        workspace: str
        id: str
        requestBody: dict

    def get_workspace() -> str:
        return "your_workspace"

    def main(id: int, resume_payload: Optional[dict] = None) -> list:
        resume_payload = resume_payload or {}
        job_service_url = "https://api.windmill.com/v1/resumeSuspendedFlowAsOwner"

        payload: windmill = {
            "workspace": get_workspace(),
            "id": id,
            "requestBody": resume_payload,
        }

        response = nonexistentlib.post(job_service_url, json=payload)
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library named `nonexistentlib`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the `main` function's `id` parameter type has been changed from `str` to `int`, which is inconsistent with the `windmill` TypedDict definition where `id` is expected to be a `str`. The return type of the `main` function has also been changed from `dict` to `list`, which is not consistent with the original function's behavior of returning a dictionary. Lastly, the `requests` library function call has been replaced with `nonexistentlib.post`, which does not exist and would cause a runtime error if the import error was ignored.
  id: |-
    hubfix_hub_271
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class windmill(TypedDict):
        workspace: str
        id: str
        requestBody: dict

    def get_workspace() -> str:
        # Placeholder for the actual implementation to get the workspace
        return "your_workspace"

    def main(id: str, resume_payload: Optional[dict] = None) -> dict:
        resume_payload = resume_payload or {}
        job_service_url = "https://api.windmill.com/v1/resumeSuspendedFlowAsOwner"

        payload: windmill = {
            "workspace": get_workspace(),
            "id": id,
            "requestBody": resume_payload,
        }

        response = requests.post(job_service_url, json=payload)
        return response.json()
  original_instructions: |-
    Resume Suspended Flow as Owner in windmill
  resource_type: |-
    windmill
  resource_type_def: |-
    class windmill(TypedDict):
        workspace: str
        id: str
        requestBody: dict
- broken_code: |-
    from notion_client import Client
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str

    def secondary(auth: slack_resource, block_id: str):
        client = Client(auth=auth['token'])
        return client.blocks.fetch(block_id=block_id)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        return client.blocks.fetch(block_id=block_id)
    AttributeError: 'BlockEndpoint' object has no attribute 'fetch'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` was renamed from `notion` to `slack_resource`, which is not used anywhere in the code.
    2. The `token` field in the `TypedDict` was changed to `api_key`, which does not match the key used in the `auth` dictionary within the `secondary` function.
    3. The `main` function was renamed to `secondary`, which by itself is not an error, but if the script relies on a function named `main`, this would cause an issue.
    4. The method `client.blocks.fetch` does not exist in the `notion_client` library. The correct method is `client.blocks.retrieve`.
    5. The script is trying to access a non-existent property `token` of the `auth` dictionary since the `TypedDict` now has `api_key` instead.

    If this code were part of a larger application expecting a `main` function and a `notion` TypedDict, the renaming would cause additional issues beyond the scope of the provided script.
  id: |-
    hubfix_hub_352
  lang: |-
    python
  original_code: |-
    from notion_client import Client
    from typing import TypedDict

    class notion(TypedDict):
        token: str

    def main(auth: notion, block_id: str):
        client = Client(auth=auth['token'])
        return client.blocks.retrieve(block_id=block_id)
  original_instructions: |-
    Retrieve Block in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    import telebot  # Assuming pyTelegramBotAPI package is installed

    class telegram(TypedDict):
        api_key: str

    def main(auth: telegram, chat_id: str, user_id: int, until_date: Optional[int] = None, revoke_messages: Optional[bool] = None):
        client = telebot.TeleBot(auth['token'])
        if revoke_messages is None:
            revoke_messages = False
        return client.expel_chat_member(chat_id, user_id, until_when=until_date, remove_messages=revoke_messages)
  error: |-
    AttributeError: 'TeleBot' object has no attribute 'expel_chat_member'
  explanation: |-
    The code is broken because the method `expel_chat_member` does not exist in the `telebot` library. The correct method name should be `kick_chat_member`. Additionally, the parameters `until_when` and `remove_messages` are incorrect; they should be `until_date` and `revoke_messages` respectively. Furthermore, the `TypedDict` named `telegram` has a key `api_key` instead of `token`, which will cause a KeyError when `auth['token']` is accessed because the key `token` does not exist in the `auth` dictionary.
  id: |-
    hubfix_hub_238
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    import telebot  # You might need to install pyTelegramBotAPI package (`pip install pyTelegramBotAPI`)

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str, user_id: int, until_date: Optional[int] = None, revoke_messages: Optional[bool] = None):
        client = telebot.TeleBot(auth['token'])
        if revoke_messages is None:
            revoke_messages = False
        return client.kick_chat_member(chat_id, user_id, until_date=until_date, revoke_messages=revoke_messages)
  original_instructions: |-
    Kick a Chat Member in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, spreadsheetId: str, sheetId: str):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheetId,
                        },
                        "fields": "userEnteredValue",
                    },
                },
            ],
        }

        response = nonexistentlibrary.post(
            ADD_WORKSHEET_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the `sheetId` parameter type in the function signature has been changed from `int` to `str`, which could cause issues if the API expects an integer. The function name has also been changed from `main` to `broken_function`, which would cause an error if code elsewhere expects a function named `main`. Lastly, the `requests.post` method has been replaced with `nonexistentlibrary.post`, which will fail because `nonexistentlibrary` does not exist and therefore does not have a `post` method.
  id: |-
    hubfix_hub_66
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, sheetId: int):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheetId,
                        },
                        "fields": "userEnteredValue",
                    },
                },
            ],
        }

        response = requests.post(
            ADD_WORKSHEET_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Clear All Values in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional, Union, Any, Dict
    import nonexistentlibrary  # This import will fail

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        return action()

    def main(
        auth: supabase,
        table: str,
        filter: Dict[str, Any],
        return_deleted: bool = False,
        token: Optional[Dict[str, Union[str, int]]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            params = {
                'select': '*' if return_deleted else '',
                'filter': f"{filter['column']}.{filter['operator']}.{filter['value']}"
            }
            if count:
                params['count'] = count

            response = requests.delete(f"{auth['url']}/{table}", headers=headers, params=params)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. To fix this error, you would need to remove the import statement for `nonexistentlibrary` or replace it with a valid library name.
  id: |-
    hubfix_hub_285
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, Union, Any, Dict
    import requests

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        # This is a placeholder for the refreshAndRetryIfExpired logic.
        # In a real-world scenario, you would implement token refresh logic here.
        # For the purpose of this example, we'll assume the token is valid and directly call the action.
        return action()

    def main(
        auth: supabase,
        table: str,
        filter: Dict[str, Any],
        return_deleted: bool = False,
        token: Optional[Dict[str, Union[str, int]]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            params = {
                'select': '*' if return_deleted else '',
                'filter': f"{filter['column']}.{filter['operator']}.{filter['value']}"
            }
            if count:
                params['count'] = count

            response = requests.delete(f"{auth['url']}/{table}", headers=headers, params=params)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  original_instructions: |-
    Delete data in supabase
  resource_type: |-
    supabase
  resource_type_def: |-
    class supabase(TypedDict):
        url: str
        key: str
- broken_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: str,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
        collection_enabled: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        return db.update_collection(
            database_id=database_id,
            collection_id=collection_id,
            name=collection_name,
            permissions=collection_permissions,
            document_security=collection_document_security,
            enabled=collection_enabled,
            extra_param=123,  # This parameter doesn't exist
        )
  error: |-
    TypeError: update_collection() got an unexpected keyword argument 'extra_param'
  explanation: |-
    The `update_collection` method of the `Databases` class is called with a parameter `extra_param` that does not exist in the method's signature. This results in a `TypeError` because the function does not expect an argument with that name.
  id: |-
    hubfix_hub_332
  lang: |-
    python
  original_code: |-
    from typing import List, Optional, TypedDict
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_name: str,
        collection_id: str,
        collection_permissions: Optional[List[str]] = None,
        collection_document_security: Optional[bool] = None,
        collection_enabled: Optional[bool] = None,
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        return db.update_collection(
            database_id=database_id,
            collection_id=collection_id,
            name=collection_name,
            permissions=collection_permissions,
            document_security=collection_document_security,
            enabled=collection_enabled,
        )
  original_instructions: |-
    Update Collection in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import nonexistentlibrary

    def main(min: int = 0, max: str = "100") -> int:
        return random.randint(min, max)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, the `max` parameter is given a string default value "100", but `random.randint` expects an integer, not a string, which would cause a TypeError if the import statement did not already cause the script to fail.
  id: |-
    hubfix_hub_101
  lang: |-
    python
  original_code: |-
    import random

    def main(min: int = 0, max: int = 100) -> int:
        return random.randint(min, max)
  original_instructions: |-
    Random Integer in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Mapping

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Mapping[str, Any],
        document: Mapping[str, Any],
        upsert: bool = False
    ):
        client = MongoClient(auth['end_point'])  # Note the underscore
        db = client[database]
        coll = db[collection]
        upsert_option = upsert
        return coll.update_one(filter, {'$set': document}, upsert=upsert_option)
  error: |-
    Traceback (most recent call last):
      File "script.py", line XX, in <module>
        main(...)
      File "script.py", line YY, in main
        client = MongoClient(auth['end_point'])
    KeyError: 'end_point'
  explanation: |-
    The code is trying to access a key 'end_point' in the 'auth' dictionary, which does not exist. The correct key as defined in the 'mongodbrest' TypedDict is 'endpoint' without the underscore. This results in a KeyError because the dictionary does not contain the incorrect key 'end_point'.
  id: |-
    hubfix_hub_261
  lang: |-
    python
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Mapping

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Mapping[str, Any],
        document: Mapping[str, Any],
        upsert: bool = False
    ):
        client = MongoClient(auth['endpoint'])
        db = client[database]
        coll = db[collection]
        upsert_option = upsert
        return coll.update_one(filter, {'$set': document}, upsert=upsert_option)
  original_instructions: |-
    Update a Document in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    import json
    from typing import TypedDict
    from nacl.signing import VerifyKey
    from nacl.exceptions import BadSignatureError

    class discordbotconfiguration(TypedDict):
        public_key: str
        application_id: str

    class InteractionType:
        PING = 1
        APPLICATION_COMMAND = 2

    class InteractionResponseType:
        PONG = 1
        CHANNEL_MESSAGE_WITH_SOURCE = 4

    def main(x_signature_ed25519: str, x_signature_timestamp: str, raw_string: str, discord_config: discordbotconfiguration):
        try:
            verify_key = VerifyKey(bytes.fromhex(discord_config['public_key']))
            verify_key.verify(f'{x_signature_timestamp}{raw_string}'.encode(), bytes.fromhex(x_signature_ed25519))
        except BadSignatureError:
            return {'windmill_status_code': 401}

        interaction = json.loads(raw_string)

        if interaction['type'] == InteractionType.PING:
            return {'type': InteractionResponseType.PONG}

        if interaction['type'] == InteractionType.APPLICATION_COMMAND:
            message = f"Received command: ```json\n{json.dumps({'id': interaction['id'], 'sender': interaction.get('member', {}).get('user'), 'data': interaction['data']}, indent=2)}\n```"
            return {
                'type': InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                'data': {
                    'content': message,
                },
            }

        return json.parse({'type': InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE})
  error: |-
    Traceback (most recent call last):
      File "script.py", line 37, in <module>
        main(...)
      File "script.py", line 35, in main
        return json.parse({'type': InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE})
    AttributeError: module 'json' has no attribute 'parse'
  explanation: |-
    The code is broken because the `json` module in Python does not have a `parse` method. The correct method to use for parsing a JSON string is `json.loads`. The `json.parse` method does not exist, which is why the AttributeError is raised. To fix the code, replace `json.parse` with `json.dumps` if the intention is to convert a Python dictionary to a JSON-formatted string, or remove that line if it's not needed.
  id: |-
    hubfix_hub_377
  lang: |-
    python
  original_code: |-
    import json
    from typing import TypedDict
    from nacl.signing import VerifyKey
    from nacl.exceptions import BadSignatureError

    # Define the TypedDict for the Discord bot configuration
    class discordbotconfiguration(TypedDict):
        public_key: str
        application_id: str

    # Define the InteractionType and InteractionResponseType enums
    class InteractionType:
        PING = 1
        APPLICATION_COMMAND = 2

    class InteractionResponseType:
        PONG = 1
        CHANNEL_MESSAGE_WITH_SOURCE = 4

    def main(x_signature_ed25519: str, x_signature_timestamp: str, raw_string: str, discord_config: discordbotconfiguration):
        # Verify the request signature
        try:
            verify_key = VerifyKey(bytes.fromhex(discord_config['public_key']))
            verify_key.verify(f'{x_signature_timestamp}{raw_string}'.encode(), bytes.fromhex(x_signature_ed25519))
        except BadSignatureError:
            return {'windmill_status_code': 401}

        interaction = json.loads(raw_string)

        # Respond to a PING interaction
        if interaction['type'] == InteractionType.PING:
            return {'type': InteractionResponseType.PONG}

        # Handle an APPLICATION_COMMAND interaction
        if interaction['type'] == InteractionType.APPLICATION_COMMAND:
            message = f"Received command: ```json\n{json.dumps({'id': interaction['id'], 'sender': interaction.get('member', {}).get('user'), 'data': interaction['data']}, indent=2)}\n```"
            return {
                'type': InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                'data': {
                    'content': message,
                },
            }
  original_instructions: |-
    Receive Application Command Sample in discord
  resource_type: |-
    discordbotconfiguration
  resource_type_def: |-
    class discordbotconfiguration(TypedDict):
        public_key: str
        application_id: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def broken_function(gdrive_auth: gdrive, fileId: str):
        supportsAllDrives = True
        COPY_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/copy/?supportsAllDrives={supportsAllDrives}"

        token = gdrive_auth["token"]

        response = nonexistentlibrary.post(
            COPY_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `nonexistentlibrary.post` is called, which would also break the code because `nonexistentlibrary` does not exist, and even if it did, it might not have a `post` method.
  id: |-
    hubfix_hub_57
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        supportsAllDrives = True
        COPY_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/copy/?supportsAllDrives={supportsAllDrives}"

        token = gdrive_auth["token"]

        response = requests.post(
            COPY_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Copy File in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    import psycopg2
    import psycopg2.extras
    import non_existent_library  # This library does not exist

    class postgresql(TypedDict):
        host: str
        port: str  # This should be an int, not a str
        user: str
        dbname: str
        sslmode: str
        password: str

    class Cacertificate(TypedDict):
        certificate: str

    def main(db_config: postgresql, cacertificate: Cacertificate, sql: str = "SELECT 1 as id"):
        connection = psycopg2.connect(
            host=db_config['host'],
            port=db_config['port'],  # This will cause an error because port should be an int
            user=db_config['user'],
            dbname=db_config['dbname'],
            password=db_config['password'],
            sslmode=db_config['sslmode'],
            sslrootcert=cacertificate['certificate']
        )

        cursor = connection.cursor(cursor_factory=psycopg2.extras.DictCursor)
        cursor.execute(sql)
        rows = cursor.fetchall()
        cursor.close()
        connection.close()

        return [dict(row) for row in rows]

    main()  # This will cause an error because the required arguments are not provided
  error: |-
    Traceback (most recent call last):
      File "script.py", line 26, in <module>
        main()  # This will cause an error because the required arguments are not provided
    TypeError: main() missing 2 required positional arguments: 'db_config' and 'cacertificate'
  explanation: |-
    The code is broken for several reasons:

    1. The import statement `import non_existent_library` is trying to import a library that does not exist, which will raise an `ImportError`.
    2. The `postgresql` TypedDict has been modified so that the `port` field is now a string (`port: str`) instead of an integer. This will cause a type error when the `psycopg2.connect` function is called because it expects an integer for the port.
    3. The `main` function is called without any arguments, but it requires two positional arguments (`db_config` and `cacertificate`). This will raise a `TypeError` because the required arguments are not provided.
  id: |-
    hubfix_hub_366
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import psycopg2
    import psycopg2.extras

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    class Cacertificate(TypedDict):
        certificate: str

    def main(db_config: postgresql, cacertificate: Cacertificate, sql: str = "SELECT 1 as id"):
        connection = psycopg2.connect(
            host=db_config['host'],
            port=db_config['port'],
            user=db_config['user'],
            dbname=db_config['dbname'],
            password=db_config['password'],
            sslmode=db_config['sslmode'],
            sslrootcert=cacertificate['certificate']
        )

        cursor = connection.cursor(cursor_factory=psycopg2.extras.DictCursor)
        cursor.execute(sql)
        rows = cursor.fetchall()
        cursor.close()
        connection.close()

        return [dict(row) for row in rows]
  original_instructions: |-
    Postgres with TLS  / SSL  in postgresql
  resource_type: |-
    postgresql
  resource_type_def: |-
    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        token: str

    def broken_function(slack_auth: slack):
        q = ""
        SEARCH_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/?q={q}"

        token = slack_auth["access_token"]

        response = nonexistentlibrary.post(
            SEARCH_SHARED_DRIVE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `gdrive` to `slack_resource`, but the function parameter type is still `slack`, which is not defined.
    3. Inside the function, `slack_auth["access_token"]` is used, but `access_token` is not a property of the `TypedDict` (which should be `slack_resource` with a `token` property).
    4. The function `nonexistentlibrary.post` is called, but `nonexistentlibrary` does not exist, which would raise a `NameError` if the import error was not raised first.
    5. The function is renamed from `main` to `broken_function`, which in itself is not an error, but if the script relies on a function named `main`, this would cause an issue.
    6. The return statement uses `response.text`, but the original code used `response.json()`. If `nonexistentlibrary.post` was supposed to mimic `requests.post`, then `response.text` would return the raw response content, not parsed JSON.
  id: |-
    hubfix_hub_61
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive):
        q = ""
        SEARCH_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/?q={q}"

        token = gdrive_auth["token"]

        response = requests.get(
            SEARCH_SHARED_DRIVE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Search Shared Drives in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.users import Users

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: Optional[str] = None, email: Optional[str] = None,
             phone: Optional[str] = None, password: Optional[str] = None,
             name: Optional[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        users = Users(client)

        user_id = id if id is not None else unique()
        return users.create(user_id, email, password, name, phone)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 23, in <module>
        main({...})
      File "script.py", line 21, in main
        user_id = id if id is not None else unique()
    NameError: name 'unique' is not defined
  explanation: |-
    The code is broken because the function `unique()` is called without being defined or imported. In the original code, 'unique()' was a placeholder string, but in the broken code, it is incorrectly used as a function call. Additionally, the `users.create` method is called with an extra `phone` parameter that does not exist in the original method signature.
  id: |-
    hubfix_hub_323
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.users import Users

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, id: Optional[str] = None, email: Optional[str] = None,
             phone: Optional[str] = None, password: Optional[str] = None,
             name: Optional[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        users = Users(client)

        user_id = id if id is not None else 'unique()'
        return users.create(user_id, email, password, name)
  original_instructions: |-
    Create User in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class http(TypedDict):
        response: str

    def main(url: str, request_type: str) -> http:
        resp = nonexistentlibrary.request(request_type, url)
        return {'response': resp.text}
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library called `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the `main` function tries to use a method `request` from this non-existent library, which would also cause an error if the import statement did not already cause the script to fail.
  id: |-
    hubfix_hub_26
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        response: str

    def main(url: str, request_type: str) -> http:
        resp = requests.request(request_type, url)
        return {'response': resp.text}
  original_instructions: |-
    Send any HTTP Request in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        response: str
- broken_code: |-
    from typing import TypedDict, Optional, Dict
    from pymongo import MongoClient
    from bson import ObjectId

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def remove_empty_fields(d: Dict):
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document_id: str, projection: Optional[Dict[str, int]] = None):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        projection = remove_empty_fields(projection) if projection else None
        return coll.find_unicorn({'_id': ObjectId(document_id)}, projection)
  error: |-
    AttributeError: 'Collection' object has no attribute 'find_unicorn'
  explanation: |-
    The code is trying to call a method `find_unicorn` on the `coll` object, which is an instance of `pymongo.collection.Collection`. However, the `Collection` class does not have a method named `find_unicorn`. The correct method to call for finding a single document by its ID is `find_one`.
  id: |-
    hubfix_hub_255
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, Dict
    from pymongo import MongoClient
    from bson import ObjectId

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def remove_empty_fields(d: Dict):
        return {k: v for k, v in d.items() if v is not None}

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document_id: str, projection: Optional[Dict[str, int]] = None):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        projection = remove_empty_fields(projection) if projection else None
        return coll.find_one({'_id': ObjectId(document_id)}, projection)
  original_instructions: |-
    Find Document by Id in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    import base64
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict

    class slack_resource(TypedDict):  # Changed the name of the TypedDict
        token: str

    def main(image: str, channel: str, slack: slack_resource, imagename: str = "image.png"):
        decoded_image = base64.b64decode(image)
        files = {
            'file': (imagename, decoded_image, 'image/png'),
        }
        payload = {
            'token': slack['api_key'],  # Changed the key to a non-existent one
            'channels': channel,
            'filename': imagename,
            'filetype': 'auto'
        }
        response = requests.post("https://slack.com/api/files.upload", params=payload, files=files)
        return response.text  # Changed the return type to text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError` when Python tries to import it. Additionally, the TypedDict name was changed from `slack` to `slack_resource`, which would cause a type error if the `slack` parameter was passed to the `main` function as it expects a `slack_resource` now. The key `'api_key'` is also used instead of `'token'` in the `payload` dictionary, which would cause a KeyError if the `slack` dictionary does not contain an `'api_key'` key. Lastly, the function returns `response.text` instead of `response.json()`, which is not necessarily an error but changes the return type from JSON to plain text.
  id: |-
    hubfix_hub_110
  lang: |-
    python
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class slack(TypedDict):
        token: str

    def main(image: str, channel: str, slack: slack, imagename: str = "image.png"):
        decoded_image = base64.b64decode(image)
        files = {
            'file': (imagename, decoded_image, 'image/png'),
        }
        payload = {
            'token': slack['token'],
            'channels': channel,
            'filename': imagename,
            'filetype': 'auto'
        }
        response = requests.post("https://slack.com/api/files.upload", params=payload, files=files)
        return response.json()
  original_instructions: |-
    Send an image to channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlib
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def broken_function(gcal_auth: gcal, calendarId: str, eventText: str):
        sendUpdates = "all"
        QUICK_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/quickAdd/?text={eventText}&sendUpdates={sendUpdates}"
        token = gcal_auth["access_token"]

        response = nonexistentlib.post(
            QUICK_EVENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        result = response.json()
        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlib`, which does not exist. Additionally, the function `main` has been renamed to `broken_function`, which would cause an error if another part of the program expects a function named `main`. Furthermore, the `gcal_auth` TypedDict is accessed with a key `"access_token"` which does not exist in the defined TypedDict; it should be `"token"`. Lastly, the `requests.post` method has been replaced with `nonexistentlib.post`, which is invalid because `nonexistentlib` does not exist and therefore does not have a `post` method.
  id: |-
    hubfix_hub_46
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, eventText: str):
        sendUpdates = "all"
        QUICK_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/quickAdd/?text={eventText}&sendUpdates={sendUpdates}"
        token = gcal_auth["token"]

        response = requests.post(
            QUICK_EVENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        result = response.json()
        return result
  original_instructions: |-
    Create Quick Event in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from slack_sdk import WebClient

    class slack_resource(TypedDict):  # Changed the class name from 'slack' to 'slack_resource'
        token: str

    def main(slack_auth: slack, file: str, count: Optional[int] = None, page: Optional[int] = None):  # The type hint still refers to 'slack'
        web = WebClient(token=slack_auth['api_key'])  # Changed 'token' to 'api_key'

        response = web.file_info(  # Changed 'files_info' to 'file_info'
            file=file,
            count=count,
            page=page
        )

        return response  # Changed the return type
  error: |-
    TypeError: TypedDict "slack" has no key 'api_key'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict class name was changed from `slack` to `slack_resource`, but the type hint in the `main` function parameter `slack_auth` still refers to the old name `slack`. This will cause a type hint error because `slack` is no longer defined.

    2. Inside the `main` function, `slack_auth['api_key']` is used, but the `slack_resource` TypedDict only defines a key `token`. This will result in a KeyError because 'api_key' does not exist in the TypedDict.

    3. The method `web.files_info` was incorrectly changed to `web.file_info`. If `file_info` is not a valid method of the `WebClient` class, this will result in an AttributeError.

    4. The return statement was changed from returning a dictionary to returning the `response` directly. If the expected return type is a dictionary with a key 'response', this change will break the expected return type contract.
  id: |-
    hubfix_hub_16
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, file: str, count: Optional[int] = None, page: Optional[int] = None):
        web = WebClient(token=slack_auth['token'])

        response = web.files_info(
            file=file,
            count=count,
            page=page
        )

        return {'response': response}
  original_instructions: |-
    Get File in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class stripe_resource(TypedDict):
        api_key: str

    def stripe_cancel(stripe_con: stripe_resource, cancel_id: int):
        STRIPE_CANCEL_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{cancel_id}/cancel'

        api_key = stripe_con["token"]

        response = nonexistentlibrary.post(
            STRIPE_CANCEL_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + api_key,
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The `import nonexistentlibrary` statement is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    - The `stripe_resource` TypedDict is defined with an `api_key` field, but the function tries to access a non-existent `token` field from `stripe_con`.
    - The `stripe_cancel` function is expecting an `int` for `cancel_id`, but the Stripe API expects a string ID for the payout.
    - The `nonexistentlibrary.post` call is using a library (`nonexistentlibrary`) that doesn't exist, which would raise a `NameError` if the code execution reached this point.
    - The function `stripe_cancel` is returning `response.text`, but the original function was expected to return `response.json()`. This change doesn't necessarily "break" the code, but it changes the return type, which could lead to issues if the calling code expects a JSON response.
  id: |-
    hubfix_hub_117
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, cancel_id: str):
        STRIPE_CANCEL_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{cancel_id}/cancel'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_CANCEL_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Cancel a Payment Intent in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import List, TypedDict, Optional

    class slack_resource(TypedDict):
        api_key: str
        server: str

    def broken_function(auth: slack_resource, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        base_url = f"https://{auth['server_resource']}.api.mailchimp.com/3.0/reports/{campaign_id}"
        params = {}
        if fields:
            params['fields'] = ','.join(fields)
        if exclude_fields:
            params['exclude_fields'] = ','.join(exclude_fields)

        response = nonexistentlibrary.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if response.status_code != 200:
            raise Exception(response.text)

        return response.wrong_method()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `mailchimp` to `slack_resource`, but the function still expects the original `mailchimp` TypedDict.
    3. The function `broken_function` is trying to access a non-existent property `server_resource` of the `auth` TypedDict.
    4. The function `broken_function` is calling `nonexistentlibrary.get`, which does not exist because the library `nonexistentlibrary` was not found.
    5. The function `broken_function` is trying to call a non-existent method `wrong_method()` on the `response` object.
  id: |-
    hubfix_hub_206
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        base_url = f"https://{auth['server']}.api.mailchimp.com/3.0/reports/{campaign_id}"
        params = {}
        if fields:
            params['fields'] = ','.join(fields)
        if exclude_fields:
            params['exclude_fields'] = ','.join(exclude_fields)

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if response.status_code != 200:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Get A Campaign Report in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    from typing import TypedDict, Dict, Any, Optional, List
    import nonexistentlibrary  # This library does not exist
    from uuid import uuid4

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def broken_function(  # Renamed the function from 'main' to 'broken_function'
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_data: Dict[str, Any],
        document_id: Optional[str] = None,
        document_permissions: Optional[List[str]] = None
    ):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
            'content-type': 'application/json'
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings()

        document_id = document_id or str(uuid4())
        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents"

        data = {
            'documentId': document_id,
            'data': document_data
        }

        if document_permissions:
            data['permissions'] = document_permissions

        response = requests.post(url, json=data, headers=headers, verify=not auth['self_signed'])
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the main function has been renamed to `broken_function`, which would cause an issue if other parts of the code expect a function named `main`.
  id: |-
    hubfix_hub_334
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Dict, Any, Optional, List
    import requests
    from uuid import uuid4

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_data: Dict[str, Any],
        document_id: Optional[str] = None,
        document_permissions: Optional[List[str]] = None
    ):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
            'content-type': 'application/json'
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings()

        document_id = document_id or str(uuid4())
        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents"

        data = {
            'documentId': document_id,
            'data': document_data
        }

        if document_permissions:
            data['permissions'] = document_permissions

        response = requests.post(url, json=data, headers=headers, verify=not auth['self_signed'])
        return response.json()
  original_instructions: |-
    Create Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, spreadsheetId: str, title: str):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            "requests": [
                {
                    "addSheet": {
                        "properties": {
                            "title": title,
                            "gridProperties": {
                                "rowCount": 20,
                                "columnCount": 12
                            },
                            "tabColor": {
                                "red": 1.0,
                                "green": 0.3,
                                "blue": 0.4
                            }
                        }
                    }
                }
            ]
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = nonexistentlibrary.post(ADD_WORKSHEET_URL, json=body, headers=headers)

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `nonexistentlibrary.post` is called, which would also break the code because `nonexistentlibrary` does not exist, and even if it did, it might not have a `post` method. The function name has also been changed from `main` to `broken_function`, which could cause issues if other parts of the code expect a function named `main`.
  id: |-
    hubfix_hub_65
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, title: str):
        token = gsheets_auth["token"]

        ADD_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate'

        body = {
            "requests": [
                {
                    "addSheet": {
                        "properties": {
                            "title": title,
                            "gridProperties": {
                                "rowCount": 20,
                                "columnCount": 12
                            },
                            "tabColor": {
                                "red": 1.0,
                                "green": 0.3,
                                "blue": 0.4
                            }
                        }
                    }
                }
            ]
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.post(ADD_WORKSHEET_URL, json=body, headers=headers)

        return response.text
  original_instructions: |-
    Create Worksheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None, json_content: str = None):
        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{nonexistentlibrary.utils.quote(room_id)}/state/{requests.utils.quote(type)}/"
        if state_key:
            url += requests.utils.quote(state_key)
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        resp = requests.put(url, headers=headers, data=json_content)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return resp.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python attempts to import it. Additionally, the code attempts to use `nonexistentlibrary.utils.quote(room_id)`, which would fail even if the library did exist, because the `requests` library is the correct library that provides the `quote` function, not `nonexistentlibrary`. Furthermore, the code references `matrix_res['baseURL']` instead of `matrix_res['baseUrl']`, which would cause a KeyError because the key 'baseURL' does not exist in the `matrix` TypedDict.
  id: |-
    hubfix_hub_190
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None, json_content: str = None):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/{requests.utils.quote(type)}/"
        if state_key:
            url += requests.utils.quote(state_key)
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        resp = requests.put(url, headers=headers, data=json_content)
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return resp.json()
  original_instructions: |-
    Set room state in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str

    def secondary(auth: slack_resource, objectType: str, propertyName: str):
        url = f"https://api.hubapi.com/crm/v3/properties/{objectType}/{propertyName}?archived=false"
        headers = {
            "Authorization": f"Bearer {auth['token']}",
            "Accept": "application/json",
        }
        response = nonexistentlibrary.get(url, headers=headers)
        json_res = response.jsonify()
        if json_res.get("status") == "error":
            print(json_res)
            raise ValueError(json_res.get("message"))
        return json_res
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` attempts to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `hubspot` to `slack_resource`, but the function `secondary` still expects a token under the key 'token', which is not defined in `slack_resource`.
    3. The `main` function is renamed to `secondary`, which by itself is not an error, but if the expectation is to call `main`, this would cause an issue.
    4. The `requests.get` function is replaced with `nonexistentlibrary.get`, which does not exist and will raise a `NameError` if it were to reach this line.
    5. The method `response.jsonify()` does not exist; the correct method is `response.json()`, so this would raise an `AttributeError`.
  id: |-
    hubfix_hub_361
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class hubspot(TypedDict):
        token: str

    def main(auth: hubspot, objectType: str, propertyName: str):
        url = f"https://api.hubapi.com/crm/v3/properties/{objectType}/{propertyName}?archived=false"
        headers = {
            "Authorization": f"Bearer {auth['token']}",
            "Accept": "application/json",
        }
        response = requests.get(url, headers=headers)
        json_res = response.json()
        if json_res.get("status") == "error":
            print(json_res)
            raise ValueError(json_res.get("message"))
        return json_res
  original_instructions: |-
    Get a properties configuration from hubspot crm in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class http(TypedDict):
        ok: bool
        status: int
        content: str

    def main(url: str) -> http:
        resp = requests.get(url)

        return {
            'ok': resp.ok,
            'status': resp.status_code,
            'text': resp.content,
        }
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name.
  id: |-
    hubfix_hub_98
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str) -> http:
        resp = requests.get(url)

        return {
            'ok': resp.ok,
            'status': resp.status_code,
            'text': resp.text,
        }
  original_instructions: |-
    Send GET Request in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        ok: bool
        status: int
        text: str
- broken_code: |-
    from typing import TypedDict

    class main_return(TypedDict):
        arg: int

    def main(arg: str) -> main_return:
        return {"argx": arg}
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        print(main("Hello"))
      File "script.py", line 6, in main
        return {"argx": arg}
    TypeError: TypedDict "main_return" has no key 'argx'
  explanation: |-
    The code is broken because the TypedDict `main_return` is defined with a key `arg` that has a type of `int`, but the function `main` is trying to return a dictionary with a key `argx` which does not exist in the TypedDict definition. Additionally, the type of `arg` in the TypedDict was changed from `str` to `int`, which is inconsistent with the type of the parameter `arg` in the `main` function, which is still `str`. The function should return a dictionary with the correct key as defined in the TypedDict and the value should match the type specified in the TypedDict.
  id: |-
    hubfix_hub_25
  lang: |-
    python
  original_code: |-
    from typing import TypedDict

    class main_return(TypedDict):
        arg: str

    def main(arg: str) -> main_return:
        return {"arg": arg}
  original_instructions: |-
    Echo argument in windmill
  resource_type: |-
    main_return
  resource_type_def: |-
    class main_return(TypedDict):
        arg: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def broken_function(gdocs_auth: gdocs, documentId: str, text: str):
        token = gdocs_auth["token"]

        APPEND_TEXT_URL = f"https://docs.googleapis.com/v1/documents/{documentId}:batchUpdate"

        body = {
            "requests": [
                {
                    "insertText": {"content": text}
                }
            ]
        }
        response = nonexistentlibrary.post(APPEND_TEXT_URL, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        })

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `main` has been renamed to `broken_function`, which would cause issues if other parts of the code expect a function named `main`. The `insertText` key in the `body` dictionary has been changed to `content`, which is not the correct key expected by the Google Docs API, and would result in an API error if the code were to run. Lastly, the `requests.post` method has been replaced with `nonexistentlibrary.post`, which is not a valid method because the `nonexistentlibrary` module does not exist.
  id: |-
    hubfix_hub_56
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, documentId: str, text: str):
        token = gdocs_auth["token"]

        APPEND_TEXT_URL = f"https://docs.googleapis.com/v1/documents/{documentId}:batchUpdate"

        body = {
            "requests": [
                {
                    "insertText": {"text": text}
                }
            ]
        }
        response = requests.post(APPEND_TEXT_URL, json=body, headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        })

        return response.text
  original_instructions: |-
    Append Text in gdocs
  resource_type: |-
    gdocs
  resource_type_def: |-
    class gdocs(TypedDict):
        token: str
- broken_code: |-
    import base64
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def broken_function(gdrive_auth: gdrive, fileId: str):  # Renamed the main function
        DOWNLOAD_FILE_URL = f'https://www.googleapis.com/drive/v3/files/{fileId}?alt=media'

        token = gdrive_auth["token"]

        response = nonexistentlibrary.get(DOWNLOAD_FILE_URL, headers={  # Using a nonexistent library function
            'Authorization': f'Bearer {token}',
            'Accept': 'application/json',
        })

        if response:
            return base64.b64encode(response.content).decode('utf-8')
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if the script relies on a function named `main`. Furthermore, the code tries to use a `get` method from the `nonexistentlibrary`, which is not a real library, so this method does not exist.
  id: |-
    hubfix_hub_90
  lang: |-
    python
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str):
        DOWNLOAD_FILE_URL = f'https://www.googleapis.com/drive/v3/files/{fileId}?alt=media'

        token = gdrive_auth["token"]

        response = requests.get(DOWNLOAD_FILE_URL, headers={
            'Authorization': f'Bearer {token}',
            'Accept': 'application/json',
        })

        if response:
            return base64.b64encode(response.content).decode('utf-8')
  original_instructions: |-
    Download a file in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, List
    import nonexistentlibrary  # This library does not exist

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def broken_function(auth: appwrite, database_id: str, collection_id: str, document_id: str, queries: List[str] = None):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents/{document_id}"

        params = {}
        if queries:
            params['queries'] = queries

        response = requests.get(url, headers=headers, params=params, verify=not auth['self_signed'])
        return response.get_json()  # This method does not exist
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if the code expects a function named `main`. Lastly, the method `get_json()` is called on the `response` object, which is incorrect because the correct method name is `json()`.
  id: |-
    hubfix_hub_336
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, List
    import requests

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, document_id: str, queries: List[str] = None):
        headers = {
            'X-Appwrite-Project': auth['project'],
            'X-Appwrite-Key': auth['key'],
        }

        if auth['self_signed']:
            requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

        url = f"{auth['endpoint']}/v1/databases/{database_id}/collections/{collection_id}/documents/{document_id}"

        params = {}
        if queries:
            params['queries'] = queries

        response = requests.get(url, headers=headers, params=params, verify=not auth['self_signed'])
        return response.json()
  original_instructions: |-
    Get Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Dict

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def broken_function(at_con: airtable, at_table: airtableTable, new_record: Dict):
        base_url = f"https://api.airtable.com/v0/{at_table['baseId']}/{at_table['tableName']}"
        headers = {
            "Authorization": f"Bearer {at_con['apiSecret']}",
            "Content-Type": "application/json"
        }
        response = nonexistentlibrary.post(base_url, headers=headers, json={"fields": new_record})
        return response.get_json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The function `main` has been renamed to `broken_function`, which will cause an error if the code expects a function named `main`.
    3. The `airtable` TypedDict is being accessed with a non-existent key `'apiSecret'` instead of `'apiKey'`.
    4. The `requests.post` method has been replaced with `nonexistentlibrary.post`, which does not exist and will raise a `NameError` if it gets to that point.
    5. The method `response.get_json()` does not exist; the correct method to get the JSON content from a `requests.Response` object is `response.json()`.
  id: |-
    hubfix_hub_1024
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Dict

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, new_record: Dict):
        base_url = f"https://api.airtable.com/v0/{at_table['baseId']}/{at_table['tableName']}"
        headers = {
            "Authorization": f"Bearer {at_con['apiKey']}",
            "Content-Type": "application/json"
        }
        response = requests.post(base_url, headers=headers, json={"fields": new_record})
        return response.json()
  original_instructions: |-
    Create single record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Dict

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str, body: Dict = None) -> http:
        if body is None:
            body = {}

        resp = requests.put(url, json=body, headers={"Content-Type": "application/json"})

        return {
            "ok": resp.ok,
            "status": resp.status_code,
            "content": resp.text,  # This line is intentionally incorrect
        }
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python cannot find this library, so it raises a `ModuleNotFoundError`. Additionally, the returned dictionary is trying to use a key "content" which is not defined in the TypedDict `http`. The correct key should be "text".
  id: |-
    hubfix_hub_99
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Dict

    class http(TypedDict):
        ok: bool
        status: int
        text: str

    def main(url: str, body: Dict = None) -> http:
        if body is None:
            body = {}

        resp = requests.put(url, json=body, headers={"Content-Type": "application/json"})

        return {
            "ok": resp.ok,
            "status": resp.status_code,
            "text": resp.text,
        }
  original_instructions: |-
    Send PUT Request in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        ok: bool
        status: int
        text: str
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):
        token_key: str

    def main(slack_auth: slack_resource, channel: str, user: str):
        web = WebClient(token=slack_auth['token'])

        web.conversations_remove(
            channel=channel,
            member=user
        )

        return "User has been removed"
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main(slack_auth, channel, user)
      File "script.py", line 6, in main
        web = WebClient(token=slack_auth['token'])
    KeyError: 'token'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict class was renamed from `slack` to `slack_resource`, but the `main` function still expects a parameter of type `slack`. This will not cause a runtime error but is a semantic error because the type hint no longer matches the expected input.

    2. The key in the `slack_resource` TypedDict was changed from `token` to `token_key`, but the `main` function still tries to access `slack_auth['token']`, which will result in a `KeyError` because the key 'token' does not exist in the `slack_auth` dictionary.

    3. The method `conversations_remove` does not exist in the `slack_sdk.WebClient`. The correct method name should be `conversations_kick`.

    4. The parameter `member` is incorrect for the method `conversations_kick`. The correct parameter name is `user`.

    5. The return type of the function was changed from a dictionary to a string, which is a semantic error if the caller expects a dictionary.
  id: |-
    hubfix_hub_14
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, user: str):
        web = WebClient(token=slack_auth['token'])

        web.conversations_kick(
            channel=channel,
            user=user
        )

        return {"message": "Successfully Kicked user"}
  original_instructions: |-
    Kick User in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class value_typeddict(TypedDict):
        pass

    def broken_function(value: value_typeddict, indented: bool = False) -> int:
        indent = 2 if indented else None
        return json.dumps(value, indent=indent)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the function `broken_function` is supposed to return a string as per the original `main` function, but the return type is incorrectly changed to `int`, which would cause a type error if the import error was resolved and the function was called.
  id: |-
    hubfix_hub_102
  lang: |-
    python
  original_code: |-
    import json
    from typing import TypedDict

    class value_typeddict(TypedDict):
        pass

    def main(value: value_typeddict, indented: bool = False) -> str:
        indent = 2 if indented else None
        return json.dumps(value, indent=indent)
  original_instructions: |-
    Convert JavaScript Object to JSON String in helper
  resource_type: |-
    value_typeddict
  resource_type_def: |-
    class value_typeddict(TypedDict):
        pass
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class slack_resource(TypedDict):  # Changed class name from 'slack' to 'slack_resource'
        token: str

    def main(slack_auth: slack, channel: str, timestamp: str):  # 'slack' should be 'slack_resource'
        web = WebClient(token=slack_auth['token'])

        try:
            response = web.chat_delete(
                channel=channel,
                ts=timestamp
            )
            return {'response': response}
        except SlackApiError as e:
            return {'error': e.response['error']}
  error: |-
    TypeError: TypedDict "slack" has no attribute "token".
  explanation: |-
    The TypedDict class was renamed from `slack` to `slack_resource`, but the parameter type in the `main` function was not updated to reflect this change. The `main` function still expects a parameter of type `slack`, which no longer exists. This will cause a TypeError when trying to access the 'token' attribute of `slack_auth` because `slack_auth` is expected to be of the non-existent `slack` type instead of the correct `slack_resource` type.
  id: |-
    hubfix_hub_18
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, timestamp: str):
        web = WebClient(token=slack_auth['token'])

        try:
            response = web.chat_delete(
                channel=channel,
                ts=timestamp
            )
            return {'response': response}
        except SlackApiError as e:
            return {'error': e.response['error']}
  original_instructions: |-
    Delete Message in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        api_key: str  # Changed apiKey to api_key

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable):
        table = Table(at_con['api_key'], at_table['baseId'], at_table['tableName'])
        result_list = table.all()

        return result_list  # Changed the return type
  error: |-
    KeyError: 'api_key'
  explanation: |-
    The code is trying to access a key 'api_key' in the 'at_con' dictionary, but the original key defined in the 'airtable' TypedDict is 'apiKey'. Since TypedDicts enforce the keys to match exactly, this results in a KeyError because 'api_key' does not exist in the 'at_con' dictionary.

    Additionally, the return type of the function has been changed from a dictionary containing the key 'results' to just the 'result_list'. If the function is expected to return a dictionary with a specific structure, this change would break the code that relies on the original return type.
  id: |-
    hubfix_hub_8
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])
        result_list = table.all()

        return {'results': result_list}
  original_instructions: |-
    List Records in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- broken_code: |-
    import nonexistentlib
    from typing import TypedDict

    class slack_resource(TypedDict):
        token: str

    def broken_function(slack_auth: slack_resource, driveId: str, useDomainAdminAccess: bool = False) -> int:
        GET_SHARED_DRIVE_URL = f'https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}'

        token = slack_auth["access_token"]

        response = nonexistentlib.post(
            GET_SHARED_DRIVE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken for several reasons:
    1. The import statement `import nonexistentlib` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `gdrive` to `slack_resource`, but the function parameter `slack_auth` is still expected to be of type `gdrive`.
    3. The function `broken_function` is trying to access a non-existent property `access_token` of the `TypedDict` `slack_auth`.
    4. The function `broken_function` is calling a method `nonexistentlib.post` which doesn't exist because the library `nonexistentlib` doesn't exist.
    5. The return type of the function is changed from `str` to `int`, but `response.text` is a string, not an integer.
  id: |-
    hubfix_hub_64
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = False) -> str:
        GET_SHARED_DRIVE_URL = f'https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}'

        token = gdrive_auth["token"]

        response = requests.get(
            GET_SHARED_DRIVE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Get Shared Drive in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Optional, Dict, Any

    class slack(TypedDict):
        api_key: str
        server: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None and v != {}}

    def main(auth: slack, list_id: str, name: str, static_segment: Optional[List[str]] = None, options: Optional[Dict[str, Any]] = None) -> Any:
        url = f"https://{auth['server_resource']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        body = {
            'name': name,
            'static_segment': static_segment,
            'options': options,
        }

        cleaned_body = remove_empty_fields(body)
        response = requests.post(url, headers={
            'Authorization': f"Bearer {auth['api_key']}"
        }, json=cleaned_body)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the TypedDict `slack` is used instead of `mailchimp`, and the property `server_resource` is accessed on the `auth` dictionary, which does not exist in the original `mailchimp` TypedDict. This would also cause an error if the code execution reached that point.
  id: |-
    hubfix_hub_210
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Optional, Dict, Any

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None and v != {}}

    def main(auth: mailchimp, list_id: str, name: str, static_segment: Optional[List[str]] = None, options: Optional[Dict[str, Any]] = None) -> Any:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        body = {
            'name': name,
            'static_segment': static_segment,
            'options': options,
        }

        cleaned_body = remove_empty_fields(body)
        response = requests.post(url, headers={
            'Authorization': f"Bearer {auth['api_key']}"
        }, json=cleaned_body)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Create a Segment in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    from typing import Union, TypedDict
    from telebot import TeleBot

    class telegram(TypedDict):
        api_key: str

    def main(auth: telegram, chat_id: Union[str, int], message_id: int, text: str, inline_message_id: str = None):
        client = TeleBot(auth['token'])
        if inline_message_id:
            return client.update_message_text(text, inline_message_id=inline_message_id)
        else:
            return client.update_message_text(text, chat_id, message_id)
  error: |-
    AttributeError: 'TeleBot' object has no attribute 'update_message_text'
  explanation: |-
    The code is broken because the `TeleBot` object does not have a method called `update_message_text`. The correct method name should be `edit_message_text`. Additionally, the `TypedDict` named `telegram` has a key `api_key` instead of `token`, which will cause a KeyError when `auth['token']` is accessed because the key `token` does not exist in the `auth` dictionary.
  id: |-
    hubfix_hub_235
  lang: |-
    python
  original_code: |-
    from typing import Union, TypedDict
    from telebot import TeleBot

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], message_id: int, text: str, inline_message_id: str = None):
        client = TeleBot(auth['token'])
        if inline_message_id:
            return client.edit_message_text(text, inline_message_id=inline_message_id)
        else:
            return client.edit_message_text(text, chat_id, message_id)
  original_instructions: |-
    Edit a Text Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str
        server_prefix: str

    def secondary(auth: slack_resource, campaign_id: str):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/finish-send"
        response = nonexistentlibrary.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.okay:
            raise Exception(response.text)
        return response.get_json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The import statement `import nonexistentlibrary` tries to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    - The `TypedDict` class is renamed from `mailchimp` to `slack_resource`, but the function `secondary` still tries to access `auth['server']`, which is not a property of `slack_resource`.
    - The main function is renamed to `secondary`, which by itself is not an error, but if the expectation is to have a `main` function, this would be incorrect.
    - The `requests` library is replaced with `nonexistentlibrary`, which does not exist, so calling `nonexistentlibrary.post` will raise a `NameError`.
    - The `response.ok` attribute is incorrectly changed to `response.okay`, which is not a valid attribute of the `Response` object.
    - The method `response.get_json()` does not exist; the correct method is `response.json()`.
    - The API endpoint is changed from `cancel-send` to `finish-send`, which may not exist, leading to an incorrect API call.
  id: |-
    hubfix_hub_204
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/cancel-send"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Cancel a Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    import nonexistentlibrary as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        deleted = stripe_module.NonExistentMethod(customer_id)
        return deleted
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named 'nonexistentlibrary' as 'stripe_module', which does not exist. Additionally, it is trying to call a method 'NonExistentMethod' on 'stripe_module', which is not a valid method of the Stripe API (or any module, since the import would fail before reaching this point).
  id: |-
    hubfix_hub_128
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        deleted = stripe_module.Customer.delete(customer_id)
        return deleted
  original_instructions: |-
    Delete a Customer in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['end_point'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        return coll.delete_one(filter).deleted_count
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main(auth, data_source, database, collection, filter)
      File "script.py", line 7, in main
        client = MongoClient(auth['end_point'], username='apikey', password=auth['api_key'])
    KeyError: 'end_point'
  explanation: |-
    The code is trying to access a key 'end_point' in the 'auth' dictionary which does not exist. The correct key as defined in the TypedDict 'mongodbrest' is 'endpoint'. This results in a KeyError because 'end_point' is not a valid key in the 'auth' dictionary.
  id: |-
    hubfix_hub_257
  lang: |-
    python
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        return coll.delete_one(filter)
  original_instructions: |-
    Delete a Document in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    import os
    from typing import TypedDict, List
    from slack_sdk import WebClient
    from urllib.parse import urljoin

    class slack_resource(TypedDict):  # Changed the class name
        token: str

    def main(channel: str, slack: slack_resource, approvers: List[str]):
        web = WebClient(slack['api_token'])  # Changed the key to a non-existent one
        wm_base_url = os.environ.get("WM_BASE_URL")
        wm_flow_job_id = os.environ.get("WM_FLOW_JOB_ID")
        job_url = urljoin(wm_base_url, f"/run/{wm_flow_job_id}")
        wm_flow_path = os.environ.get("WM_FLOW_PATH")
        wm_username = os.environ.get("WM_USERNAME")
        text = f"Flow job {job_url} ({wm_flow_path}) run by {wm_username} was approved by {', '.join(approvers)}"

        web.chat_postMessage(
            channel=channel,
            message=text,  # Changed the parameter name to a non-existent one
        )
  error: |-
    KeyError: 'api_token'
  explanation: |-
    The code is broken due to the following reasons:

    1. The TypedDict class name was changed from `slack` to `slack_resource`, but the parameter type in the `main` function was not updated to reflect this change. This would cause a type hinting issue, although it wouldn't necessarily break the code at runtime.

    2. Inside the `main` function, `slack['api_token']` is used, but the original TypedDict only defined `token`. Since `api_token` does not exist in the TypedDict, this will raise a `KeyError`.

    3. The `chat_postMessage` method of the `WebClient` object is called with a parameter named `message`, but the correct parameter name is `text`. This will raise a `TypeError` because the `chat_postMessage` method does not accept a `message` keyword argument.
  id: |-
    hubfix_hub_180
  lang: |-
    python
  original_code: |-
    import os
    from typing import TypedDict, List
    from slack_sdk import WebClient
    from urllib.parse import urljoin

    class slack(TypedDict):
        token: str

    def main(channel: str, slack: slack, approvers: List[str]):
        web = WebClient(slack['token'])
        wm_base_url = os.environ.get("WM_BASE_URL")
        wm_flow_job_id = os.environ.get("WM_FLOW_JOB_ID")
        job_url = urljoin(wm_base_url, f"/run/{wm_flow_job_id}")
        wm_flow_path = os.environ.get("WM_FLOW_PATH")
        wm_username = os.environ.get("WM_USERNAME")
        text = f"Flow job {job_url} ({wm_flow_path}) run by {wm_username} was approved by {', '.join(approvers)}"

        web.chat_postMessage(
            channel=channel,
            text=text,
        )
  original_instructions: |-
    Send information about approved job to channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str

    def secondary(auth: slack_resource, from_chat_id: str, to_chat_id: str, message_id: str):
        client = TeleBot(auth['token'])
        return client.send_message(to_chat_id, from_chat_id, message_id)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 9, in <module>
        secondary(...)
      File "script.py", line 7, in secondary
        client = TeleBot(auth['token'])
    KeyError: 'token'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict class was renamed from `telegram` to `slack_resource`, and the `token` field was changed to `api_key`. This causes a KeyError because the `auth` dictionary is expected to have a 'token' key, but it does not.

    2. The `main` function was renamed to `secondary`, which would break any code that expects a function named `main`.

    3. The `message_id` parameter type was changed from `int` to `str`, which could cause issues if the `forward_message` method expects an integer.

    4. The `forward_message` method was changed to `send_message`, which is a different method and likely requires different parameters.

    5. The `send_message` method is called with incorrect parameters. It typically expects the chat ID and the text of the message to send, not three IDs.

    Running this code would result in a KeyError because the `auth` dictionary does not contain a 'token' key, as the TypedDict was changed and the code tries to access a non-existent key.
  id: |-
    hubfix_hub_241
  lang: |-
    python
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, from_chat_id: str, to_chat_id: str, message_id: int):
        client = TeleBot(auth['token'])
        return client.forward_message(to_chat_id, from_chat_id, message_id)
  original_instructions: |-
    Forward a Message in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    import nonexistentlibrary  # This library does not exist

    class job_service(TypedDict):
        workspace: str
        suspended: bool
        per_page: int
        script_path_exact: Optional[str]

    def get_workspace() -> str:
        return "your_workspace_here"

    def list_queue(params: job_service):
        response = nonexistentlibrary.post("https://api.windmill.example.com/jobs", data=params)  # Changed from requests.get to nonexistentlibrary.post
        return response.json()

    def main(script_path_exact: Optional[str] = None, only_suspended_jobs: bool = False):
        return list_queue({
            "workspace": get_workspace(),
            "suspended": only_suspended_jobs,
            "per_page": 50,
            "script_path_incorrect": script_path_exact,  # Changed from script_path_exact to script_path_incorrect
        })
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `requests.get` method has been incorrectly changed to `nonexistentlibrary.post`, which would also cause an error if the import statement were correct. Furthermore, the `list_queue` function is using a non-existent property `script_path_incorrect` instead of the correct `script_path_exact` property defined in the `job_service` TypedDict.
  id: |-
    hubfix_hub_269
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    import requests

    class job_service(TypedDict):
        workspace: str
        suspended: bool
        per_page: int
        script_path_exact: Optional[str]

    def get_workspace() -> str:
        # Assuming get_workspace is a function that retrieves the current workspace
        # Replace with actual implementation
        return "your_workspace_here"

    def list_queue(params: job_service):
        # Assuming the Windmill API has a similar endpoint in Python
        # Replace with actual API endpoint and API key if needed
        response = requests.get("https://api.windmill.example.com/jobs", params=params)
        return response.json()

    def main(script_path_exact: Optional[str] = None, only_suspended_jobs: bool = False):
        return list_queue({
            "workspace": get_workspace(),
            "suspended": only_suspended_jobs,
            "per_page": 50,
            "script_path_exact": script_path_exact,
        })
  original_instructions: |-
    List Queued Jobs in windmill
  resource_type: |-
    job_service
  resource_type_def: |-
    class job_service(TypedDict):
        workspace: str
        suspended: bool
        per_page: int
        script_path_exact: Optional[str]
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class currencyapi(TypedDict):
        apiKey: str

    def main(currency_api_resource: currencyapi, base_currency: str, currencies: str):
        params = {
            'base_currency': base_currency,
            'currencies': currencies,
        }
        headers = {
            'apikey': currency_api_resource['apiSecret'],
        }
        response = nonexistentlibrary.get(
            'https://api.currencyapi.com/v3/latest',
            params=params,
            headers=headers
        )
        data = response.json()
        currency = data.get('data')
        return currency
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, within the `headers` dictionary, it tries to access a key `'apiSecret'` that is not defined in the `currencyapi` TypedDict (the correct key is `'apiKey'`). Finally, it calls a method `get` on `nonexistentlibrary`, which is not possible because the library does not exist.
  id: |-
    hubfix_hub_322
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class currencyapi(TypedDict):
        apiKey: str

    def main(currency_api_resource: currencyapi, base_currency: str, currencies: str):
        params = {
            'base_currency': base_currency,
            'currencies': currencies,
        }
        headers = {
            'apikey': currency_api_resource['apiKey'],
        }
        response = requests.get(
            'https://api.currencyapi.com/v3/latest',
            params=params,
            headers=headers
        )
        data = response.json()
        currency = data.get('data')
        return currency
  original_instructions: |-
    Latest exchange rate from CurrencyApi.com in currencyapi
  resource_type: |-
    currencyapi
  resource_type_def: |-
    class currencyapi(TypedDict):
        apiKey: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def broken_function(discord_webhook: discordwebhook, message: str):
        payload = {'content': message}
        response = nonexistentlibrary.post(discord_webhook['webhook_url'], json=payload)
        return response
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find the specified module. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if another piece of code is expecting a function named `main`. Lastly, the code attempts to use `nonexistentlibrary.post`, which will fail because `nonexistentlibrary` does not exist and therefore does not have a `post` method.
  id: |-
    hubfix_hub_77
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, message: str):
        payload = {'content': message}
        response = requests.post(discord_webhook['webhook_url'], json=payload)
        return response
  original_instructions: |-
    Send a message to discord using webhook in discord
  resource_type: |-
    discordwebhook
  resource_type_def: |-
    class discordwebhook(TypedDict):
        webhook_url: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        token: str

    def broken_function(slack_auth: slack, spreadsheetId: str, worksheet_name: str):
        token = slack_auth["access_token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{worksheet_name}"

        response = nonexistentlibrary.get(
            GET_VALUES_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    - The `class slack_resource(TypedDict)` is defined, but the function `broken_function` is expecting a parameter of type `slack`, which is not defined. This will raise a `NameError`.
    - Inside the function, `slack_auth["access_token"]` is used, but the `TypedDict` `slack_resource` only defines a `token` field, not `access_token`. This will raise a `KeyError` if the previous errors were fixed and the code was executed.
    - The function `nonexistentlibrary.get` is called, but since `nonexistentlibrary` does not exist, this will raise a `NameError`.
    - The function name has been changed from `main` to `broken_function`, which in itself is not an error, but if the script relies on a function named `main`, this change will break the expected behavior.
  id: |-
    hubfix_hub_53
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str, worksheet_name: str):
        token = gsheets_auth["token"]

        GET_VALUES_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}/values/{worksheet_name}"

        response = requests.get(
            GET_VALUES_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Get Values in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional, Dict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_id: str,
        document_data: Optional[Dict[str, any]] = None,
        document_permissions: Optional[List[str]] = None
    ):
        client = Client()
        client.set_endpoint(auth['end_point'])  # Incorrect key
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        response = db.update_document(
            database_id,
            collection_id,
            document_id,
            document_data,
            document_permissions
        )

        return response

    # Breaking change: calling a non-existent property of a typeddict inside the function
  error: |-
    KeyError: 'end_point'
  explanation: |-
    The code is trying to access a key 'end_point' in the 'auth' TypedDict which does not exist. The correct key should be 'endpoint' as defined in the 'appwrite' TypedDict. Accessing a non-existent key in a dictionary in Python results in a KeyError.
  id: |-
    hubfix_hub_337
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, Dict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(
        auth: appwrite,
        database_id: str,
        collection_id: str,
        document_id: str,
        document_data: Optional[Dict[str, any]] = None,
        document_permissions: Optional[List[str]] = None
    ):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        db = Databases(client)

        response = db.update_document(
            database_id,
            collection_id,
            document_id,
            document_data,
            document_permissions
        )

        return response
  original_instructions: |-
    Update Document in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import smtplib
    from email.mime.text import MIMEText
    from typing import TypedDict

    class smtp(TypedDict):
        host: str
        port: str  # Changed the type from int to str
        user: str
        password: str

    def main(smtp_res: smtp, to_email: str, from_email: str, subject: str, content: str):
        message = MIMEText(content)
        message['Subject'] = subject
        message['From'] = from_email
        message['To'] = to_email

        with smtplib.SMTP_SSL(smtp_res['host'], smtp_res['port']) as client:
            client.login(smtp_res['user'], smtp_res['password'])
            client.sendmail(from_email, to_email, message.as_string())

        return f"Email sent from {from_email} to {to_email}"
  error: |-
    TypeError: an integer is required (got type str)
  explanation: |-
    The error occurs because the `port` field in the `smtp` TypedDict was changed from an `int` to a `str`. The `smtplib.SMTP_SSL` function expects an integer for the port number, but it is being passed a string due to the incorrect type definition. This causes a TypeError when the script attempts to establish an SSL connection to the SMTP server.
  id: |-
    hubfix_hub_106
  lang: |-
    python
  original_code: |-
    import smtplib
    from email.mime.text import MIMEText
    from typing import TypedDict

    class smtp(TypedDict):
        host: str
        port: int
        user: str
        password: str

    def main(smtp_res: smtp, to_email: str, from_email: str, subject: str, content: str):
        message = MIMEText(content)
        message['Subject'] = subject
        message['From'] = from_email
        message['To'] = to_email

        with smtplib.SMTP_SSL(smtp_res['host'], smtp_res['port']) as client:
            client.login(smtp_res['user'], smtp_res['password'])
            client.sendmail(from_email, to_email, message.as_string())

        return f"Email sent from {from_email} to {to_email}"
  original_instructions: |-
    Send Email in smtp
  resource_type: |-
    smtp
  resource_type_def: |-
    class smtp(TypedDict):
        host: str
        port: int
        user: str
        password: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class http(TypedDict):
        status: int
        statusText: str

    def main(endpoint: str) -> http:
        try:
            res = nonexistentlibrary.get(endpoint)
            return {'status': res.status_code, 'statusText': res.reason}
        except Exception as e:
            return {'status': -1, 'statusText': str(e)}
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library called `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the `nonexistentlibrary.get(endpoint)` call would also fail because `nonexistentlibrary` does not exist, and therefore it does not have a `get` method.
  id: |-
    hubfix_hub_199
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class http(TypedDict):
        status: int
        statusText: str

    def main(endpoint: str) -> http:
        try:
            res = requests.get(endpoint)
            return {'status': res.status_code, 'statusText': res.reason}
        except Exception as e:
            return {'status': -1, 'statusText': str(e)}
  original_instructions: |-
    Get an endpoint status and statusText in http
  resource_type: |-
    http
  resource_type_def: |-
    class http(TypedDict):
        status: int
        statusText: str
- broken_code: |-
    import json
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict

    class slack_resource(TypedDict):  # Changed the name of the TypedDict
        token: str

    def secondary(api_token: slack_resource, query: str):  # Renamed the main function
        headers = {
            "Authorization": f"Bearer {api_token['nonexistent_property']}",  # Using a non-existent property
            "Content-Type": "application/json"
        }
        body = json.dumps({"search": query})  # Changed the key in the JSON body
        url = "https://api.sendgrid.com/v3/marketing/contacts/nonexistent_method"  # Calling an API method that doesn't exist

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()
            return response.text  # Changed the return type from JSON to text
        except requests.exceptions.HTTPError as http_err:
            raise Exception(json.dumps({
                "status_code": http_err.response.status_code,
                "body": http_err.response.json()
            }))
        except Exception as err:
            raise Exception(str(err))

    # Assuming the function is called with the following parameters
    api_token = {"token": "your_api_token"}
    query = "email='example@example.com'"
    secondary(api_token, query)  # Calling the renamed function with the wrong TypedDict
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        import nonexistentlibrary  # This library does not exist
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. The import statement `import nonexistentlibrary` attempts to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` class was renamed from `sendgrid` to `slack_resource`, which is not used anywhere in the code.
    3. The main function was renamed to `secondary`, which would break any code that expects a function named `main`.
    4. The function `secondary` is called with the wrong type of `TypedDict` (`slack_resource` instead of `sendgrid`).
    5. Inside the function, `api_token['nonexistent_property']` attempts to access a property that does not exist in the `TypedDict`.
    6. The JSON body of the request was changed from `{"query": query}` to `{"search": query}`, which may not be what the API endpoint expects.
    7. The URL was changed to include `nonexistent_method`, which likely does not correspond to a valid API endpoint.
    8. The function now returns `response.text` instead of `response.json()`, which changes the return type and may not be the expected format.
  id: |-
    hubfix_hub_221
  lang: |-
    python
  original_code: |-
    import json
    import requests
    from typing import TypedDict

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, query: str):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }
        body = json.dumps({"query": query})
        url = "https://api.sendgrid.com/v3/marketing/contacts/search"

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as http_err:
            raise Exception(json.dumps({
                "status_code": http_err.response.status_code,
                "body": http_err.response.json()
            }))
        except Exception as err:
            raise Exception(str(err))
  original_instructions: |-
    Search Contacts in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- broken_code: |-
    from pymongo import MongoClient
    from bson.objectid import ObjectId
    import time

    from typing_extensions import TypedDict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def get_state():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def set_state(state):
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def main(auth: mongodbrest, data_source: str, database: str, collection: str):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        documents = client[database][collection]
        last_check = get_state()
        set_state(int(time.time()))
        id = ObjectId.from_datetime(last_check)
        return list(documents.find({ '_id': { '$gt': id } }))

    result = main(
        auth={'endpoint': 'your_endpoint', 'api_key': 'your_api_key'},
        data_source='Cluster0',
        database='your_database',
        collection='your_collection'
    )
    print(result)
    print(broken_function())
  error: |-
    NameError: name 'broken_function' is not defined
  explanation: |-
    The code is calling a function named `broken_function()` which is not defined anywhere in the script. This results in a `NameError` because Python cannot find a function with that name in the current scope.
  id: |-
    hubfix_hub_262
  lang: |-
    python
  original_code: |-
    from pymongo import MongoClient
    from bson.objectid import ObjectId
    import time

    # Define the TypedDict for MongoDB authentication
    from typing_extensions import TypedDict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    # Replace getState and setState with a simple file-based approach for demonstration purposes
    def get_state():
        try:
            with open('state.txt', 'r') as file:
                return int(file.read())
        except FileNotFoundError:
            return 0

    def set_state(state):
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def main(auth: mongodbrest, data_source: str, database: str, collection: str):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        documents = client[database][collection]
        last_check = get_state()
        set_state(int(time.time()))
        id = ObjectId.from_datetime(last_check)
        return list(documents.find({ '_id': { '$gt': id } }))

    # Example usage:
    # result = main(
    #     auth={'endpoint': 'your_endpoint', 'api_key': 'your_api_key'},
    #     data_source='Cluster0',
    #     database='your_database',
    #     collection='your_collection'
    # )
    # print(result)
  original_instructions: |-
    Get recently inserted documents in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    from notion_client import Client
    from typing import List, TypedDict

    class slack_resource(TypedDict):
        token: str

    def main(auth: slack_resource, block_id: str, children: List[dict] = []):
        client = Client(auth=auth['api_key'])
        return client.blocks.children.add(block_id=block_id, items=children)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main({'token': 'fake_token'}, 'block_id')
      File "script.py", line 8, in main
        client = Client(auth=auth['api_key'])
    KeyError: 'api_key'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict is renamed from `notion` to `slack_resource`, which is not used anywhere and does not match the expected usage in the `main` function.
    2. Inside the `main` function, `auth['api_key']` is used, but the correct key according to the TypedDict should be `auth['token']`. Since 'api_key' does not exist in the provided dictionary, a KeyError is raised.
    3. The method `client.blocks.children.add` does not exist in the notion-client library; the correct method is `client.blocks.children.append`.
    4. The parameter `items` is passed to the non-existent `add` method, but the correct parameter for the `append` method is `children`.
  id: |-
    hubfix_hub_355
  lang: |-
    python
  original_code: |-
    from notion_client import Client
    from typing import List, TypedDict

    class notion(TypedDict):
        token: str

    def main(auth: notion, block_id: str, children: List[dict] = []):
        client = Client(auth=auth['token'])
        return client.blocks.children.append(block_id=block_id, children=children)
  original_instructions: |-
    Append Block Children in notion
  resource_type: |-
    notion
  resource_type_def: |-
    class notion(TypedDict):
        token: str
- broken_code: |-
    import sendgrid
    from sendgrid.helpers.mail import Mail
    from typing import TypedDict, Optional

    class sendgrid_type(TypedDict):
        api_key: str

    def main(api_token: sendgrid_type, email: str, source: Optional[str] = None):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        data = {
            "email": email
        }
        if source:
            data["source"] = source

        try:
            response = sg.client.mail.send.post(request_body=Mail(from_email=source, to_emails=email).get())
            return response.body
        except Exception as error:
            raise Exception("\n" + str(error))
  error: |-
    KeyError: 'token'
  explanation: |-
    The `sendgrid_type` TypedDict is defined with a key `api_key`, but inside the `main` function, the code attempts to access `api_token['token']`, which does not exist in the `sendgrid_type` TypedDict. This results in a `KeyError` because the 'token' key is not present in the `api_token` dictionary.
  id: |-
    hubfix_hub_218
  lang: |-
    python
  original_code: |-
    import sendgrid
    from sendgrid.helpers.mail import Mail
    from typing import TypedDict, Optional

    class sendgrid_type(TypedDict):
        token: str

    def main(api_token: sendgrid_type, email: str, source: Optional[str] = None):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        data = {
            "email": email
        }
        if source:
            data["source"] = source

        try:
            response = sg.client.mail.send.post(request_body=Mail(from_email=source, to_emails=email).get())
            return response.body
        except Exception as error:
            raise Exception("\n" + str(error))
  original_instructions: |-
    Validate Email in sendgrid
  resource_type: |-
    sendgrid_type
  resource_type_def: |-
    class sendgrid_type(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Dict, List, Optional
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        document_path: List[str],
        document: Dict[str, any],
        merge: Optional[bool] = None,
        mergeFields: Optional[List[str]] = None
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        if merge is not None:
            doc_ref.set(document, merge=merge)
        elif mergeFields is not None:
            doc_ref.set(document, merge_fields=mergeFields)
        else:
            doc_ref.set(document)

        return db.non_existent_method()
  error: |-
    AttributeError: 'FirestoreClient' object has no attribute 'non_existent_method'
  explanation: |-
    The code attempts to call a method `non_existent_method()` on the `db` object, which is an instance of `FirestoreClient`. Since `FirestoreClient` does not have a method named `non_existent_method`, Python raises an `AttributeError` indicating that the attribute does not exist on the object.
  id: |-
    hubfix_hub_359
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Dict, List, Optional
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(
        auth: firebase,
        collection_id: str,
        document_path: List[str],
        document: Dict[str, any],
        merge: Optional[bool] = None,
        mergeFields: Optional[List[str]] = None
    ):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        if merge is not None:
            doc_ref.set(document, merge=merge)
        elif mergeFields is not None:
            doc_ref.set(document, merge_fields=mergeFields)
        else:
            doc_ref.set(document)
  original_instructions: |-
    Set Document in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- broken_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        result = coll.delete_everything(filter)
        return result.deleted_count
  error: |-
    AttributeError: 'Collection' object has no attribute 'delete_everything'
  explanation: |-
    The code attempts to call a method `delete_everything` on the `coll` object, which is an instance of `pymongo.collection.Collection`. However, this method does not exist in the `pymongo` library. The correct method for deleting multiple documents is `delete_many`, as was used in the original code. The error message indicates that the `Collection` object does not have an attribute named `delete_everything`, which is the method that was incorrectly called.
  id: |-
    hubfix_hub_258
  lang: |-
    python
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, filter: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        result = coll.delete_many(filter)
        return result
  original_instructions: |-
    Delete Many Documents in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class stripe_resource(TypedDict):
        api_key: str

    def broken_function(stripe_con: stripe_resource):
        STRIPE_CREATE_CUSTOMER_URL = 'https://api.stripe.com/v1/customers'
        api_key = stripe_con['token']

        response = nonexistentlibrary.post(
            STRIPE_CREATE_CUSTOMER_URL,
            headers={
                'Authorization': 'Bearer ' + api_key,
                'Content-Type': 'application/json',
            }
        )

        return response.text()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:

    1. The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` class is renamed from `stripe` to `stripe_resource`, but the parameter type in the function `broken_function` is not updated to reflect this change.
    3. The `TypedDict` now has a key `api_key` instead of `token`, but the code attempts to access `stripe_con['token']`, which will raise a `KeyError` because the key 'token' does not exist in the `stripe_resource` TypedDict.
    4. The function `nonexistentlibrary.post` is called, but `nonexistentlibrary` does not exist, which will raise a `NameError`.
    5. The method `response.text()` is incorrect; it should be `response.text` without parentheses, or `response.json()` if the intention is to return JSON data.
  id: |-
    hubfix_hub_120
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe):
        STRIPE_CREATE_CUSTOMER_URL = 'https://api.stripe.com/v1/customers'
        token = stripe_con['token']

        response = requests.post(
            STRIPE_CREATE_CUSTOMER_URL,
            headers={
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json',
            }
        )

        return response.json()
  original_instructions: |-
    Create a Customer in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import base64
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict

    class nextcloud_resource(TypedDict):  # Changed the name of the TypedDict
        baseUrl: str
        username: str
        password: str

    def main(nextcloud_res: nextcloud_resource, userId: int):  # Changed the type of userId to int
        url = f"{nextcloud_res['baseURL']}/ocs/v1.php/cloud/users/{requests.utils.quote(userId)}"  # Changed 'baseUrl' to 'baseURL' and passed int to quote
        auth = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['passwd']}".encode('utf-8')).decode('utf-8')  # Changed 'password' to 'passwd'
        headers = {
            'Authorization': f"Basic {auth}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, there are other issues:
    - The TypedDict `nextcloud` was renamed to `nextcloud_resource`, but the function parameter type was not updated to reflect this change.
    - The `userId` parameter type was changed from `str` to `int`, which will cause an error when `requests.utils.quote` is called because it expects a string.
    - The dictionary key `'baseURL'` is incorrect; it should be `'baseUrl'`.
    - The dictionary key `'passwd'` is incorrect; it should be `'password'`.
  id: |-
    hubfix_hub_164
  lang: |-
    python
  original_code: |-
    import base64
    import requests
    from typing import TypedDict

    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str

    def main(nextcloud_res: nextcloud, userId: str) -> str:
        url = f"{nextcloud_res['baseUrl']}/ocs/v1.php/cloud/users/{requests.utils.quote(userId)}"
        auth = base64.b64encode(f"{nextcloud_res['username']}:{nextcloud_res['password']}".encode('utf-8')).decode('utf-8')
        headers = {
            'Authorization': f"Basic {auth}",
            'OCS-APIRequest': 'true',
        }
        resp = requests.get(url, headers=headers)
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_instructions: |-
    Get user metadata in ocs
  resource_type: |-
    nextcloud
  resource_type_def: |-
    class nextcloud(TypedDict):
        baseUrl: str
        username: str
        password: str
- broken_code: |-
    import nonexistentlibrary as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, amount: str, currency: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        payout = stripe_module.Payout.create(
            amount=amount,
            currency=currency,
            extra_param=123
        )

        return payout
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary' as 'stripe_module', which does not exist. This will cause a `ModuleNotFoundError` when the script is run. Additionally, the `amount` parameter in the `main` function has been changed from an `int` to a `str`, which is incorrect for creating a payout where an integer is expected. Furthermore, an undefined parameter `extra_param` is passed to the `Payout.create` method, which is not a valid parameter for this method and would cause an error if the nonexistent library error was resolved.
  id: |-
    hubfix_hub_124
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, amount: int, currency: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        payout = stripe_module.Payout.create(
            amount=amount,
            currency=currency,
        )

        return payout
  original_instructions: |-
    Create a Payout in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Dict
    from firebase_admin import credentials, firestore, initialize_app

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document: Dict[str, any]):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        store = firestore.client(app)

        col_ref = store.collection(collection_id)
        res = col_ref.push(document)  # Changed 'add' to 'push'

        return res[1].id
  error: |-
    AttributeError: 'CollectionReference' object has no attribute 'push'
  explanation: |-
    The error occurs because the `CollectionReference` object in the `firebase_admin.firestore` module does not have a method called `push`. The correct method to add a document to a Firestore collection is `add`, not `push`. By changing `add` to `push`, the code attempts to call a non-existent method, resulting in an AttributeError.
  id: |-
    hubfix_hub_358
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Dict
    from firebase_admin import credentials, firestore, initialize_app

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document: Dict[str, any]):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": "your-private-key-id",
            "private_key": "your-private-key",
            "client_email": "your-client-email",
            "client_id": "your-client-id",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "your-client-x509-cert-url"
        })
        app = initialize_app(cred)
        store = firestore.client(app)

        col_ref = store.collection(collection_id)
        res = col_ref.add(document)

        return res[1].id
  original_instructions: |-
    Create Document in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- broken_code: |-
    import jsn
    import requests
    from typing import TypedDict, Optional

    class slack(TypedDict):
        token: str

    def broken_function(api_token: slack_resource, list_id: str, contact_sample: Optional[bool] = None):
        headers = {
            "Authorization": f"Bearer {api_token['api_key']}"
        }
        params = {}
        if contact_sample is not None:
            params['contact_sample'] = contact_sample

        url = f"https://api.sendgrid.com/v3/marketing/lsts/{list_id}"

        try:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + jsn.dumps(error.response.json() if error.response else str(error)))
  error: |-
    ModuleNotFoundError: No module named 'jsn'
  explanation: |-
    The code is broken due to several issues:

    1. The import statement `import jsn` is incorrect because there is no module named 'jsn'. It should be `import json`.
    2. The class `slack` is defined instead of `sendgrid`, which is the TypedDict used in the original code.
    3. The function is renamed to `broken_function` from `main`, which is not necessarily an error by itself but could cause issues if the function is expected to be named `main` elsewhere in the code.
    4. The parameter `api_token` is expected to be of type `slack_resource`, which does not exist. It should be of type `slack` as defined in the class or `sendgrid` as in the original code.
    5. The TypedDict `api_token` is being accessed with a key `'api_key'` which does not exist; it should be `'token'`.
    6. The URL string has a typo: `lsts` should be `lists`.
    7. The `jsn.dumps` function call is incorrect because the module name should be `json`.
  id: |-
    hubfix_hub_224
  lang: |-
    python
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, list_id: str, contact_sample: Optional[bool] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}"
        }
        params = {}
        if contact_sample is not None:
            params['contact_sample'] = contact_sample

        url = f"https://api.sendgrid.com/v3/marketing/lists/{list_id}"

        try:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + json.dumps(error.response.json() if error.response else str(error)))
  original_instructions: |-
    Get A Contact List in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- broken_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        api_key: str

    def main(api_token: sendgrid, email: str, on_behalf_of: Optional[str] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Accept": "application/json"
        }
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        url = f"https://api.sendgrid.com/v3/suppression/bounces/{email}"

        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + json.dumps(response.json()))

    main({"api_key": "SG.xxxxx"}, "example@example.com")
  error: |-
    KeyError: 'token'
  explanation: |-
    The TypedDict `sendgrid` is defined with a key `api_key`, but within the `main` function, the code attempts to access `api_token['token']`, which does not exist in the dictionary. The correct key should be `api_token['api_key']` to match the TypedDict definition.
  id: |-
    hubfix_hub_217
  lang: |-
    python
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, email: str, on_behalf_of: Optional[str] = None):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Accept": "application/json"
        }
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        url = f"https://api.sendgrid.com/v3/suppression/bounces/{email}"

        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + json.dumps(response.json()))
  original_instructions: |-
    Get A Bounce in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        api_key: str

    def broken_function(
        api_token: sendgrid,
        on_behalf_of: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        offset: Optional[str] = None,  # Changed int to str
    ):
        headers = {"Authorization": f"Bearer {api_token['token']}", "Accept": "application/json"}
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        params = {
            "start_time": start_time,
            "end_time": end_time,
            "limit": limit,
            "offset": offset,
        }
        params = {k: v for k, v in params.items() if v is not None}

        url = "https://api.sendgrid.com/v3/suppression/bounces"
        response = nonexistentlibrary.get(url, headers=headers, params=params)  # Changed requests to nonexistentlibrary

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + response.text)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the function `broken_function` is trying to use `nonexistentlibrary.get`, which would also fail even if the library did exist because the correct function should be `requests.get`. Furthermore, the `offset` parameter type in the function signature has been changed from `Optional[int]` to `Optional[str]`, which is inconsistent with the expected type for an offset parameter. Lastly, the `api_token` TypedDict is accessed with the key `'token'`, but the TypedDict is defined with the key `'api_key'`, so this would also cause a KeyError if the code were to run.
  id: |-
    hubfix_hub_216
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class sendgrid(TypedDict):
        token: str

    def main(
        api_token: sendgrid,
        on_behalf_of: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
    ):
        headers = {"Authorization": f"Bearer {api_token['token']}", "Accept": "application/json"}
        if on_behalf_of:
            headers["on-behalf-of"] = on_behalf_of

        params = {
            "start_time": start_time,
            "end_time": end_time,
            "limit": limit,
            "offset": offset,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        url = "https://api.sendgrid.com/v3/suppression/bounces"
        response = requests.get(url, headers=headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception("\n" + response.text)
  original_instructions: |-
    Get All Bounces in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):
        token: str

    def main(
        slack_auth: slack_resource,
        channel: str = None,
        timestamp: str = None,
        file: str = None,
    ):
        web = WebClient(token=slack_auth['access_token'])

        response = web.add_star(
            channel=channel,
            timestamp=timestamp,
            file=file,
        )

        return response
  error: |-
    Traceback (most recent call last):
      File "script.py", line 14, in <module>
        main({'token': 'xoxb-...'})
      File "script.py", line 10, in main
        web = WebClient(token=slack_auth['access_token'])
    KeyError: 'access_token'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict is renamed from `slack` to `slack_resource`, but the parameter type in the `main` function is not updated to reflect this change. It should be `slack_auth: slack` instead of `slack_auth: slack_resource`.

    2. The `slack_auth` dictionary is being accessed with a key `'access_token'` which does not exist. The correct key as per the original TypedDict definition is `'token'`.

    3. The method `web.add_star` does not exist in the `slack_sdk.WebClient`. The correct method name is `web.stars_add`.

    4. The return type of the function is changed. The original function returns a dictionary with the key `'response'`, but the broken code returns the `response` object directly.

    To fix the code, the TypedDict should not be renamed or if it is renamed, the parameter type in the `main` function should be updated accordingly, the correct key `'token'` should be used to access the token, the correct method `web.stars_add` should be called, and the return statement should be `return {'response': response}`.
  id: |-
    hubfix_hub_22
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(
        slack_auth: slack,
        channel: str = None,  # Channel to add star to, or channel where the message to add star to was posted (used with timestamp)
        timestamp: str = None,  # Timestamp of the message to add star to
        file: str = None,  # File to add star to
    ):
        web = WebClient(token=slack_auth['token'])

        response = web.stars_add(
            channel=channel,
            timestamp=timestamp,
            file=file,
        )

        return {'response': response}
  original_instructions: |-
    Add Star in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict
    import json

    class sendgrid_typed(TypedDict):
        api_key: str

    def broken_function(api_token: sendgrid_typed, job_id: str):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        request_url = f"/v3/marketing/contacts/imports/{job_id}"

        try:
            response = sg.client.make_request(method='GET', url=request_url)
            return response.text
        except Exception as error:
            raise Exception("\n" + json.dumps(getattr(error, 'body', str(error))))
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError` when the script is run. Additionally, the function `make_request` does not exist in the SendGridAPIClient class, and the TypedDict `sendgrid_typed` has a key `api_key` instead of `token`, but the function tries to access `api_token['token']`, which would result in a KeyError. The function name has also been changed from `main` to `broken_function`, which could be an issue if the function is expected to be named `main` elsewhere in the code. Lastly, `response.text` is used instead of `response.body`, which would be incorrect if the `response` object does not have a `text` attribute.
  id: |-
    hubfix_hub_220
  lang: |-
    python
  original_code: |-
    import sendgrid
    from typing import TypedDict
    import json

    class sendgrid_typed(TypedDict):
        token: str

    def main(api_token: sendgrid_typed, job_id: str):
        sg = sendgrid.SendGridAPIClient(api_key=api_token['token'])

        request_url = f"/v3/marketing/contacts/imports/{job_id}"

        try:
            response = sg.client.request(method='GET', url=request_url)
            return response.body
        except Exception as error:
            raise Exception("\n" + json.dumps(getattr(error, 'body', str(error))))
  original_instructions: |-
    Get Contacts Job Status in sendgrid
  resource_type: |-
    sendgrid_typed
  resource_type_def: |-
    class sendgrid_typed(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Union, Optional
    import nonexistentlibrary  # This library does not exist

    class telegram(TypedDict):
        token: str

    def broken_function(auth: telegram, chat_id: Union[str, int], photo: str, reply_to_message_id: Optional[int] = None):
        token = auth['api_key']  # Incorrect key
        method = 'sendImage'  # Incorrect API method
        url = f"https://api.telegram.org/bot{token}/{method}"
        data = {
            'chat_id': chat_id,
            'image': photo,  # Incorrect parameter name
            'reply_to_message_id': reply_to_message_id
        }
        response = requests.post(url, data=data)
        return response.text  # Changed from .json() to .text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken due to several reasons:

    1. The import statement `import nonexistentlibrary` is trying to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The function `main` has been renamed to `broken_function`, which will cause an error if the code expects a function named `main`.
    3. Inside the function, `auth['api_key']` is used, but the correct key according to the `telegram` TypedDict is `token`. This will raise a `KeyError`.
    4. The method `sendImage` is not a valid Telegram API method. The correct method is `sendPhoto`, and using an incorrect method will result in an API error.
    5. The parameter `'image': photo` is incorrect. The correct parameter name for sending a photo is `'photo'`.
    6. The function returns `response.text` instead of `response.json()`. While this change will not break the code, it will change the return type from a JSON object to a raw text string, which may not be the expected behavior.
  id: |-
    hubfix_hub_236
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Union, Optional
    import requests

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], photo: str, reply_to_message_id: Optional[int] = None):
        token = auth['token']
        method = 'sendPhoto'
        url = f"https://api.telegram.org/bot{token}/{method}"
        data = {
            'chat_id': chat_id,
            'photo': photo,
            'reply_to_message_id': reply_to_message_id
        }
        response = requests.post(url, data=data)
        return response.json()
  original_instructions: |-
    Send a Photo in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, spreadsheetId: str) -> List[dict]:
        token = gsheets_auth["token"]

        GET_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}?&fields=sheets.properties'

        response = nonexistentlibrary.get(GET_WORKSHEET_URL, headers={
            'Authorization': 'Bearer ' + token,
            'Content-Type': 'application/json',
        })
        text = response.json()

        list = []
        for i in text["sheets"]:
            list.append({
                'sheetId': i["properties"]["sheetId"],
                'title': i["properties"]["title"],
            })

        return list
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if there is code elsewhere expecting a function named `main`. Lastly, the `requests.get` method has been replaced with `nonexistentlibrary.get`, which will fail because `nonexistentlibrary` does not exist and therefore does not have a `get` method.
  id: |-
    hubfix_hub_68
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str) -> List[dict]:
        token = gsheets_auth["token"]

        GET_WORKSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}?&fields=sheets.properties'

        response = requests.get(GET_WORKSHEET_URL, headers={
            'Authorization': 'Bearer ' + token,
            'Content-Type': 'application/json',
        })
        text = response.json()

        list = []
        for i in text["sheets"]:
            list.append({
                'sheetId': i["properties"]["sheetId"],
                'title': i["properties"]["title"],
            })

        return list
  original_instructions: |-
    List Worksheets in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str

    def launch(auth: slack_resource, chat_id: str):
        client = TeleBot(auth['token'])
        return client.fetch_chat_user_count(chat_id)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 9, in <module>
        launch({'api_key': '12345'}, 'chat_id')
      File "script.py", line 7, in launch
        client = TeleBot(auth['token'])
    KeyError: 'token'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` class was renamed from `telegram` to `slack_resource`, and the key was changed from `token` to `api_key`. However, the `launch` function still tries to access `auth['token']`, which does not exist in the `slack_resource` TypedDict, resulting in a `KeyError`.

    2. The `main` function was renamed to `launch`, which by itself is not an error, but if there is code elsewhere expecting a function named `main`, this would cause an issue.

    3. The method `fetch_chat_user_count` does not exist in the `TeleBot` class. The correct method name is `get_chat_members_count`, so calling `fetch_chat_user_count` will result in an `AttributeError`.

    To fix the code, the `TypedDict` should be named `telegram` with a key `token`, the function should be named `main`, and the correct method `get_chat_members_count` should be called on the `TeleBot` client.
  id: |-
    hubfix_hub_242
  lang: |-
    python
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str):
        client = TeleBot(auth['token'])
        return client.get_chat_members_count(chat_id)
  original_instructions: |-
    Get the Number of Members in a Chat in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import base64
    import json
    import requests
    from typing import TypedDict

    class gmail_resource(TypedDict):
        access_token: str

    def main(gmail_auth: gmail_resource, to_email: str, subject: str, message: str, user_id: str = "me"):
        token = gmail_auth["token"]
        if not token:
            raise ValueError("""
            No authentication token was found.
            Go to "https://app.windmill.dev/resources?connect_app=gmail" to connect gmail,
            then select your token from the dropdown in the arguments window.
            (Click "Refresh" if you don't see your resource in the list.)\n""")

        text = f"From: <{user_id}>\nTo: <{to_email}>\nSubject: {subject}\n\n{message}"
        email = base64.urlsafe_b64encode(text.encode("utf-8")).decode("utf-8")
        body = json.dumps({
            "raw": email
        })
        SEND_URL = f"https://gmail.googleapis.com/gmail/v1/users/{user_id}/messages/send"

        response = requests.post(SEND_URL, headers={"Authorization": f"Bearer {token}"}, data=body)
        result = handle_send_email_result(response.json(), to_email)
        return result

    def handle_send_email_result(result: dict, to_email: str):
        if "error" in result:
            raise ValueError({ "wm_to_email": to_email, **result })

        return result
  error: |-
    KeyError: 'token'
  explanation: |-
    The TypedDict `gmail` was renamed to `gmail_resource`, and the key `token` was changed to `access_token`. However, the code inside the `main` function still tries to access `gmail_auth["token"]`, which no longer exists in the `gmail_resource` TypedDict. This results in a `KeyError` because the key 'token' does not exist in the `gmail_auth` dictionary.
  id: |-
    hubfix_hub_194
  lang: |-
    python
  original_code: |-
    import base64
    import json
    import requests
    from typing import TypedDict

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, to_email: str, subject: str, message: str, user_id: str = "me"):
        token = gmail_auth["token"]
        if not token:
            raise ValueError("""
            No authentication token was found.
            Go to "https://app.windmill.dev/resources?connect_app=gmail" to connect gmail,
            then select your token from the dropdown in the arguments window.
            (Click "Refresh" if you don't see your resource in the list.)\n""")

        text = f"From: <{user_id}>\nTo: <{to_email}>\nSubject: {subject}\n\n{message}"
        email = base64.urlsafe_b64encode(text.encode("utf-8")).decode("utf-8")
        body = json.dumps({
            "raw": email
        })
        SEND_URL = f"https://gmail.googleapis.com/gmail/v1/users/{user_id}/messages/send"

        response = requests.post(SEND_URL, headers={"Authorization": f"Bearer {token}"}, data=body)
        result = handle_send_email_result(response.json(), to_email)
        return result

    def handle_send_email_result(result: dict, to_email: str):
        if "error" in result:
            raise ValueError({ "wm_to_email": to_email, **result })

        return result
  original_instructions: |2-
     Send Email in gmail
  resource_type: |-
    gmail
  resource_type_def: |-
    class gmail(TypedDict):
        token: str
- broken_code: |-
    import base64
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.backends import default_backend
    from typing import TypedDict
    import os

    class client(TypedDict):
        client: str

    def main(client: int) -> int:
        encoded = client.encode('utf-8')

        private_key_pem = os.environ.get("YOUR_PRIVATE_KEY_PEM")
        if private_key_pem is None:
            raise ValueError("Private key not found")

        private_key = import_private_key(private_key_pem)

        signature = private_key.sign(
            encoded,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=32
            ),
            hashes.SHA256()
        )

        license_key = f"{base64.b64encode(encoded).decode('utf-8')}.{base64.b64encode(signature).decode('utf-8')}"

        return license_key

    def import_private_key(pem: str):
        private_key = load_pem_private_key(
            pem.encode('utf-8'),
            password=None,
            backend=default_backend()
        )
        return private_key
  error: |-
    AttributeError: 'int' object has no attribute 'encode'
  explanation: |-
    The `main` function has been changed to accept an `int` as its parameter instead of a `str`, and it also incorrectly attempts to return an `int`. However, the `client` parameter is used as if it were a string with the `encode` method, which is not available on integers. This results in an `AttributeError` because integers do not have an `encode` method. Additionally, the return type of the function should be `str` instead of `int` because the function is returning a license key which is a string, not an integer.
  id: |-
    hubfix_hub_278
  lang: |-
    python
  original_code: |-
    import base64
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.serialization import load_pem_private_key
    from cryptography.hazmat.backends import default_backend
    from typing import TypedDict
    import os

    class client(TypedDict):
        client: str

    def main(client: str) -> str:
        encoded = client.encode('utf-8')

        # Replace this with the actual way you retrieve your private key
        private_key_pem = os.environ.get("YOUR_PRIVATE_KEY_PEM")
        if private_key_pem is None:
            raise ValueError("Private key not found")

        private_key = import_private_key(private_key_pem)

        signature = private_key.sign(
            encoded,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=32
            ),
            hashes.SHA256()
        )

        # Combine the encoded data and signature to create a license key
        license_key = f"{base64.b64encode(encoded).decode('utf-8')}.{base64.b64encode(signature).decode('utf-8')}"

        return license_key

    def import_private_key(pem: str):
        private_key = load_pem_private_key(
            pem.encode('utf-8'),
            password=None,
            backend=default_backend()
        )
        return private_key
  original_instructions: |-
    Generate a license key using RSA PSS for a customer in helper
  resource_type: |-
    client
  resource_type_def: |-
    class client(TypedDict):
        client: str
- broken_code: |-
    import os
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def broken_function(discord_webhook: discordwebhook, message: str, name: str):
        flow_id = os.environ.get("WM_FLOW_JOB_ID")
        message = f"Flow [{flow_id}]({os.environ.get('WM_BASE_URL')}/run/{flow_id}?workspace={os.environ.get('WM_WORKSPACE')}) had an error:\n{name}: {message}"
        response = nonexistentlibrary.post(discord_webhook['webhook_url'], json={"content": message})  # nonexistentlibrary does not have a post method
        return response
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `requests.post` method is incorrectly replaced with `nonexistentlibrary.post`, which would also cause an AttributeError if the nonexistent library import error was resolved.
  id: |-
    hubfix_hub_291
  lang: |-
    python
  original_code: |-
    import os
    import requests
    from typing import TypedDict

    class discordwebhook(TypedDict):
        webhook_url: str

    def main(discord_webhook: discordwebhook, message: str, name: str):
        flow_id = os.environ.get("WM_FLOW_JOB_ID")
        message = f"Flow [{flow_id}]({os.environ.get('WM_BASE_URL')}/run/{flow_id}?workspace={os.environ.get('WM_WORKSPACE')}) had an error:\n{name}: {message}"
        response = requests.post(discord_webhook['webhook_url'], json={"content": message})
        return response
  original_instructions: |-
    Send the error to discord in discord
  resource_type: |-
    discordwebhook
  resource_type_def: |-
    class discordwebhook(TypedDict):
        webhook_url: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def broken_function(gh_auth: github, username: int):
        headers = {
            "Authorization": f"token {gh_auth['nonexistent_property']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        response = nonexistentlibrary.get(f"https://api.github.com/users/{username}", headers=headers)
        return response.get_json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `broken_function` is expecting an `int` for the `username` parameter, but the GitHub API requires a string for the username.
    3. `gh_auth['nonexistent_property']` is trying to access a property `nonexistent_property` that does not exist in the `github` TypedDict.
    4. `nonexistentlibrary.get` is called, but `nonexistentlibrary` does not exist, which would raise a `NameError` if the import error was ignored.
    5. `response.get_json()` is incorrect because the correct method to get JSON from a `requests.Response` object is `response.json()`, not `get_json()`.
  id: |-
    hubfix_hub_316
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def main(gh_auth: github, username: str):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        response = requests.get(f"https://api.github.com/users/{username}", headers=headers)
        return response.json()
  original_instructions: |-
    Get a user in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, spreadsheetId: str):
        token = gsheets_auth["token"]
        GET_SPREADSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}'

        response = nonexistentlibrary.get(
            GET_SPREADSHEET_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the function `nonexistentlibrary.get` is called, which would also break the code because `nonexistentlibrary` does not exist, and even if it did, it might not have a `get` method.
  id: |-
    hubfix_hub_51
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, spreadsheetId: str):
        token = gsheets_auth["token"]
        GET_SPREADSHEET_URL = f'https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}'

        response = requests.get(
            GET_SPREADSHEET_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        return response.json()
  original_instructions: |-
    Get Spreadsheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Optional, Dict, Any

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Optional[Dict[str, Any]] = None,
        projection: Optional[Dict[str, int]] = None,
        sort: Optional[Dict[str, int]] = None,
        limit: Optional[int] = None,
        skip: Optional[int] = None,
    ):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        options = remove_empty_fields({'projection': projection, 'sort': sort, 'limit': limit, 'skip': skip})
        return list(coll.find(filter, **options))

    main(
        auth={'endpoint': 'mongodb://localhost:27017', 'api_key': 'secret'},
        data_source='myDataSource',
        database='myDatabase',
        collection='myCollection',
        filter={'name': 'John Doe'},
        projection={'name': 1, '_id': 0},
        sort={'age': -1},
        limit='10',  # This should be an integer, not a string
        skip=5
    )
  error: |-
    TypeError: 'limit' field must be numeric, not <class 'str'>
  explanation: |-
    The error occurs because the `limit` parameter is expected to be an integer, but a string is passed instead. The `limit` parameter in the `find` method of a MongoDB collection is used to specify the maximum number of documents to return, and it must be a numeric value. Passing a string '10' instead of an integer 10 causes the `TypeError`.
  id: |-
    hubfix_hub_256
  lang: |-
    python
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Optional, Dict, Any

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: mongodbrest,
        data_source: str,
        database: str,
        collection: str,
        filter: Optional[Dict[str, Any]] = None,
        projection: Optional[Dict[str, int]] = None,
        sort: Optional[Dict[str, int]] = None,
        limit: Optional[int] = None,
        skip: Optional[int] = None,
    ):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[database]
        coll = db[collection]
        options = remove_empty_fields({'projection': projection, 'sort': sort, 'limit': limit, 'skip': skip})
        return list(coll.find(filter, **options))
  original_instructions: |-
    Search Documents in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    import nonexistentlibrary
    from typing import List, Optional, TypedDict

    class slack_resource(TypedDict):
        api_key: str
        server: str

    def broken_function(
        auth: slack_resource,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        type: Optional[str] = None,
        since_created_at: Optional[str] = None,
        before_created_at: Optional[str] = None,
        since_updated_at: Optional[str] = None,
        before_updated_at: Optional[str] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
    ):
        url = f"https://{auth['server_resource']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'type': type,
            'since_created_at': since_created_at,
            'before_created_at': before_created_at,
            'since_updated_at': since_updated_at,
            'before_updated_at': before_updated_at,
            'include_cleaned': include_cleaned,
            'include_transactional': include_transactional,
            'include_unsubscribed': include_unsubscribed,
        }
        params = {k: v for k, v in params.items() if v is not None}

        response = nonexistentlibrary.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:

    1. `import nonexistentlibrary`: The script is trying to import a library named `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError`.

    2. `class slack_resource(TypedDict)`: The original `TypedDict` named `mailchimp` has been renamed to `slack_resource`. This will cause an error if the `TypedDict` is used elsewhere in the code with its original name.

    3. `def broken_function(`: The function `main` has been renamed to `broken_function`. If there is code that expects a function named `main`, this will cause an error.

    4. `url = f"https://{auth['server_resource']}.api.mailchimp.com/3.0/lists/{list_id}/segments"`: The `TypedDict` `auth` does not have a key named `server_resource`, which will raise a `KeyError` when trying to access it.

    5. `response = nonexistentlibrary.get(url, headers={...}, params=params)`: The script is trying to use a method `get` from the non-existent library `nonexistentlibrary`. This will raise a `NameError` because `nonexistentlibrary` is not defined.
  id: |-
    hubfix_hub_211
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, Optional, TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        type: Optional[str] = None,
        since_created_at: Optional[str] = None,
        before_created_at: Optional[str] = None,
        since_updated_at: Optional[str] = None,
        before_updated_at: Optional[str] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'type': type,
            'since_created_at': since_created_at,
            'before_created_at': before_created_at,
            'since_updated_at': since_updated_at,
            'before_updated_at': before_updated_at,
            'include_cleaned': include_cleaned,
            'include_transactional': include_transactional,
            'include_unsubscribed': include_unsubscribed,
        }
        # Remove None values
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Search Segments in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    import nonexistentlibrary
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}?"
        if fields and not exclude_fields:
            url += f"fields={','.join(fields)}"
        if exclude_fields:
            url += f"{'&' if fields else ''}exclude_fields={','.join(exclude_fields)}"

        response = nonexistentlibrary.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find the specified module. Additionally, the `TypedDict` `mailchimp` has a key `server_prefix` which is not used in the function, and the key `server` which is used in the function is not defined in the `TypedDict`. This would cause a `KeyError` if the `ModuleNotFoundError` was resolved and the code attempted to access `auth['server']`. Lastly, the function `nonexistentlibrary.get` is called, but since `nonexistentlibrary` does not exist, this would also cause a `NameError` if the import error was fixed.
  id: |-
    hubfix_hub_200
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str, fields: Optional[List[str]] = None, exclude_fields: Optional[List[str]] = None):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}?"
        if fields and not exclude_fields:
            url += f"fields={','.join(fields)}"
        if exclude_fields:
            url += f"{'&' if fields else ''}exclude_fields={','.join(exclude_fields)}"

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Get Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    import nonexistentlibrary
    from typing import List, TypedDict, Optional

    class slack_resource(TypedDict):
        api_key: str
        server: str

    def broken_function(
        auth: slack_resource,
        list_id: str,
        segment_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
    ):
        base_url = f"https://{auth['server_resource']}.api.mailchimp.com/3.0/lists/{list_id}/segments/{segment_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_cleaned': str(include_cleaned).lower() if include_cleaned is not None else None,
            'include_transactional': str(include_transactional).lower() if include_transactional is not None else None,
            'include_unsubscribed': str(include_unsubscribed).lower() if include_unsubscribed is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_secret"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:

    1. `import nonexistentlibrary`: This line attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. `class slack_resource(TypedDict)`: The original `mailchimp` TypedDict class has been renamed to `slack_resource`, which is not defined anywhere in the code. This will cause a `NameError` if `slack_resource` is used.
    3. `auth['server_resource']`: The `server_resource` key does not exist in the `auth` dictionary. The original key was `server`. This will raise a `KeyError`.
    4. `auth["api_secret"]`: The `api_secret` key does not exist in the `auth` dictionary. The original key was `api_key`. This will also raise a `KeyError`.
    5. `def broken_function`: The function has been renamed from `main` to `broken_function`. If the script relies on a function named `main`, this change will cause issues when trying to call the expected `main` function.
  id: |-
    hubfix_hub_212
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        segment_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_cleaned: Optional[bool] = None,
        include_transactional: Optional[bool] = None,
        include_unsubscribed: Optional[bool] = None,
    ):
        base_url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}/segments/{segment_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_cleaned': str(include_cleaned).lower() if include_cleaned is not None else None,
            'include_transactional': str(include_transactional).lower() if include_transactional is not None else None,
            'include_unsubscribed': str(include_unsubscribed).lower() if include_unsubscribed is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(base_url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Get Segment in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, name: str, id: Optional[str] = None):
        client = Client() \
            .set_endpoint(auth['endpoint']) \
            .set_project(auth['project']) \
            .set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        unique_id = id or 'unique()'  # Replace 'unique()' with actual unique ID generation logic
        return db.create_document(database_id='default', collection_id='unique_collection_id', document_id=unique_id, data={'fullname': name})
  error: |-
    KeyError: 'fullname'
  explanation: |-
    The error occurs because the `data` dictionary passed to `db.create_document` contains a key `'fullname'` which is not expected by the Appwrite database schema for the collection with the ID `'unique_collection_id'`. The schema likely expects a key `'name'` instead of `'fullname'`. To fix the error, the key in the `data` dictionary should match the expected schema of the Appwrite collection.
  id: |-
    hubfix_hub_326
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, name: str, id: Optional[str] = None):
        client = Client() \
            .set_endpoint(auth['endpoint']) \
            .set_project(auth['project']) \
            .set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        unique_id = id or 'unique()'  # Replace 'unique()' with actual unique ID generation logic
        return db.create_document(database_id='default', collection_id='unique_collection_id', document_id=unique_id, data={'name': name})
  original_instructions: |-
    Create Database in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    from typing import TypedDict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class slack_resource(TypedDict):
        endpoint: str
        project: str
        api_key: str
        self_signed: bool

    def initialize(auth: slack_resource, database_id: str, collection_id: str, queries: List[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint_url'])
        client.set_project(auth['project_id'])
        client.set_key(auth['api_key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        result = db.get_all_documents(database_id, collection_id, query=queries)
        return result
  error: |-
    AttributeError: 'Client' object has no attribute 'set_endpoint_url'
  explanation: |-
    The code is broken due to several changes:
    1. The TypedDict class name was changed from `appwrite` to `slack_resource`, which is not consistent with the usage in the function.
    2. The `main` function was renamed to `initialize`, which would break any code that expects a function named `main`.
    3. The dictionary key 'endpoint' was changed to 'endpoint_url' in the function, but not in the TypedDict definition.
    4. The dictionary key 'project' was changed to 'project_id' in the function, but not in the TypedDict definition.
    5. The `Client` object does not have a method `set_endpoint_url`; it should be `set_endpoint`.
    6. The `Databases` object does not have a method `get_all_documents`; it should be `list_documents`.
    7. The parameter `query` should be `queries` in the `list_documents` method call.
  id: |-
    hubfix_hub_335
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, List
    from appwrite.client import Client
    from appwrite.services.databases import Databases

    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool

    def main(auth: appwrite, database_id: str, collection_id: str, queries: List[str] = None):
        client = Client()
        client.set_endpoint(auth['endpoint'])
        client.set_project(auth['project'])
        client.set_key(auth['key'])

        if auth['self_signed']:
            client.set_self_signed()

        db = Databases(client)

        result = db.list_documents(database_id, collection_id, queries=queries)
        return result
  original_instructions: |-
    List Documents in appwrite
  resource_type: |-
    appwrite
  resource_type_def: |-
    class appwrite(TypedDict):
        endpoint: str
        project: str
        key: str
        self_signed: bool
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional

    class windmill(TypedDict):
        approvalPage: str

    def get_resume_urls(approver: Optional[str] = None) -> windmill:
        response = nonexistentlibrary.get('http://api.example.com/getResumeUrls', params={'approver': approver})
        response.raise_for_status()
        return response.json()

    def main(approver: Optional[str] = None) -> windmill:
        endpoints = get_resume_urls(approver)
        print(f"Approval page at {endpoints['nonExistentKey']}")
        return endpoints
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, within the `main` function, the code attempts to access a key `'nonExistentKey'` from the `endpoints` dictionary, which is not defined in the `windmill` TypedDict and would result in a `KeyError` if the code execution reached that point.
  id: |-
    hubfix_hub_172
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class windmill(TypedDict):
        approvalPage: str

    def get_resume_urls(approver: Optional[str] = None) -> windmill:
        # Assuming there's an equivalent API endpoint to get resume URLs
        # Replace 'http://api.example.com/getResumeUrls' with the actual API endpoint
        response = requests.get('http://api.example.com/getResumeUrls', params={'approver': approver})
        response.raise_for_status()
        return response.json()

    def main(approver: Optional[str] = None) -> windmill:
        endpoints = get_resume_urls(approver)
        print(f"Approval page at {endpoints['approvalPage']}")
        return endpoints
  original_instructions: |-
    Return resume and cancel endpoints in windmill
  resource_type: |-
    windmill
  resource_type_def: |-
    class windmill(TypedDict):
        approvalPage: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional, Dict, Any

    class github(TypedDict):
        token: str

    def broken_function(
        gh_auth: github,
        owner: str,
        repo: str,
        workflow_id: str,
        ref: str,
        inputs: Optional[Dict[str, Any]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        payload = {
            "ref": ref,
            "inputs": inputs or {},
        }
        response = nonexistentlibrary.post(url, headers=headers, json=payload)
        return response
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module. Additionally, the function `nonexistentlibrary.post` is called, which would also break the code because `nonexistentlibrary` does not exist, and even if it did, it might not have a `post` method.
  id: |-
    hubfix_hub_312
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional, Dict, Any

    class github(TypedDict):
        token: str

    def main(
        gh_auth: github,
        owner: str,
        repo: str,
        workflow_id: str,
        ref: str,
        inputs: Optional[Dict[str, Any]] = None
    ):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json",
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        payload = {
            "ref": ref,
            "inputs": inputs or {},
        }
        response = requests.post(url, headers=headers, json=payload)
        return response
  original_instructions: |-
    Dispatch Workflow Run in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- broken_code: |-
    import requests
    from typing import List, TypedDict

    class hackernews(TypedDict):
        text: str

    MAX_LOOKBACK = 100

    def get_state():
        with open('state.txt', 'r') as file:
            return int(file.read().strip())

    def set_state(state):
        with open('state.txt', 'w') as file:
            file.write(state)

    def get_max_item():
        res = requests.get("https://hacker-news.firebaseio.com/v0/maxitem.json")
        return int(res.text)

    def get_item(id: int) -> hackernews:
        res = requests.get(f"https://hacker-news.firebaseio.com/v0/item/{id}.json")
        return res.json()

    def main(mentions: List[str]):
        last_state = get_state()
        max_item = get_max_item()

        if last_state is None:
            last_state = max_item - MAX_LOOKBACK
        max_item = min(max_item, last_state + MAX_LOOKBACK)

        items = []
        for i in range(last_state, max_item):
            item = get_item(i)
            if any(mention.strip().lower() in (item.get('content') or '').lower() for mention in mentions):
                items.append(item)

        set_state(max_item)

        return items
  error: |-
    TypeError: write() argument must be str, not int
  explanation: |-
    The `set_state` function attempts to write an integer to a file without converting it to a string first. The `write()` method of file objects expects a string argument, not an integer. To fix this, the integer `state` should be converted to a string using `str(state)` before being passed to `file.write()`.
  id: |-
    hubfix_hub_88
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, TypedDict

    class hackernews(TypedDict):
        text: str

    MAX_LOOKBACK = 100

    def get_state():
        # Replace with actual state retrieval logic
        # For example, reading from a file or a database
        try:
            with open('state.txt', 'r') as file:
                return int(file.read().strip())
        except FileNotFoundError:
            return None

    def set_state(state):
        # Replace with actual state saving logic
        # For example, writing to a file or a database
        with open('state.txt', 'w') as file:
            file.write(str(state))

    def get_max_item():
        res = requests.get("https://hacker-news.firebaseio.com/v0/maxitem.json")
        return int(res.text)

    def get_item(id: int) -> hackernews:
        res = requests.get(f"https://hacker-news.firebaseio.com/v0/item/{id}.json")
        return res.json()

    def main(mentions: List[str]):
        last_state = get_state()
        max_item = get_max_item()

        if last_state is None:
            last_state = max_item - MAX_LOOKBACK
        max_item = min(max_item, last_state + MAX_LOOKBACK)

        items = []
        for i in range(last_state, max_item):
            item = get_item(i)
            if any(mention.strip().lower() in (item.get('text') or '').lower() for mention in mentions):
                items.append(item)

        set_state(max_item)

        return items
  original_instructions: |-
    Trigger everytime a new item text on HackerNews match at least one mention in hackernews
  resource_type: |-
    hackernews
  resource_type_def: |-
    class hackernews(TypedDict):
        text: str
- broken_code: |-
    import nonexistent_library
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, charge_id: str):
        token = stripe_con["token"]
        nonexistent_library.api_key = token

        refund = nonexistent_library.Refund.create(
            charge=charge_id
        )

        return refund
  error: |-
    ModuleNotFoundError: No module named 'nonexistent_library'
  explanation: |-
    The code attempts to import a library named `nonexistent_library`, which does not exist. Python raises a `ModuleNotFoundError` because it cannot find a module with that name. Additionally, the code tries to use `nonexistent_library.api_key` and `nonexistent_library.Refund.create`, which would also fail even if the import statement was corrected, because these attributes or methods are not part of the `stripe_module` that was originally used.
  id: |-
    hubfix_hub_125
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, charge_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        refund = stripe_module.Refund.create(
            charge=charge_id
        )

        return refund
  original_instructions: |-
    Create a Refund in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import urllib.parse
    import nonexistentlibrary  # This library does not exist
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None):
        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{urllib.parse.quote(room_id)}/state/{urllib.parse.quote(type)}/"  # Incorrect dictionary key
        if state_key:
            url += urllib.parse.quote(state_key)
        resp = nonexistentlibrary.get(url, headers={  # Using a function from a nonexistent library
            'Authorization': f"Bearer {matrix_res['token']}",
        })
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return {
            'content': resp.json(),
        }

    main({'baseUrl': 'https://matrix.org', 'token': 'sometoken'}, '!roomid:matrix.org', 'm.room.message')
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, within the `main` function, it tries to use `nonexistentlibrary.get`, which is a function call to a nonexistent library, leading to a runtime error if the import error was ignored. Furthermore, the dictionary key `'baseURL'` is incorrect; it should be `'baseUrl'` as defined in the `matrix` TypedDict.
  id: |-
    hubfix_hub_159
  lang: |-
    python
  original_code: |-
    import urllib.parse
    import requests
    from typing import TypedDict, Optional

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, type: str, state_key: Optional[str] = None):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{urllib.parse.quote(room_id)}/state/{urllib.parse.quote(type)}/"
        if state_key:
            url += urllib.parse.quote(state_key)
        resp = requests.get(url, headers={
            'Authorization': f"Bearer {matrix_res['token']}",
        })
        if not resp.ok:
            raise Exception(f"Failed to read room state: Error HTTP{resp.status_code}")
        return {
            'content': resp.json(),
        }
  original_instructions: |-
    Get room state by type and state_key in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gcal(TypedDict):
        token: str
        extra_field: int

    def broken_function(gcal_auth: gcal, calendarId: str, eventId: int):
        sendUpdates = "all"
        DELETE_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?sendUpdates={sendUpdates}"
        token = gcal_auth["token"]

        response = nonexistentlibrary.delete(
            DELETE_EVENT_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The `import nonexistentlibrary` statement is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    - The function `broken_function` is called instead of `main`, which by itself is not an error, but if the script expects a function named `main`, this will cause an issue.
    - The `eventId` parameter type has been changed from `str` to `int`, which could cause issues if the API expects a string.
    - The `nonexistentlibrary.delete` call is trying to use a method from a library that doesn't exist, which will raise a `NameError` if the script somehow gets past the import error.
    - The `gcal` TypedDict has been given an extra field `extra_field` that is not used anywhere in the function, which is not an error by itself but is unnecessary and could be misleading.
    - The `response.json()` call at the end will fail if the `response` object does not have a `json` method, which will be the case since `nonexistentlibrary.delete` would not return a valid response object.
  id: |-
    hubfix_hub_44
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str, eventId: str):
        sendUpdates = "all"
        DELETE_EVENT_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?sendUpdates={sendUpdates}"
        token = gcal_auth["token"]

        response = requests.delete(
            DELETE_EVENT_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response
  original_instructions: |-
    Delete Event in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str
        server: str

    def broken_function(auth: slack_resource, campaign_id: str):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/publish"
        response = nonexistentlibrary.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` class is renamed from `mailchimp` to `slack_resource`, which is not used anywhere and will cause confusion.
    3. The `main` function is renamed to `broken_function`, which will cause an issue if the function is expected to be called as `main` elsewhere.
    4. The `requests.post` method is replaced with `nonexistentlibrary.post`, which will raise a `NameError` because `nonexistentlibrary` does not exist.
    5. The API endpoint is changed from `/actions/send` to `/actions/publish`, which may not exist or may not be the correct endpoint for sending a campaign.
    6. The return statement is changed from `return response.json()` to `return response.text`, which changes the return type and may not be the expected behavior.
  id: |-
    hubfix_hub_203
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/send"
        response = requests.post(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Send a Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Any

    class appdata(TypedDict):
        apps: List[Any]

    def broken_function() -> appdata:
        url = "https://hub.windmill.dev/searchAppData"
        response = nonexistentlibrary.get(url)
        return response.jsonify()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if the script relies on a function named `main`. Furthermore, the code attempts to call `nonexistentlibrary.get(url)`, which will fail because `nonexistentlibrary` is not a real module. Lastly, `response.jsonify()` is incorrect because the correct method to parse JSON from a response object in the `requests` library is `response.json()`, not `response.jsonify()`.
  id: |-
    hubfix_hub_167
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class appdata(TypedDict):
        apps: List[Any]

    def main() -> appdata:
        url = "https://hub.windmill.dev/searchAppData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List Apps in windmillhub
  resource_type: |-
    appdata
  resource_type_def: |-
    class appdata(TypedDict):
        apps: List[Any]
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):  # Changed the name of the TypedDict
        token: str

    def main(slack_auth: slack, channel: str):  # The TypedDict name is not updated here
        web = WebClient(token=slack_auth['api_key'])  # Changed 'token' to 'api_key'

        response = web.conversations_exit(  # Changed 'conversations_leave' to 'conversations_exit'
            channel=channel
        )

        return response  # Changed the return type
  error: |-
    TypeError: TypedDict "slack" has no key 'api_key'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict class was renamed from `slack` to `slack_resource`, but the parameter type in the `main` function was not updated to reflect this change. It should be `slack_auth: slack_resource`.

    2. Inside the `main` function, `slack_auth['api_key']` is used, but the `slack_resource` TypedDict only defines a key named `token`. There is no key `api_key` in the TypedDict.

    3. The method `conversations_exit` does not exist in the `slack_sdk.WebClient`. The correct method name is `conversations_leave`.

    4. The return statement was changed from `return {'response': response}` to `return response`, which changes the return type of the function. If the function is expected to return a dictionary with a key 'response', this change will break the code where the function's return value is used.
  id: |-
    hubfix_hub_23
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_leave(
            channel=channel
        )

        return {'response': response}
  original_instructions: |-
    Leave Channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.contacts import SimplePublicObjectInput

    class slack_resource(TypedDict):
        api_key: str

    def remove_object_empty_fields(d: dict) -> list:
        return [k for k, v in d.items() if v is not None and v != '']

    def main(auth: slack_resource, company: Optional[str] = None, email: Optional[str] = None,
             firstname: Optional[int] = None, lastname: Optional[str] = None,
             phone: Optional[str] = None, website: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'company': company,
            'email': email,
            'firstname': firstname,
            'lastname': lastname,
            'phone': phone,
            'website': website,
        })
        try:
            return client.crm.contacts.basic_api.create(SimplePublicObjectInput(properties=properties))
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  error: |-
    KeyError: 'token'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` was renamed from `hubspot` to `slack_resource`, but the `main` function still expects a dictionary with a 'token' key, which does not exist in `slack_resource` (it has 'api_key' instead). This will raise a `KeyError` when `auth['token']` is accessed.

    2. The `remove_object_empty_fields` function was changed to return a list instead of a dictionary. This will cause an error when the `SimplePublicObjectInput` constructor expects a dictionary for the `properties` parameter but receives a list instead.

    3. The `firstname` parameter in the `main` function was changed to expect an `Optional[int]` instead of `Optional[str]`. This is incorrect because the properties expected by the HubSpot API are strings, not integers.

    4. The `TypedDict` definition was changed from `hubspot` to `slack_resource`, which is not used anywhere in the code. This change by itself would not break the code, but it is an inconsistency that could lead to confusion.

    To fix the code, the `TypedDict` should be named correctly (e.g., `hubspot`), the `remove_object_empty_fields` function should return a dictionary, the `firstname` parameter should be `Optional[str]`, and the `auth` dictionary should contain the correct key ('token' or 'api_key') as expected by the rest of the code.
  id: |-
    hubfix_hub_226
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.contacts import SimplePublicObjectInput

    class hubspot(TypedDict):
        token: str

    def remove_object_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None and v != ''}

    def main(auth: hubspot, company: Optional[str] = None, email: Optional[str] = None,
             firstname: Optional[str] = None, lastname: Optional[str] = None,
             phone: Optional[str] = None, website: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'company': company,
            'email': email,
            'firstname': firstname,
            'lastname': lastname,
            'phone': phone,
            'website': website,
        })
        try:
            return client.crm.contacts.basic_api.create(SimplePublicObjectInput(properties=properties))
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  original_instructions: |-
    Create Contact in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- broken_code: |-
    from slack_sdk import WebClient
    from typing import TypedDict

    class slack_resource(TypedDict):  # Changed the name of the TypedDict
        token: str

    def main(text: str, channel: str, slack: slack_resource):
        web = WebClient(token=slack['api_key'])  # Changed the key to a non-existent one
        web.chat_postMessage(channel=channel, text=text)

    main("Hello, world!", "#general", {"token": "xoxb-..."})
  error: |-
    TypeError: 'slack' object is not subscriptable
  explanation: |-
    The code is broken because of two changes:

    1. The TypedDict class name was changed from `slack` to `slack_resource`, but the parameter type in the `main` function was not updated to reflect this change. This would cause a type error if type checking was enforced, but Python's runtime does not enforce type annotations, so this would not cause an immediate runtime error.

    2. The key used to access the token in the `slack` dictionary was changed from `'token'` to `'api_key'`. Since `'api_key'` does not exist in the provided dictionary, this would result in a KeyError at runtime. However, the error message provided does not match this issue. The correct error message for this issue would be a KeyError.

    The provided error message "TypeError: 'slack' object is not subscriptable" suggests that the `slack` parameter is not a dictionary or does not support the subscription operation (i.e., using square brackets to access items). This error message would occur if the `slack` parameter was passed an incorrect type that does not support item access, such as an instance of a class without a `__getitem__` method. However, this does not match the changes made to the code, so the error message seems to be incorrect for the given code changes.
  id: |-
    hubfix_hub_72
  lang: |-
    python
  original_code: |-
    from slack_sdk import WebClient
    from typing import TypedDict

    class slack(TypedDict):
        token: str

    def main(text: str, channel: str, slack: slack):
        web = WebClient(token=slack['token'])
        web.chat_postMessage(channel=channel, text=text)
  original_instructions: |-
    Send Message to Channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        balance_transactions = stripe_module.NonExistentMethod(limit=limit)

        return balance_transactions
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a module named 'nonexistentlibrary' which does not exist. This will raise a `ModuleNotFoundError` when Python cannot find the specified module. Additionally, the `limit` parameter in the `main` function has been changed to expect a string instead of an integer, which would cause a type error if the `ModuleNotFoundError` was resolved. Furthermore, the `stripe_module.NonExistentMethod` is called, which would fail because `NonExistentMethod` does not exist in the `stripe_module`.
  id: |-
    hubfix_hub_126
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: int):
        token = stripe_con["token"]
        stripe_module.api_key = token

        balance_transactions = stripe_module.BalanceTransaction.list(limit=limit)

        return balance_transactions
  original_instructions: |-
    List Balance History in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class stripe_config(TypedDict):
        api_key: str

    def main(sk: stripe_config, subscriptionId: str, quantity: str):
        client = stripe.StripeClient(sk['token'])
        stripe.api_version = "2022-11-15"

        return client.SubscriptionItem.create_usage_record(subscriptionId, {
            'amount': quantity,
        })
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, there are other issues:
    - The `quantity` parameter in the `main` function is expected to be an `int`, but it has been changed to a `str`, which is incorrect for the usage record creation.
    - The `stripe_config` TypedDict has a key `api_key` instead of `token`, but the `main` function still tries to access `sk['token']`.
    - The `create_usage_record` method is called with a dictionary containing `'amount'` instead of `'quantity'`, which is not the correct parameter for creating a usage record.
  id: |-
    hubfix_hub_127
  lang: |-
    python
  original_code: |-
    import stripe
    from typing import TypedDict

    class stripe_config(TypedDict):
        token: str

    def main(sk: stripe_config, subscriptionId: str, quantity: int):
        client = stripe.StripeClient(sk['token'])
        stripe.api_version = "2022-11-15"

        return client.SubscriptionItem.create_usage_record(subscriptionId, {
            'quantity': quantity,
        })
  original_instructions: |-
    Create Usage Record in stripe
  resource_type: |-
    stripe_config
  resource_type_def: |-
    class stripe_config(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Any

    class msteamswebhook(TypedDict):
        webhook_url: str

    def main(ms_teams_webhook: msteamswebhook, message_card: Any) -> Any:
        webhook_url = ms_teams_webhook['webhook_url']
        response = nonexistentlibrary.post(webhook_url, json=message_card)
        return response.json()

    example_card = {
        "@type": "MessageCard",
        "@context": "https://schema.org/extensions",
        "summary": "This is a test summary",
        "themeColor": "0078D7",
        "title": "This is a test title",
        "sections": [
            {
                "activityTitle": "Windmill Webhook",
                "activitySubtitle": "2023-05-25 17:57:55",
                "activityImage": "https://connectorsdemo.azurewebsites.net/images/MSC12_Oscar_002.jpg",
                "text": "This is a test text",
            },
        ],
    }
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the code tries to use `nonexistentlibrary.post`, which would also fail even if the import statement was corrected, because the `post` method should be called on the `requests` library, not on a non-existent one.
  id: |-
    hubfix_hub_373
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Any

    class msteamswebhook(TypedDict):
        webhook_url: str

    def main(ms_teams_webhook: msteamswebhook, message_card: Any) -> Any:
        webhook_url = ms_teams_webhook['webhook_url']
        response = requests.post(webhook_url, json=message_card)
        return response.json()

    example_card = {
        "@type": "MessageCard",
        "@context": "https://schema.org/extensions",
        "summary": "This is a test summary",
        "themeColor": "0078D7",
        "title": "This is a test title",
        "sections": [
            {
                "activityTitle": "Windmill Webhook",
                "activitySubtitle": "2023-05-25 17:57:55",
                "activityImage": "https://connectorsdemo.azurewebsites.net/images/MSC12_Oscar_002.jpg",
                "text": "This is a test text",
            },
        ],
    }
  original_instructions: |-
    Send a message to MS Teams channel via webhook in msteams
  resource_type: |-
    msteamswebhook
  resource_type_def: |-
    class msteamswebhook(TypedDict):
        webhook_url: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Dict

    class gcal(TypedDict):
        token: str

    def broken_function(
        gcal_auth: gcal,
        calendarId: str,
        eventId: str,
        attendees: List[Dict],
    ):
        alwaysIncludeEmail = True
        sendUpdates = "all"
        supportsAttachments = True
        UPDATE_EVENT_ATTENDEES_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?alwaysIncludeEmail={alwaysIncludeEmail}&sendUpdates={sendUpdates}&supportsAttachments={supportsAttachments}"

        token = gcal_auth["access_token"]

        body = {
            "attendees": attendees,
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = nonexistentlibrary.put(UPDATE_EVENT_ATTENDEES_URL, json=body, headers=headers)

        result = response.json()

        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `broken_function` is trying to use a method `put` from this non-existent library, which would also cause an error if the import statement did not already do so. Furthermore, the `gcal_auth` TypedDict is accessed with a key "access_token" which does not exist; it should be "token" as defined in the `gcal` TypedDict.
  id: |-
    hubfix_hub_47
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Dict

    class gcal(TypedDict):
        token: str

    def main(
        gcal_auth: gcal,
        calendarId: str,
        eventId: str,
        attendees: List[Dict],
    ):
        alwaysIncludeEmail = True
        sendUpdates = "all"
        supportsAttachments = True
        UPDATE_EVENT_ATTENDEES_URL = f"https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events/{eventId}/?alwaysIncludeEmail={alwaysIncludeEmail}&sendUpdates={sendUpdates}&supportsAttachments={supportsAttachments}"

        token = gcal_auth["token"]

        body = {
            "attendees": attendees,
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = requests.put(UPDATE_EVENT_ATTENDEES_URL, json=body, headers=headers)

        result = response.json()

        return result
  original_instructions: |-
    Update Attendees of an Event in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Union, List, Dict, Any, Optional
    import nonexistentlibrary  # This library does not exist

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        return action()

    def main(
        auth: supabase,
        table: str,
        values: Union[Dict[str, Any], List[Dict[str, Any]]],
        return_inserted: bool = False,
        token: Optional[Dict[str, str]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access_token']}"}
            url = f"{auth['url']}/{table}"
            params = {'return': 'representation' if return_inserted else None, 'count': count}
            response = nonexistentlibrary.post(url, json=values, headers=headers, params=params)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, within the `action` function, `nonexistentlibrary.post` is called, which would also fail even if the import statement were corrected, because `post` is not a method of `nonexistentlibrary` (since it doesn't exist). The correct library to use for HTTP requests is `requests`, and the correct method to call is `requests.post`.
  id: |-
    hubfix_hub_283
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Union, List, Dict, Any, Optional
    import requests

    class supabase(TypedDict):
        url: str
        key: str

    def refresh_and_retry_if_expired(auth: supabase, token: Optional[Dict[str, Any]], action):
        # This function should handle the token refresh logic and retry the action if the token is expired.
        # Since the original TypeScript function is from an external library, we'll need to implement
        # the logic ourselves or use a similar library in Python. For simplicity, we'll assume the token
        # is always valid in this example.
        return action()

    def main(
        auth: supabase,
        table: str,
        values: Union[Dict[str, Any], List[Dict[str, Any]]],
        return_inserted: bool = False,
        token: Optional[Dict[str, str]] = None,
        count: Optional[str] = None
    ):
        def action():
            headers = {'apikey': auth['key'], 'Authorization': f"Bearer {token['access']}"}
            url = f"{auth['url']}/{table}"
            params = {'return': 'representation' if return_inserted else None, 'count': count}
            response = requests.post(url, json=values, headers=headers, params=params)
            return response.json()

        return refresh_and_retry_if_expired(auth, token, action)
  original_instructions: |-
    Insert data in supabase
  resource_type: |-
    supabase
  resource_type_def: |-
    class supabase(TypedDict):
        url: str
        key: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        api_key: str
        server: str

    def broken_function(auth: slack_resource, campaign_id: int) -> int:
        url = f"https://{auth['nonexistent_server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}"
        response = nonexistentlibrary.delete(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })
        if not response.ok:
            raise Exception(response.text)
        return "Successfully deleted campaign with ID '{}'".format(campaign_id)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The import statement `import nonexistentlibrary` tries to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `mailchimp` to `slack_resource`, but the function `broken_function` still expects the original `mailchimp` TypedDict.
    3. The `auth` parameter in `broken_function` is expected to be of type `slack_resource`, but the function tries to access a non-existent property `auth['nonexistent_server']`.
    4. The `campaign_id` parameter type is changed from `str` to `int`, which is inconsistent with the expected string interpolation in the URL.
    5. The `nonexistentlibrary.delete` function is called, but since `nonexistentlibrary` does not exist, this will raise a `NameError`.
    6. The return type of the function is changed from `str` to `int`, but the function returns a string, which is a type mismatch.
  id: |-
    hubfix_hub_202
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(auth: mailchimp, campaign_id: str) -> str:
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/campaigns/{campaign_id}"
        response = requests.delete(url, headers={
            "Authorization": f"Bearer {auth['api_key']}",
        })
        if not response.ok:
            raise Exception(response.text)
        return f"Successfully deleted campaign with ID '{campaign_id}'"
  original_instructions: |-
    Delete Campaign in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    from typing import TypedDict
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document_path: list):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['apiKey'],
            "private_key": auth['appId'],
            "client_email": f"firebase-adminsdk@{auth['projectId']}.iam.gserviceaccount.com",
            "client_id": auth['messagingSenderId'],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": f"https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk%40{auth['projectId']}.iam.gserviceaccount.com"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        doc_ref.remove()
  error: |-
    AttributeError: 'DocumentReference' object has no attribute 'remove'
  explanation: |-
    The error occurs because the method `remove()` does not exist on the `DocumentReference` object. The correct method to delete a document in Firestore using the Firebase Admin SDK is `delete()`. By changing `doc_ref.delete()` to `doc_ref.remove()`, the code attempts to call a non-existent method, resulting in an AttributeError.
  id: |-
    hubfix_hub_360
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from firebase_admin import credentials, initialize_app, firestore

    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str

    def main(auth: firebase, collection_id: str, document_path: list):
        cred = credentials.Certificate({
            "type": "service_account",
            "project_id": auth['projectId'],
            "private_key_id": auth['apiKey'],
            "private_key": auth['appId'],
            "client_email": f"firebase-adminsdk@{auth['projectId']}.iam.gserviceaccount.com",
            "client_id": auth['messagingSenderId'],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": f"https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk%40{auth['projectId']}.iam.gserviceaccount.com"
        })
        app = initialize_app(cred)
        db = firestore.client(app)

        doc_ref = db.collection(collection_id).document(*document_path)
        doc_ref.delete()
  original_instructions: |-
    Delete Document in firebase
  resource_type: |-
    firebase
  resource_type_def: |-
    class firebase(TypedDict):
        apiKey: str
        authDomain: str
        projectId: str
        storageBucket: str
        messagingSenderId: str
        appId: str
        measurementId: str
- broken_code: |-
    from typing import TypedDict, Optional, List
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(s3_config: s3, prefix: Optional[str] = None, bucket_name: Optional[str] = None, max_results: Optional[int] = None, page_size: Optional[int] = None) -> List[dict]:
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            endpoint_url=s3_config['endPoint'],
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        options = remove_empty_fields({
            'Prefix': prefix,
            'Bucket': bucket_name or s3_config['bucket'],
            'MaxKeys': max_results,
            'PageSize': page_size,
        })

        paginator = s3_client.get_paginator('list_objects_v2')
        page_iterator = paginator.paginate(**options)

        result = []
        try:
            for page in page_iterator:
                result.extend(page.get('Contents', []))
        except NoCredentialsError:
            print("Credentials not available")

        return result

    main({'endPoint': 'https://example.com', 'port': 443, 'useSSL': False, 'pathStyle': True, 'bucket': 'mybucket', 'accessKey': 'AKIAIOSFODNN7EXAMPLE', 'secretKey': 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY', 'region': 'us-west-2'}, 'my-prefix', 'my-bucket')
  error: |-
    TypeError: 's3' object does not support item assignment
  explanation: |-
    The error occurs because the 's3' TypedDict is being used as a regular dictionary and an attempt is made to assign a value to a key that does not exist in the TypedDict definition. TypedDicts in Python are used to specify expected keys and their associated value types, and they do not allow setting values for keys that are not defined in the TypedDict.

    In the provided code, the error is triggered when the 'main' function is called with a dictionary that uses string keys instead of the TypedDict keys defined in the 's3' class. The keys in the dictionary passed to 'main' do not match the TypedDict definition, which causes the TypeError when the 's3_client' tries to access the 'endPoint' key (which should be 'endPoint' according to the TypedDict definition).

    To fix the error, the keys in the dictionary passed to 'main' should match the TypedDict definition exactly, including the case of the keys (e.g., 'endPoint' instead of 'endPoint').
  id: |-
    hubfix_hub_107
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, List
    import boto3
    from botocore.exceptions import NoCredentialsError

    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str

    def remove_empty_fields(d: dict) -> dict:
        return {k: v for k, v in d.items() if v is not None}

    def main(s3_config: s3, prefix: Optional[str] = None, bucket_name: Optional[str] = None, max_results: Optional[int] = None, page_size: Optional[int] = None) -> List[dict]:
        session = boto3.session.Session()
        s3_client = session.client(
            service_name='s3',
            endpoint_url=s3_config['endPoint'],
            aws_access_key_id=s3_config['accessKey'],
            aws_secret_access_key=s3_config['secretKey'],
            region_name=s3_config['region'],
            use_ssl=s3_config['useSSL'],
            config=boto3.session.Config(s3={'addressing_style': 'path' if s3_config['pathStyle'] else 'virtual'})
        )

        options = remove_empty_fields({
            'Prefix': prefix,
            'Bucket': bucket_name or s3_config['bucket'],
            'MaxKeys': max_results,
            'PageSize': page_size,
        })

        paginator = s3_client.get_paginator('list_objects_v2')
        page_iterator = paginator.paginate(**options)

        result = []
        try:
            for page in page_iterator:
                result.extend(page.get('Contents', []))
        except NoCredentialsError:
            print("Credentials not available")

        return result
  original_instructions: |-
    List objects in a bucket in s3
  resource_type: |-
    s3
  resource_type_def: |-
    class s3(TypedDict):
        endPoint: str
        port: int
        useSSL: bool
        pathStyle: bool
        bucket: str
        accessKey: str
        secretKey: str
        region: str
- broken_code: |-
    import requests
    import random
    import json
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def resolveRoomAlias(matrix_res: matrix, room: str) -> str:
        if room.startswith("!"):
            return room
        resp = requests.get(
            f"{matrix_res['baseURL']}/_matrix/client/v3/directory/room/{requests.utils.quote(room)}",
            headers={
                "Accept": "application/json",
                **({"Authorization": f"Bearer {matrix_res['token']}"} if matrix_res['token'] else {}),
            },
        )
        if not resp.ok:
            raise Exception(f"Failed to resolve room alias: Error HTTP{resp.status_code}")
        roomId = resp.json().get("room_id")
        if not isinstance(roomId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide room_id for this alias.")
        return roomId

    def main(matrix_res: matrix, room: str, body: str) -> str:
        if not matrix_res['token']:
            raise Exception("Sending a message requires an access token.")
        roomId = resolveRoomAlias(matrix_res, room)
        txnId = str(random.random())
        resp = requests.put(
            f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/send/m.room.message/{txnId}",
            headers={
                "Accept": "application/json",
                "Authorization": f"Bearer {matrix_res['token']}",
                "Content-Type": "application/json",
            },
            data=json.dumps({
                "body": body,
                "msgtype": "m.text",
            }),
        )
        if not resp.ok:
            raise Exception(f"Failed to send message: Error HTTP{resp.status_code}")
        eventId = resp.json().get("event_id")
        if not isinstance(eventId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide event_id for this message.")
        return eventId
  error: |-
    KeyError: 'baseURL'
  explanation: |-
    The TypedDict `matrix` defines a key `baseUrl`, but in the `resolveRoomAlias` and `main` functions, the code attempts to access `matrix_res['baseURL']` (with uppercase 'URL'). Since dictionary keys in Python are case-sensitive, this results in a `KeyError` because 'baseURL' does not exist in the `matrix_res` dictionary; the correct key is 'baseUrl'.
  id: |-
    hubfix_hub_95
  lang: |-
    python
  original_code: |-
    import requests
    import random
    import json
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def resolveRoomAlias(matrix_res: matrix, room: str) -> str:
        if room.startswith("!"):
            return room
        resp = requests.get(
            f"{matrix_res['baseUrl']}/_matrix/client/v3/directory/room/{requests.utils.quote(room)}",
            headers={
                "Accept": "application/json",
                **({"Authorization": f"Bearer {matrix_res['token']}"} if matrix_res['token'] else {}),
            },
        )
        if not resp.ok:
            raise Exception(f"Failed to resolve room alias: Error HTTP{resp.status_code}")
        roomId = resp.json().get("room_id")
        if not isinstance(roomId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide room_id for this alias.")
        return roomId

    def main(matrix_res: matrix, room: str, body: str) -> str:
        if not matrix_res['token']:
            raise Exception("Sending a message requires an access token.")
        roomId = resolveRoomAlias(matrix_res, room)
        txnId = str(random.random())
        resp = requests.put(
            f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/send/m.room.message/{txnId}",
            headers={
                "Accept": "application/json",
                "Authorization": f"Bearer {matrix_res['token']}",
                "Content-Type": "application/json",
            },
            data=json.dumps({
                "body": body,
                "msgtype": "m.text",
            }),
        )
        if not resp.ok:
            raise Exception(f"Failed to send message: Error HTTP{resp.status_code}")
        eventId = resp.json().get("event_id")
        if not isinstance(eventId, str):
            raise Exception("Faulty matrix server implementation: Server didn't provide event_id for this message.")
        return eventId
  original_instructions: |-
    Post an unencrypted message in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Optional

    class slack_resource(TypedDict):
        api_key: str
        server: str

    def broken_function(
        auth: slack_resource,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        sort_dir: Optional[str] = None,
        before_date_created: Optional[str] = None,
        since_date_created: Optional[str] = None,
        before_campaign_last_sent: Optional[str] = None,
        since_campaign_last_sent: Optional[str] = None,
        email: Optional[str] = None,
        sort_field: Optional[str] = None,
        has_ecommerce_store: Optional[bool] = None,
        include_total_contacts: Optional[bool] = None,
    ):
        url = f"https://{auth['server_resource']}.api.mailchimp.com/3.0/lists"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'sort_dir': sort_dir,
            'before_date_created': before_date_created,
            'since_date_created': since_date_created,
            'before_campaign_last_sent': before_campaign_last_sent,
            'since_campaign_last_sent': since_campaign_last_sent,
            'email': email,
            'sort_field': sort_field,
            'has_ecommerce_store': has_ecommerce_store,
            'include_total_contacts': include_total_contacts,
        }
        params = {k: v for k, v in params.items() if v is not None}

        response = nonexistentfunction(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:

    1. `import nonexistentlibrary`: The script is trying to import a library named `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError`.

    2. `class slack_resource(TypedDict)`: The original `TypedDict` was named `mailchimp`, and the function `main` expects a `TypedDict` of that name. Renaming it to `slack_resource` breaks the code because `main` (now `broken_function`) is expecting a `TypedDict` named `mailchimp`.

    3. `auth['server_resource']`: The `TypedDict` `slack_resource` (originally `mailchimp`) does not have a key named `server_resource`. This will raise a `KeyError` because the correct key is `server`.

    4. `nonexistentfunction`: The function `requests.get` has been replaced with `nonexistentfunction`, which does not exist. This will raise a `NameError` because `nonexistentfunction` is not defined anywhere in the code.

    5. The function name has been changed from `main` to `broken_function`. If there is code elsewhere that depends on calling `main`, this change will break that code because `main` no longer exists.

    Each of these changes individually would break the script, and together they ensure that the script will not run successfully.
  id: |-
    hubfix_hub_207
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        count: Optional[int] = None,
        offset: Optional[int] = None,
        sort_dir: Optional[str] = None,
        before_date_created: Optional[str] = None,
        since_date_created: Optional[str] = None,
        before_campaign_last_sent: Optional[str] = None,
        since_campaign_last_sent: Optional[str] = None,
        email: Optional[str] = None,
        sort_field: Optional[str] = None,
        has_ecommerce_store: Optional[bool] = None,
        include_total_contacts: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'count': count,
            'offset': offset,
            'sort_dir': sort_dir,
            'before_date_created': before_date_created,
            'since_date_created': since_date_created,
            'before_campaign_last_sent': before_campaign_last_sent,
            'since_campaign_last_sent': since_campaign_last_sent,
            'email': email,
            'sort_field': sort_field,
            'has_ecommerce_store': has_ecommerce_store,
            'include_total_contacts': include_total_contacts,
        }
        params = {k: v for k, v in params.items() if v is not None}

        response = requests.get(url, headers={
            'Authorization': f'Bearer {auth["api_key"]}'
        }, params=params)

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Search Lists in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str
        secret: int  # Added an unnecessary field

    def main(auth: telegram, chat_id: int):  # Changed chat_id type to int
        client = TeleBot(auth['token'])
        return client.export_chat_invite_link(chat_id, extra_param=True)  # Added a non-existent parameter
  error: |-
    TypeError: export_chat_invite_link() got an unexpected keyword argument 'extra_param'
  explanation: |-
    The code is broken because of the following reasons:
    - The `chat_id` parameter type was changed from `str` to `int`, which might not be compatible with the `export_chat_invite_link` method, depending on the implementation of the TeleBot library.
    - An additional, non-existent parameter `extra_param` is passed to the `export_chat_invite_link` method, which is not expected by the TeleBot library and will cause a TypeError.
    - An unnecessary field `secret` is added to the `telegram` TypedDict, which is not used in the code and does not break the code by itself, but it is a deviation from the original code's intent.
  id: |-
    hubfix_hub_237
  lang: |-
    python
  original_code: |-
    from telebot import TeleBot
    from typing import TypedDict

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: str):
        client = TeleBot(auth['token'])
        return client.export_chat_invite_link(chat_id)
  original_instructions: |-
    Create Chat Invite Link in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def broken_function(at_con: airtable, at_table: airtableTable, recordId: str):
        api_key = at_con['apiToken']
        base_id = at_table['baseId']
        table_name = at_table['tableName']
        endpoint = f"https://api.airtable.com/v0/{base_id}/{table_name}/{recordId}"

        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

        response = nonexistentlibrary.delete(endpoint, headers=headers)
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the function `main` has been renamed to `broken_function`, which would cause an issue if there is code elsewhere expecting a function named `main`. The `apiKey` is incorrectly accessed with `apiToken` which would cause a `KeyError` if the `ModuleNotFoundError` was resolved and the code executed. Lastly, the `nonexistentlibrary.delete` call is trying to use a method from the non-existent library, which would also cause an error if the import statement was corrected but the library call was not.
  id: |-
    hubfix_hub_1023
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import requests

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, recordId: str):
        api_key = at_con['apiKey']
        base_id = at_table['baseId']
        table_name = at_table['tableName']
        endpoint = f"https://api.airtable.com/v0/{base_id}/{table_name}/{recordId}"

        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

        response = requests.delete(endpoint, headers=headers)
        return response.json()
  original_instructions: |-
    Delete Record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- broken_code: |-
    from typing import TypedDict, Optional, Dict
    import nonexistentlibrary  # This import will fail

    class pinecone(TypedDict):
        apiKey: str
        environment: str

    def remove_object_empty_fields(d: Dict) -> Dict:
        return {k: v for k, v in d.items() if v is not None and v != ""}

    def main(
        auth: pinecone,
        name: str,
        dimension: str,  # Changed the type of dimension from int to str, which is incorrect
        metric: Optional[str] = None,
        pods: Optional[int] = None,
        replicas: Optional[int] = None,
        pod_type: Optional[str] = None,
        pod_size: Optional[str] = None,
        metadata_config: Optional[Dict[str, str]] = None,
        source_collection: Optional[int] = None,
    ):
        headers = {
            'Api-Key': auth['apiKey'],
            'Content-Type': 'application/json'
        }
        base_url = f"https://{auth['environment']}.pinecone.io"

        pod_type_size = f"{pod_type}.{pod_size or 'x1'}" if pod_type else None
        create_request = remove_object_empty_fields({
            'name': name,
            'dimension': dimension,
            'metric': metric,
            'pods': pods,
            'replicas': replicas,
            'pod_type': pod_type_size,
            'metadata_config': metadata_config,
            'source_collection': source_collection,
        })

        response = nonexistentlibrary.post(  # This function call will fail
            f"{base_url}/indexes",
            headers=headers,
            json=create_request
        )

        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of two main issues:

    1. The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist. Python will raise a `ModuleNotFoundError` when it cannot find a module.

    2. The type of the `dimension` parameter in the `main` function has been changed from `int` to `str`, which is incorrect based on the original code's context. This might not immediately cause a runtime error, but it is a logical error that could lead to incorrect behavior or a failure when the `dimension` is expected to be an integer in the API request.

    Additionally, the `nonexistentlibrary.post` function call will fail because `nonexistentlibrary` does not exist. This would raise a `NameError` if the import error was not already present.
  id: |-
    hubfix_hub_343
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, Dict
    import requests

    class pinecone(TypedDict):
        apiKey: str
        environment: str

    def remove_object_empty_fields(d: Dict) -> Dict:
        return {k: v for k, v in d.items() if v is not None and v != ""}

    def main(
        auth: pinecone,
        name: str,
        dimension: int,
        metric: Optional[str] = None,
        pods: Optional[int] = None,
        replicas: Optional[int] = None,
        pod_type: Optional[str] = None,
        pod_size: Optional[str] = None,
        metadata_config: Optional[Dict[str, str]] = None,
        source_collection: Optional[int] = None,
    ):
        headers = {
            'Api-Key': auth['apiKey'],
            'Content-Type': 'application/json'
        }
        base_url = f"https://{auth['environment']}.pinecone.io"

        pod_type_size = f"{pod_type}.{pod_size or 'x1'}" if pod_type else None
        create_request = remove_object_empty_fields({
            'name': name,
            'dimension': dimension,
            'metric': metric,
            'pods': pods,
            'replicas': replicas,
            'pod_type': pod_type_size,
            'metadata_config': metadata_config,
            'source_collection': source_collection,
        })

        response = requests.post(
            f"{base_url}/indexes",
            headers=headers,
            json=create_request
        )

        return response.json()
  original_instructions: |-
    Create Index in pinecone
  resource_type: |-
    pinecone
  resource_type_def: |-
    class pinecone(TypedDict):
        apiKey: str
        environment: str
- broken_code: |-
    import nonexistentlibrary as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        return invoice_item
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary` as `stripe_module`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name.
  id: |-
    hubfix_hub_121
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        return invoice_item
  original_instructions: |-
    Create Invoice in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def broken_function(gcal_auth: gcal):
        CALENDAR_LIST_URL = "https://www.googleapis.com/calendar/v3/users/me/calendarList"

        token = gcal_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = nonexistentlibrary.get(CALENDAR_LIST_URL, headers=headers)

        result = response.jsonify()

        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the function `nonexistentlibrary.get` is called, which would also fail even if the import statement were corrected, because `nonexistentlibrary` is not a valid module and does not have a `get` function. Lastly, `response.jsonify()` is incorrect because the correct method to parse the JSON response is `response.json()`, not `jsonify()`.
  id: |-
    hubfix_hub_40
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal):
        CALENDAR_LIST_URL = "https://www.googleapis.com/calendar/v3/users/me/calendarList"

        token = gcal_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response = requests.get(CALENDAR_LIST_URL, headers=headers)

        result = response.json()

        return result
  original_instructions: |-
    Get Calendar List in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Any

    class gdrive(TypedDict):
        token: str

    def broken_function(
        gdrive_auth: gdrive,
        drive_id: str,
        webhook_address: str,
        channelId: Any,
    ):
        SUPPORT_ALL_DRIVES = True
        SUPPORT_TEAM_DRIVES = True
        INCLUDE_ITEMS_FROM_ALL_DRIVES = True
        START_PAGE_URL = f"https://www.googleapis.com/drive/v3/changes/startPageToken/?driveId={drive_id}&supportsAllDrives={SUPPORT_ALL_DRIVES}"

        token = gdrive_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response_sp = requests.get(START_PAGE_URL, headers=headers)
        start_page_result = response_sp.json()
        START_PAGE_TOKEN = start_page_result["startPageToken"]

        WATCH_URL = f"https://www.googleapis.com/drive/v3/changes/watch/?pageToken={START_PAGE_TOKEN}&supportsAllDrives={SUPPORT_ALL_DRIVES}&supportsTeamDrives={SUPPORT_TEAM_DRIVES}&includeItemsFromAllDrives={INCLUDE_ITEMS_FROM_ALL_DRIVES}"

        requestBody = {
            "kind": "api#channel",
            "type": "webhook",
            "address": webhook_address,
            "id": channelId,
        }

        response = requests.post(WATCH_URL, json=requestBody, headers=headers)
        message = response.json()

        return message
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. To fix this error, you should remove the import statement for the nonexistent library or replace it with a valid library name.
  id: |-
    hubfix_hub_39
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Any

    class gdrive(TypedDict):
        token: str

    def main(
        gdrive_auth: gdrive,
        drive_id: str,
        webhook_address: str,
        channelId: Any,
    ):
        SUPPORT_ALL_DRIVES = True
        SUPPORT_TEAM_DRIVES = True
        INCLUDE_ITEMS_FROM_ALL_DRIVES = True
        START_PAGE_URL = f"https://www.googleapis.com/drive/v3/changes/startPageToken/?driveId={drive_id}&supportsAllDrives={SUPPORT_ALL_DRIVES}"

        token = gdrive_auth["token"]

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        response_sp = requests.get(START_PAGE_URL, headers=headers)
        start_page_result = response_sp.json()
        START_PAGE_TOKEN = start_page_result["startPageToken"]

        WATCH_URL = f"https://www.googleapis.com/drive/v3/changes/watch/?pageToken={START_PAGE_TOKEN}&supportsAllDrives={SUPPORT_ALL_DRIVES}&supportsTeamDrives={SUPPORT_TEAM_DRIVES}&includeItemsFromAllDrives={INCLUDE_ITEMS_FROM_ALL_DRIVES}"

        requestBody = {
            "kind": "api#channel",
            "type": "webhook",
            "address": webhook_address,
            "id": channelId,
        }

        response = requests.post(WATCH_URL, json=requestBody, headers=headers)
        message = response.json()

        return message
  original_instructions: |-
    Subscribe to Watch Changes in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def get_internal_state():
        return None

    def set_internal_state(new_start_page_token):
        pass

    def main(gdrive_auth: gdrive):
        START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken/"

        last_start_page_token = get_internal_state()

        token = gdrive_auth["token"]

        if last_start_page_token is None:
            START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken"

            response_sp = nonexistentlibrary.get(START_PAGE_URL, headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            })
            start_page_result = response_sp.json()

            last_start_page_token = start_page_result["startPageToken"]

        CHECK_CHANGES_URL = f"https://www.googleapis.com/drive/v3/changes/?pageToken={last_start_page_token}"

        changes_response = requests.get(CHECK_CHANGES_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        result_changes = changes_response.json()

        set_internal_state(result_changes["newStartPageToken"])

        return result_changes["changes"]
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the `nonexistentlibrary.get` function call would also fail because the library does not exist, and therefore it does not have a `get` method. To fix the code, you would need to remove or replace the import statement with a valid library and ensure that all function calls are made to existing functions from imported libraries.
  id: |-
    hubfix_hub_38
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def get_internal_state():
        # Placeholder for getting internal state, replace with actual implementation
        return None

    def set_internal_state(new_start_page_token):
        # Placeholder for setting internal state, replace with actual implementation
        pass

    def main(gdrive_auth: gdrive):
        START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken/"

        last_start_page_token = get_internal_state()

        token = gdrive_auth["token"]

        if last_start_page_token is None:
            START_PAGE_URL = "https://www.googleapis.com/drive/v3/changes/startPageToken"

            response_sp = requests.get(START_PAGE_URL, headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            })
            start_page_result = response_sp.json()

            last_start_page_token = start_page_result["startPageToken"]

        CHECK_CHANGES_URL = f"https://www.googleapis.com/drive/v3/changes/?pageToken={last_start_page_token}"

        changes_response = requests.get(CHECK_CHANGES_URL, headers={
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json",
        })

        result_changes = changes_response.json()

        set_internal_state(result_changes["newStartPageToken"])

        return result_changes["changes"]
  original_instructions: |-
    Get Changes in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets):
        CREATE_URL = "https://sheets.googleapis.com/v4/spreadsheets"

        token = gsheets_auth["token"]

        response = nonexistentlibrary.post(
            CREATE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the function `main` has been renamed to `broken_function`, which would cause an issue if another part of the program expects a function named `main`. Lastly, the `requests.post` method has been replaced with `nonexistentlibrary.post`, which is not a valid method since the library does not exist, and even if it did, it's unlikely to have a `post` method identical to that of the `requests` library.
  id: |-
    hubfix_hub_36
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets):
        CREATE_URL = "https://sheets.googleapis.com/v4/spreadsheets"

        token = gsheets_auth["token"]

        response = requests.post(
            CREATE_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return {"result": result}
  original_instructions: |-
    Create Spreadsheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):
        token: str

    def main(slack_auth: slack_resource, channel: str):
        web = WebClient(token=slack_auth['access_token'])

        response = web.conversations_join(
            channel_id=channel
        )

        return response
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main({'token': 'xoxb-...'}, '#general')
      File "script.py", line 6, in main
        web = WebClient(token=slack_auth['access_token'])
    KeyError: 'access_token'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict is renamed from `slack` to `slack_resource`, but the parameter type in the `main` function is not updated to reflect this change. It should be `slack_auth: slack` instead of `slack_auth: slack_resource`.

    2. The key used to access the token in `slack_auth` is changed from `'token'` to `'access_token'`. Since the TypedDict `slack_resource` defines the key as `'token'`, trying to access `'access_token'` will result in a KeyError.

    3. The parameter passed to the `conversations_join` method is changed from `channel=channel` to `channel_id=channel`. The `conversations_join` method expects a parameter named `channel`, not `channel_id`, so this will result in a TypeError because the method will not receive the required parameter.

    4. The return statement is changed to return the `response` directly instead of wrapping it in a dictionary. This change in the return type could potentially break code that expects the original return type of `{'response': response}`.
  id: |-
    hubfix_hub_20
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_join(
            channel=channel
        )

        return {'response': response}
  original_instructions: |-
    Join Channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        token: str

    def broken_function(slack_con: slack_resource, id: str):
        STRIPE_CAPTURE_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/capture'

        token = slack_con["api_key"]

        response = nonexistentlibrary.post(
            STRIPE_CAPTURE_PAYMENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `stripe` to `slack_resource`, but the function parameter `slack_con` is still expected to be of type `stripe`, which will cause a type error if type checking is enforced.
    3. The function `main` is renamed to `broken_function`, which will cause an error if somewhere else in the code `main` is being called.
    4. The `TypedDict` property `token` is accessed with a non-existent key `api_key`, which will raise a `KeyError` if the code execution reaches that point.
    5. The `nonexistentlibrary.post` call is trying to use a function from the non-existent library, which will raise a `NameError` if the code execution reaches that point.
    6. The function is returning `response.text` instead of `response.json()`, which is not necessarily a breaking change but could be if the calling code expects a JSON response.
  id: |-
    hubfix_hub_118
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: str):
        STRIPE_CAPTURE_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/capture'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_CAPTURE_PAYMENT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Capture a Payment Intent in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistent_library
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def broken_function(stripe_con: stripe, customer_id: str, order_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        customer = stripe_module.Customer.modify(customer_id, metadata={'order_id': order_id})

        return customer_metadata
  error: |-
    ModuleNotFoundError: No module named 'nonexistent_library'
  explanation: |-
    The code is trying to import a library named `nonexistent_library`, which does not exist. This will cause a `ModuleNotFoundError` because Python cannot find a library with that name. Additionally, the function `main` has been renamed to `broken_function`, which would cause an issue if the script expects a function named `main`. Lastly, the variable `customer_metadata` is returned, but it is not defined anywhere in the function, which would lead to a `NameError` if the import error was fixed and the code reached that point.
  id: |-
    hubfix_hub_131
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, order_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        customer = stripe_module.Customer.modify(customer_id, metadata={'order_id': order_id})

        return customer
  original_instructions: |-
    Update a Customer in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, user_id: str, reason: str = ""):
        if not matrix_res['token']:
            raise ValueError("Inviting a user requires an access token.")

        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{nonexistentlibrary.utils.quote(room_id)}/invite"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        payload = {
            "user_id": user_id,
            **({"reason": reason} if reason else {}),
        }

        resp = requests.post(url, headers=headers, json=payload)

        if not resp.ok:
            raise ValueError(f"Failed to invite: Error HTTP{resp.status_code}")
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the code tries to access `nonexistentlibrary.utils.quote(room_id)`, which would also fail even if the library existed because the `requests` library was replaced with `nonexistentlibrary`. Furthermore, the code uses `matrix_res['baseURL']` instead of `matrix_res['baseUrl']`, which would cause a KeyError because the key 'baseURL' does not exist in the `matrix` TypedDict.
  id: |-
    hubfix_hub_104
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, user_id: str, reason: str = ""):
        if not matrix_res['token']:
            raise ValueError("Inviting a user requires an access token.")

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/invite"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        payload = {
            "user_id": user_id,
            **({"reason": reason} if reason else {}),
        }

        resp = requests.post(url, headers=headers, json=payload)

        if not resp.ok:
            raise ValueError(f"Failed to invite: Error HTTP{resp.status_code}")
  original_instructions: |-
    Invite user to a room in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional

    class github(TypedDict):
        token: str

    def broken_function(gh_auth: github, owner: int, repo: str, path: Optional[str] = None, ref: Optional[str] = None, result_format: str = "github_object"):
        headers = {
            "Authorization": f"token {gh_auth['nonexistent_property']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": f"application/vnd.github.{ 'vnd.github+json' if result_format == 'json' else 'vnd.github.object' }"
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path or ''}"
        if ref:
            url += f"?ref={ref}"

        response = nonexistentlibrary.get(url, headers=headers)
        return response.jsonify()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. `import nonexistentlibrary` attempts to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The function `broken_function` is called instead of `main`, which means the function cannot be called using its original name.
    3. The `owner` parameter type has been changed from `str` to `int`, which is incorrect for the GitHub API URL construction.
    4. `gh_auth['nonexistent_property']` is trying to access a property that does not exist in the `github` TypedDict.
    5. `nonexistentlibrary.get(url, headers=headers)` is calling a method from a library that does not exist, which will raise a `NameError`.
    6. `response.jsonify()` is calling a method that does not exist on the `response` object; the correct method is `response.json()`.
  id: |-
    hubfix_hub_345
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str, path: Optional[str] = None, ref: Optional[str] = None, result_format: str = "github_object"):
        headers = {
            "Authorization": f"token {gh_auth['token']}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": f"application/vnd.github.{ 'vnd.github+json' if result_format == 'json' else 'vnd.github.object' }"
        }
        url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path or ''}"
        if ref:
            url += f"?ref={ref}"

        response = requests.get(url, headers=headers)
        return response.json()
  original_instructions: |-
    Get Repo Content in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- broken_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[data_source].get_database
        documents = db[collection]
        return documents.insert_one(document)
  error: |-
    TypeError: 'method' object is not subscriptable
  explanation: |-
    The code is attempting to subscript a method object. The error occurs on the line `documents = db[collection]` because `db` is assigned the method `get_database` from the `client[data_source]` object, but it is not called as a function. The `get_database` should be called with parentheses to actually retrieve the database object before attempting to subscript it to access the collection.
  id: |-
    hubfix_hub_259
  lang: |-
    python
  original_code: |-
    from pymongo import MongoClient
    from typing import TypedDict, Any, Dict

    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str

    def main(auth: mongodbrest, data_source: str, database: str, collection: str, document: Dict[str, Any]):
        client = MongoClient(auth['endpoint'], username='apikey', password=auth['api_key'])
        db = client[data_source][database]
        documents = db[collection]
        return documents.insert_one(document)
  original_instructions: |-
    Create New Document in mongodb
  resource_type: |-
    mongodbrest
  resource_type_def: |-
    class mongodbrest(TypedDict):
        endpoint: str
        api_key: str
- broken_code: |-
    from typing import TypedDict
    import psycopg3  # This library does not exist

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    def main(db: postgresql, query: str = "SELECT * FROM demo;"):
        if not query:
            raise ValueError("Query must not be empty.")

        connection = psycopg3.connect(  # Incorrect library name
            host=db['host'],
            port=db['port'],
            user=db['user'],
            dbname=db['dbname'],
            sslmode=db['sslmode'],
            password=db['password']
        )

        with connection.cursor() as cursor:
            cursor.execute(query)
            rows = cursor.fetch_all()  # Incorrect method name

        connection.close()
        return rows
  error: |-
    ModuleNotFoundError: No module named 'psycopg3'
  explanation: |-
    The code is broken because it attempts to import a library named `psycopg3`, which does not exist. The correct library name is `psycopg2`. Additionally, the method `fetch_all()` does not exist on the cursor object; the correct method name is `fetchall()`. If the non-existent library import was fixed, the incorrect method call would raise an AttributeError.
  id: |-
    hubfix_hub_82
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import psycopg2

    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str

    def main(db: postgresql, query: str = "SELECT * FROM demo;"):
        if not query:
            raise ValueError("Query must not be empty.")

        connection = psycopg2.connect(
            host=db['host'],
            port=db['port'],
            user=db['user'],
            dbname=db['dbname'],
            sslmode=db['sslmode'],
            password=db['password']
        )

        with connection.cursor() as cursor:
            cursor.execute(query)
            rows = cursor.fetchall()

        connection.close()
        return rows
  original_instructions: |-
    Execute Query and return results in postgresql
  resource_type: |-
    postgresql
  resource_type_def: |-
    class postgresql(TypedDict):
        host: str
        port: int
        user: str
        dbname: str
        sslmode: str
        password: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List, Any

    class flowdata(TypedDict):
        flows: List[Any]

    def broken_function() -> flowdata:
        url = "https://hub.windmill.dev/searchFlowData"
        response = nonexistentlibrary.get(url)
        return response.jsonify()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `requests.get` method is replaced with `nonexistentlibrary.get`, which is not a valid method since the library does not exist. Lastly, `response.jsonify()` is not a valid method; the correct method to parse JSON from a response object is `response.json()`.
  id: |-
    hubfix_hub_169
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List, Any

    class flowdata(TypedDict):
        flows: List[Any]

    def main() -> flowdata:
        url = "https://hub.windmill.dev/searchFlowData"
        response = requests.get(url)
        return response.json()
  original_instructions: |-
    List Flows in windmillhub
  resource_type: |-
    flowdata
  resource_type_def: |-
    class flowdata(TypedDict):
        flows: List[Any]
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def broken_function(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = True):
        UPDATE_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}"

        token = gdrive_auth["token"]

        body = {
            "name": "Update Drive Test",
            "restrictions": {
                "adminManagedRestrictions": False,
                "copyRequiresWriterPermission": False,
                "domainUsersOnly": False,
                "driveMembersOnly": False,
            },
            "colorRgb": "#ff0000",
        }
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }
        response = nonexistentlibrary.patch(UPDATE_SHARED_DRIVE_URL, json=body, headers=headers)

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if the script relies on a function named `main` being present. Lastly, the `requests.patch` method has been incorrectly replaced with `nonexistentlibrary.patch`, which would also raise an error because `nonexistentlibrary` does not have a `patch` method or any method at all, as it does not exist.
  id: |-
    hubfix_hub_63
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, driveId: str, useDomainAdminAccess: bool = True):
        UPDATE_SHARED_DRIVE_URL = f"https://www.googleapis.com/drive/v3/drives/{driveId}/?useDomainAdminAccess={useDomainAdminAccess}"

        token = gdrive_auth["token"]

        body = {
            "name": "Update Drive Test",
            "restrictions": {
                "adminManagedRestrictions": False,
                "copyRequiresWriterPermission": False,
                "domainUsersOnly": False,
                "driveMembersOnly": False,
            },
            "colorRgb": "#ff0000",
        }
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }
        response = requests.patch(UPDATE_SHARED_DRIVE_URL, json=body, headers=headers)

        return response.text
  original_instructions: |-
    Update Shared Drive in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    import nonexistent_library
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        api_token = stripe_con["api_key"]
        nonexistent_library.api_key = api_token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
            quantity=1,
        )

        return invoice_data
  error: |-
    ModuleNotFoundError: No module named 'nonexistent_library'
  explanation: |-
    The code attempts to import a library named `nonexistent_library`, which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find a module with the given name. Additionally, the variable `api_token` is trying to access a key "api_key" from the `stripe_con` TypedDict, which does not exist as the correct key is "token". The variable `invoice_data` is returned, but it is not defined anywhere in the function; the correct variable should be `invoice_item`. Lastly, the `stripe_module` is used to create an invoice item with a parameter `quantity` which is not part of the original function signature and may not be a valid parameter for the `InvoiceItem.create` method.
  id: |-
    hubfix_hub_122
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, customer_id: str, price_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.create(
            customer=customer_id,
            price=price_id,
        )

        return invoice_item
  original_instructions: |-
    Create Invoice Line Item in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def remove_object_empty_fields(d):
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: mailchimp,
        name: str,
        permission_reminder: str,
        campaign_from_name: str,
        campaign_from_email: str,
        campaign_subject: str,
        campaign_language: str,
        email_type_option: bool,
        contact_company: str,
        contact_country: str,
        contact_city: str,
        contact_address1: str,
        contact_address2: Optional[str] = None,
        contact_state: Optional[str] = None,
        contact_zip: Optional[str] = None,
        contact_phone: Optional[str] = None,
        notify_on_subscribe: Optional[str] = None,
        notify_on_unsubscribe: Optional[str] = None,
        use_archive_bar: Optional[bool] = None,
        double_optin: Optional[bool] = None,
        marketing_permissions: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        body = {
            "name": name,
            "contact": {
                "company": contact_company,
                "country": contact_country,
                "city": contact_city,
                "address1": contact_address1,
                "address2": contact_address2,
                "state": contact_state,
                "zip": contact_zip,
                "phone": contact_phone,
            },
            "permission_reminder": permission_reminder,
            "campaign_defaults": {
                "from_name": campaign_from_name,
                "from_email": campaign_from_email,
                "subject": campaign_subject,
                "language": campaign_language,
            },
            "email_type_option": email_type_option,
            "use_archive_bar": use_archive_bar,
            "notify_on_subscribe": notify_on_subscribe,
            "notify_on_unsubscribe": notify_on_unsubscribe,
            "double_optin": double_optin,
            "marketing_permissions": marketing_permissions,
        }

        cleaned_body = remove_object_empty_fields(body)
        headers = {
            "Authorization": f"Bearer {auth['api_key']}",
            "Content-Type": "application/json",
        }

        response = requests.post(url, headers=headers, data=json.dumps(cleaned_body))

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  error: |-
    KeyError: 'server'
  explanation: |-
    The TypedDict `mailchimp` originally had a key named `server`, which was used to construct the URL for the API request. The key was changed to `server_prefix`, which does not exist in the `auth` dictionary when the `main` function tries to access `auth['server']`. This results in a `KeyError` because the `server` key is not found in the `auth` dictionary.
  id: |-
    hubfix_hub_209
  lang: |-
    python
  original_code: |-
    import json
    import requests
    from typing import TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def remove_object_empty_fields(d):
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: mailchimp,
        name: str,
        permission_reminder: str,
        campaign_from_name: str,
        campaign_from_email: str,
        campaign_subject: str,
        campaign_language: str,
        email_type_option: bool,
        contact_company: str,
        contact_country: str,
        contact_city: str,
        contact_address1: str,
        contact_address2: Optional[str] = None,
        contact_state: Optional[str] = None,
        contact_zip: Optional[str] = None,
        contact_phone: Optional[str] = None,
        notify_on_subscribe: Optional[str] = None,
        notify_on_unsubscribe: Optional[str] = None,
        use_archive_bar: Optional[bool] = None,
        double_optin: Optional[bool] = None,
        marketing_permissions: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists"
        body = {
            "name": name,
            "contact": {
                "company": contact_company,
                "country": contact_country,
                "city": contact_city,
                "address1": contact_address1,
                "address2": contact_address2,
                "state": contact_state,
                "zip": contact_zip,
                "phone": contact_phone,
            },
            "permission_reminder": permission_reminder,
            "campaign_defaults": {
                "from_name": campaign_from_name,
                "from_email": campaign_from_email,
                "subject": campaign_subject,
                "language": campaign_language,
            },
            "email_type_option": email_type_option,
            "use_archive_bar": use_archive_bar,
            "notify_on_subscribe": notify_on_subscribe,
            "notify_on_unsubscribe": notify_on_unsubscribe,
            "double_optin": double_optin,
            "marketing_permissions": marketing_permissions,
        }

        cleaned_body = remove_object_empty_fields(body)
        headers = {
            "Authorization": f"Bearer {auth['api_key']}",
            "Content-Type": "application/json",
        }

        response = requests.post(url, headers=headers, data=json.dumps(cleaned_body))

        if not response.ok:
            raise Exception(response.text)

        return response.json()
  original_instructions: |-
    Create List in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def broken_function(gcal_auth: gcal, calendarId: str):
        CALENDAR_LIST_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}'

        token = gcal_auth["access_token"]

        response = nonexistentlibrary.get(
            CALENDAR_LIST_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The function has been renamed from `main` to `broken_function`, which will cause an issue if the function is expected to be called by its original name elsewhere in the code.
    3. The variable `token` is trying to access a key `"access_token"` from the `gcal_auth` TypedDict, which does not exist; the correct key is `"token"`.
    4. The `nonexistentlibrary.get` call is using a library that was not imported (because it doesn't exist), which will raise a `NameError` if the code execution ever reached this point.
  id: |-
    hubfix_hub_41
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str):
        CALENDAR_LIST_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}'

        token = gcal_auth["token"]

        response = requests.get(
            CALENDAR_LIST_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return result
  original_instructions: |-
    Get Calendar Metadata in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class ocs(TypedDict):
        pass

    def broken_function(base_url: str) -> int:
        resp = nonexistentlibrary.get(f"{base_url}/ocs/v1.php/cloud/capabilities", headers={"OCS-APIRequest": "true"})
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it tries to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if the script relies on a function named `main`. Furthermore, the return type of the function has been changed from `str` to `int`, but the function still returns `resp.text`, which is a string. Lastly, the `requests.get` method has been replaced with `nonexistentlibrary.get`, which is not a valid method since the library does not exist.
  id: |-
    hubfix_hub_162
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class ocs(TypedDict):
        pass

    def main(base_url: str) -> str:
        resp = requests.get(f"{base_url}/ocs/v1.php/cloud/capabilities", headers={"OCS-APIRequest": "true"})
        if not resp.ok:
            raise Exception(f"HTTP Error {resp.status_code} - {resp.text}")
        return resp.text
  original_instructions: |-
    Get API capabilities in ocs
  resource_type: |-
    ocs
  resource_type_def: |-
    class ocs(TypedDict):
        pass
- broken_code: |-
    from typing import TypedDict, Optional
    from nonexistentlib import PineconeClient

    class slack_resource(TypedDict):
        apiKey: str
        environment: str

    def broken_function(auth: slack_resource, index_name: str, namespace: Optional[str] = None):
        client = PineconeClient(api_key=auth['api_key'], environment=auth['env'])
        index = client.index(index_name)

        return index.delete_all(delete_everything=True, namespace=namespace)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `from nonexistentlib import PineconeClient` is trying to import `PineconeClient` from a library that doesn't exist. This will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `pinecone` to `slack_resource`, which is not used anywhere and will cause confusion.
    3. The function is renamed from `main` to `broken_function`, which will cause issues if other parts of the code expect a function named `main`.
    4. The `apiKey` and `environment` keys are accessed incorrectly as `auth['api_key']` and `auth['env']` instead of `auth['apiKey']` and `auth['environment']`.
    5. The method `delete_all` does not exist on the `index` object. The correct method is `delete`, and it is called with an incorrect parameter `delete_everything` instead of `delete_all`.
  id: |-
    hubfix_hub_346
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from pinecone import PineconeClient

    class pinecone(TypedDict):
        apiKey: str
        environment: str

    def main(auth: pinecone, index_name: str, namespace: Optional[str] = None):
        client = PineconeClient(api_key=auth['apiKey'], environment=auth['environment'])
        index = client.index(index_name)

        return index.delete(delete_all=True, namespace=namespace)
  original_instructions: |-
    Delete All Vectors in pinecone
  resource_type: |-
    pinecone
  resource_type_def: |-
    class pinecone(TypedDict):
        apiKey: str
        environment: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(gsheets_auth: gsheets, sheet_id: str, spreadsheet_id_1: str, spreadsheet_id_2: str):
        token = gsheets_auth["token"]

        COPY_TO_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id_1}/sheets/{sheet_id}:copyTo"

        req = {
            "destinationSpreadsheetId": spreadsheet_id_2,
        }

        response = nonexistentlibrary.post(
            COPY_TO_URL,
            json=req,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `nonexistentlibrary.post` is called, which would also break the code because `nonexistentlibrary` does not exist, and even if it did, it might not have a `post` method. The function name has also been changed from `main` to `broken_function`, which could cause issues if other parts of the code expect a function named `main`.
  id: |-
    hubfix_hub_50
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(gsheets_auth: gsheets, sheet_id: str, spreadsheet_id_1: str, spreadsheet_id_2: str):
        token = gsheets_auth["token"]

        COPY_TO_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id_1}/sheets/{sheet_id}:copyTo"

        req = {
            "destinationSpreadsheetId": spreadsheet_id_2,
        }

        response = requests.post(
            COPY_TO_URL,
            json=req,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Copy Worksheet in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server_prefix: str

    def main(
        auth: mailchimp,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_total_contacts: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_total_contacts': str(include_total_contacts).lower() if include_total_contacts is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}
        response = requests.get(url, headers={'Authorization': f'Bearer {auth["api_key"]}'}, params=params)

        if not response.ok:
            raise Exception(response.text)
        return response.json()

    main({'api_key': 'fake_api_key', 'server_prefix': 'us1'}, 'list_id')
  error: |-
    KeyError: 'server'
  explanation: |-
    The TypedDict `mailchimp` was changed to have a key `server_prefix` instead of `server`. However, the `main` function still tries to access `auth['server']` which no longer exists in the `mailchimp` TypedDict, resulting in a `KeyError`. To fix this, the `main` function should be updated to use `auth['server_prefix']` when constructing the `url`.
  id: |-
    hubfix_hub_208
  lang: |-
    python
  original_code: |-
    import requests
    from typing import List, TypedDict, Optional

    class mailchimp(TypedDict):
        api_key: str
        server: str

    def main(
        auth: mailchimp,
        list_id: str,
        fields: Optional[List[str]] = None,
        exclude_fields: Optional[List[str]] = None,
        include_total_contacts: Optional[bool] = None,
    ):
        url = f"https://{auth['server']}.api.mailchimp.com/3.0/lists/{list_id}"
        params = {
            'fields': ','.join(fields) if fields else None,
            'exclude_fields': ','.join(exclude_fields) if exclude_fields else None,
            'include_total_contacts': str(include_total_contacts).lower() if include_total_contacts is not None else None,
        }
        # Remove None values from params
        params = {k: v for k, v in params.items() if v is not None}
        response = requests.get(url, headers={'Authorization': f'Bearer {auth["api_key"]}'}, params=params)

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Get List in mailchimp
  resource_type: |-
    mailchimp
  resource_type_def: |-
    class mailchimp(TypedDict):
        api_key: str
        server: str
- broken_code: |-
    from typing import TypedDict, Union
    import nonexistentlibrary  # This library does not exist

    class telegram(TypedDict):
        api_key: str  # Changed 'token' to 'api_key'

    def main(auth: telegram, chat_id: Union[str, int], text: str, reply_to_message_id: int = None):
        token = auth['token']  # 'token' key does not exist in 'auth' TypedDict
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        payload = {
            'chat_identifier': chat_id,  # Changed 'chat_id' to 'chat_identifier'
            'message': text,  # Changed 'text' to 'message'
            'reply_to_message_id': reply_to_message_id
        }
        response = nonexistentlibrary.post(url, data=payload)  # 'nonexistentlibrary' does not have a 'post' method
        return response.get_json()  # Changed 'json()' to 'get_json()'
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The import statement `import nonexistentlibrary` attempts to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The `telegram` TypedDict has been changed to have an 'api_key' key instead of 'token', but the `main` function still tries to access `auth['token']`, which will raise a `KeyError` because 'token' is no longer a valid key in the `telegram` TypedDict.
    3. The `payload` dictionary uses 'chat_identifier' and 'message' instead of 'chat_id' and 'text', which are not the correct parameter names expected by the Telegram API, and this would result in an API error.
    4. The `nonexistentlibrary.post` call attempts to use a non-existent library's `post` method, which will raise a `NameError` because `nonexistentlibrary` is not defined.
    5. The `response.get_json()` call attempts to use a non-existent method `get_json()` on the `response` object. The correct method to retrieve JSON from the response is `response.json()`.
  id: |-
    hubfix_hub_234
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Union
    import requests

    class telegram(TypedDict):
        token: str

    def main(auth: telegram, chat_id: Union[str, int], text: str, reply_to_message_id: int = None):
        token = auth['token']
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        payload = {
            'chat_id': chat_id,
            'text': text,
            'reply_to_message_id': reply_to_message_id
        }
        response = requests.post(url, data=payload)
        return response.json()
  original_instructions: |-
    Send a Text Message or Reply in telegram
  resource_type: |-
    telegram
  resource_type_def: |-
    class telegram(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        token_key: str

    def secondary_function(slack_con: slack_resource, payout_identifier: str):
        STRIPE_REVERSE_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{payout_identifier}/cancel'

        token = slack_con["token"]

        response = nonexistentlibrary.post(
            STRIPE_REVERSE_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.get_json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `stripe` to `slack_resource`, and the field `token` is renamed to `token_key`, but the function still tries to access `slack_con["token"]`, which will raise a `KeyError` because the key "token" does not exist in `slack_resource`.
    3. The function `secondary_function` is called instead of `main`, which is not necessarily an error by itself, but if the script expects a function named `main`, this will cause an issue.
    4. The URL is changed to an endpoint that does not exist (`/cancel` at the end of the Stripe API URL), which will likely result in a 404 error from the Stripe API.
    5. The `nonexistentlibrary.post` call is using a library that was not imported (because it doesn't exist), which will raise a `NameError`.
    6. The method `get_json()` does not exist on the `response` object returned by the `requests` library (which is not being used here due to the incorrect import). The correct method is `json()`.
  id: |-
    hubfix_hub_116
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, payout_id: str):
        STRIPE_REVERSE_PAYOUT_URL = f'https://api.stripe.com/v1/payouts/{payout_id}/reverse'

        token = stripe_con["token"]

        response = requests.post(
            STRIPE_REVERSE_PAYOUT_URL,
            headers={
                "Authorization": "Bearer " + token,
                "Content-Type": "application/json",
            },
        )

        return response.json()
  original_instructions: |-
    Cancel Or Reverse a Payout in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import mysql.connector
    from typing import TypedDict

    class mysql(TypedDict):
        host: str
        port: str  # Changed from int to str
        user: str
        database: str
        password: str
        ssl: bool

    def main(mysql_conn: mysql, query: str):
        mysql_conn['db'] = mysql_conn['database']
        mysql_conn['hostname'] = mysql_conn['host']
        mysql_conn['username'] = mysql_conn['user']

        connection = mysql.connector.connect(
            host=mysql_conn['hostname'],
            user=mysql_conn['username'],
            password=mysql_conn['password'],
            database=mysql_conn['db'],
            port=mysql_conn['port'],  # This will cause an error
            ssl_disabled=not mysql_conn['ssl']
        )

        cursor = connection.cursor()
        cursor.execute(query)
        result = cursor.fetchall()
        cursor.close()
        connection.close()
        return result
  error: |-
    TypeError: int() argument must be a string, a bytes-like object or a number, not 'NoneType'
  explanation: |-
    The error occurs because the `port` field in the `mysql` TypedDict was changed from `int` to `str`. The `mysql.connector.connect` function expects an integer for the `port` parameter, but it receives a string. If the string cannot be converted to an integer (for example, if it's an empty string or contains non-numeric characters), a TypeError will be raised. The error message provided is a generic one and might differ depending on the actual string passed to the `port` parameter. If the string is empty or None, the error message would indicate that an `int` cannot be created from a `NoneType`.
  id: |-
    hubfix_hub_28
  lang: |-
    python
  original_code: |-
    import mysql.connector
    from typing import TypedDict

    class mysql(TypedDict):
        host: str
        port: int
        user: str
        database: str
        password: str
        ssl: bool

    def main(mysql_conn: mysql, query: str):
        mysql_conn['db'] = mysql_conn['database']
        mysql_conn['hostname'] = mysql_conn['host']
        mysql_conn['username'] = mysql_conn['user']

        connection = mysql.connector.connect(
            host=mysql_conn['hostname'],
            user=mysql_conn['username'],
            password=mysql_conn['password'],
            database=mysql_conn['db'],
            port=mysql_conn['port'],
            ssl_disabled=not mysql_conn['ssl']
        )

        cursor = connection.cursor()
        cursor.execute(query)
        result = cursor.fetchall()
        cursor.close()
        connection.close()
        return result
  original_instructions: |-
    Execute Query in mysql
  resource_type: |-
    mysql
  resource_type_def: |-
    class mysql(TypedDict):
        host: str
        port: int
        user: str
        database: str
        password: str
        ssl: bool
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):  # Changed the name of the TypedDict
        token: str

    def main(email: str, slack: slack_resource):
        web = WebClient(token=slack['access_token'])  # Changed the key to a non-existent one

        response = web.users_lookupByEmail(email_address=email)  # Changed the parameter name

        return response  # Changed the return type
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main('example@example.com', {'token': 'xoxb-...'})
      File "script.py", line 7, in main
        web = WebClient(token=slack['access_token'])
    KeyError: 'access_token'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` name was changed from `slack` to `slack_resource`, but the parameter type in the `main` function was not updated to reflect this change. This would cause a type error if type checking was enforced.

    2. Inside the `main` function, `slack['access_token']` is used, but the original `TypedDict` only defines a key named `token`. This will raise a `KeyError` because 'access_token' does not exist in the provided dictionary.

    3. The `users_lookupByEmail` method is called with a parameter `email_address`, but the correct parameter name is `email`. This will cause the Slack SDK to raise an error because it does not recognize the parameter `email_address`.

    4. The return type of the function was changed. The original code returned a dictionary with a key 'response', but the modified code returns the response object directly. This is not necessarily an error, but it changes the expected output of the function and could break code that depends on the original return structure.
  id: |-
    hubfix_hub_21
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(email: str, slack: slack):
        web = WebClient(token=slack['token'])

        response = web.users_lookupByEmail(email=email)

        return {'response': response}
  original_instructions: |-
    Find User by Email in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import boto3
    from botocore.exceptions import ClientError
    from typing import TypedDict, List

    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str

    def send_email(
        to_addresses: List[str],
        html_data: int,
        text_data: str,
        subject: str,
        source: str,
        credentials: aws,
    ):
        params = {
            'Destination': {
                'ToAddresses': to_addresses,
            },
            'Message': {
                'Body': {
                    'Html': {
                        'Charset': "UTF-8",
                        'Data': html_data,
                    },
                    'Text': {
                        'Charset': "UTF-8",
                        'Data': text_data,
                    },
                },
                'Subject': {
                    'Charset': "UTF-8",
                    'Data': subject,
                },
            },
            'Source': source,
        }

        ses_client = boto3.client(
            'ses',
            aws_access_key_id=credentials['aws_access_key'],
            aws_secret_access_key=credentials['aws_secret_access_key'],
            region_name=credentials['region_name'],
        )

        try:
            response = ses_client.send_email(**params)
            return response
        except ClientError as e:
            return e.response['Error']
  error: |-
    TypeError: send_email() missing 1 required positional argument: 'credentials'
  explanation: |-
    The code is broken due to the following reasons:

    1. The `main` function has been renamed to `send_email`, which means that if the script expects a function named `main` to be called, it will not find it and will raise an error.

    2. The `html_data` parameter type has been changed from `str` to `int`, which is incorrect because the SES 'Data' field expects a string.

    3. The `aws_access_key_id` key is incorrectly referenced as `aws_access_key` in the `boto3.client` call, which will result in a KeyError because the dictionary `credentials` does not contain a key named `aws_access_key`.

    4. The error message provided is generic and assumes that the function is called without the required `credentials` argument. However, the actual error that would occur depends on how the function is called. If the function is called without the `credentials` argument, it would indeed raise a TypeError as shown. If the function is called with all arguments, it would raise a KeyError due to the incorrect dictionary key access.
  id: |-
    hubfix_hub_371
  lang: |-
    python
  original_code: |-
    import boto3
    from botocore.exceptions import ClientError
    from typing import TypedDict, List

    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str

    def main(
        to_addresses: List[str],
        html_data: str,
        text_data: str,
        subject: str,
        source: str,
        credentials: aws,
    ):
        params = {
            'Destination': {
                'ToAddresses': to_addresses,
            },
            'Message': {
                'Body': {
                    'Html': {
                        'Charset': "UTF-8",
                        'Data': html_data,
                    },
                    'Text': {
                        'Charset': "UTF-8",
                        'Data': text_data,
                    },
                },
                'Subject': {
                    'Charset': "UTF-8",
                    'Data': subject,
                },
            },
            'Source': source,
        }

        ses_client = boto3.client(
            'ses',
            aws_access_key_id=credentials['aws_access_key_id'],
            aws_secret_access_key=credentials['aws_secret_access_key'],
            region_name=credentials['region_name'],
        )

        try:
            response = ses_client.send_email(**params)
            return response
        except ClientError as e:
            return e.response['Error']
  original_instructions: |-
    send an email with aws ses  in aws-ses
  resource_type: |-
    aws
  resource_type_def: |-
    class aws(TypedDict):
        aws_access_key_id: str
        aws_secret_access_key: str
        region_name: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Literal

    class slack(TypedDict):
        token: str

    def broken_function(auth: slack_resource, content: str, visibility: Literal["PUBLIC", "CONNECTIONS"] = "PUBLIC"):
        entityResponse = nonexistentlibrary.get("https://api.linkedin.com/v2/me", headers={"Authorization": "Bearer " + auth['token']})
        entityId = entityResponse.json()['id']

        url = "https://api.linkedin.com/v2/ugcPosts"
        body = {
            "author": f"urn:li:person:{entityId}",
            "lifecycleState": "PUBLISHED",
            "specificContent": {
                "com.linkedin.ugc.ShareContent": {
                    "shareCommentary": {
                        "text": content,
                    },
                    "shareMediaCategory": "NONE",
                },
            },
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": visibility,
            },
        }
        response = requests.post(url, json=body, headers={
            "Authorization": "Bearer " + auth['wrong_key'],
            "X-Restli-Protocol-Version": "2.0.0",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` is renamed from `linkedin` to `slack`, but the function parameter `auth` is still annotated with `slack_resource`, which is not defined anywhere.
    3. The function `main` is renamed to `broken_function`, which by itself is not an error, but if there is code elsewhere expecting a function named `main`, this will cause an issue.
    4. Inside the `broken_function`, it tries to use `nonexistentlibrary.get(...)`, but since `nonexistentlibrary` does not exist, this will raise a `NameError`.
    5. The `auth` dictionary is accessed with a key `'wrong_key'` which does not exist in the `TypedDict` definition, resulting in a `KeyError` if the code were to execute past the import error.
  id: |-
    hubfix_hub_243
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Literal

    class linkedin(TypedDict):
        token: str

    def main(auth: linkedin, content: str, visibility: Literal["PUBLIC", "CONNECTIONS"] = "PUBLIC"):
        entityResponse = requests.get("https://api.linkedin.com/v2/me", headers={"Authorization": "Bearer " + auth['token']})
        entityId = entityResponse.json()['id']

        url = "https://api.linkedin.com/v2/ugcPosts"
        body = {
            "author": f"urn:li:person:{entityId}",
            "lifecycleState": "PUBLISHED",
            "specificContent": {
                "com.linkedin.ugc.ShareContent": {
                    "shareCommentary": {
                        "text": content,
                    },
                    "shareMediaCategory": "NONE",
                },
            },
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": visibility,
            },
        }
        response = requests.post(url, json=body, headers={
            "Authorization": "Bearer " + auth['token'],
            "X-Restli-Protocol-Version": "2.0.0",
        })

        if not response.ok:
            raise Exception(response.text)
        return response.json()
  original_instructions: |-
    Create a Simple Post (User) in linkedin
  resource_type: |-
    linkedin
  resource_type_def: |-
    class linkedin(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def broken_function(gdocs_auth: gdocs, title: int) -> int:
        token = gdocs_auth["nonexistent_key"]

        body = {
            "title": title,
        }
        CREATE_DOC_URL = "https://docs.googleapis.com/v1/documents"

        response = nonexistentlibrary.post(
            CREATE_DOC_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The function name has been changed from `main` to `broken_function`, which by itself is not an error, but if the script relies on a function named `main`, this will break the expected behavior.
    3. The `gdocs_auth` TypedDict is expected to have a key `"token"`, but the code attempts to access a non-existent key `"nonexistent_key"`, which would raise a `KeyError` if the code execution reached that point.
    4. The `title` parameter in the function signature has been changed from `str` to `int`, and the return type from `str` to `int`, which could cause type errors if the function is called with the wrong types or if the caller expects a string return type.
    5. The `nonexistentlibrary.post` call attempts to use a method from the non-existent library, which would raise a `NameError` if the code execution reached that point.
  id: |-
    hubfix_hub_54
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, title: str) -> str:
        token = gdocs_auth["token"]

        body = {
            "title": title,
        }
        CREATE_DOC_URL = "https://docs.googleapis.com/v1/documents"

        response = requests.post(
            CREATE_DOC_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        return response.text
  original_instructions: |-
    Create a New Document in gdocs
  resource_type: |-
    gdocs
  resource_type_def: |-
    class gdocs(TypedDict):
        token: str
- broken_code: |-
    import os
    from slack_sdk import WebClient
    from typing import TypedDict

    class slack_resource(TypedDict):  # Changed the class name
        token: str

    def main(message: str, name: str, channel: str, slack_config: slack_resource):
        web = WebClient(token=slack_config['api_key'])  # Changed 'token' to 'api_key'
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        base_url = os.getenv("WM_BASE_URL")
        workspace = os.getenv("WM_WORKSPACE")
        text = f"Flow [{flow_id}]({base_url}/run/{flow_id}?workspace={workspace}) had an error:\n{name}: {message}"
        web.chat_postMessage(channel=channel, text=text)
        return message  # Changed the return type
  error: |-
    TypeError: TypedDict "slack_resource" has no key 'api_key'
  explanation: |-
    The code is broken for several reasons:

    1. The TypedDict class name was changed from `slack` to `slack_resource`, but the parameter `slack_config` in the `main` function is still annotated with the old class name `slack`. This will cause a type error because `slack` is no longer defined.

    2. Inside the `main` function, `slack_config['api_key']` is used, but the `slack_resource` TypedDict only defines a key named `token`. This will cause a KeyError because 'api_key' does not exist in the `slack_resource` TypedDict.

    3. The return type of the `main` function was changed from a dictionary to a string. This is a breaking change because the function is expected to return a dictionary with keys "message" and "flow_id", but now it only returns the message string.
  id: |-
    hubfix_hub_293
  lang: |-
    python
  original_code: |-
    import os
    from slack_sdk import WebClient
    from typing import TypedDict

    class slack(TypedDict):
        token: str

    def main(message: str, name: str, channel: str, slack_config: slack):
        web = WebClient(token=slack_config['token'])
        flow_id = os.getenv("WM_FLOW_JOB_ID")
        base_url = os.getenv("WM_BASE_URL")
        workspace = os.getenv("WM_WORKSPACE")
        text = f"Flow [{flow_id}]({base_url}/run/{flow_id}?workspace={workspace}) had an error:\n{name}: {message}"
        web.chat_postMessage(channel=channel, text=text)
        return {"message": message, "flow_id": flow_id}
  original_instructions: |-
    Send error to slack channel in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import List, Optional, TypedDict
    from nonexistentlibrary import HubSpot

    class hubspot(TypedDict):
        token: str

    def main(
        auth: hubspot,
        deal_id: str,
        properties: Optional[List[str]] = None,
        properties_with_history: Optional[List[str]] = None,
        associations: Optional[List[str]] = None,
        archived: Optional[bool] = None,
        id_property: Optional[str] = None,
    ):
        client = HubSpot(api_key=auth['api_token'])

        try:
            return client.crm.deals.basic_api.get_by_id(
                deal_id,
                get_prop(properties),
                get_prop(properties_with_history),
                get_prop(associations),
                archived,
                id_property,
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")

    def get_prop(prop: Optional[List[str]]):
        return prop if prop and isinstance(prop, list) and len(prop) > 0 else None
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import `HubSpot` from a module named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find the specified module. Additionally, the `auth` TypedDict is accessed with a key `'api_token'` which does not exist in the TypedDict definition; it should be `'token'`.
  id: |-
    hubfix_hub_230
  lang: |-
    python
  original_code: |-
    from typing import List, Optional, TypedDict
    from hubspot import HubSpot

    class hubspot(TypedDict):
        token: str

    def main(
        auth: hubspot,
        deal_id: str,
        properties: Optional[List[str]] = None,
        properties_with_history: Optional[List[str]] = None,
        associations: Optional[List[str]] = None,
        archived: Optional[bool] = None,
        id_property: Optional[str] = None,
    ):
        client = HubSpot(api_key=auth['token'])

        try:
            return client.crm.deals.basic_api.get_by_id(
                deal_id,
                get_prop(properties),
                get_prop(properties_with_history),
                get_prop(associations),
                archived,
                id_property,
            )
        except Exception as e:
            raise Exception(f"{e}\nMessage: {str(e)}\n")

    def get_prop(prop: Optional[List[str]]):
        return prop if prop and isinstance(prop, list) and len(prop) > 0 else None
  original_instructions: |-
    Get Deal in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, name: str = ""):
        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{nonexistentlibrary.utils.quote(room_id)}/state/m.room.name/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        response = requests.put(url, headers=headers, json={"name": name})
        if not response.ok:
            raise Exception(f"Failed to set room name: Error HTTP{response.status_code}")
        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the code tries to access `matrix_res['baseURL']` which should be `matrix_res['baseUrl']` (case-sensitive), and `response.text` is used instead of `response.json()`, which would not necessarily break the code but might not return the expected JSON response.
  id: |-
    hubfix_hub_286
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, name: str = ""):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.name/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        response = requests.put(url, headers=headers, json={"name": name})
        if not response.ok:
            raise Exception(f"Failed to set room name: Error HTTP{response.status_code}")
        return response.json()
  original_instructions: |-
    Set room name in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import base64
    import json
    import os
    import requests
    from typing import List, TypedDict, Dict

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, approver_emails: List[str], subject: str = "Resume Windmill flow"):
        throw_on_invalid_approvers(approver_emails)

        token = gmail_auth["access_token"]  # Changed from "token" to "access_token"
        results = []
        for to_email in approver_emails:
            results.append(send_email(token, to_email, subject))

        return results

    def send_email(gmail_token: str, to_email: str, subject: str) -> Dict:
        email = get_email_body(to_email, subject)
        SEND_EMAIL_URL = "https://gmail.googleapis.com/gmail/v1/users/me/messages/send"
        body = {
            'raw': email
        }
        response = requests.post(SEND_EMAIL_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {gmail_token}',
            'Content-Type': 'application/json'
        })
        response_json = response.json()

        return handle_send_email_result(response_json, to_email)

    def get_email_body(to_email: str, subject: str) -> str:
        approval_page = get_resume_urls(to_email)
        message = f"There is a Windmill flow at {os.getenv('WM_FLOW_PATH')} run by {os.getenv('WM_USERNAME')} waiting for your approval to resume.\n\nIn order to resume or cancel the flow go to {approval_page}"
        email_body = f"From: <me>\nTo: <{to_email}>\nSubject: {subject}\n\n {message}"

        return base64.urlsafe_b64encode(email_body.encode()).decode()

    def throw_on_invalid_approvers(approvers: List[str]):
        if not isinstance(approvers, list) or len(approvers) == 0:
            raise ValueError("Expected at least one approver email")

    def handle_send_email_result(result: Dict, to_email: str) -> Dict:
        if "error" in result:
            result.update({"wm_to_email": to_email})
            raise ValueError(result)

        return result

    def get_resume_urls(to_email: str) -> str:
        return f"https://example.com/approval?email={to_email}"
  error: |-
    KeyError: 'access_token'
  explanation: |-
    The code is broken because the key used to access the token in the `gmail_auth` TypedDict has been changed from "token" to "access_token". Since the TypedDict `gmail` only defines the key "token", trying to access `gmail_auth["access_token"]` will result in a KeyError because "access_token" is not a valid key in the `gmail_auth` dictionary.
  id: |-
    hubfix_hub_178
  lang: |-
    python
  original_code: |-
    import base64
    import json
    import os
    import requests
    from typing import List, TypedDict, Dict

    class gmail(TypedDict):
        token: str

    def main(gmail_auth: gmail, approver_emails: List[str], subject: str = "Resume Windmill flow"):
        throw_on_invalid_approvers(approver_emails)

        token = gmail_auth["token"]
        results = []
        for to_email in approver_emails:
            results.append(send_email(token, to_email, subject))

        return results

    def send_email(gmail_token: str, to_email: str, subject: str) -> Dict:
        email = get_email_body(to_email, subject)
        SEND_EMAIL_URL = "https://gmail.googleapis.com/gmail/v1/users/me/messages/send"
        body = {
            'raw': email
        }
        response = requests.post(SEND_EMAIL_URL, data=json.dumps(body), headers={
            'Authorization': f'Bearer {gmail_token}',
            'Content-Type': 'application/json'
        })
        response_json = response.json()

        return handle_send_email_result(response_json, to_email)

    def get_email_body(to_email: str, subject: str) -> str:
        approval_page = get_resume_urls(to_email)
        message = f"There is a Windmill flow at {os.getenv('WM_FLOW_PATH')} run by {os.getenv('WM_USERNAME')} waiting for your approval to resume.\n\nIn order to resume or cancel the flow go to {approval_page}"
        email_body = f"From: <me>\nTo: <{to_email}>\nSubject: {subject}\n\n {message}"

        return base64.urlsafe_b64encode(email_body.encode()).decode()

    def throw_on_invalid_approvers(approvers: List[str]):
        if not isinstance(approvers, list) or len(approvers) == 0:
            raise ValueError("Expected at least one approver email")

    def handle_send_email_result(result: Dict, to_email: str) -> Dict:
        if "error" in result:
            result.update({"wm_to_email": to_email})
            raise ValueError(result)

        return result

    def get_resume_urls(to_email: str) -> str:
        # Placeholder for the actual implementation of get_resume_urls
        # In the original TypeScript code, this function is imported from an external module
        # Here, we'll just return a dummy URL for demonstration purposes
        return f"https://example.com/approval?email={to_email}"
  original_instructions: |-
    Suspend/resume a flow by sending approval URL via email in gmail
  resource_type: |-
    gmail
  resource_type_def: |-
    class gmail(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        customers = stripe_module.Customer.retrieve(limit=limit)
        return customers
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named 'nonexistentlibrary' as 'stripe_module', which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find a module with the given name. Additionally, the `limit` parameter in the `main` function is changed to expect a string instead of an integer, which would cause a type error if the `ModuleNotFoundError` was resolved. Furthermore, the `Customer.retrieve` method is being called with a `limit` parameter, which is incorrect because `retrieve` is typically used to get a single customer by ID, not a list with a limit. The correct method to list customers with a limit is `Customer.list`.
  id: |-
    hubfix_hub_129
  lang: |-
    python
  original_code: |-
    import stripe as stripe_module
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, limit: int):
        token = stripe_con["token"]
        stripe_module.api_key = token

        customers = stripe_module.Customer.list(limit=limit)
        return customers
  original_instructions: |-
    List Customers in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def broken_function(gdocs_auth: gdocs, documentId: str):
        token = gdocs_auth["token"]
        GET_DOC_URL = f'https://docs.googleapis.com/v1/documents/{documentId}'

        response = nonexistentlibrary.get(
            GET_DOC_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        return response.text
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python cannot find a module with the given name. Additionally, the `main` function has been renamed to `broken_function`, which would cause an issue if there is code elsewhere expecting a function named `main`. Lastly, the `requests.get` method has been replaced with `nonexistentlibrary.get`, which will fail because `nonexistentlibrary` does not exist and therefore does not have a `get` method.
  id: |-
    hubfix_hub_55
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdocs(TypedDict):
        token: str

    def main(gdocs_auth: gdocs, documentId: str):
        token = gdocs_auth["token"]
        GET_DOC_URL = f'https://docs.googleapis.com/v1/documents/{documentId}'

        response = requests.get(
            GET_DOC_URL,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }
        )

        return response.text
  original_instructions: |-
    Get Document in gdocs
  resource_type: |-
    gdocs
  resource_type_def: |-
    class gdocs(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: int):
        STRIPE_CONFIRM_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/confirm'

        token = stripe_con["tokenz"]

        response = nonexistentlibrary.post(STRIPE_CONFIRM_PAYMENT_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        return response.jsonify()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The `import nonexistentlibrary` statement is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `tokenz` key is being accessed from the `stripe_con` TypedDict, but this key does not exist in the defined `stripe` TypedDict, which would raise a `KeyError` if the code execution reached this point.
    3. The `nonexistentlibrary.post` call is attempting to use a method from a library that doesn't exist, which would raise a `NameError` if the code execution reached this point.
    4. The `response.jsonify()` method does not exist on the `response` object returned by the `requests.post` method. The correct method is `response.json()`. This would raise an `AttributeError` if the code execution reached this point.
    5. The `id` parameter type in the `main` function signature has been changed from `str` to `int`, which is not necessarily a breaking change by itself, but it could lead to issues if the API endpoint expects a string and not an integer.
  id: |-
    hubfix_hub_119
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, id: str):
        STRIPE_CONFIRM_PAYMENT_URL = f'https://api.stripe.com/v1/payment_intents/{id}/confirm'

        token = stripe_con["token"]

        response = requests.post(STRIPE_CONFIRM_PAYMENT_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        return response.json()
  original_instructions: |-
    Confirm a Payment Intent in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gdrive_resource(TypedDict):
        access_token: str

    def broken_function(gdrive_auth: gdrive_resource, fileId: str, mimeType: str):
        DOWNLOAD_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/export?mimeType={mimeType}"

        token = gdrive_auth["token"]

        response = nonexistentlibrary.get(
            DOWNLOAD_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.jsonify()

        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `TypedDict` class was renamed from `gdrive` to `gdrive_resource`, but the function parameter `gdrive_auth` is still annotated with the old name `gdrive`.
    3. The `TypedDict` field was changed from `token` to `access_token`, but the code still tries to access `gdrive_auth["token"]`, which will raise a `KeyError` since the key "token" does not exist in the `gdrive_resource` TypedDict.
    4. The function `main` was renamed to `broken_function`, which could cause issues if other parts of the code expect a function named `main`.
    5. The `requests.get` method is replaced with `nonexistentlibrary.get`, which does not exist and will raise a `NameError`.
    6. The method `response.jsonify()` does not exist; the correct method is `response.json()`, so calling `jsonify()` will raise an `AttributeError`.
  id: |-
    hubfix_hub_48
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gdrive(TypedDict):
        token: str

    def main(gdrive_auth: gdrive, fileId: str, mimeType: str):
        DOWNLOAD_FILE_URL = f"https://www.googleapis.com/drive/v3/files/{fileId}/export?mimeType={mimeType}"

        token = gdrive_auth["token"]

        response = requests.get(
            DOWNLOAD_FILE_URL,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )

        result = response.json()

        return result
  original_instructions: |-
    Download Files (Google Docs, Sheets, Slides) in gdrive
  resource_type: |-
    gdrive
  resource_type_def: |-
    class gdrive(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional

    class ipinfo(TypedDict):
        token: str

    def broken_function(ipinfo: Optional[ipinfo] = None, ip: Optional[str] = None) -> list:
        token = ipinfo['api_key'] if ipinfo and 'api_key' in ipinfo else ''
        url = f'https://ipinfo.io{"/" + ip if ip else ""}/json?token={token}'
        ipAddressInformation = nonexistentlibrary.get(url)

        return {
            'status': ipAddressInformation.status_code,
            'payload': ipAddressInformation.json(),
        }
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. The import statement `import nonexistentlibrary` attempts to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The function `main` has been renamed to `broken_function`, which will cause an error if the script relies on a function named `main`.
    3. Inside the function, `ipinfo['api_key']` is used, but `api_key` is not a property of the `ipinfo` TypedDict; the correct property is `token`.
    4. The function `nonexistentlibrary.get(url)` is called, but `nonexistentlibrary` does not exist, which will raise a `NameError`.
    5. The return type of the function is changed from `dict` to `list`, but the actual return value is still a dictionary, which is inconsistent with the declared return type.
  id: |-
    hubfix_hub_393
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class ipinfo(TypedDict):
        token: str

    def main(ipinfo: Optional[ipinfo] = None, ip: Optional[str] = None) -> dict:
        token = ipinfo['token'] if ipinfo and 'token' in ipinfo else ''
        url = f'https://ipinfo.io{"/" + ip if ip else ""}/json?token={token}'
        ipAddressInformation = requests.get(url)

        return {
            'status': ipAddressInformation.status_code,
            'payload': ipAddressInformation.json(),
        }
  original_instructions: |-
    Get IP address insights from IPinfo - geolocation, privacy detection, company and more in ipinfo
  resource_type: |-
    ipinfo
  resource_type_def: |-
    class ipinfo(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):
        api_key: str

    def main(slack_auth: slack_resource, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_history(channels=channel)

        return response
  error: |-
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main({'api_key': 'xoxb-...'}, 'C1234567890')
      File "script.py", line 7, in main
        web = WebClient(token=slack_auth['token'])
    KeyError: 'token'
  explanation: |-
    The code is broken for several reasons:

    1. The `TypedDict` class was renamed from `slack` to `slack_resource`, but the `main` function still expects a parameter of type `slack`. This will not cause a runtime error directly since Python's type hints are not enforced at runtime, but it is a logical error.

    2. The `TypedDict` now expects an `api_key` instead of a `token`, but the `WebClient` is still being passed `slack_auth['token']`, which will not exist in the `slack_auth` dictionary if it's created with the new `slack_resource` definition. This will cause a `KeyError` at runtime.

    3. The `conversations_history` method is called with a keyword argument `channels` instead of `channel`. This will not cause an error directly, as the Slack SDK will ignore unexpected parameters, but it will not work as intended because the correct parameter is `channel`.

    4. The return statement has been changed to return `response` directly instead of a dictionary with `response` as a key. This is not an error per se, but it changes the return type of the function, which could break code that depends on the original return type.
  id: |-
    hubfix_hub_19
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str):
        web = WebClient(token=slack_auth['token'])

        response = web.conversations_history(channel=channel)

        return {'response': response}
  original_instructions: |-
    List Conversation History in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: int, topic: str = ""):
        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{nonexistentlibrary.utils.quote(room_id)}/state/m.room.topic/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        body = {
            "topic": topic,
        }
        resp = requests.put(url, headers=headers, json=body)
        if not resp.ok:
            raise Exception(f"Failed to set room topic: Error HTTP{resp.status_code}")
        return resp.text()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The script tries to import a library named `nonexistentlibrary`, which does not exist.
    - The `room_id` parameter type in the `main` function is changed from `str` to `int`, which is incorrect because the `requests.utils.quote` function expects a string.
    - The `matrix_res['baseURL']` is incorrect because the correct key is `baseUrl` as defined in the `matrix` TypedDict.
    - The `nonexistentlibrary.utils.quote(room_id)` call will fail because `nonexistentlibrary` does not exist, and even if it did, `room_id` should be a string, not an integer.
    - The `return resp.text()` is incorrect because the original function returns `resp.json()`, which is the expected return type for a JSON response.
  id: |-
    hubfix_hub_287
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, room_id: str, topic: str = ""):
        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(room_id)}/state/m.room.topic/"
        headers = {
            "Authorization": f"Bearer {matrix_res['token']}",
            "Content-Type": "application/json",
        }
        body = {
            "topic": topic,
        }
        resp = requests.put(url, headers=headers, json=body)
        if not resp.ok:
            raise Exception(f"Failed to set room topic: Error HTTP{resp.status_code}")
        return resp.json()
  original_instructions: |-
    Set room topic in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, Optional

    class slack_resource(TypedDict, total=False):
        sensitive: bool
        status: str
        visibility: str
        in_reply_to_id: str
        spoiler_text: str
        language: str

    def broken_function(
        base_url: str,
        access_token: str,
        status: str,
        in_reply_to_id: Optional[str] = None,
        sensitive: bool = False,
        spoiler_text: Optional[str] = None,
        visibility: str = "public",
        language: Optional[str] = None
    ) -> slack_resource:
        payload = {
            "sensitive": sensitive,
            "status": status,
            "visibility": visibility
        }
        if in_reply_to_id:
            payload["in_reply_to_id"] = in_reply_to_id
        if spoiler_text:
            payload["spoiler_text"] = spoiler_text
        if language:
            payload["language"] = language

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        resp = nonexistentlibrary.post(f"{base_url}/api/v1/statuses", headers=headers, json=payload)

        if not resp.ok:
            raise Exception(f"Failed to post status: Error HTTP{resp.status_code}")

        return resp.json()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name. Additionally, the function `broken_function` is trying to use a method `post` from this non-existent library, which would also cause an `AttributeError` if the import statement were to be corrected but the library still didn't have a `post` method. Furthermore, the TypedDict has been renamed from `mastodon` to `slack_resource`, which is not used anywhere in the code, and the main function has been renamed to `broken_function`, which would cause issues if other parts of the code expect a function named `main`.
  id: |-
    hubfix_hub_100
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Optional

    class mastodon(TypedDict, total=False):
        sensitive: bool
        status: str
        visibility: str
        in_reply_to_id: str
        spoiler_text: str
        language: str

    def main(
        base_url: str,
        access_token: str,
        status: str,
        in_reply_to_id: Optional[str] = None,
        sensitive: bool = False,
        spoiler_text: Optional[str] = None,
        visibility: str = "public",
        language: Optional[str] = None
    ) -> mastodon:
        payload = {
            "sensitive": sensitive,
            "status": status,
            "visibility": visibility
        }
        if in_reply_to_id:
            payload["in_reply_to_id"] = in_reply_to_id
        if spoiler_text:
            payload["spoiler_text"] = spoiler_text
        if language:
            payload["language"] = language

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        resp = requests.post(f"{base_url}/api/v1/statuses", headers=headers, json=payload)

        if not resp.ok:
            raise Exception(f"Failed to post status: Error HTTP{resp.status_code}")

        return resp.json()
  original_instructions: |-
    Post status in mastodon
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary as stripe_module

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, invoice_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.retrieve(invoice_id)

        return invoice_item
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is attempting to import a module named 'nonexistentlibrary' as 'stripe_module', which does not exist. Python raises a `ModuleNotFoundError` because it cannot find a module with that name in the Python package index or among the installed packages.
  id: |-
    hubfix_hub_123
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import stripe as stripe_module

    class stripe(TypedDict):
        token: str

    def main(stripe_con: stripe, invoice_id: str):
        token = stripe_con["token"]
        stripe_module.api_key = token

        invoice_item = stripe_module.InvoiceItem.retrieve(invoice_id)

        return invoice_item
  original_instructions: |-
    Retrieve Invoice Line Item in stripe
  resource_type: |-
    stripe
  resource_type_def: |-
    class stripe(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.deals import SimplePublicObjectInput

    class slack_resource(TypedDict):
        token: str

    def remove_object_empty_fields(properties: dict) -> dict:
        return {k: v for k, v in properties.items() if v is not None and v != ''}

    def main(auth: slack_resource, amount: Optional[str] = None, closedate: Optional[str] = None,
             dealname: Optional[str] = None, dealstage: Optional[str] = None,
             hubspot_owner_id: Optional[str] = None, pipeline: Optional[str] = None):
        client = HubSpot(api_key=auth['api_token'])
        properties = remove_object_empty_fields({
            'amount': amount,
            'closedate': closedate,
            'dealname': dealname,
            'dealstage': dealstage,
            'hubspot_owner_id': hubspot_owner_id,
            'pipeline': pipeline,
        })
        try:
            simple_public_object_input = SimplePublicObjectInput(properties=properties)
            return client.crm.deals.basic_api.create(simple_public_object_input=simple_public_object_input)
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  error: |-
    KeyError: 'api_token'
  explanation: |-
    The code is broken because of two changes:

    1. The `TypedDict` class was renamed from `hubspot` to `slack_resource`, which is not consistent with the usage in the `main` function. The `main` function still expects a `TypedDict` named `hubspot`, but it has been renamed to `slack_resource`. This change will not cause a runtime error but will cause confusion and potential type checking errors.

    2. The `auth` dictionary is being accessed with a key `'api_token'` that does not exist. The original `TypedDict` defined a key `'token'`, not `'api_token'`. This will cause a `KeyError` at runtime when the `auth` dictionary is accessed with a non-existent key.
  id: |-
    hubfix_hub_229
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from hubspot import HubSpot
    from hubspot.crm.deals import SimplePublicObjectInput

    class hubspot(TypedDict):
        token: str

    def remove_object_empty_fields(properties: dict) -> dict:
        return {k: v for k, v in properties.items() if v is not None and v != ''}

    def main(auth: hubspot, amount: Optional[str] = None, closedate: Optional[str] = None,
             dealname: Optional[str] = None, dealstage: Optional[str] = None,
             hubspot_owner_id: Optional[str] = None, pipeline: Optional[str] = None):
        client = HubSpot(api_key=auth['token'])
        properties = remove_object_empty_fields({
            'amount': amount,
            'closedate': closedate,
            'dealname': dealname,
            'dealstage': dealstage,
            'hubspot_owner_id': hubspot_owner_id,
            'pipeline': pipeline,
        })
        try:
            simple_public_object_input = SimplePublicObjectInput(properties=properties)
            return client.crm.deals.basic_api.create(simple_public_object_input=simple_public_object_input)
        except Exception as e:
            raise Exception(f"""
                {e.__class__.__name__} - {getattr(e, 'category', 'Unknown')}\n
                Message: {str(e)}\n
                Correlation ID: {getattr(e, 'correlation_id', 'Unknown')}
            """)
  original_instructions: |-
    Create Deal in hubspot
  resource_type: |-
    hubspot
  resource_type_def: |-
    class hubspot(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def broken_function(gh_auth: github, owner: int, repo: str):
        headers = {
            'Authorization': f'token {gh_auth["nonexistent_key"]}',
            'X-GitHub-Api-Version': '2022-11-28',
            'Accept': 'application/vnd.github+json',
        }
        response = nonexistentlibrary.get(f'https://api.github.com/repos/{owner}/{repo}', headers=headers)
        response.raise_for_status()
        repository_data = response.json()
        return repository_data.get('stargazers_count')
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The `import nonexistentlibrary` statement is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The `broken_function` is expecting an `int` type for the `owner` parameter, but it should be a `str` since GitHub repository owners are represented by their username as a string.
    3. The `gh_auth["nonexistent_key"]` is trying to access a key that doesn't exist in the `github` TypedDict, which would raise a `KeyError` if the code execution reached this point.
    4. The `nonexistentlibrary.get` call is trying to use a method from the non-existent library, which would raise a `NameError` if the code execution reached this point after fixing the import error.
  id: |-
    hubfix_hub_314
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class github(TypedDict):
        token: str

    def main(gh_auth: github, owner: str, repo: str):
        headers = {
            'Authorization': f'token {gh_auth["token"]}',
            'X-GitHub-Api-Version': '2022-11-28',
            'Accept': 'application/vnd.github+json',
        }
        response = requests.get(f'https://api.github.com/repos/{owner}/{repo}', headers=headers)
        response.raise_for_status()
        repository_data = response.json()
        return repository_data.get('stargazers_count')
  original_instructions: |-
    Get Repo Star Count in github
  resource_type: |-
    github
  resource_type_def: |-
    class github(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class slack_resource(TypedDict):
        base_url: str
        token_key: str

    def secondary(glab: slack_resource, projectId: str):
        url = f"{glab['baseURL']}/api/v4/projects/{projectId}/repository/commits"
        response = nonexistentlibrary.get(url, headers={
            'Authorization': f"Bearer: {glab['token']}",
            'Content-Type': 'application/json',
        })
        return response.text()
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    - The script attempts to import a library named `nonexistentlibrary`, which does not exist.
    - The `TypedDict` class is renamed from `gitlab` to `slack_resource`, which is not used anywhere in the code.
    - The `main` function is renamed to `secondary`, which would not be an issue by itself, but if the script relies on a function named `main`, this would cause a problem.
    - The `TypedDict` properties are changed from `baseUrl` and `token` to `base_url` and `token_key`, which do not match the keys used in the function (`glab['baseURL']` and `glab['token']`).
    - The `requests.get` function is replaced with `nonexistentlibrary.get`, which does not exist.
    - The method `response.text()` is incorrect; it should be `response.text` if you want to get the raw response text, or `response.json()` if you want to parse JSON response.
  id: |-
    hubfix_hub_165
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gitlab(TypedDict):
        baseUrl: str
        token: str

    def main(glab: gitlab, projectId: str):
        url = f"{glab['baseUrl']}/api/v4/projects/{projectId}/repository/commits"
        response = requests.get(url, headers={
            'Authorization': f"Bearer: {glab['token']}",
            'Content-Type': 'application/json',
        })
        return response.json()
  original_instructions: |-
    List Commits in gitlab
  resource_type: |-
    gitlab
  resource_type_def: |-
    class gitlab(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def broken_function(gcal_auth: gcal, calendarId: str):
        LIST_EVENTS_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events'

        token = gcal_auth["access_token"]

        response = nonexistentlibrary.get(LIST_EVENTS_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        result = response.jsonify()

        return result
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` is trying to import a library that doesn't exist, which will raise a `ModuleNotFoundError`.
    2. The function `main` has been renamed to `broken_function`, which will cause an error if the code expects a function named `main`.
    3. The `gcal_auth` TypedDict is accessed with a key `"access_token"` which does not exist; it should be `"token"`.
    4. The `nonexistentlibrary.get` function call is trying to use a method from the non-existent library, which will raise a `NameError`.
    5. The method `response.jsonify()` does not exist; the correct method to parse the JSON response is `response.json()`.
  id: |-
    hubfix_hub_43
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gcal(TypedDict):
        token: str

    def main(gcal_auth: gcal, calendarId: str):
        LIST_EVENTS_URL = f'https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events'

        token = gcal_auth["token"]

        response = requests.get(LIST_EVENTS_URL, headers={
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        })

        result = response.json()

        return result
  original_instructions: |-
    List Events in gcal
  resource_type: |-
    gcal
  resource_type_def: |-
    class gcal(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional, Dict, Any
    from clickhouse_driver import Client

    class clickhouse(TypedDict):
        host: str
        username: str
        password: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: clickhouse,
        query: str,
        parse_into: str = "json",
        format: Optional[str] = None,
        clickhouse_settings: Optional[Dict[str, Any]] = None,
        query_params: Optional[Dict[str, Any]] = None,
    ):
        client = Client(**remove_empty_fields(auth))

        params = remove_empty_fields({
            'query': query,
            'format': format,
            'settings': clickhouse_settings,
        })

        if query_params:
            params['params'] = query_params

        result = client.execute_query(**params)  # Changed from execute to execute_query

        client.disconnect()

        if parse_into == "json":
            return result
        elif parse_into == "text":
            return str(result)
        else:
            raise ValueError(f"Unsupported parse_into value: {parse_into}")
  error: |-
    AttributeError: 'Client' object has no attribute 'execute_query'
  explanation: |-
    The error occurs because the method `execute_query` does not exist on the `Client` object from the `clickhouse_driver` library. The correct method name is `execute`. By changing `client.execute(**params)` to `client.execute_query(**params)`, the code attempts to call a non-existent method, resulting in an AttributeError.
  id: |-
    hubfix_hub_268
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional, Dict, Any
    from clickhouse_driver import Client

    class clickhouse(TypedDict):
        host: str
        username: str
        password: str

    def remove_empty_fields(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: v for k, v in d.items() if v is not None}

    def main(
        auth: clickhouse,
        query: str,
        parse_into: str = "json",
        format: Optional[str] = None,
        clickhouse_settings: Optional[Dict[str, Any]] = None,
        query_params: Optional[Dict[str, Any]] = None,
    ):
        client = Client(**remove_empty_fields(auth))

        params = remove_empty_fields({
            'query': query,
            'format': format,
            'settings': clickhouse_settings,
        })

        if query_params:
            params['params'] = query_params

        result = client.execute(**params)

        client.disconnect()

        if parse_into == "json":
            return result
        elif parse_into == "text":
            return str(result)
        else:
            raise ValueError(f"Unsupported parse_into value: {parse_into}")
  original_instructions: |-
    Run Query in clickhouse
  resource_type: |-
    clickhouse
  resource_type_def: |-
    class clickhouse(TypedDict):
        host: str
        username: str
        password: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def broken_function(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: str,  # Changed the type from int to str
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        DELETE_ROWS_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "deleteDimension": {
                        "range": {
                            "sheetId": sheetId,
                            "dimension": "ROWS",
                            "startIndex": start_index,
                            "endIndex": end_index,
                        },
                    },
                },
            ],
        }
        response = requests.post(
            DELETE_ROWS_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()

        return "Rows deleted."
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the type of the `sheetId` parameter in the `broken_function` has been changed from `int` to `str`, which could potentially cause issues if the API expects an integer value for the `sheetId`. However, the `ModuleNotFoundError` will prevent the script from running to the point where this would be a problem.
  id: |-
    hubfix_hub_69
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class gsheets(TypedDict):
        token: str

    def main(
        gsheets_auth: gsheets,
        spreadsheetId: str,
        sheetId: int,
        start_index: int,
        end_index: int,
    ):
        token = gsheets_auth["token"]

        DELETE_ROWS_URL = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheetId}:batchUpdate"

        body = {
            "requests": [
                {
                    "deleteDimension": {
                        "range": {
                            "sheetId": sheetId,
                            "dimension": "ROWS",
                            "startIndex": start_index,
                            "endIndex": end_index,
                        },
                    },
                },
            ],
        }
        response = requests.post(
            DELETE_ROWS_URL,
            json=body,
            headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            },
        )
        response.raise_for_status()  # Raises an HTTPError if the HTTP request returned an unsuccessful status code

        return "Rows deleted."
  original_instructions: |-
    Clear Row in gsheets
  resource_type: |-
    gsheets
  resource_type_def: |-
    class gsheets(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlib
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, roomId: int):
        if not matrix_res['access_token']:
            raise ValueError("Leaving a room requires an access token.")

        url = f"{matrix_res['baseURL']}/_matrix/client/v3/rooms/{nonexistentlib.utils.quote(roomId)}/leave"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        resp = nonexistentlib.post(url, headers=headers)

        if not resp.ok:
            raise ValueError(f"Failed to leave room: Error HTTP{resp.status_code}")
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code is trying to import a library called `nonexistentlib`, which does not exist. This will cause a `ModuleNotFoundError` when the script is run. Additionally, the `roomId` parameter type has been changed from `str` to `int`, which could cause issues if the `requests.utils.quote` function expects a string. The `matrix_res` dictionary is being accessed with incorrect keys: 'access_token' and 'baseURL' instead of 'token' and 'baseUrl'. Lastly, `nonexistentlib.post` is being called instead of `requests.post`, which will also cause a runtime error since `nonexistentlib` does not exist.
  id: |-
    hubfix_hub_96
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class matrix(TypedDict):
        baseUrl: str
        token: str

    def main(matrix_res: matrix, roomId: str):
        if not matrix_res['token']:
            raise ValueError("Leaving a room requires an access token.")

        url = f"{matrix_res['baseUrl']}/_matrix/client/v3/rooms/{requests.utils.quote(roomId)}/leave"
        headers = {
            'Authorization': f"Bearer {matrix_res['token']}",
        }

        resp = requests.post(url, headers=headers)

        if not resp.ok:
            raise ValueError(f"Failed to leave room: Error HTTP{resp.status_code}")
  original_instructions: |-
    Leave room in matrix
  resource_type: |-
    matrix
  resource_type_def: |-
    class matrix(TypedDict):
        baseUrl: str
        token: str
- broken_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):  # Changed the class name from 'slack' to 'slack_resource'
        token: str

    def main(slack_auth: slack, channel: str, purpose: str):  # The type hint still refers to the old 'slack' class
        web = WebClient(token=slack_auth['token'])

        web.conversations_setPurpose(
            channel=channel,
            purpose=purpose
        )

        return "Successfully updated channel purpose"  # Changed the return type from a dictionary to a string
  error: |-
    TypeError: TypedDict "slack" has no attribute "token"
  explanation: |-
    The code is broken because of two changes:

    1. The TypedDict class name was changed from `slack` to `slack_resource`, but the type hint in the `main` function's parameter `slack_auth` still refers to the old name `slack`. This will cause a TypeError because the `slack_auth` parameter is expected to be of type `slack`, which no longer exists.

    2. The return type of the `main` function was changed from a dictionary to a string. If the function is expected to return a dictionary elsewhere in the code, this change will cause a type mismatch error.
  id: |-
    hubfix_hub_15
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def main(slack_auth: slack, channel: str, purpose: str):
        web = WebClient(token=slack_auth['token'])

        web.conversations_setPurpose(
            channel=channel,
            purpose=purpose
        )

        return {"message": "Successfully updated channel purpose"}
  original_instructions: |-
    Set Channel Purpose in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: Optional[str] = None):
        table = Table(at_con['api_key'], at_table['baseId'], at_table['tableName'])

        if record_id:
            record = table.get(record_id)
            return {'result': record}
        else:
            records = table.fetch_all()
            return {'result': records}
  error: |-
    AttributeError: 'Table' object has no attribute 'fetch_all'
  explanation: |-
    The code is broken because the `Table` class from the `pyairtable` library does not have a method called `fetch_all`. The correct method to retrieve all records is `all()`, not `fetch_all()`. Additionally, the dictionary key `'api_key'` is incorrect; it should be `'apiKey'` as defined in the `airtable` TypedDict.
  id: |-
    hubfix_hub_357
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    from pyairtable import Table

    class airtable(TypedDict):
        apiKey: str

    class airtableTable(TypedDict):
        baseId: str
        tableName: str

    def main(at_con: airtable, at_table: airtableTable, record_id: Optional[str] = None):
        table = Table(at_con['apiKey'], at_table['baseId'], at_table['tableName'])

        if record_id:
            record = table.get(record_id)
            return {'result': record}
        else:
            records = table.all()
            return {'result': records}
  original_instructions: |-
    Get Record in airtable
  resource_type: |-
    airtable
  resource_type_def: |-
    class airtable(TypedDict):
        apiKey: str
- broken_code: |-
    import requests
    from typing import TypedDict

    class scheduleapi(TypedDict):
        workspace_id: str
        schedule_path: str
        enabled: bool

    def create_conf() -> scheduleapi:
        return {
            "workspace_id": "your_workspace_id",
            "schedule_path": "",
            "enabled": False
        }

    def set_schedule_enabled(conf: scheduleapi, schedule_path: str, enabled: str):
        api_url = f"https://api.example.com/workspaces/{conf['workspace_id']}/schedules/{schedule_path}"
        payload = {"enabled": enabled}
        response = requests.put(api_url, json=payload)
        return response.json()

    def main(schedule_path: str, enabled: bool):
        conf = create_conf()
        conf['schedule_path'] = schedule_path
        return set_schedule_enabled(conf, schedule_path, "yes")
  error: |-
    TypeError: set_schedule_enabled() argument 'enabled' must be bool, not str
  explanation: |-
    The `set_schedule_enabled` function is defined to take a `bool` for the `enabled` parameter, but in the `main` function, it is called with a string `"yes"` instead of a boolean. This causes a `TypeError` because the type of the `enabled` parameter is not consistent with the type specified in the function definition.
  id: |-
    hubfix_hub_114
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict

    class scheduleapi(TypedDict):
        workspace_id: str
        schedule_path: str
        enabled: bool

    def create_conf() -> scheduleapi:
        # Assuming createConf initializes some configuration
        # Replace with actual initialization as needed
        return {
            "workspace_id": "your_workspace_id",  # Replace with actual workspace ID
            "schedule_path": "",
            "enabled": False
        }

    def set_schedule_enabled(conf: scheduleapi, schedule_path: str, enabled: bool):
        # Assuming setScheduleEnabled makes an HTTP request to an API
        # Replace with actual API endpoint and authentication as needed
        api_url = f"https://api.example.com/workspaces/{conf['workspace_id']}/schedules/{schedule_path}"
        payload = {"enabled": enabled}
        response = requests.put(api_url, json=payload)
        return response.json()

    def main(schedule_path: str, enabled: bool):
        conf = create_conf()
        conf['schedule_path'] = schedule_path
        return set_schedule_enabled(conf, schedule_path, enabled)
  original_instructions: |-
    Turn on/off a schedule in windmill
  resource_type: |-
    scheduleapi
  resource_type_def: |-
    class scheduleapi(TypedDict):
        workspace_id: str
        schedule_path: str
        enabled: bool
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack_resource(TypedDict):
        token: str

    def get_resume_urls(channel: str):
        response = nonexistentlibrary.get(f"https://api.example.com/getResumeUrls/channel-{channel}")
        return response.json()

    def main(slack_config: slack_resource, channel: str, text: str = "A flow is requesting an approval to be resumed"):
        web = WebClient(token=slack_config['api_token'])

        resume_urls = get_resume_urls(channel)
        approval_page = resume_urls['approvalPage']
        response = web.chat_postMessage(
            channel=channel,
            text=f"{text} <{approval_page}|approval page>"
        )
        return response
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the `slack_config` parameter in the `main` function is expected to be of type `slack`, but the TypedDict has been renamed to `slack_resource`, which would cause a type mismatch if the import error was resolved. Furthermore, the `slack_config` dictionary is accessed with a key `'api_token'` that was not defined in the original `slack` TypedDict, which would lead to a `KeyError` if the code were to run past the import error. The `nonexistentlibrary.get` function call would also fail because `nonexistentlibrary` does not exist.
  id: |-
    hubfix_hub_273
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict
    from slack_sdk import WebClient

    class slack(TypedDict):
        token: str

    def get_resume_urls(channel: str):
        # Assuming there is a similar API endpoint to get resume URLs
        response = requests.get(f"https://api.example.com/getResumeUrls/channel-{channel}")
        return response.json()

    def main(slack_config: slack, channel: str, text: str = "A flow is requesting an approval to be resumed"):
        web = WebClient(token=slack_config['token'])

        resume_urls = get_resume_urls(channel)
        approval_page = resume_urls['approvalPage']
        response = web.chat_postMessage(
            channel=channel,
            text=f"{text} <{approval_page}|approval page>"
        )
        return response
  original_instructions: |-
    Ask channel for approval in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    import nonexistentlibrary
    from typing import TypedDict, List

    class sendgrid(TypedDict):
        token: str

    def broken_function(api_token: sendgrid, list_id: str, contact_ids: List[str]):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }

        contact_ids_str = ",".join(contact_ids) if contact_ids else ""
        url = f"https://api.sendgrid.com/v3/marketing/lists/{list_id}/contacts"
        params = {'contact_ids': contact_ids_str}

        try:
            response = nonexistentlibrary.delete(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()
        except nonexistentlibrary.exceptions.RequestException as error:
            raise Exception("\n" + str(error.response.json() if error.response else error))
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary`, which does not exist. This will cause a `ModuleNotFoundError` when Python tries to import it. Additionally, the function `requests.delete` has been incorrectly replaced with `nonexistentlibrary.delete`, which would also cause an error if the import statement did not already fail. The `except` block also references `nonexistentlibrary.exceptions.RequestException`, which is invalid for the same reason. Lastly, the `main` function has been renamed to `broken_function`, which would cause an error if there is code elsewhere expecting a function named `main`.
  id: |-
    hubfix_hub_225
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, List

    class sendgrid(TypedDict):
        token: str

    def main(api_token: sendgrid, list_id: str, contact_ids: List[str]):
        headers = {
            "Authorization": f"Bearer {api_token['token']}",
            "Content-Type": "application/json"
        }

        contact_ids_str = ",".join(contact_ids) if contact_ids else ""
        url = f"https://api.sendgrid.com/v3/marketing/lists/{list_id}/contacts"
        params = {'contact_ids': contact_ids_str}

        try:
            response = requests.delete(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as error:
            raise Exception("\n" + str(error.response.json() if error.response else error))
  original_instructions: |-
    Remove Contact From List in sendgrid
  resource_type: |-
    sendgrid
  resource_type_def: |-
    class sendgrid(TypedDict):
        token: str
- broken_code: |-
    import requests
    from typing import TypedDict, Dict
    from email_validator import validate_email, EmailNotValidError

    class slack_resource(TypedDict):  # Renamed from 'slack' to 'slack_resource'
        token: str

    class UserData(TypedDict):
        id: str
        email: str
        real_name: str

    def main(user_email: str, text: str, slack_config: slack_resource):  # Changed 'slack' to 'slack_resource'
        throw_on_invalid_email(user_email)

        client = WebClient(slack_config['token'])
        user_data = get_user_data(client, user_email)
        print(user_data)
        result = send_direct_message(text, client, user_data)

        return result

    def get_user_data(client: 'WebClient', email: str) -> UserData:
        try:
            response = client.users_lookup_by_email(email=email)

            user = response['user']
            return UserData(id=user['id'], email=email, real_name=user['real_name'])
        except Exception as err:
            return handle_api_response(email, err)

    def send_direct_message(text: str, client: 'WebClient', user_data: UserData):
        response = client.chat_post_message(channel=user_data['id'], text=text)
        return {
            'ok': response['ok'],
            'ts': response['ts'],
            'channel': response['channel'],
            'email': user_data['email']
        }

    def throw_on_invalid_email(email: str):
        try:
            validate_email(email)
        except EmailNotValidError:
            raise ValueError("Expected user email")

    def handle_api_response(email: str, error: Exception):
        raise ValueError({'email': email, 'err_msg': str(error)})

    class WebClient:
        def __init__(self, token: str):
            self.token = token
            self.session = requests.Session()
            self.session.headers.update({'Authorization': f'Bearer {self.token}'})

        def users_lookup_by_email(self, email: str) -> Dict:
            url = 'https://slack.com/api/users.lookupByEmail'
            response = self.session.get(url, params={'email': email})
            return response.json()

        def chat_post_message(self, channel: str, text: str) -> Dict:
            url = 'https://slack.com/api/chat.postMessage'
            response = self.session.post(url, data={'channel': channel, 'text': text})
            return response.json()
  error: |-
    TypeError: TypedDict "slack_resource" has no key 'token'
  explanation: |-
    The TypedDict class `slack` was renamed to `slack_resource`, but the parameter `slack_config` in the `main` function is still expected to be of type `slack`. Since `slack` no longer exists, the code will break when trying to access `slack_config['token']` because `slack_resource` is not recognized as the correct type for `slack_config`. The type hint for the `slack_config` parameter in the `main` function should have remained as `slack` to match the TypedDict name.
  id: |-
    hubfix_hub_189
  lang: |-
    python
  original_code: |-
    import requests
    from typing import TypedDict, Dict
    from email_validator import validate_email, EmailNotValidError

    class slack(TypedDict):
        token: str

    class UserData(TypedDict):
        id: str
        email: str
        real_name: str

    def main(user_email: str, text: str, slack_config: slack):
        throw_on_invalid_email(user_email)

        client = WebClient(slack_config['token'])
        user_data = get_user_data(client, user_email)
        print(user_data)
        result = send_direct_message(text, client, user_data)

        return result

    def get_user_data(client: 'WebClient', email: str) -> UserData:
        try:
            response = client.users_lookup_by_email(email=email)

            user = response['user']
            return UserData(id=user['id'], email=email, real_name=user['real_name'])
        except Exception as err:
            return handle_api_response(email, err)

    def send_direct_message(text: str, client: 'WebClient', user_data: UserData):
        response = client.chat_post_message(channel=user_data['id'], text=text)
        return {
            'ok': response['ok'],
            'ts': response['ts'],
            'channel': response['channel'],
            'email': user_data['email']
        }

    def throw_on_invalid_email(email: str):
        try:
            validate_email(email)
        except EmailNotValidError:
            raise ValueError("Expected user email")

    def handle_api_response(email: str, error: Exception):
        raise ValueError({'email': email, 'err_msg': str(error)})

    class WebClient:
        def __init__(self, token: str):
            self.token = token
            self.session = requests.Session()
            self.session.headers.update({'Authorization': f'Bearer {self.token}'})

        def users_lookup_by_email(self, email: str) -> Dict:
            url = 'https://slack.com/api/users.lookupByEmail'
            response = self.session.get(url, params={'email': email})
            return response.json()

        def chat_post_message(self, channel: str, text: str) -> Dict:
            url = 'https://slack.com/api/chat.postMessage'
            response = self.session.post(url, data={'channel': channel, 'text': text})
            return response.json()
  original_instructions: |-
    Send direct message in slack
  resource_type: |-
    slack
  resource_type_def: |-
    class slack(TypedDict):
        token: str
- broken_code: |-
    from typing import TypedDict, Optional
    import nonexistentlibrary  # This library does not exist

    class wmill(TypedDict):
        workspace: str
        suspend: bool
        perPage: int
        scriptPathExact: Optional[str]

    def main(scriptPathExact: Optional[str] = None):
        params = {
            'workspace': 'your_workspace_name',
            'suspend': True,
            'perPage': 50,
            'scriptPathWrong': scriptPathExact,  # Incorrect dictionary key
        }
        response = nonexistentlibrary.post('https://api.yourwindmillserver.com/listQueue', data=params)  # Using a nonexistent library
        return response.jsonify()  # Incorrect method call
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named `nonexistentlibrary`, which does not exist. Additionally, the `requests` library is replaced with `nonexistentlibrary` when calling the `post` method, which would also cause a runtime error if the import error was fixed. Furthermore, the method `jsonify()` does not exist; the correct method to call is `json()`. Lastly, the dictionary key `scriptPathWrong` is used instead of `scriptPathExact`, which would not match the expected API parameters if the code were to run.
  id: |-
    hubfix_hub_270
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Optional
    import requests

    class wmill(TypedDict):
        workspace: str
        suspend: bool
        perPage: int
        scriptPathExact: Optional[str]

    def main(scriptPathExact: Optional[str] = None):
        params = {
            'workspace': 'your_workspace_name',  # Replace with your actual workspace name
            'suspend': True,
            'perPage': 50,
            'scriptPathExact': scriptPathExact,
        }
        response = requests.get('https://api.yourwindmillserver.com/listQueue', params=params)  # Replace with your actual Windmill server URL
        return response.json()
  original_instructions: |-
    List Suspended Jobs in windmill
  resource_type: |-
    wmill
  resource_type_def: |-
    class wmill(TypedDict):
        workspace: str
        suspend: bool
        perPage: int
        scriptPathExact: Optional[str]
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary  # This library does not exist
    from io import BytesIO
    import base64

    class qrcode_typeddict(TypedDict):
        qr_url: str

    def main(qr_url: int) -> qrcode_typeddict:  # Changed the type of qr_url parameter to int
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(qr_url)  # qr_url is now an int, which might not be accepted
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")

        base64_image = f"data:image/png;base64,{img_str}"
        return {"qr_code": base64_image}  # Changed the key from 'qr_url' to 'qr_code'
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement `import nonexistentlibrary` attempts to import a library that does not exist, which will raise a `ModuleNotFoundError`.
    2. The `main` function's parameter `qr_url` has been changed from `str` to `int`, which is not the expected type for the `qr.add_data()` method. This could potentially raise a `TypeError` if the `qrcode` library does not accept integers as data.
    3. The key in the returned dictionary has been changed from `'qr_url'` to `'qr_code'`, which does not match the defined `TypedDict` `qrcode_typeddict`. This would not raise an error but would result in incorrect behavior if the caller expects a dictionary with the key `'qr_url'`.
  id: |-
    hubfix_hub_87
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import qrcode
    from io import BytesIO
    import base64

    class qrcode_typeddict(TypedDict):
        qr_url: str

    def main(qr_url: str) -> qrcode_typeddict:
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(qr_url)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")

        base64_image = f"data:image/png;base64,{img_str}"
        return {"qr_url": base64_image}
  original_instructions: |-
    Generate QR Code in qrcode
  resource_type: |-
    qrcode_typeddict
  resource_type_def: |-
    class qrcode_typeddict(TypedDict):
        qr_url: str
- broken_code: |-
    from typing import TypedDict
    import nonexistentlibrary

    class openai_auth(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai_auth, prompt: str, model: str = "text-embedding-ada-002"):
        nonexistentlibrary.api_key = auth['api_key']
        nonexistentlibrary.organization = auth['organization_id']

        response = nonexistentlibrary.Embedding.create(
            model=model,
            input_data=prompt
        )
        return response['information']
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is trying to import a library called `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError` when Python cannot find a module with the given name. Additionally, the code attempts to use `nonexistentlibrary` to set `api_key` and `organization`, and to call `Embedding.create`, which would also fail because `nonexistentlibrary` does not have these attributes or methods. Lastly, the code tries to return `response['information']`, which would fail even if the previous errors were fixed because the correct key should be `response['data']` based on the original working code.
  id: |-
    hubfix_hub_248
  lang: |-
    python
  original_code: |-
    from typing import TypedDict
    import openai

    class openai_auth(TypedDict):
        api_key: str
        organization_id: str

    def main(auth: openai_auth, prompt: str, model: str = "text-embedding-ada-002"):
        openai.api_key = auth['api_key']
        openai.organization = auth['organization_id']

        response = openai.Embedding.create(
            model=model,
            input=prompt
        )
        return response['data']
  original_instructions: |-
    Create Embedding in openai
  resource_type: |-
    openai_auth
  resource_type_def: |-
    class openai_auth(TypedDict):
        api_key: str
        organization_id: str
- broken_code: |-
    from typing import TypedDict, Any

    class record_type(TypedDict):
        type: str
        table: str
        record: Any
        schema: str
        old_record: Any

    def main(type: str, table: str, record: object, schema: str, old_record: object) -> record_type:
        print("type", typo)
        print("table", table)
        print("record", record)
        print("schema", schema)
        print("old_record", old_record)
        return {
            "type": type,
            "table": table,
            "record": record,
            "schema": schema,
            "old_record": old_record,
        }
  error: |-
    NameError: name 'typo' is not defined
  explanation: |-
    The variable `typo` is used in the first print statement, but it has not been defined anywhere in the code. The correct variable name should be `type`, which is the parameter passed to the `main` function.
  id: |-
    hubfix_hub_250
  lang: |-
    python
  original_code: |-
    from typing import TypedDict, Any

    class record_type(TypedDict):
        type: str
        table: str
        record: Any
        schema: str
        old_record: Any

    def main(type: str, table: str, record: object, schema: str, old_record: object) -> record_type:
        print("type", type)
        print("table", table)
        print("record", record)
        print("schema", schema)
        print("old_record", old_record)
        return {
            "type": type,
            "table": table,
            "record": record,
            "schema": schema,
            "old_record": old_record,
        }
  original_instructions: |-
    preview supabase event in supabase
  resource_type: |-
    record_type
  resource_type_def: |-
    class record_type(TypedDict):
        type: str
        table: str
        record: Any
        schema: str
        old_record: Any
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string,
      is_flow: boolean,
      schedule_path: string,
      error: object,
      error_started_at: string,
      success_times: number,
      success_result: object,
      success_started_at: string,
      slack: Slack,
      channel: string,
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> recovered*${
                success_times > 1 ? (" " + success_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last failure at: ${
                    dayjs(error_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n${formatError(error)}`,
                },
              },
            ],
          },
          {
            color: "#00ff00",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last success at: ${
                    dayjs(success_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n\`\`\`\n${JSON.stringify(success_result, null, 2)}\n\`\`\``,
                },
              },
            ],
          },
        ],
      });
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'get')
  explanation: |-
    The error occurs because the `Deno.env.get` method is being called, but `Deno.env` is undefined. This could happen if the Deno runtime does not have the environment variable access permission. To fix this, you would need to grant the script permission to access environment variables by using the `--allow-env` flag when running the script with Deno. Alternatively, the error could be due to a typo or incorrect import that results in `Deno.env` being undefined.
  id: |-
    hubfix_hub_1031
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      error_started_at: string, // The start datetime of the latest job that failed
      success_times: number, // The number of times the schedule succeeded before calling the recovery handler.
      success_result: object, // The result of the latest successful job
      success_started_at: string, // The start datetime of the latest successful job
      slack: Slack,
      channel: string,
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> recovered*${
                success_times > 1 ? (" " + success_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last failure at: ${
                    dayjs(error_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n${formatError(error)}`,
                },
              },
            ],
          },
          {
            color: "#00ff00",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": `Last success at: ${
                    dayjs(success_started_at).format("DD.MM.YYYY HH:mm (Z)")
                  }\n\`\`\`\n${success_result}\n\`\`\``,
                },
              },
            ],
          },
        ],
      });
    }
  original_instructions: |-
    Schedule recovery handler in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, path: number) {
      return (await new S3Client(s3).getObject(path)).text();
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `getObject` method of `S3Client` expects a string as its parameter, which should be the path to the object in the S3 bucket. However, the `main` function has been modified to take a `path` parameter of type `number` instead of `string`. When `getObject` is called with `path`, TypeScript throws an error because a number is not assignable to a parameter that should be a string.
  id: |-
    hubfix_hub_392
  lang: |-
    deno
  original_code: |
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, path: string) {
      return (await new S3Client(s3).getObject(path)).text();
    }
  original_instructions: |-
    Get object in bucket as text in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- broken_code: |-
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(auth: Pinecone, index_name: number) {
      const client = new PineconeClient();
      await client.initialize(auth);
      return await client.describeIndex({ index: index_name });
    }
  error: |-
    TypeError: client.initialize is not a function
  explanation: |-
    The code is broken because of the following reasons:

    1. The `PineconeClient` class does not have a method called `initialize`. The correct method name is `init`, so calling `client.initialize(auth)` will result in a TypeError because `initialize` is not a function.

    2. The `describeIndex` method is being called with an object that has a property `index` instead of `indexName`. This will likely result in an error because the API is expecting a property named `indexName`.

    3. The `index_name` parameter type has been changed from `string` to `number`, which is incorrect because the `describeIndex` method expects an object with a `indexName` property of type `string`.
  id: |-
    hubfix_hub_339
  lang: |-
    deno
  original_code: |
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(auth: Pinecone, index_name: string) {
      const client = new PineconeClient();
      await client.init(auth);
      return await client.describeIndex({ indexName: index_name });
    }
  original_instructions: |-
    Describe Index in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- broken_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      collection_id?: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createCollection(
        database_id,
        collection_id || ID.unique(),
        collection_name,
        collection_permissions,
        collection_document_security,
        "extraArgument",
      );
    }
  error: |-
    TypeError: Too many arguments passed to db.createCollection. Expected 5 but received 6.
  explanation: |-
    The `db.createCollection` function is called with an extra argument that it does not expect. The function signature specifies 5 parameters, but 6 are provided in the call. This results in a `TypeError` because the function does not know how to handle the additional argument.
  id: |-
    hubfix_hub_329
  lang: |-
    deno
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param collection_id ID of the collection to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      collection_id?: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createCollection(
        database_id,
        collection_id || ID.unique(),
        collection_name,
        collection_permissions,
        collection_document_security,
      );
    }
  original_instructions: |-
    Create Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      error_started_at: string, // The start datetime of the latest job that failed
      success_times: number, // The number of times the schedule succeeded before calling the recovery handler.
      success_result: object, // The result of the latest successful job
      success_started_at: string, // The start datetime of the latest successful job
    ) {
      console.log(
        `Schedule ${schedulePath} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${error_started_at}:`, error);
      console.log(`Last success at ${success_started_at}:`, success_result);
      return error;
    }
  error: |-
    ReferenceError: schedulePath is not defined
  explanation: |-
    The variable `schedulePath` is used in the template literal within the `console.log` statement, but it is not defined anywhere in the code. The correct variable name, as defined in the function parameters, is `schedule_path`. This is a case-sensitive error, and using the incorrect case breaks the code.
  id: |-
    hubfix_hub_1028
  lang: |-
    deno
  original_code: |
    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      error_started_at: string, // The start datetime of the latest job that failed
      success_times: number, // The number of times the schedule succeeded before calling the recovery handler.
      success_result: object, // The result of the latest successful job
      success_started_at: string, // The start datetime of the latest successful job
    ) {
      console.log(
        `Schedule ${schedule_path} recovered ${
          success_times > 1 ? (success_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${error_started_at}:`, error);
      console.log(`Last success at ${success_started_at}:`, success_result);
      return error;
    }
  original_instructions: |-
    Schedule recovery handler template in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      apiKey: string;
    };
    export async function main(
      auth: Hubspot,
      file_id: string,
      size?: "" | "thumb" | "icon" | "medium" | "preview",
      expiration_seconds?: number,
      upscale?: boolean,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.files.getSignedUrl(
          file_id,
          size || undefined,
          expiration_seconds || undefined,
          upscale || undefined,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'getSignedUrl')
  explanation: |-
    The code is broken because of two reasons:

    1. The `Hubspot` type has been changed to have an `apiKey` property instead of a `token` property. However, the `Client` constructor is still trying to access `auth.token`, which no longer exists on the `auth` object.

    2. The method `getSignedUrl` is being called on `client.files` directly, but according to the original code, it should be `client.files.filesApi.getSignedUrl`. The `filesApi` property is missing in the broken code, which means the `getSignedUrl` method does not exist on `client.files` and thus cannot be called.
  id: |-
    hubfix_hub_231
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      file_id: string,
      size?: "" | "thumb" | "icon" | "medium" | "preview",
      expiration_seconds?: number,
      upscale?: boolean,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.files.filesApi.getSignedUrl(
          file_id,
          size || undefined,
          expiration_seconds || undefined,
          upscale || undefined,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  original_instructions: |-
    Get File Public URL in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    type Faunadb = {
      region: string;
      secret: string;
    };
    export async function main(
      auth: Faunadb,
      query: string,
      variables?: Record<string, any>,
      operationName?: string,
    ) {
      const region = ["us", "eu"].includes(auth.regions) ? auth.region : ""; // Error introduced here
      const response = await fetch(`https://graphql.${region}.fauna.com/graphql`, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + auth.secret,
        },
        body: JSON.stringify({
          query,
          variables: variables || {},
          operationName: operationName || null,
        }),
      });
      return await response.json();
    }
  error: |-
    TypeError: Cannot read property 'includes' of undefined
  explanation: |-
    The error is caused by attempting to access a non-existent property `regions` on the `auth` object. The correct property name is `region`, as defined in the `Faunadb` type. Accessing `auth.regions` instead of `auth.region` results in `undefined`, and since `undefined` does not have an `includes` method, a TypeError is thrown.
  id: |-
    hubfix_hub_263
  lang: |-
    deno
  original_code: |
    type Faunadb = {
      region: string;
      secret: string;
    };
    export async function main(
      auth: Faunadb,
      query: string,
      variables?: Record<string, any>,
      operationName?: string,
    ) {
      const region = ["us", "eu"].includes(auth.region) ? auth.region : "";
      const response = await fetch(`https://graphql.${region}.fauna.com/graphql`, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + auth.secret,
        },
        body: JSON.stringify({
          query,
          variables: variables || {},
          operationName: operationName || null,
        }),
      });
      return await response.json();
    }
  original_instructions: |-
    Execute GraphQL Query in faunadb
  resource_type: |-
    Faunadb
  resource_type_def: |-
    type Faunadb = {
      region: string;
      secret: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      apiToken: string;
    };
    export async function main(auth: Telegram, chat_id: string) {
      const client = new Telegram(auth.apiToken);
      return await client.getChatLink(chat_id);
    }
  error: |-
    TypeError: Telegram is not a constructor
  explanation: |-
    The code is broken because of the following reasons:

    1. The `Telegram` type is redeclared as a type with a property `apiToken`, which conflicts with the imported `Telegram` class from the `telegraf` library. TypeScript does not allow a type and a class with the same name in the same scope.

    2. The `client.getChatLink(chat_id)` function call is incorrect because `getChatLink` is not a method of the `Telegram` class from the `telegraf` library. The correct method name should be `exportChatInviteLink`.

    To fix the code, the type should be renamed to something other than `Telegram` to avoid the naming conflict, and the correct method `exportChatInviteLink` should be used.
  id: |-
    hubfix_hub_233
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(auth: Telegram, chat_id: string) {
      const client = new Telegram(auth.token);
      return await client.exportChatInviteLink(chat_id);
    }
  original_instructions: |-
    Export Chat Invite Link in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import {
      Configuration,
      CreateCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.2.1";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      text: string,
      translate_to: string[] = ["french", "german"],
      model: string = "text-davinci-003",
      max_tokens: number = 100,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const prompt = `Translate the text below into the languages found in this array:
    [${translate_to.map((l) => l.trim().toLowerCase()).join(", ")}]
    Apply the following rules:
      - return ONLY a valid JSON object
      - the object keys are strictly the languages in the array above
      - the values are the corresponding translations
      - do NOT try to complete the original text

    ${text}`;
      console.log(prompt);
      const request = removeObjectEmptyFields({
        model,
        prompt,
        max_tokens,
        temperature: 0.3,
        top_p: 1.0,
        frequency_penalty: 0.0,
        presence_penalty: 0.0,
      }) as CreateCompletionRequest;
      const { data } = await openai.createCompletion(request);
      console.log(data?.choices[0]?.text);

      return JSON.parse(data?.choices[0]?.text.replaceAll('"', '\'') ?? "");
    }
  error: |-
    TypeError: data?.choices[0]?.text.replaceAll is not a function
  explanation: |-
    The error occurs because the `replaceAll` method is being used incorrectly. In the original code, `replaceAll('"', '"')` is a no-op, meaning it replaces double quotes with double quotes, which does nothing. In the broken code, `replaceAll('"', '\'')` is intended to replace double quotes with single quotes, but this is not a valid operation for parsing JSON, and moreover, `replaceAll` expects a string or a regular expression as the first argument, not a single character. If `data?.choices[0]?.text` contains no double quotes or is not a string, calling `replaceAll` would result in a TypeError. Additionally, replacing double quotes with single quotes would break the JSON parsing, as JSON requires double quotes for keys and string values.
  id: |-
    hubfix_hub_348
  lang: |-
    deno
  original_code: "import { removeObjectEmptyFields } from \"https://deno.land/x/windmill_helpers@v1.1.1/mod.ts\"\
    ;\nimport {\n  Configuration,\n  CreateCompletionRequest,\n  OpenAIApi,\n} from\
    \ \"npm:openai@3.2.1\";\n\n/**\n * You can read about the parameters at\n * https://platform.openai.com/docs/api-reference/completions/create\n\
    \ *\n * @returns An object with the **lowercase** values of the `translate_to`\
    \ array as keys.\n *\n * *For example:*\n * ```\n *  { french: \"J'aime les pommes\"\
    , german: \"Ich liebe \xC4pfel\" }\n * ```\n */\ntype Openai = {\n  api_key: string;\n\
    \  organization_id: string;\n};\nexport async function main(\n  auth: Openai,\n\
    \  text: string,\n  translate_to: string[] = [\"french\", \"german\"],\n  model:\
    \ string = \"text-davinci-003\",\n  max_tokens: number = 100,\n) {\n  const configuration\
    \ = new Configuration({\n    apiKey: auth.api_key,\n    organization: auth.organization_id,\n\
    \  });\n  const openai = new OpenAIApi(configuration);\n\n  const prompt = `Translate\
    \ the text below into the languages found in this array:\n[${translate_to.map((l)\
    \ => l.trim().toLowerCase()).join(\", \")}]\nApply the following rules:\n  - return\
    \ ONLY a valid JSON object\n  - the object keys are strictly the languages in\
    \ the array above\n  - the values are the corresponding translations\n  - do NOT\
    \ try to complete the original text\n\n${text}`;\n  console.log(prompt);\n  const\
    \ request = removeObjectEmptyFields({\n    model,\n    prompt,\n    max_tokens,\n\
    \    temperature: 0.3,\n    top_p: 1.0,\n    frequency_penalty: 0.0,\n    presence_penalty:\
    \ 0.0,\n  }) as CreateCompletionRequest;\n  const { data } = await openai.createCompletion(request);\n\
    \  console.log(data?.choices[0]?.text);\n\n  return JSON.parse(data?.choices[0]?.text.replaceAll('\"\
    ', '\"') ?? \"\");\n}\n"
  original_instructions: |-
    Create Translation in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      start_cursor?: string | undefined,
      page_size?: number | undefined,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        page_size,
        start_cursor,
      });
      return await client.users.fetch(args);
    }
  error: |-
    TypeError: client.users.fetch is not a function
  explanation: |-
    The error occurs because the method `fetch` does not exist on the `client.users` object. The original code used `client.users.list`, which is the correct method to list users in the Notion API. By changing `.list` to `.fetch`, the code attempts to call a method that doesn't exist, resulting in a `TypeError`.
  id: |-
    hubfix_hub_349
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * @param start_cursor If supplied, only results starting after the cursor will be returned.
     *
     * @param page_size The number of items in the response. Maximum is `100`.
     *
     * Learn more at
     * https://developers.notion.com/reference/get-users
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      start_cursor?: string | undefined,
      page_size?: number | undefined,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        page_size,
        start_cursor,
      });
      return await client.users.list(args);
    }
  original_instructions: |-
    List Users in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string[],
      subject: string,
      message: string,
      is_message_html: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, string | string[]> = {
        to,
        from,
        subject,
      };
      messageObject[is_message_html ? "htmlContent" : "text"] = message;

      try {
        return await sendgrid.sendEmail(messageObject, true);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: sendgrid.sendEmail is not a function
  explanation: |-
    The code is attempting to call a method `sendEmail` on the `sendgrid` object, which does not exist in the SendGrid Mail library. The correct method to call is `send`. This is a common mistake where a developer might confuse the method name with another similar API or library.
  id: |-
    hubfix_hub_215
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";

    /**
     * @param is_message_html If `true` then the message will be sent and parsed as HTML,
     * otherwise it will be sent as plain text.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string[],
      subject: string,
      message: string,
      is_message_html: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, string | string[]> = {
        to,
        from,
        subject,
      };
      messageObject[is_message_html ? "html" : "text"] = message;

      try {
        return await sendgrid.send(messageObject, true);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Send Email Multiple Recipients in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: number) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Invalid name
  explanation: |-
    The code is broken because the `fileId` parameter type was changed from `string` to `number`. The `fileId` is expected to be a string because it is part of a URL. When a number is concatenated to a string, it is implicitly converted to a string, but if the number is not a valid file ID, the URL will be incorrect, leading to a fetch error.

    Additionally, the return statement was changed from `response.text()` to `response.json()`. If the API does not return a JSON response, this will result in a syntax error when trying to parse the response as JSON. If the API returns a simple text response or an error message in plain text, `response.json()` will fail to parse it.
  id: |-
    hubfix_hub_49
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Delete File in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string,
      is_flow: boolean,
      schedule_path: string,
      error: object,
      started_at: string,
      failed_times: number,
      slack: Slack,
      channel: string,
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> failed*${
                failed_times > 1 ? (" " + failed_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            color: "#ff0000",
            "blocks": [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": `Last failure at: ${
                  dayjs(started_at).format("DD.MM.YYYY HH:mm (Z)")
                }\n${formatError(error)}`,
              },
            }],
          },
        ],
      });

      return "Error notification sent";
    }
  error: |-
    TypeError: dayjs(...).format is not a function
  explanation: |-
    The error occurs because the `dayjs` library is being imported incorrectly. In the original code, `dayjs` is imported from `npm:dayjs` without specifying the correct import syntax for Deno to handle npm packages. Deno requires a specific plugin or URL to import npm packages, which is not being used here. As a result, the `dayjs` object does not have the `format` method, leading to the error message.
  id: |-
    hubfix_hub_1030
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";
    import dayjs from "npm:dayjs";

    type Slack = {
      token: string;
    };

    function formatError(error: any) {
      if (error.stack && error.name && error.message) {
        return `*${error.name}: ${error.message}*\`\`\`\n${error.stack}\n\`\`\``;
      } else {
        return `\`\`\`\n${JSON.stringify(error, null, 2)}\n\`\`\``;
      }
    }

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      started_at: string, // The start datetime of the latest job that failed
      failed_times: number, // Minimum number of times the schedule failed before calling the error handler
      slack: Slack,
      channel: string,
    ) {
      const baseUrl = Deno.env.get("WM_BASE_URL");
      const scheduleUrl = baseUrl + "/runs?schedule_path=" +
        encodeURIComponent(schedule_path);
      const runnableUrl = baseUrl + (is_flow ? "/flows/get/" : "/scripts/get/") +
        path;
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text: `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        }`,
        blocks: [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": `*Schedule <${scheduleUrl}|${schedule_path}> failed*${
                failed_times > 1 ? (" " + failed_times + " times in a row") : ""
              }:\n- ${is_flow ? "Flow" : "Script"}: <${runnableUrl}|${path}>`,
            },
          },
        ],
        attachments: [
          {
            color: "#ff0000",
            "blocks": [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": `Last failure at: ${
                  dayjs(started_at).format("DD.MM.YYYY HH:mm (Z)")
                }\n${formatError(error)}`,
              },
            }],
          },
        ],
      });
    }
  original_instructions: |-
    Schedule error handler in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, id: number) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.getDatabase(id);
    }
  error: |-
    TypeError: db.getDatabase is not a function
  explanation: |-
    The code is broken because of the following reasons:

    1. The import statement is incorrect. The version number (@7.0.0) is missing from the URL, which could lead to importing a wrong or non-existent version of the library.

    2. The `id` parameter type in the `main` function has been changed from `string` to `number`. The `get` method expects a string as the database ID, not a number.

    3. The method `getDatabase` does not exist on the `Databases` class. The correct method name should be `get` to retrieve a database by its ID.
  id: |-
    hubfix_hub_328
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, id: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.get(id);
    }
  original_instructions: |-
    Get Database in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    type Faunadb = {
      region: string;
      secret: string;
    };
    export async function main(
      auth: Faunadb,
      schema: string,
      mode: "merge" | "replace" | "override" = "merge",
    ) {
      const region = ["us", "eu"].includes(auth.regions) ? auth.region : "";
      const response = await fetch(
        `https://graphql.${region}.fauna.com/import?mode=${mode}`,
        {
          method: "POST",
          headers: {
            Authorization: "Bearer " + auth.secrets,
          },
          body: schema,
        },
      );
      return await response.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'includes')
  explanation: |-
    The code is trying to access a non-existent property `regions` on the `auth` object (the correct property is `region`). Additionally, it attempts to access `auth.secrets` instead of `auth.secret`. Lastly, the function is returning `response.json()` which may not be an error per se, but if the response is not in JSON format, this will result in a runtime error. The original code correctly used `response.text()`.
  id: |-
    hubfix_hub_264
  lang: |-
    deno
  original_code: |
    /**
     * Learn more at
     * https://docs.fauna.com/fauna/current/api/graphql/endpoints#import
     */
    type Faunadb = {
      region: string;
      secret: string;
    };
    export async function main(
      auth: Faunadb,
      schema: string,
      mode: "merge" | "replace" | "override" = "merge",
    ) {
      const region = ["us", "eu"].includes(auth.region) ? auth.region : "";
      const response = await fetch(
        `https://graphql.${region}.fauna.com/import?mode=${mode}`,
        {
          method: "POST",
          headers: {
            Authorization: "Bearer " + auth.secret,
          },
          body: schema,
        },
      );
      return await response.text();
    }
  original_instructions: |-
    Import GraphQL schema in faunadb
  resource_type: |-
    Faunadb
  resource_type_def: |-
    type Faunadb = {
      region: string;
      secret: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";
    import { UpdateType } from "npm:telegraf@4.11/typings/telegram-types";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      limit = 100,
      offset = 0,
      allowed_updates?: UpdateType[],
    ) {
      const client = new Telegram(auth.token);
      return await client.fetchUpdates(
        0,
        limit,
        offset,
        allowed_updates || undefined,
      );
    }
  error: |-
    TypeError: client.fetchUpdates is not a function
  explanation: |-
    The error occurs because the method `fetchUpdates` does not exist on the `Telegram` client object. The original method name should be `getUpdates`, which is the correct API method provided by the `telegraf` library to fetch updates from the Telegram bot API. By changing the method name to `fetchUpdates`, the code attempts to call a non-existent method, resulting in a `TypeError`.
  id: |-
    hubfix_hub_232
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";
    import { UpdateType } from "npm:telegraf@4.11/typings/telegram-types";

    /**
     * @param limit Number of elements in the returned list.
     * Defaults to 100 and must be between 1-100.
     *
     * @param offset Identifier of the first update to be returned.
     *
     * @param allowed_updates The update types that should be received.
     * Read more about types at
     * https://core.telegram.org/bots/api#update
     */
    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      limit = 100,
      offset = 0,
      allowed_updates?: UpdateType[],
    ) {
      const client = new Telegram(auth.token);
      return await client.getUpdates(
        0,
        limit,
        offset,
        allowed_updates || undefined,
      );
    }
  original_instructions: |-
    List Chats in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    export async function main() {
      const url = "https://hub.windmill.dev/searchResourceData";
      const response = await fetch(url);
      const data = await response.json();
      return data.map((item) => item.nonExistentProperty);
    }
  error: |-
    TypeError: item.nonExistentProperty is not a function
  explanation: |-
    The code attempts to access a property `nonExistentProperty` on each `item` in the `data` array, which is assumed to be the result of the JSON response. However, this property does not exist on the items, leading to a `TypeError` when trying to access it. This is an example of using a non-existent property of a type inside the function.
  id: |-
    hubfix_hub_168
  lang: |-
    deno
  original_code: "// Should return {resources: [{\u2026},\u2026]}\n\nexport async\
    \ function main() {\n  const url = \"https://hub.windmill.dev/searchResourceData\"\
    ;\n  const response = await fetch(url);\n  return await response.json();\n}\n"
  original_instructions: |-
    List Resource Types in windmillhub
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import { SlackAPI } from "https://deno.land/x/deno_slack_api@1.6.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(auth: Slack, cursor?: string, limit?: string) {
      const client = SlackAPI(auth.token);
      const params = removeObjectEmptyFields({ cursor, limit });
      return await client.users.list(params);
    }
  error: |-
    TS2345: Argument of type '{ cursor?: string | undefined; limit?: string | undefined; }' is not assignable to parameter of type 'UsersListParams'.
      Types of property 'limit' are incompatible.
        Type 'string | undefined' is not assignable to type 'number | undefined'.
          Type 'string' is not assignable to type 'number | undefined'.
  explanation: |-
    The `limit` parameter in the `main` function has been changed from `number` to `string`, which is incorrect because the `client.users.list` method expects a `number` type for the `limit` parameter, not a `string`. This type mismatch causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_hub_299
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import { SlackAPI } from "https://deno.land/x/deno_slack_api@1.6.0/mod.ts";

    /**
     * @param cursor Paginate the list of users by setting the cursor parameter
     * to a `next_cursor` attribute returned by a previous request's
     * `response_metadata`. Default value fetches the first "page" of the users.
     * Used in conjunction with `limit`.
     *
     * @param limit The maximum number of users to return. Fewer than the
     * requested number of users may be returned, even if the end of the result
     * list hasn't been reached.
     * Used in conjunction with `cursor`.
     */
    type Slack = {
      token: string;
    };
    export async function main(auth: Slack, cursor?: string, limit?: number) {
      const client = SlackAPI(auth.token);
      const params = removeObjectEmptyFields({ cursor, limit });
      return await client.users.list(params);
    }
  original_instructions: |-
    List Users in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { Client, Users } from "https://deno.land/x/appwrite/mod.ts";

    type AppwriteConfig = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: AppwriteConfig, userId: number) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.remove(userId);
    }
  error: |-
    TypeError: users.remove is not a function
  explanation: |-
    The code is broken for several reasons:

    1. The import URL for the Appwrite library is incorrect. It should include the version number (e.g., `@7.0.0`) to ensure the correct version of the library is imported. Without the version number, Deno might not be able to resolve the import correctly.

    2. The type `Appwrite` was renamed to `AppwriteConfig`, which is not necessarily a breaking change by itself, but it could cause confusion if other parts of the codebase expect the type to be named `Appwrite`.

    3. The `id` parameter in the `main` function was changed to `userId`, and its type was changed from `string` to `number`. The Appwrite SDK expects the user ID to be a string, not a number, so this will cause a type error.

    4. The `Users` class method `delete` was incorrectly changed to `remove`. The correct method name to delete a user in the Appwrite SDK is `delete`, not `remove`. This will result in a runtime error because `remove` is not a function in the `Users` class.
  id: |-
    hubfix_hub_325
  lang: |-
    deno
  original_code: |
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, id: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.delete(id);
    }
  original_instructions: |-
    Delete User in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.1.0";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      model = "text-davinci-003",
      prompt?: string,
      suffix?: string,
      max_tokens?: number,
      temperature?: number,
      top_p?: number,
      n?: number,
      stream?: boolean,
      logprobs?: number,
      echo?: boolean,
      stop?: string,
      presence_penalty?: number,
      frequency_penalty?: number,
      best_of?: number,
      logit_bias?: object,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request = removeObjectEmptyFields({
        model,
        prompt,
        suffix,
        max_tokens,
        temperature,
        top_p,
        n,
        stream,
        logprobs,
        echo,
        stop,
        presence_penalty,
        frequency_penalty,
        best_of,
        logit_bias,
      }) as CreateCompletionRequest;
      const response = await openai.createCompletion({
        model: "non-existent-model",
        prompt: "Hello, world!",
      });
      return response.data;
    }
  error: |-
    TypeError: The `model` parameter is not a valid model. Please use one of the available models.
  explanation: |-
    The error is caused by passing a non-existent model name "non-existent-model" to the `createCompletion` method of the `OpenAIApi` instance. OpenAI's API expects a valid model identifier, and if an invalid one is provided, it will throw a TypeError indicating that the model parameter is not valid. To fix this error, a valid model identifier such as "text-davinci-003" should be used.
  id: |-
    hubfix_hub_245
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.1.0";

    /**
     * You can read about the parameters at
     * https://beta.openai.com/docs/api-reference/completions/create
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      model = "text-davinci-003",
      prompt?: string,
      suffix?: string,
      max_tokens?: number,
      temperature?: number,
      top_p?: number,
      n?: number,
      stream?: boolean,
      logprobs?: number,
      echo?: boolean,
      stop?: string,
      presence_penalty?: number,
      frequency_penalty?: number,
      best_of?: number,
      logit_bias?: object,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request = removeObjectEmptyFields({
        model,
        prompt,
        suffix,
        max_tokens,
        temperature,
        top_p,
        n,
        stream,
        logprobs,
        echo,
        stop,
        presence_penalty,
        frequency_penalty,
        best_of,
        logit_bias,
      }) as CreateCompletionRequest;
      const response = await openai.createCompletion(request);
      return response.data;
    }
  original_instructions: |-
    Create Completion in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
      start_index: number,
      end_index: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_COLUMN_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteDimension: {
              range: {
                sheetId: sheetId,
                dimension: "COLUMNS",
                startIndex: start_index,
                endIndex: end_index,
              },
            },
          },
        ],
      };
      const response = await fetch(DELETE_COLUMN_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.text();

      return text.length;
    }
  error: |-
    TypeError: Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function `main` is expected to return a string, as indicated by the last line in the original code `return "Columns deleted.";`. However, in the broken code, the return statement has been changed to `return text.length;`, which returns a number because `length` is a property of a string that gives the number of characters in the string. This change causes a type mismatch error because the TypeScript compiler expects the function to return a string, not a number.
  id: |-
    hubfix_hub_70
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
      start_index: number,
      end_index: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_COLUMN_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteDimension: {
              range: {
                sheetId: sheetId,
                dimension: "COLUMNS",
                startIndex: start_index,
                endIndex: end_index,
              },
            },
          },
        ],
      };
      const response = await fetch(DELETE_COLUMN_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.json();

      return "Columns deleted.";
    }
  original_instructions: |-
    Clear Columns in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    export async function main(
      url: string,
      user: string,
      password: string,
      namespace?: string,
      database?: string,
      scope?: string,
    ) {
      const client = new Surreal(url);
      return await client.login({
        username: user,
        passwd: password,
        NS: namespace,
        DB: database,
        SC: scope,
      });
    }
  error: |-
    TypeError: client.login is not a function
  explanation: |-
    The code is attempting to call a method `login` on the `client` object, which does not exist in the Surreal API. The correct method name is `signin`, not `login`. Additionally, the parameters passed to the method are incorrect. The Surreal API expects `user` and `pass` as the keys for the username and password, not `username` and `passwd`.
  id: |-
    hubfix_hub_320
  lang: |-
    deno
  original_code: |
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    /**
     * @returns The authenication token.
     */
    export async function main(
      url: string,
      user: string,
      password: string,
      namespace?: string,
      database?: string,
      scope?: string,
    ) {
      const client = new Surreal(url);
      return await client.signin({
        user,
        pass: password,
        NS: namespace,
        DB: database,
        SC: scope,
      });
    }
  original_instructions: |-
    Sign in in surrealdb
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gitlab = {
      baseUri: string;
      token: string;
    };

    export async function main(
      glab: Gitlab,
      projectId: string,
      releaseTag: string,
    ) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/releases/${releaseTag}`;
      const response = await fetch(`${url}`, {
        headers: { "PRIVATE-TOKEN": `${glab.token}` },
      });
      return await response.text();
    }
  error: |-
    TS2339: Property 'baseUrl' does not exist on type 'Gitlab'.
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken for two reasons:

    1. The property `baseUrl` is being accessed on the `glab` object, but the type `Gitlab` defines the property as `baseUri`. This is a common mistake where a property is renamed or mistyped.

    2. The `projectId` parameter is expected to be a number according to the original function signature, but the broken code has changed the type to `string`. This will cause a type mismatch error when trying to pass a string where a number is expected.
  id: |-
    hubfix_hub_414
  lang: |-
    deno
  original_code: |
    type Gitlab = {
      baseUrl: string;
      token: string;
    };

    export async function main(
      glab: Gitlab,
      projectId: number,
      releaseTag: string,
    ) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/releases/${releaseTag}`;
      const response = await fetch(`${url}`, {
        headers: { "PRIVATE-TOKEN": `${glab.token}` },
      });
      return await response.json();
    }
  original_instructions: |-
    Get release in gitlab
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import type { Sql } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      token: string,
      account_id: string,
      database: string,
      schema: string,
      sql: Sql,
    ) {
      const POST_URL = `https://${account_id}.snowflakecomputing.com/api/statements`;

      const body = {
        statement: `${sql}`,
        timeout: 60,
        database: `${database}`,
        schema: `${schema}`,
      };

      const response = await fetch(POST_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: response.text is not a function
  explanation: |-
    The error is caused by attempting to call a method `.text()` on the `response` object that does not exist. In the context of the Deno runtime and the Fetch API, the correct method to call to get the response body as text is `.text()`, but it should be invoked as a function, like `response.text()`. The code mistakenly tries to access it as a property, not a function, hence the error.
  id: |-
    hubfix_hub_112
  lang: |-
    deno
  original_code: |
    import type { Sql } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      token: string,
      account_id: string,
      database: string,
      schema: string,
      sql: Sql,
    ) {
      const POST_URL = `https://${account_id}.snowflakecomputing.com/api/statements`;

      const body = {
        statement: `${sql}`,
        timeout: 60,
        database: `${database}`,
        schema: `${schema}`,
      };

      const response = await fetch(POST_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Execute Query & Return Results in snowflake
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string, salt_num: string) {
      const salt = await bcrypt.genSalt(salt_num);
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `genSalt` function expects a number as its parameter, but the modified code passes `salt_num` as a string. This type mismatch causes TypeScript to throw an error because the types are not compatible.
  id: |-
    hubfix_hub_85
  lang: |-
    deno
  original_code: |
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string, salt_num: number) {
      const salt = await bcrypt.genSalt(salt_num);
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }
  original_instructions: |-
    Hash Password with Manual Salt in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };
    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: AirtableConfig,
      atTable: AirtableTable,
      recordId: string,
      newRecord: object,
    ) {
      const airtable = new Airtable({...atCon, ...atTable});

      const updateSingleRecord = await airtable.update(recordId, newRecord, false);

      return updateSingleRecord;
    }
  error: |-
    TypeError: The "update" method does not accept 3 arguments.
  explanation: |-
    The `update` method of the `Airtable` class is expected to take two arguments: the `recordId` and the `newRecord` object. However, in the broken code, a third argument `false` is passed to the `update` method, which is not expected by the method's signature. This would result in a `TypeError` because the method does not support three arguments.
  id: |-
    hubfix_hub_1022
  lang: |-
    deno
  original_code: |
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };
    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordId: string,
      newRecord: object,
    ) {
      const airtable = new Airtable({...atCon, ...atTable});

      const updateSingleRecord = await airtable.update(recordId, newRecord);

      return updateSingleRecord;
    }
  original_instructions: |-
    Update record in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- broken_code: |-
    import { Configurations, OpenAIApi } from "npm:openai@3.1.0";

    export async function main(
      auth: Openai,
      prompt: string,
      number_of_images:
        | "1"
        | "2"
        | "3"
        | "4"
        | "5"
        | "6"
        | "7"
        | "8"
        | "9"
        | "10" = "1",
      size: "256x256" | "512x512" | "1024x1024" = "1024x1024",
      response_format: "url" | "b64_json" = "url",
    ) {
      const configuration = new Configurations({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.generateImage({
        prompt,
        n: +number_of_images,
        size,
        response_format,
      });
      return response.data.data;
    }
  error: |-
    TypeError: Configurations is not a constructor
  explanation: |-
    The code is trying to import `Configurations` from the `openai` package, but the correct class name is `Configuration`. Since `Configurations` does not exist, attempting to instantiate it with `new Configurations(...)` will result in a `TypeError`. Additionally, the method `generateImage` is called on the `openai` instance, but this method does not exist in the OpenAI API; the correct method name is `createImage`. Calling a non-existent method will also result in an error.
  id: |-
    hubfix_hub_244
  lang: |-
    deno
  original_code: |
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";

    /**
     * @param prompt The maximum length is 1000 characters.
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      number_of_images:
        | "1"
        | "2"
        | "3"
        | "4"
        | "5"
        | "6"
        | "7"
        | "8"
        | "9"
        | "10" = "1",
      size: "256x256" | "512x512" | "1024x1024" = "1024x1024",
      response_format: "url" | "b64_json" = "url",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createImage({
        prompt,
        n: +number_of_images,
        size,
        response_format,
      });
      return response.data.data;
    }
  original_instructions: |-
    Generate Image in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      query?: string,
      filter?: { property: string; value: string },
      sort?: { timestamp: string; direction: string },
      start_cursor?: string,
      page_size?: number,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        query,
        filter,
        sort,
        start_cursor,
        page_size,
      });
      return await client.searchEverything(args);
    }
  error: |-
    TypeError: client.searchEverything is not a function
  explanation: |-
    The error occurs because the method `searchEverything` does not exist on the `client` object. The correct method to call as per the original code is `search`. By changing the method name to `searchEverything`, we are trying to call a method that is not defined in the Notion client API, hence the TypeError is thrown.
  id: |-
    hubfix_hub_353
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/post-search
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      query?: string,
      filter?: { property: string; value: string },
      sort?: { timestamp: string; direction: string },
      start_cursor?: string,
      page_size?: number,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        query,
        filter,
        sort,
        start_cursor,
        page_size,
      });
      return await client.search(args);
    }
  original_instructions: |-
    Search by Title in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- broken_code: |-
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2.10.0";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(auth: Supabase, email: number, password: string) {
      const client = createClient(auth.url, auth.key);
      const { data, error } = await client.auth.signInWithPassword({
        email,
        password,
      });
      if (error) {
        return {
          accessToken: undefined,
          refreshToken: undefined,
          error: error.message,
        };
      }
      return {
        accessToken: data?.session?.access_token,
        refreshToken: data?.session?.refresh_token,
        error: undefined,
      };
    }
  error: |-
    TypeError: email must be a string, but was number
  explanation: |-
    The `email` parameter in the `main` function has been changed from type `string` to type `number`. The `signInWithPassword` method expects an email as a string, not a number, so passing a number will cause a type error. Additionally, the return object keys `access_token` and `refresh_token` have been changed to `accessToken` and `refreshToken`, which do not match the original keys expected in the return type, potentially causing issues when the returned object is used elsewhere in the code.
  id: |-
    hubfix_hub_310
  lang: |-
    deno
  original_code: |
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2.10.0";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(auth: Supabase, email: string, password: string) {
      const client = createClient(auth.url, auth.key);
      const { data, error } = await client.auth.signInWithPassword({
        email,
        password,
      });
      if (error) {
        return {
          access_token: undefined,
          refresh_token: undefined,
          error: error.message,
        };
      }
      return {
        access_token: data?.session?.access_token,
        refresh_token: data?.session?.refresh_token,
        error: undefined,
      };
    }
  original_instructions: |-
    Authenticate with email and password in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      block_id: string,
      start_cursor?: string,
      page_size?: number,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        block_identifier: block_id,
        start_cursor,
        page_size,
      });
      return await client.blocks.children.list(args);
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'children')
  explanation: |-
    The code is attempting to call `client.blocks.children.list(args)`; however, the `args` object has been modified to use `block_identifier` instead of `block_id`. The Notion API client expects a property named `block_id` as part of the arguments object when calling `list` on `client.blocks.children`. Since `block_identifier` is not recognized by the API client, it results in an error because the required `block_id` is not provided, leading to an attempt to access a property of `undefined`.
  id: |-
    hubfix_hub_354
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/get-block-children
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      block_id: string,
      start_cursor?: string,
      page_size?: number,
    ) {
      const client = new Client({ auth: auth.token });
      const args = removeObjectEmptyFields({
        block_id,
        start_cursor,
        page_size,
      });
      return await client.blocks.children.list(args);
    }
  original_instructions: |-
    Retrieve Block Children in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      range: string,
    ) {
      const token = gsheets_auth["token"];

      const GET_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}`;

      const response = await fetch(GET_VALUES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }

    const result = main({ token: "some-fake-token" }, "spreadsheet-id", "A1:D5");
    console.log(result);
  error: |-
    TypeError: Cannot read properties of undefined (reading 'json')
  explanation: |-
    The error occurs because the `response` object returned by `fetch` does not have a method `json` that can be called without awaiting it. The `json` method returns a Promise that must be resolved before accessing the actual JSON data. The correct usage should be `return await response.json();` to wait for the Promise to resolve and then return the JSON data. However, in the broken code, the `await` keyword is missing, which leads to trying to access the `json` property of the unresolved Promise, hence the error.
  id: |-
    hubfix_hub_52
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      range: string,
    ) {
      const token = gsheets_auth["token"];

      const GET_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}`;

      const response = await fetch(GET_VALUES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Get Values in Range in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.listUsers(queries, search);
    }
  error: |-
    TypeError: users.listUsers is not a function
  explanation: |-
    The error occurs because the method `listUsers` does not exist on the `Users` class. The correct method name is `list`, as used in the original code. By changing `users.list` to `users.listUsers`, we are trying to call a method that doesn't exist, which results in a `TypeError`.
  id: |-
    hubfix_hub_324
  lang: |-
    deno
  original_code: |
    import { Client, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.list(queries, search);
    }
  original_instructions: |-
    List Users in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import { Configurations, OpenAIApi } from "npm:openai@3.1.0";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      model:
        | "text-moderation-latest"
        | "text-moderation-stable" = "text-moderation-latest",
    ) {
      const configurations = new Configurations({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configurations);

      const response = await openai.createModeration({
        inputs: prompt,
        model,
      });
      return response.data;
    }
  error: |-
    TypeError: Configurations is not a constructor
  explanation: |-
    The code is broken because of two changes:

    1. The import statement has been changed from `Configuration` to `Configurations`. The correct name of the class to be imported from the `openai` package is `Configuration`, not `Configurations`. This will cause a runtime error because `Configurations` is not a valid class or function that can be instantiated.

    2. The property `input` in the `createModeration` method call has been changed to `inputs`. The correct property name expected by the `createModeration` method is `input`, not `inputs`. This will cause a runtime error because the method will not recognize the `inputs` property and will not be able to process the request properly.
  id: |-
    hubfix_hub_246
  lang: |-
    deno
  original_code: |
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      model:
        | "text-moderation-latest"
        | "text-moderation-stable" = "text-moderation-latest",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createModeration({
        input: prompt,
        model,
      });
      return response.data;
    }
  original_instructions: |-
    Create Moderation in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- broken_code: |-
    export async function main(message: number, name: string) {
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      console.log("message", message);
      console.log("name", name);
      console.log("undefinedVar", undefinedVar);
      return { message, flow_id, undefinedVar };
    }
  error: |-
    error: TS2304 [ERROR]: Cannot find name 'undefinedVar'.
      console.log("undefinedVar", undefinedVar);
                                 ~~~~~~~~~~~
  explanation: |-
    The code is trying to log and return a variable called `undefinedVar`, which has not been defined anywhere in the script. This results in a TypeScript error because the variable is not known to the compiler. Additionally, the `message` parameter type was changed from `string` to `number`, which could also cause a type mismatch error if the function is expected to receive a string as per its original design.
  id: |-
    hubfix_hub_158
  lang: |-
    deno
  original_code: |
    export async function main(message: string, name: string) {
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      console.log("message", message);
      console.log("name", name);
      return { message, flow_id };
    }
  original_instructions: |-
    Log error in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, title: number) {
      const supportsAllDrives = true;
      const CREATE_FOLDER_URL = `https://www.googleapis.com/drive/v3/file/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];
      const body = {
        name: title.toString(),
        mimeType: "application/vnd.google-apps.folder",
      };
      const response = await fetch(CREATE_FOLDER_URL, {
        method: "PUSH",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Invalid name
  explanation: |-
    The code is broken for two reasons:

    1. The `title` parameter type has been changed from `string` to `number`, which is not consistent with the expected type for the `name` property in the `body` object. The `name` property should be a string because it represents the name of the folder to be created on Google Drive.

    2. The `method` in the `fetch` call has been changed from `"POST"` to `"PUSH"`, which is not a valid HTTP method. The valid HTTP methods are `"GET"`, `"POST"`, `"PUT"`, `"DELETE"`, `"PATCH"`, `"OPTIONS"`, `"HEAD"`, and a few others, but `"PUSH"` is not one of them.

    The error message provided is a generic one and may not accurately reflect the specific errors in the code. The actual error message would depend on the runtime environment and how it handles the invalid HTTP method and the type mismatch.
  id: |-
    hubfix_hub_58
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, title: string) {
      const supportsAllDrives = true;
      const CREATE_FOLDER_URL = `https://www.googleapis.com/drive/v3/file/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];
      const body = {
        name: title,
        mimeType: "application/vnd.google-apps.folder",
      };
      const response = await fetch(CREATE_FOLDER_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Create Folder in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { AirtableBase } from "https://deno.land/x/airtable_base/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableTitle: string;
    };
    export async function main(
      atCon: AirtableConfig,
      atTable: AirtableTable,
      recordList: object[],
    ) {
      const airtable = new AirtableBase({ ...atCon, ...atTable });

      const createMultiple = await airtable.create(recordList);

      return createMultiple.results;
    }
  error: |-
    error: TS2339 [ERROR]: Property 'results' does not exist on type 'unknown[]'.
      return createMultiple.results;
                           ~~~~~~~
  explanation: |-
    The code is broken due to the following reasons:

    1. The import statement is trying to import `AirtableBase` from a non-existent module `https://deno.land/x/airtable_base/mod.ts`. The correct module should be `https://deno.land/x/airtable/mod.ts`, and the correct import should be `Airtable` instead of `AirtableBase`.

    2. The type `AirtableTable` has a property `tableTitle` which does not exist in the original code. The correct property name should be `tableName`.

    3. The return statement `return createMultiple.results;` is trying to access a property `results` on the `createMultiple` variable, which is assumed to be an array (as per the original code's behavior). Arrays do not have a `results` property, so this will cause a TypeScript error.

    To fix the code, the import statement should be corrected, the property name in `AirtableTable` should be reverted to `tableName`, and the return statement should simply return `createMultiple` without trying to access a non-existent `results` property.
  id: |-
    hubfix_hub_1025
  lang: |-
    deno
  original_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordList: object[],
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      const createMultiple = await airtable.create(recordList);

      return createMultiple;
    }
  original_instructions: |-
    Create Multiple Records in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- broken_code: |-
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, owner: string, repo: number) {
      const octokit = new Octocat({ auth: gh_auth.token });

      return await octokit.request("GET /repos/{owner}/{repository}", {
        owner,
        repository: repo,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  error: |-
    TypeError: Octocat is not a constructor
  explanation: |-
    The code is trying to import `Octocat` from the `@octokit/rest` package, but the correct class name is `Octokit`. This is a common mistake where a developer might misremember or mistype the name of a class or function they are trying to import.

    Additionally, the `repo` parameter in the `main` function has been changed from a string to a number, which is incorrect because repository names are strings, not numbers. The API endpoint also expects a string for the repository name.

    Furthermore, the placeholder `{repository}` in the `octokit.request` method is incorrect. The correct placeholder for the repository name is `{repo}` as per the original code.

    Lastly, the variable `Octocat` is used as if it were a constructor to create a new instance, but since it doesn't exist due to the incorrect import, it will throw a TypeError when trying to instantiate it.
  id: |-
    hubfix_hub_313
  lang: |-
    deno
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     */
    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request("GET /repos/{owner}/{repo}", {
        owner,
        repo,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  original_instructions: |-
    Get Repo in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    export async function main() {
      const workspace = Deno.env.get("WM_WORKSPACE");
      const baseUrl = Deno.env.get('WM_BASE_URL')
      const url = `${baseUrl}/api/w/${workspace}/users/list`;
      const response = await fetch(url, {
        headers: {
          "Authorization": "Bearer " + Deno.env.get("WM_SECRET") || "",
        },
      });

      if (response.statusText.toUpperCase() != "OK") {
        let errorMsg: number;
        if (response.headers.get("Content-Type")?.includes("json")) {
          errorMsg = await response.json();
        } else {
          errorMsg = await response.text();
        }
        throw new Error(`${response.status} ${response.statusText}: ${errorMsg}`);
      }
      const jsonData = await response.json();
      return jsonData;
    }
  error: |-
    TypeError: Cannot mix BigInt and other types, use explicit conversions
  explanation: |-
    The error message provided is a generic type error message that might not directly relate to the actual changes made in the code. However, the code has been broken in two ways:

    1. The `Deno.env.get("WM_TOKEN")` has been changed to `Deno.env.get("WM_SECRET")`. If the environment variable `WM_SECRET` does not exist, this will result in the "Authorization" header being set incorrectly, which could lead to an authentication error when the API is called.

    2. The `errorMsg` variable has been changed from type `string` to `number`. Since `response.json()` and `response.text()` both return promises that resolve to a string, trying to assign their resolved values to a `number` variable will cause a type error. TypeScript will not allow this assignment, and the code will fail to compile.
  id: |-
    hubfix_hub_1033
  lang: |-
    deno
  original_code: |
    // import * as wmill from "npm:windmill-client@1"

    export async function main() {
      const workspace = Deno.env.get("WM_WORKSPACE");
      const baseUrl = Deno.env.get('WM_BASE_URL')
      const url = `${baseUrl}/api/w/${workspace}/users/list`;
      const response = await fetch(url, {
        headers: {
          "Authorization": "Bearer " + Deno.env.get("WM_TOKEN") || "",
        },
      });

      if (response.statusText.toUpperCase() != "OK") {
        let errorMsg: string;
        if (response.headers.get("Content-Type")?.includes("json")) {
          errorMsg = await response.json();
        } else {
          errorMsg = await response.text();
        }
        throw new Error(`${response.status} ${response.statusText}: ${errorMsg}`);
      }
      const jsonData = await response.json();
      return jsonData;
    }
  original_instructions: |-
    Get list of users from current workspace in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      title: string,
      body: string,
      assignees?: string[],
      milestone?: string | number,
      labels?: string[],
    ) {
      const octokit = new Octocat({ auth: gh_auth.token });

      return await octokit.request("POST /repos/{owner}/{repo}/issues", {
        owner,
        repo,
        title,
        body,
        assignees: assignees || [],
        milestone,
        labels,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  error: |-
    error: TS2307 [ERROR]: Cannot find module 'https://cdn.skypack.dev/@octokit/rest' or its corresponding type declarations.
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";
  explanation: |-
    The code is broken because of two main issues:

    1. The import statement is trying to import `Octocat` from the `@octokit/rest` package, but the correct class name is `Octokit`. This would result in a runtime error because `Octocat` does not exist in the `@octokit/rest` package.

    2. Even if the class name was correct, the error message indicates that the module or its type declarations cannot be found. This could be due to a typo in the URL, a network issue, or the module not being available at the specified location. However, in this case, the error is due to the incorrect class name, which makes TypeScript think the module doesn't exist because it can't find the export `Octocat`.
  id: |-
    hubfix_hub_315
  lang: |-
    deno
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     *
     * @param title The title of the new issue.
     *
     * @param body The body of the new issue.
     *
     * @param assignees Logins for Users to assign to this issue.
     * *NOTE*: Only users with push access can set assignees for new issues.
     * Assignees are silently dropped otherwise.
     *
     * @param milestone The number of the milestone to associate this issue with.
     * *NOTE*: Only users with push access can set the milestone for new issues.
     * The milestone is silently dropped otherwise.
     *
     * @param labels Labels to associate with this issue.
     * *NOTE*: Only users with push access can set labels for new issues.
     * Labels are silently dropped otherwise.
     */
    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      title: string,
      body: string,
      assignees?: string[],
      milestone?: string | number,
      labels?: string[],
    ) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request("POST /repos/{owner}/{repo}/issues", {
        owner,
        repo,
        title,
        body,
        assignees: assignees || [],
        milestone,
        labels,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  original_instructions: |-
    Create Issue in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      sheet_id: string,
      values: Array<Array<any>>,
      range: string = "Sheet1",
    ) {
      const body = {
        values: values,
      };

      const valueInputOption = "USER_ENTERED";
      const insertDataOption = "INSERT_ROWS";
      const includeValuesInResponse = true;
      const APPEND_URL = `https://sheets.googleapis.com/v4/spreadsheets/${sheet_id}/values/${range}:append/?valueInputOption=${valueInputOption}&insertDataOption=${insertDataOption}&includeValuesInResponse=${includeValuesInResponse}`;

      const token = gsheets_auth["token"];

      const response = await fetch(APPEND_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.jason();

      return { result: result };
    }
  error: |-
    TypeError: response.jason is not a function
  explanation: |-
    The error is caused by a typo in the method name when trying to parse the JSON response. The correct method name is `json`, not `jason`. The incorrect method call `response.jason()` will result in a `TypeError` because `jason` is not a valid method on the `Response` object.
  id: |-
    hubfix_hub_37
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      sheet_id: string,
      values: Array<Array<any>>,
      range: string = "Sheet1",
    ) {
      const body = {
        values: values,
      };

      const valueInputOption = "USER_ENTERED";
      const insertDataOption = "INSERT_ROWS";
      const includeValuesInResponse = true;
      const APPEND_URL = `https://sheets.googleapis.com/v4/spreadsheets/${sheet_id}/values/${range}:append/?valueInputOption=${valueInputOption}&insertDataOption=${insertDataOption}&includeValuesInResponse=${includeValuesInResponse}`;

      const token = gsheets_auth["token"];

      const response = await fetch(APPEND_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return { result: result };
    }
  original_instructions: |-
    Add Rows in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    };
    export async function main(glab: Gitlab, projectId: string, issueId: number) {
      const url = `${glab.baseUri}/api/v4/projects/${projectId}/issues/${issueId}`;
      const issue = await fetch(`${url}`, {
        headers: { Authorization: `Bearer: ${glab.token}` },
      });
      return await issue.text();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseUri')
  explanation: |-
    The code is trying to access a property `baseUri` on the `glab` object, which does not exist. The correct property name is `baseUrl`. Additionally, the `projectId` parameter type was changed from `number` to `string`, which may not be an error by itself but could lead to incorrect behavior if the API expects a numeric project ID. Lastly, the function is returning `issue.text()` instead of `issue.json()`, which changes the return type from a JSON object to a string. This could be an error if the calling code expects a JSON object.
  id: |-
    hubfix_hub_146
  lang: |-
    deno
  original_code: |
    /*
    @param: {Gitlab} glab - Resource containing Gitlab Auth API Key
    Example:
    {
      auth: gitlab_api_key,
      baseUrl: "https://www.gitlab.com"
    }
    */
    type Gitlab = {
      baseUrl: string;
      token: string;
    };
    export async function main(glab: Gitlab, projectId: number, issueId: number) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/issues/${issueId}`;
      const issue = await fetch(`${url}`, {
        headers: { Authorization: `Bearer: ${glab.token}` },
      });
      return await issue.json();
    }
  original_instructions: |-
    Get Issue in gitlab
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import Stripe from "https://esm.sh/stripe@11.4.0?target=deno";

    type StripeCredentials = {
      apiKey: string;
    };
    export async function main(auth: StripeCredentials) {
      const stripe = new Stripe(auth.apiKey, {
        httpClient: Stripe.createFetchHttpClient(),
      });
      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const customers = await stripe.customers.retrieve({
        created: { gt: lastCheck },
      });
      return customers.data;
    }
  error: |-
    TypeError: stripe.customers.retrieve is not a function
  explanation: |-
    The code is attempting to call a method `retrieve` on `stripe.customers` which does not exist in the Stripe API. The correct method for listing customers is `list`, not `retrieve`. The `retrieve` method is used to retrieve a single customer by ID, not to list customers with a filter.
  id: |-
    hubfix_hub_265
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import Stripe from "https://esm.sh/stripe@11.4.0?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(auth: Stripe) {
      const stripe = new Stripe(auth.token, {
        httpClient: Stripe.createFetchHttpClient(),
      });
      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const customers = await stripe.customers.list({
        created: { gt: lastCheck },
      });
      return customers.data;
    }
  original_instructions: |-
    Get recently added customers in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    export async function main() {
      const url = "https://hub.windmill.dev/searchData";
      const response = await fetch(url);
      const data = await response.jason(); // Intentional typo
      return data;
    }
  error: |-
    TypeError: response.jason is not a function
  explanation: |-
    The code is attempting to call a method `jason()` on the `response` object, which does not exist. The correct method to parse the JSON response is `json()`. The typo `jason` instead of `json` causes the error.
  id: |-
    hubfix_hub_170
  lang: |-
    deno
  original_code: "// Should return {asks: [{\u2026},\u2026]}\n\nexport async function\
    \ main() {\n  const url = \"https://hub.windmill.dev/searchData\";\n  const response\
    \ = await fetch(url);\n  return await response.json();\n}\n"
  original_instructions: |-
    List suggestions in windmillhub
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: number) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v2/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return 42;
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Failed to parse URL from https://www.googleapis.com/drive/v2/files/123/?supportsAllDrives=true
  explanation: |-
    The code is broken because of two changes:

    1. The `fileId` parameter type was changed from `string` to `number`. The Google Drive API expects the file ID to be a string, not a number. When the `fileId` is inserted into the URL, it will not be properly recognized if it's not a string.

    2. The return type of the function was changed from a string to a number (`return 42;`). This is a breaking change if the calling code expects a string to be returned, as the original function signature implied that a string describing the action ("file moved to trash") would be returned.

    The error message provided is a generic one that might be shown if the URL is not correctly formed due to the `fileId` being a number instead of a string. However, the actual error message might differ depending on the runtime environment and how it handles the URL parsing and fetch request.
  id: |-
    hubfix_hub_59
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const DELETE_FILE_URL = `https://www.googleapis.com/drive/v2/files/${fileId}/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_FILE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return "file moved to trash";
    }
  original_instructions: |-
    Move File to Trash in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    type Nocodb = {
      apiUrl: string;
      xc_token: string;
      table: string;
      workspace: string;
    };
    export async function main(nocodb: Nocodb, limit: string) {
      // request from nocodb
      const res = await fetch(
        `${nocodb.apiUrl}/api/v1/db/data/v1/${nocodb.workspace}/${nocodb.table}?limit=${limit}`,
        {
          headers: {
            "Content-Type": "application/json",
            "xc-token": nocodb.xc_token,
          },
        },
      );
      const data = await res.json();
      return data;
    }

    main({ apiUrl: 'https://example.com', xc_token: 'token', table: 'users', workspace: 'default' }, '10');
  error: |-
    Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `limit` parameter in the `main` function was changed from `number` to `string`, which is incorrect because the function expects a number to be passed as the limit for the API request. When calling the `main` function at the end, the string `'10'` is passed as the `limit` argument, which does not match the expected type `number`. This type mismatch causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_hub_369
  lang: |-
    deno
  original_code: |
    type Nocodb = {
      apiUrl: string;
      xc_token: string;
      table: string;
      workspace: string;
    };
    export async function main(nocodb: Nocodb, limit: number) {
      // request from nocodb
      const res = await fetch(
        `${nocodb.apiUrl}/api/v1/db/data/v1/${nocodb.workspace}/${nocodb.table}?limit=${limit}`,
        {
          headers: {
            "Content-Type": "application/json",
            "xc-token": nocodb.xc_token,
          },
        },
      );
      const data = await res.json();
      return data;
    }
  original_instructions: |-
    Get item list from a NocoDb table in nocodb
  resource_type: |-
    Nocodb
  resource_type_def: |-
    type Nocodb = {
      apiUrl: string;
      xc_token: string;
      table: string;
      workspace: string;
    }
- broken_code: |-
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.2.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, path: string, content: number) {
      return await new S3Client(s3).putObject(path, content);
    }
  error: |-
    TypeError: content is not a string.
  explanation: |-
    The `putObject` method of the `S3Client` class expects the `content` parameter to be a string, but in the broken code, the `content` parameter is changed to a number. This type mismatch causes a TypeError when the `putObject` method is called with a number instead of a string.
  id: |-
    hubfix_hub_108
  lang: |-
    deno
  original_code: |
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.2.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, path: string, content: string) {
      return await new S3Client(s3).putObject(path, content);
    }
  original_instructions: |-
    Upload text in bucket in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- broken_code: |-
    // Should return an XML document on success
    type Nextcloud = {
      baseUri: string;
      user: string;
      pass: string;
    };
    export async function main(nextcloud_res: Nextcloud) {
      const response = await fetch(`${nextcloud_res.baseUri}/ocs/v1.php/cloud/users`, {
        headers: {
          Authorization:
            "Basic " + btoa(nextcloud_res.user + ":" + nextcloud_res.pass),
          "OCS-APIRequest": "true",
        },
      });
      if (!response.ok) {
        throw Error(`HTTP Error ${response.status} - ${await response.text()}`);
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.
  explanation: |-
    The code is broken for a couple of reasons:

    1. The properties of the `Nextcloud` type have been renamed from `baseUrl`, `username`, and `password` to `baseUri`, `user`, and `pass`, respectively. This will cause a TypeScript error because the properties `baseUrl`, `username`, and `password` do not exist on the `nextcloud_res` object of type `Nextcloud`.

    2. The `btoa` function is being used, which can throw an error if the input string contains characters outside of the Latin1 range. If the username or password contains such characters, this will cause a runtime error.

    3. The `response.json()` method is being called, but the original code expects an XML document, not JSON. If the server is indeed returning XML, this will result in a runtime error because `response.json()` will fail to parse the XML as JSON.
  id: |-
    hubfix_hub_163
  lang: |-
    deno
  original_code: |
    // Should return an XML document on success
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    };
    export async function main(nextcloud_res: Nextcloud) {
      const resp = await fetch(`${nextcloud_res.baseUrl}/ocs/v1.php/cloud/users`, {
        headers: {
          Authorization:
            "Basic " + btoa(nextcloud_res.username + ":" + nextcloud_res.password),
          "OCS-APIRequest": "true",
        },
      });
      if (!resp.ok) {
        throw Error(`HTTP Error ${resp.status} - ${await resp.text()}`);
      }
      return await resp.text();
    }
  original_instructions: |-
    List user IDs in ocs
  resource_type: |-
    Nextcloud
  resource_type_def: |-
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    }
- broken_code: |-
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import {
      collection,
      endAt,
      getDocs,
      getFirestore,
      limit as limitItems,
      orderBy,
      query,
      QueryConstraint,
      startAt,
    } from "npm:firebase/firestore/lite";

    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      order_by?: string,
      order_direction: "asc" | "desc" = "asc",
      start_at?: number | string,
      end_at?: number | string,
      limit?: number,
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const colRef = collection(store, collection_id);
      const constraints = [
        order_by ? orderBy(order_by, order_direction) : undefined,
        start_at ? startAt(start_at) : undefined,
        end_at ? endAt(end_at) : undefined,
        limit ? limitItems(limit) : undefined,
      ].filter(Boolean) as QueryConstraint[];
      const snapshot = await getDocs(query(colRef, ...constraints));
      const list = snapshot.docs.map((doc) => doc.data());

      return list;
    }

    // Breaking change
    const result = main({
      apiKey: "your-api-key",
      authDomain: "your-auth-domain",
      projectId: "your-project-id",
      storageBucket: "your-storage-bucket",
      messagingSenderId: "your-messaging-sender-id",
      appId: "your-app-id",
      measurementId: "your-measurement-id",
    }, "users", "createdAt", "asc", "2023-01-01", "2023-01-31", "10");
  error: |-
    TypeError: The `limit` function expects a number, but received a string.
  explanation: |-
    The breaking change introduced in the code is passing the string "10" to the `limit` function instead of a number. The `limit` function expects a number as its argument to specify the maximum number of documents to return. By passing a string, the code will throw a TypeError because it does not match the expected type for the `limit` parameter.
  id: |-
    hubfix_hub_356
  lang: |-
    deno
  original_code: |
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import {
      collection,
      endAt,
      getDocs,
      getFirestore,
      limit as limitItems,
      orderBy,
      query,
      QueryConstraint,
      startAt,
    } from "npm:firebase/firestore/lite";

    /**
     * @param order_by Name of the field to order by.
     *
     * @param start_at Can only be used if `order_by` is present,
     * because it'll filter based on the value of that field.
     *
     * @param end_at Can only be used if `order_by` is present,
     * because it'll filter based on the value of that field.
     */
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      order_by?: string,
      order_direction: "asc" | "desc" = "asc",
      start_at?: number | string,
      end_at?: number | string,
      limit?: number,
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const colRef = collection(store, collection_id);
      const constraints = [
        order_by ? orderBy(order_by, order_direction) : undefined,
        start_at ? startAt(start_at) : undefined,
        end_at ? endAt(end_at) : undefined,
        limit ? limitItems(limit) : undefined,
      ].filter(Boolean) as QueryConstraint[];
      const snapshot = await getDocs(query(colRef, ...constraints));
      const list = snapshot.docs.map((doc) => doc.data());

      return list;
    }
  original_instructions: |-
    List Documents in firebase
  resource_type: |-
    Firebase
  resource_type_def: |-
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.tokens); // Error introduced here
      return await client.pinChatMessage(chat_id, message);
    }
  error: |-
    TypeError: Cannot read property 'tokens' of undefined
  explanation: |-
    The code is trying to access a property `tokens` on the `auth` object, which does not exist. The correct property name is `token`. Additionally, the variable `message` used in the `pinChatMessage` function call is not defined anywhere in the code. The correct variable name should be `message_id`.
  id: |-
    hubfix_hub_239
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.pinChatMessage(chat_id, message_id);
    }
  original_instructions: |-
    Pin a Message in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room_id: number) {
      const url = `${
        matrix_res.baseEndpoint
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.apiKey}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.statusCode}`);
      }
      return {
        events: await resp.text(),
      };
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseEndpoint')
  explanation: |-
    The code is broken for several reasons:

    1. The `matrix_res` object does not have a property called `baseEndpoint`. The original property name is `baseUrl`.
    2. The `matrix_res` object does not have a property called `apiKey`. The original property name is `token`.
    3. The `room_id` parameter type was changed from `string` to `number`, which is incorrect because `encodeURIComponent` expects a string argument.
    4. The `resp` object does not have a property called `statusCode`. The correct property name is `status`.
    5. The function is returning `await resp.text()` instead of `await resp.json()`, which changes the expected return type from JSON to plain text. This might not be an error if the API returns plain text, but it is inconsistent with the original function's intent to return JSON events.
  id: |-
    hubfix_hub_160
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room_id: string) {
      const url = `${
        matrix_res.baseUrl
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return {
        events: await resp.json(),
      };
    }
  original_instructions: |-
    Get entire room state in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: string, // Changed the type from number to string
    ) {
      const token = gsheets_auth["token"];

      const DELETE_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteSheet: {
              sheetId: sheetId, // This will cause an error because sheetId is expected to be a number
            },
          },
        ],
      };

      const response = await fetch(DELETE_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: sheetId must be a number, received string
  explanation: |-
    The `sheetId` parameter in the `main` function was changed from `number` to `string`. The Google Sheets API expects `sheetId` to be a number, so passing a string instead will cause the API call to fail, resulting in a `TypeError`. The error message provided is a hypothetical one that describes the type mismatch issue.
  id: |-
    hubfix_hub_67
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteSheet: {
              sheetId: sheetId,
            },
          },
        ],
      };

      const response = await fetch(DELETE_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Delete Worksheet in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      type: "regular" | "plaintext" | "rss" | "variate",
      content_type: "template" | "multichannel" = "template",
      rss_opts?: Record<string, any>,
      recipients?: Record<string, any>,
      variate_settings?: Record<string, any>,
      settings?: Record<string, any>,
      tracking?: Record<string, any>,
      social_card?: Record<string, any>,
    ) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns`;
      const body = {
        type,
        content_type,
        rss_opts,
        recipients,
        variate_settings,
        settings,
        tracking,
        social_card,
      };

      const response = await fetch(url, {
        method: "PUT", // Changed from POST to PUT
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Request with GET/HEAD method cannot have body.
  explanation: |-
    The error message indicates that a fetch request with the GET or HEAD method cannot have a body. However, the error message might not be entirely accurate for the code provided, as the method used in the fetch request is "PUT", not GET or HEAD. The actual error that would occur depends on the API endpoint's expectations. If the Mailchimp API endpoint for creating campaigns only supports the POST method and not the PUT method, using "PUT" would result in an error response from the API, likely indicating that the method is not allowed. The error message would then be related to the API's response, not the fetch API itself. The code is wrong because it uses the wrong HTTP method for the API endpoint, which expects a POST request to create a new campaign.
  id: |-
    hubfix_hub_201
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * Find more information about the parameters at
     * https://mailchimp.com/developer/marketing/api/campaigns/add-campaign/
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      type: "regular" | "plaintext" | "rss" | "variate",
      content_type: "template" | "multichannel" = "template",
      rss_opts?: Record<string, any>,
      recipients?: Record<string, any>,
      variate_settings?: Record<string, any>,
      settings?: Record<string, any>,
      tracking?: Record<string, any>,
      social_card?: Record<string, any>,
    ) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns`;
      const body = {
        type,
        content_type,
        rss_opts,
        recipients,
        variate_settings,
        settings,
        tracking,
        social_card,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Create Campaign in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(
      discord_webhook: DiscordWebhook,
      messageId: string,
      newMessageContent: number,
    ) {
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.editMessage(messageId, newMessageContent);
      return ret;
    }
  error: |-
    TypeError: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `newMessageContent` parameter in the `main` function has been changed from `string` to `number`. The `editMessage` method of the `discordwebhook` class expects the second parameter to be a string, which is the new content of the message. By passing a number instead of a string, the code will not compile and will result in a type error.
  id: |-
    hubfix_hub_132
  lang: |-
    deno
  original_code: |
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(
      discord_webhook: DiscordWebhook,
      messageId: string,
      newMessageContent: string,
    ) {
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.editMessage(messageId, newMessageContent);
      return ret;
    }
  original_instructions: |-
    Edit message in discord
  resource_type: |-
    DiscordWebhook
  resource_type_def: |-
    type DiscordWebhook = {
      webhook_url: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/nonexistent@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      page_size?: number,
      page_token?: number,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "GET",
        qs: {
          page_size,
          page_token,
        },
      };

      try {
        const [_, body] = await sendgrid.makeRequest(request); // Changed from request to makeRequest
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    Error: Cannot find module 'npm:@sendgrid/nonexistent@^7.7.0'
  explanation: |-
    The code is broken because of two reasons:

    1. The import statement is trying to import a package that doesn't exist (`npm:@sendgrid/nonexistent@^7.7.0`). The original package name was `npm:@sendgrid/client@^7.7.0`, which is a valid package. Changing the package name to `nonexistent` causes the module resolution to fail, resulting in an error that the module cannot be found.

    2. The function `sendgrid.makeRequest` does not exist. The original function call was `sendgrid.request`, which is the correct method to make a request using the SendGrid client. Changing the method name to `makeRequest` will result in a runtime error because `makeRequest` is not a function in the SendGrid client API.
  id: |-
    hubfix_hub_223
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param page_size Maximum number of elements to return. Defaults to 100, returns 1000 max.
     *
     * @param page_token Token corresponding to a specific page of results.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      page_size?: number,
      page_token?: number,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "GET",
        qs: {
          page_size,
          page_token,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Get Contact Lists in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      page_id: string,
      filter_properties?: string[],
    ) {
      const client = new Client({ auth: auth.apiKey });
      if (!filter_properties?.filter(Boolean).length) {
        filter_properties = undefined;
      }
      return await client.pages.retrieve({
        pageId: page_id,
        filterProperties: filter_properties,
      });
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'apiKey')
  explanation: |-
    The code is trying to access a property `apiKey` on the `auth` object, which does not exist. The correct property name as defined in the `Notion` type is `token`. Additionally, the `retrieve` method is being called with incorrect parameter names: `pageId` and `filterProperties` should be `page_id` and `filter_properties` respectively, as per the Notion client library's expected parameters.
  id: |-
    hubfix_hub_351
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/retrieve-a-page
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      page_id: string,
      filter_properties?: string[],
    ) {
      const client = new Client({ auth: auth.token });
      if (!filter_properties?.filter(Boolean).length) {
        filter_properties = undefined;
      }
      return await client.pages.retrieve({
        page_id,
        filter_properties,
      });
    }
  original_instructions: |-
    Retrieve Page in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- broken_code: |-
    export async function main(
      zammad_host: string,
      zammad_token: string,
      user_agent?: string,
      firstname: string,
      lastname: string,
      email: string,
      login?: string,
      organisation?: string,
      roles?: string[],
    ) {
      // https://docs.zammad.org/en/latest/api/user.html#create
      const response = await fetch(`${zammad_host}/api/v1/users`, {
        method: "PUT", // This should be "POST"
        headers: {
          Authorization: `Token token=${zammad_token}`,
          "User-Agent": user_agent ?? "Public windmill.dev script",
        },
        body: JSON.stringify({
          first_name: firstname, // Incorrect property name
          last_name: lastname, // Incorrect property name
          email_address: email, // Incorrect property name
          ...(login && { login }),
          ...(organisation && { organization: organisation }), // Typo in property name
          ...(roles && { role: roles }), // Incorrect property name
        }),
      });
      // HTTP 422 means that the user already exists.
      if (!response.ok && response.status !== 422) {
        throw Error(`Failed to create user: Error HTTP${response.status}`);
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to fetch
  explanation: |-
    The code above contains several errors:

    1. The HTTP method used in the fetch request is "PUT" instead of "POST". The Zammad API expects a "POST" request to create a user.
    2. The property names in the JSON body are incorrect. The Zammad API expects 'firstname', 'lastname', and 'email', but the code uses 'first_name', 'last_name', and 'email_address'.
    3. The spread syntax is used incorrectly for the 'organisation' property. It has a typo and should be 'organization', but even if corrected, it should not be spread since it's a single property.
    4. The 'roles' property is incorrectly named 'role' in the spread syntax. It should be 'roles' to match the expected API parameters.

    The TypeError "Failed to fetch" is a generic error message that could be caused by various issues, such as network problems or incorrect request details. In a real-world scenario, the error message might be different and more specific to the actual problem, such as a 400 Bad Request due to incorrect parameters.
  id: |-
    hubfix_hub_155
  lang: |-
    deno
  original_code: |
    export async function main(
      zammad_host: string,
      zammad_token: string,
      user_agent?: string,
      firstname: string,
      lastname: string,
      email: string,
      login?: string,
      organisation?: string,
      roles?: string[],
    ) {
      // https://docs.zammad.org/en/latest/api/user.html#create
      const resp = await fetch(`${zammad_host}/api/v1/users`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${zammad_token}`,
          "User-Agent": user_agent ?? "Public windmill.dev script",
        },
        body: JSON.stringify({
          firstname,
          lastname,
          email,
          ...(login && { login }),
          ...(organisation && { organisation }),
          ...(roles && { roles }),
        }),
      });
      // HTTP 422 means that the user already exists.
      if (!resp.ok && resp.status !== 422) {
        throw Error(`Failed to create user: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  original_instructions: |-
    Create user in zammad
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite/mod.ts"; // Removed the version number

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.deleteDocument(database_id, collection_id, ID(document_id)); // Incorrectly using ID as a function
    }
  error: |-
    error: TS2339 [ERROR]: Property 'deleteDocument' does not exist on type 'Databases'.
    return await db.deleteDocument(database_id, collection_id, ID(document_id));
                      ~~~~~~~~~~~~~~~
  explanation: |-
    The code is broken because of two reasons:

    1. The import statement for the `appwrite` module does not specify a version number. This could lead to importing an incorrect or non-existent version of the module, which might not have the expected API.

    2. The `ID` is being used as if it were a function (`ID(document_id)`), but it is actually a type imported from the `appwrite` module. TypeScript expects `ID` to be used as a type annotation, not as a function. This misuse will result in a compilation error because TypeScript cannot find a function named `ID`.
  id: |-
    hubfix_hub_338
  lang: |-
    deno
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.deleteDocument(database_id, collection_id, document_id);
    }
  original_instructions: |-
    Delete Document in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: number) {
      const salt = await bcrypt.genSalt(15);
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `bcrypt.hash` function expects a string as its first argument, but the modified code is passing a number (`password: number`). This type mismatch causes TypeScript to throw an error because the `password` parameter's type was changed from `string` to `number`.
  id: |-
    hubfix_hub_86
  lang: |-
    deno
  original_code: |
    import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

    export async function main(password: string) {
      const salt = await bcrypt.genSalt();
      const hash_pass = await bcrypt.hash(password, salt);

      return hash_pass;
    }
  original_instructions: |-
    Hash Password with Random Salt in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    type Surrealdb = {
      url: string;
      token: string;
    };
    export async function main(
      auth: Surrealdb,
      namespace: string,
      database: string,
      query: string,
      variables?: Record<string, unknown>,
    ) {
      const client = new Surreal(auth.url, auth.token);
      await client.use(namespace, database);
      const result = await client.query(query, variables);
      client.disconnect(); // This method does not exist
      return result;
    }
  error: |-
    TypeError: client.disconnect is not a function
  explanation: |-
    In the provided code, the method `disconnect` is called on the `client` object. However, this method does not exist on the Surreal client object. The correct method to close the connection is `client.close()`, not `client.disconnect()`. This is a common mistake where a developer might confuse the method names or assume the existence of a method based on naming conventions from other libraries or languages.
  id: |-
    hubfix_hub_319
  lang: |-
    deno
  original_code: |
    import Surreal from "https://deno.land/x/surrealdb@v0.5.0/mod.ts";

    /**
     * @param query The query string.
     * @param variables The variables used in the query.
     */
    type Surrealdb = {
      url: string;
      token: string;
    };
    export async function main(
      auth: Surrealdb,
      namespace: string,
      database: string,
      query: string,
      variables?: Record<string, unknown>,
    ) {
      const client = new Surreal(auth.url, auth.token);
      await client.use(namespace, database);
      const result = await client.query(query, variables);
      client.close();
      return result;
    }
  original_instructions: |-
    Run Arbitrary Query in surrealdb
  resource_type: |-
    Surrealdb
  resource_type_def: |-
    type Surrealdb = {
      url: string;
      token: string;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    type AppwriteConfig = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: AppwriteConfig,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.listDocuments(queries, search);
    }
  error: |-
    error: TS2305 [ERROR]: Module '"https://deno.land/x/appwrite/mod.ts"' has no exported member 'Databases'.
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";
  explanation: |-
    The code is broken because of the following reasons:

    1. The import statement is incorrect. The version number is removed from the URL, which may lead to importing a non-existent version of the module or a module that does not have the 'Databases' export.

    2. The function `db.listDocuments` is called, but this function does not exist on the `Databases` class. The correct function name should be `db.list`.

    3. The type `Appwrite` was renamed to `AppwriteConfig`, but the parameter `auth` in the `main` function is still annotated with the old type name `Appwrite`. The type name should be updated to `AppwriteConfig` to match the new type definition.
  id: |-
    hubfix_hub_327
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.list(queries, search);
    }
  original_instructions: |-
    List Databases in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import formData from "npm:form-data@4.0.0";
    import MailgunClient from "npm:mailgun.js@9.1.0";

    interface Mailgun {
      api_key: string;
      extra_field: string; // Added a field that is not used
    }

    export async function main(
      mailgunConfig: Mailgun,
      domain: string,
      from: string,
      to: string[],
      subject: string,
      templateName: string,
      replyTo?: string,
      substitutions: Record<string, string>,
    ) {
      const mailgun = new MailgunClient(formData);
      const mg = mailgun.client({ username: "api", key: mailgunConfig.api_key });

      try {
        const result = await mg.messages.create(domain, {
          from,
          to,
          subject,
          template: templateName,
          "h:X-Mailgun-Variables": JSON.stringify(substitutions),
          ...(replyTo && { "h:Reply-To": replyTo }),
        });

        return result;
      } catch (error) {
        console.error(error);
        throw new Error("Failed to send email"); // Changed the error handling
      }
    }

    // Breaking change: Renamed the import which will cause the script to fail
    import incorrectImport from "npm:nonexistent-package@1.0.0";
  error: |-
    TypeError: Cannot read properties of undefined (reading 'client')
  explanation: |-
    The code is broken because it attempts to import a module named "nonexistent-package" which does not exist. This will cause a runtime error when trying to use the `incorrectImport` variable, as it will be `undefined`. Additionally, the error handling in the catch block has been changed to throw a new Error with a generic message, which could obscure the original error details, making debugging more difficult.
  id: |-
    hubfix_hub_396
  lang: |-
    deno
  original_code: |
    import formData from "npm:form-data@4.0.0";
    import MailgunClient from "npm:mailgun.js@9.1.0";

    interface Mailgun {
      api_key: string;
    }

    export async function main(
      mailgunConfig: Mailgun,
      domain: string,
      from: string,
      to: string[],
      subject: string,
      templateName: string,
      replyTo?: string,
      substitutions: Record<string, string>,
    ) {
      const mailgun = new MailgunClient(formData);
      const mg = mailgun.client({ username: "api", key: mailgunConfig.api_key });

      try {
        const result = await mg.messages.create(domain, {
          from,
          to,
          subject,
          template: templateName,
          "h:X-Mailgun-Variables": JSON.stringify(substitutions),
          ...(replyTo && { "h:Reply-To": replyTo }),
        });

        return result;
      } catch (error) {
        console.error(error);
        throw error;
      }
    }
  original_instructions: |-
    Send an email based on a mailgun template in mailgun
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { parse } from "https://deno.land/x/xml/mod.ts";

    type Rss = {
      url: string;
    };
    export async function main(rss_feed: Rss) {
      const rss_feed_url = rss_feed.url;
      let feedStates = (await wmill.getInternalState()) || {};
      const newestItem: Date = new Date(feedStates[rss_feed_url] || 0);

      const items = await fetch(rss_feed_url)
        .then((response) => response.text())
        .then((str) => parse(str))
        .then((feed) => {
          let items = [];
          if (feed["rss"]) {
            items = rss2_items(feed);
          } else if (feed["feed"]) {
            items = atom_items(feed);
          }
          const new_items = items.filter((item) => item.publishDate > newestItem);
          return new_items;
        });

      if (items.length > 0) {
        let newState = (await wmill.getInternalState()) || {};
        const dates = items.map((item) => item.publishDate);
        newState[rss_feed_url] = new Date(Math.max(...dates));
        await wmill.setInternalState(newState);
      }

      return items.reverse();
    }

    function rss2_items(feed) {
      var items = feed["rss"]["channel"]["item"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: item.title,
        link: item.link,
        publishDate: new Date(item.pubDate),
      }));
    }

    function atom_items(feed) {
      var items = feed["feed"]["entry"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: typeof item.title === "string" ? item.title : item.title["#text"],
        link:
          item.link instanceof Array ? item.link[0]["@href"] : item.link["@href"],
        publishDate: new Date(item.updated),
      }));
    }
  error: |-
    TypeError: item.publishDate is undefined
  explanation: |-
    The code is broken because the property `publishDate` does not exist on the items within the `items` array. The original property name is `pubDate`, and the code was changed to use `publishDate` instead. This causes a runtime error when trying to access a property that does not exist on the object, resulting in `undefined`. The filter function and the map function that create the `dates` array both attempt to access `item.publishDate`, which is not a valid property of the item objects.
  id: |-
    hubfix_hub_297
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { parse } from "https://deno.land/x/xml/mod.ts";

    type Rss = {
      url: string;
    };
    export async function main(rss_feed: Rss) {
      const rss_feed_url = rss_feed.url;
      let feedStates = (await wmill.getInternalState()) || {};
      const newestItem: Date = new Date(feedStates[rss_feed_url] || 0);

      const items = await fetch(rss_feed_url)
        .then((response) => response.text())
        .then((str) => parse(str))
        .then((feed) => {
          let items = [];
          if (feed["rss"]) {
            items = rss2_items(feed);
          } else if (feed["feed"]) {
            items = atom_items(feed);
          }
          const new_items = items.filter((item) => item.pubDate > newestItem);
          return new_items;
        });

      if (items.length > 0) {
        let newState = (await wmill.getInternalState()) || {};
        const dates = items.map((item) => item.pubDate);
        newState[rss_feed_url] = new Date(Math.max(...dates));
        await wmill.setInternalState(newState);
      }

      return items.reverse();
    }

    function rss2_items(feed) {
      var items = feed["rss"]["channel"]["item"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: item.title,
        link: item.link,
        pubDate: new Date(item.pubDate),
      }));
    }

    function atom_items(feed) {
      var items = feed["feed"]["entry"] || [];
      if (items.length === "undefined") {
        // Single entry
        items = [items];
      }
      return items.map((item) => ({
        title: typeof item.title === "string" ? item.title : item.title["#text"],
        link:
          item.link instanceof Array ? item.link[0]["@href"] : item.link["@href"],
        pubDate: new Date(item.updated),
      }));
    }
  original_instructions: |-
    RSS Feed Fetcher in RSS
  resource_type: |-
    Rss
  resource_type_def: |-
    type Rss = {
      url: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      message_id: string,
    ) {
      const client = new Telegram(auth.tokens);
      return await client.unpinChatMessage(chat_id, parseInt(message_id));
    }
  error: |-
    TypeError: Cannot read property 'tokens' of undefined
  explanation: |-
    The code is broken for several reasons:

    1. The `auth` parameter is of type `Telegram`, which is a type with a single property `token`. However, inside the `main` function, `auth.tokens` is used, which is incorrect because the property should be `auth.token`. The pluralization of `token` to `tokens` is causing the error.

    2. The `message_id` parameter type has been changed from `number` to `string`, which is not consistent with the expected type for the `unpinChatMessage` method. The method expects a `number` as the second argument, but the code is passing a `string` and then trying to parse it with `parseInt`. This could potentially cause a runtime error if `message_id` is not a valid string representation of a number.

    To fix the code, the `auth.tokens` should be changed back to `auth.token`, and the `message_id` parameter type should remain `number` without the need to parse it with `parseInt`.
  id: |-
    hubfix_hub_240
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.unpinChatMessage(chat_id, message_id);
    }
  original_instructions: |-
    Unpin a Message in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room: number) {
      if (!matrix_res.token) {
        throw Error("Joining a room requires an access token.");
      }
      const response = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/join/${encodeURIComponent(room)}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.tokens}`,
          },
        },
      );
      if (!response.okay) {
        throw Error(`Failed to join room: Error HTTP${response.status}`);
      }
    }
  error: |-
    TypeError: matrix_res.tokens is undefined
  explanation: |-
    The code is broken for several reasons:

    1. The `room` parameter type has been changed from `string` to `number`, which is incorrect because the `encodeURIComponent` function expects a string argument. This will cause a runtime error if a number is passed to `encodeURIComponent`.

    2. The property `tokens` is being accessed on `matrix_res` instead of `token`. Since `tokens` is not a property of the `Matrix` type, this will result in an undefined value and cause a runtime error when trying to use it in the `Authorization` header.

    3. The property `okay` is being accessed on `response` instead of `ok`. There is no `okay` property on the `Response` object; the correct property to check if the response was successful is `ok`. This will cause a runtime error because `response.okay` is undefined.
  id: |-
    hubfix_hub_97
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room: string) {
      if (!matrix_res.token) {
        throw Error("Joining a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/join/${encodeURIComponent(room)}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
          },
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to join room: Error HTTP${resp.status}`);
      }
    }
  original_instructions: |-
    Join room in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function mainProcess(id: number, resumePayload?: object) {
      return wmill.JobService.resumeSuspendedFlowAsOwner({
        workspace: wmill.getWorkplace(),
        identity: id,
        requestBody: resumePayload ?? {},
      });
    }
  error: |-
    TypeError: wmill.JobService.resumeSuspendedFlowAsOwner is not a function
  explanation: |-
    The code is broken for several reasons:

    1. The function name has been changed from `main` to `mainProcess`. If there is an external dependency expecting a function named `main`, this change will break the code.
    2. The type of the `id` parameter has been changed from `string` to `number`. If the `resumeSuspendedFlowAsOwner` function expects a string for the `id`, passing a number will cause a type error.
    3. The property `workspace` is incorrectly changed to `getWorkplace()`, which likely does not exist on the `wmill` object, leading to a runtime error.
    4. The property `id` in the argument object passed to `resumeSuspendedFlowAsOwner` has been changed to `identity`, which is not expected by the function and will likely result in an error because the correct property name is not being used.
  id: |-
    hubfix_hub_271
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(id: string, resumePayload?: object) {
      return wmill.JobService.resumeSuspendedFlowAsOwner({
        workspace: wmill.getWorkspace(),
        id,
        requestBody: resumePayload ?? {},
      });
    }
  original_instructions: |-
    Resume Suspended Flow as Owner in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Client } from "npm:@notionhq/client";

    type Notion = {
      apiKey: string;
    };
    export async function main(auth: Notion, block_id: string) {
      const client = new Client({ auth: auth.apiKey });
      return await client.blocks.fetch({ id: block_id });
    }
  error: |-
    TypeError: client.blocks.fetch is not a function
  explanation: |-
    The code is attempting to call a method `fetch` on `client.blocks` which does not exist in the Notion client API. The correct method to retrieve a block is `retrieve`, not `fetch`. Additionally, the parameter for the `retrieve` method should be `{ block_id }` instead of `{ id: block_id }`.
  id: |-
    hubfix_hub_352
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@notionhq/client";

    /**
     * Learn more at
     * https://developers.notion.com/reference/retrieve-a-block
     */
    type Notion = {
      token: string;
    };
    export async function main(auth: Notion, block_id: string) {
      const client = new Client({ auth: auth.token });
      return await client.blocks.retrieve({ block_id });
    }
  original_instructions: |-
    Retrieve Block in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      user_id: number,
      until_date?: number,
      revoke_messages?: boolean | undefined,
    ) {
      const client = new Telegram(auth.token);
      return await client.expelChatMember(chat_id, user_id, until_date || undefined, {
        revoke_messages,
      });
    }
  error: |-
    TypeError: client.expelChatMember is not a function
  explanation: |-
    The error is caused by calling a method `expelChatMember` on the `client` object that does not exist in the Telegram API. The correct method name should be `banChatMember` as per the original code. Since `expelChatMember` is not a valid method, trying to call it results in a `TypeError`.
  id: |-
    hubfix_hub_238
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    /**
     * @param until_date Unix time. If user is banned for more than
     * 366 days or less than 30 seconds from the current time they
     * are considered to be banned forever.
     *
     * @param revoke_messages If `true` then the banned user's messages
     * will be deleted from the chat.
     */
    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string,
      user_id: number,
      until_date?: number,
      revoke_messages?: boolean | undefined,
    ) {
      const client = new Telegram(auth.token);
      return await client.banChatMember(chat_id, user_id, until_date || undefined, {
        revoke_messages,
      });
    }
  original_instructions: |-
    Kick a Chat Member in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      accessToken: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            updateCells: {
              range: {
                sheetId: sheetId,
              },
              fields: "userEnteredValue",
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The code is trying to access the property 'token' on the 'gsheets_auth' object, but the type definition for 'Gsheets' has been changed to have a property 'accessToken' instead of 'token'. Therefore, when trying to access 'gsheets_auth["token"]', it will return `undefined`, and when trying to use this undefined value in the Authorization header, it will cause a runtime error.

    Additionally, the function is now returning `response.json()` instead of `response.text()`. If the response from the API is not in JSON format, this could also cause a runtime error when trying to parse it as JSON.
  id: |-
    hubfix_hub_66
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            updateCells: {
              range: {
                sheetId: sheetId,
              },
              fields: "userEnteredValue",
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Clear All Values in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    type AppwriteConfig = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: AppwriteConfig,
      database_id: string,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.apiKey); // This line is changed
      const db = new Databases(client);

      return await db.listAllCollections(database_id, queries, search); // This line is changed
    }
  error: |-
    error: TS2339 [ERROR]: Property 'apiKey' does not exist on type 'AppwriteConfig'.
        .setKey(auth.apiKey);
                    ~~~~~~
    error: TS2339 [ERROR]: Property 'listAllCollections' does not exist on type 'Databases'. Did you mean 'listCollections'?
      return await db.listAllCollections(database_id, queries, search);
                        ~~~~~~~~~~~~~~~~~~~
  explanation: |-
    The code is broken for two reasons:

    1. The property `apiKey` is being accessed on the `auth` object, but the `AppwriteConfig` type does not have an `apiKey` property; it has a `key` property instead. This is a common mistake where a developer might confuse the property name.

    2. The method `listAllCollections` is being called on the `db` object of type `Databases`. However, this method does not exist in the `Databases` class. The correct method name is `listCollections`, and using the wrong method name is a typical error when a developer misremembers the correct API method name.
  id: |-
    hubfix_hub_330
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     *
     * @param search Search term to filter your list results.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      queries?: string[],
      search?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.listCollections(database_id, queries, search);
    }
  original_instructions: |-
    List Collections in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_deleted: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .delete({ count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_deleted) {
          query = query.select();
        }

        return query.execute();
      });
    }
  error: |-
    TypeError: query.execute is not a function
  explanation: |-
    The error occurs because the method `execute()` is being called on the `query` object, but this method does not exist on the object returned by the chaining of `delete()` and `filter()` methods. The original code did not call `execute()`; instead, it relied on the `query` object being returned and presumably handled by the `refreshAndRetryIfExpired` function. By adding the non-existent `execute()` method, the code is now trying to call a function that doesn't exist in the API, resulting in a `TypeError`.
  id: |-
    hubfix_hub_285
  lang: |-
    deno
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param filter Learn more at https://supabase.com/docs/reference/javascript/filter
     *
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_deleted: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .delete({ count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_deleted) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Delete data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    type Funkwhale = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      auth: Funkwhale,
      query?: string,
      scope = "all",
      page_size = 10,
    ) {
      const previousState = await getState();
      const url = new URL("/api/v1/history/listenings", auth.baseUrl);
      const params = { query, scope, page_size };
      Object.entries(params).forEach(([key, value]) => {
        value && url.searchParams.append(key, encodeURIComponent(value));
      });
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const data = await response.json();
      data.results.reverse();

      const newListenings = [];
      let latestId;
      for (const listening of data.results) {
        if (latestId === undefined || listening.id > latestId) {
          latestId = listening.id;
        }
        if (
          previousState?.latestId !== undefined &&
          listening.id <= previousState.latestId
        ) {
          continue;
        }
        newListenings.push(listening);
      }

      if (latestId !== undefined) {
        await setState({
          latestId,
        });
      }
      return newListenings;
    }

    main({ baseUrl: "https://example.com", token: "sometoken" }, null, "all", "twenty");
  error: |-
    TypeError: Invalid argument
  explanation: |-
    The error occurs because the `page_size` parameter is expected to be a number, but the string "twenty" is passed to the `main` function call at the bottom of the script. This causes a type mismatch when the `page_size` is used to construct the URL parameters, as the `URLSearchParams.append` method expects both key and value to be strings, and the `encodeURIComponent` function expects a string as well. Since "twenty" is not a valid number, this will cause a runtime error when the script tries to use it as a number.
  id: |-
    hubfix_hub_161
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    /**
     * **IMPORTANT:** This does not return listenings on the first run.
     *
     * You can read more about the Listenings History API at
     * https://docs.funkwhale.audio/swagger/#/User%20activity/get_api_v1_history_listenings
     */
    type Funkwhale = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      auth: Funkwhale,
      query?: string,
      scope = "all",
      page_size = 10,
    ) {
      const previousState = await getState();
      const url = new URL("/api/v1/history/listenings", auth.baseUrl);
      const params = { query, scope, page_size };
      Object.entries(params).forEach(([key, value]) => {
        value && url.searchParams.append(key, encodeURIComponent(value));
      });
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const data = await response.json();
      data.results.reverse();

      const newListenings = [];
      let latestId;
      for (const listening of data.results) {
        if (latestId === undefined || listening.id > latestId) {
          latestId = listening.id;
        }
        if (
          previousState?.latestId !== undefined &&
          listening.id <= previousState.latestId
        ) {
          continue;
        }
        newListenings.push(listening);
      }

      if (latestId !== undefined) {
        await setState({
          latestId,
        });
      }
      return newListenings;
    }
  original_instructions: |-
    Watch for new listenings in funkwhale
  resource_type: |-
    Funkwhale
  resource_type_def: |-
    type Funkwhale = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      collection_id: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
      collection_enabled?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.updateCollection(
        database_id,
        collection_id,
        collection_name,
        collection_permissions,
        collection_document_security,
        collection_enabled,
        "extraArgument",
      );
    }
  error: |-
    error: Uncaught (in promise) TypeError: db.updateCollection is not a function
  explanation: |-
    The error message indicates that `db.updateCollection` is not a function. This could be due to a couple of reasons:

    1. The `updateCollection` method does not exist on the `Databases` class from the `appwrite` module. This could be because the method has been renamed, removed, or never existed in the first place.
    2. The `appwrite` module could have been updated, and the method signature or the way to interact with the database collections could have changed.

    Additionally, the import statement has been modified to remove the version number (`@7.0.0`) from the URL, which could lead to importing a different version of the module that does not have the `updateCollection` method.

    The extra argument "extraArgument" at the end of the `updateCollection` method call is also incorrect because it does not match the expected parameters of the method, assuming the method exists and is being called correctly.
  id: |-
    hubfix_hub_332
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_name: string,
      collection_id: string,
      collection_permissions?: string[],
      collection_document_security?: boolean,
      collection_enabled?: boolean,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.updateCollection(
        database_id,
        collection_id,
        collection_name,
        collection_permissions,
        collection_document_security,
        collection_enabled,
      );
    }
  original_instructions: |-
    Update Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    export async function main(min = 0, max = "100") {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The error occurs because the `max` parameter is being assigned a string value `"100"` instead of a number. In TypeScript, you cannot perform arithmetic operations like subtraction between a number and a string. The `max` parameter should remain a number to be compatible with the arithmetic operation in the function.
  id: |-
    hubfix_hub_101
  lang: |-
    deno
  original_code: |
    export async function main(min = 0, max = 100) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
  original_instructions: |-
    Random Integer in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
      document: Record<string, any>,
      upsert?: boolean,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);
      upsert = typeof upsert === "boolean" ? upsert : undefined;
      return await docs.updateOnce(filter, document, { upsert });
    }
  error: |-
    TypeError: docs.updateOnce is not a function
  explanation: |-
    The error is caused by calling a non-existent method `updateOnce` on the `docs` object. The correct method name should be `updateOne`, as per the original code. By changing the method name to `updateOnce`, the code attempts to call a method that does not exist in the MongoClient API, resulting in a `TypeError`.
  id: |-
    hubfix_hub_261
  lang: |-
    deno
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     *
     * @param filter For example: `{ "_id": "01234" }`
     *
     * @param upsert If `true` and no documents match the `filter`,
     * then a new document will be created with the values of `document`.
     * Default is `false`.
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
      document: Record<string, any>,
      upsert?: boolean,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);
      upsert = typeof upsert === "boolean" ? upsert : undefined;
      return await docs.updateOne(filter, document, { upsert });
    }
  original_instructions: |-
    Update a Document in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    import {
      InteractionResponseType,
      InteractionType,
      verifyKey,
    } from "npm:discord-interactions@3.4.0";

    type DiscordBotConfiguration = {
      public_key: string;
      application_id: string;
    };
    export async function main(
      x_signature_ed25519: string,
      x_signature_timestamp: string,
      raw_string: string,
      discord_config: DiscordBotConfiguration,
    ) {
      const isVerified = verifyKey(
        raw_string,
        x_signature_ed25519,
        x_signature_timestamp,
        discord_config.public_key,
      );

      if (!isVerified) {
        return { windmill_status_code: 401 };
      }

      const interaction = JSON.parse(raw_string);

      const type = interaction.type as InteractionType;
      if (type === InteractionType.PING) {
        return { type: InteractionResponseType.PONG };
      }

      if (type === InteractionType.APPLICATION_COMMAND) {
        const message = `Received command: \`\`\`json\n${JSON.stringify(
          {
            id: interaction.id,
            sender: interaction.member?.user,
            data: interaction.data,
          },
          undefined,
          2,
        )}\`\`\``;

        return {
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: message,
          },
        };
      }

      // Breaking change: Using a non-existent property of a type
      const invalidProperty = interaction.invalidProperty;

      return {
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: `You triggered an invalid property: ${invalidProperty}`,
        },
      };
    }
  error: |-
    TypeError: interaction.invalidProperty is not a property of the interaction object.
  explanation: |-
    The code attempts to access `interaction.invalidProperty`, which is not a valid property of the `interaction` object. Since `invalidProperty` does not exist on the `interaction` object, trying to access it will result in a `TypeError` when the code is executed. This is an example of using a non-existent property of a type inside the function.
  id: |-
    hubfix_hub_377
  lang: |-
    deno
  original_code: |
    // Getting started:
    // If you don't have a discord application yet, follow step 1 to get your application created and registered to your server
    //   https://discord.com/developers/docs/getting-started#step-1-creating-an-app

    // Navigate to your application in the Discord developer portal: https://discord.com/developers/applications

    // Create a new discord_bot_configuration resource with the public_key and application_id fields from the discord portal
    // Populate the DEFUALT_DISCORD_CONFIG variable below with the path to your new resource

    // Next we deploy this script to Windmill and register it as the "Interactions Endpoint URL"
    //   Get the endpoint for the sync version: https://docs.windmill.dev/docs/core_concepts/webhooks#synchronous
    //   Include query parameters for your token as well as capturing the raw body and headers to verify the signature
    //   {DEPLOYED_SCRIPT_SYNC_WEBHOOK}?include_header=X-Signature-Ed25519,X-Signature-Timestamp&raw=true&token={YOUR_TOKEN}

    // Finally we need to create a discord command and register it with our application:
    //   https://discord.com/developers/docs/interactions/application-commands#making-a-global-command

    // Now you should be able to use your registered command in discord and see the bot reply with some of the json payload

    import {
      InteractionResponseType,
      InteractionType,
      verifyKey,
    } from "npm:discord-interactions@3.4.0";

    type DiscordBotConfiguration = {
      public_key: string;
      application_id: string;
    };
    export async function main(
      x_signature_ed25519: string,
      x_signature_timestamp: string,
      raw_string: string,
      discord_config: DiscordBotConfiguration,
    ) {
      // We'll need the http request body as a string and the two headers to verify the request signature
      // https://discord.com/developers/docs/interactions/receiving-and-responding#security-and-authorization
      const isVerified = verifyKey(
        raw_string,
        x_signature_ed25519,
        x_signature_timestamp,
        discord_config.public_key,
      );

      // If we can't verify the request, we return 401.
      // We will be tested when we submit the interaction webhook to discord
      if (!isVerified) {
        return { windmill_status_code: 401 };
      }

      const interaction = JSON.parse(raw_string);

      // If we get a PING, we need to respond with a PONG
      // https://discord.com/developers/docs/interactions/receiving-and-responding#responding-to-an-interaction
      const type = interaction.type as InteractionType;
      if (type === InteractionType.PING) {
        return { type: InteractionResponseType.PONG };
      }

      // At this point we can process the interaction and can handle here or delegate to another script/flow
      // https://discord.com/developers/docs/interactions/receiving-and-responding#interactions-and-bot-users
      if (type === InteractionType.APPLICATION_COMMAND) {
        const message = `Received command: \`\`\`json\n${JSON.stringify(
          {
            id: interaction.id,
            sender: interaction.member?.user,
            data: interaction.data,
          },
          undefined,
          2,
        )}\`\`\``;

        return {
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: message,
          },
        };
      }
    }
  original_instructions: |-
    Receive Application Command Sample in discord
  resource_type: |-
    DiscordBotConfiguration
  resource_type_def: |-
    type DiscordBotConfiguration = {
      public_key: string;
      application_id: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: number) {
      const supportsAllDrives = true;
      const COPY_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/copy/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(COPY_FILE_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Invalid URL
  explanation: |-
    The `fileId` parameter type was changed from `string` to `number`, which is incorrect because file IDs in Google Drive are strings, not numbers. When the `fileId` is inserted into the URL, it will not be a valid URL if the `fileId` is a number. This will cause the `fetch` function to throw a `TypeError` because it expects a valid URL as its first argument.
  id: |-
    hubfix_hub_57
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const supportsAllDrives = true;
      const COPY_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}/copy/?supportsAllDrives=${supportsAllDrives}`;

      const token = gdrive_auth["token"];

      const response = await fetch(COPY_FILE_URL, {
        method: "POST",
        //body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Copy File in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts";

    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    };

    type Cacertificate = {
      certificate: string;
    };
    export async function main(
      dbConfig: Postgresql,
      cacertificate: Cacertificate,
      sql: string = "SELECT 1 as id",
    ) {
      dbConfig.tls = {
        enabled: true,
        enforce: true,
        caCertificates: [cacertificate.cert],
      };
      const client = new Client(dbConfig);
      await client.connect();

      const res = await client.queryObject(sql);

      await client.end();

      return res.rows;
    }
  error: |-
    TS2339 [ERROR]: Property 'cert' does not exist on type 'Cacertificate'. Did you mean 'certificate'?
        caCertificates: [cacertificate.cert],
                                          ~~~~
        at file:///path/to/script.ts:19:39
  explanation: |-
    The error occurs because the property `cert` does not exist on the type `Cacertificate`. The correct property name is `certificate`, as defined in the `Cacertificate` type. The code tries to access `cacertificate.cert` instead of `cacertificate.certificate`, which leads to a TypeScript error because the type definition enforces the structure of the object and the property names that can be accessed.
  id: |-
    hubfix_hub_366
  lang: |-
    deno
  original_code: |
    import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts";

    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    };

    type Cacertificate = {
      certificate: string;
    };
    export async function main(
      dbConfig: Postgresql,
      cacertificate: Cacertificate,
      sql: string = "SELECT 1 as id",
    ) {
      dbConfig.tls = {
        enabled: true,
        enforce: true,
        caCertificates: [cacertificate.certificate],
      };
      const client = new Client(dbConfig);
      await client.connect();

      const res = await client.queryObject(sql);

      await client.end();

      return res.rows;
    }
  original_instructions: |-
    Postgres with TLS  / SSL  in postgresql
  resource_type: |-
    Postgresql
  resource_type_def: |-
    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive) {
      const q = "";
      const SEARCH_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?q=${q}`;

      const token = gdrive_auth["tokenz"]; // Incorrect property name

      const response = await fetch(SEARCH_SHARED_DRIVE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text(); // Changed from json() to text()
    }
  error: |-
    TypeError: Cannot read property 'tokenz' of undefined
  explanation: |-
    The code is trying to access a property `tokenz` on the `gdrive_auth` object, which does not exist. The correct property name is `token`. Additionally, the function is now returning a string with `response.text()` instead of a JSON object with `response.json()`, which could be considered a breaking change if the calling code expects a JSON object.
  id: |-
    hubfix_hub_61
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive) {
      const q = "";
      const SEARCH_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?q=${q}`;

      const token = gdrive_auth["token"];

      const response = await fetch(SEARCH_SHARED_DRIVE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Search Shared Drives in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { Client, ID, Users } from "https://deno.land/x/appwrite/mod.ts";

    type AppwriteConfig = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: AppwriteConfig,
      id?: string,
      email?: string,
      phone?: string,
      password?: string,
      name?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.createAccount(
        id || ID.unique(),
        email || undefined,
        phone || undefined,
        password || undefined,
        name || undefined,
      );
    }
  error: |-
    error: TS2339 [ERROR]: Property 'createAccount' does not exist on type 'Users'. Did you mean 'create'?
        return await users.createAccount(
                          ~~~~~~~~~~~~~
  explanation: |-
    The error occurs because the method `createAccount` does not exist on the `Users` class. The correct method name is `create`, as used in the original code. By changing the method name to `createAccount`, the code attempts to call a method that doesn't exist, resulting in a TypeScript error.
  id: |-
    hubfix_hub_323
  lang: |-
    deno
  original_code: |
    import { Client, ID, Users } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param id ID of the user to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      id?: string,
      email?: string,
      phone?: string,
      password?: string,
      name?: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const users = new Users(client);

      return await users.create(
        id || ID.unique(),
        email || undefined,
        phone || undefined,
        password || undefined,
        name || undefined,
      );
    }
  original_instructions: |-
    Create User in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    type AppwriteConfig = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function mainFunction(
      auth: AppwriteConfig,
      database_id: string,
      collection_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.getDatabaseCollection(database_id, collection_id);
    }
  error: |-
    error: TS2339 [ERROR]: Property 'getDatabaseCollection' does not exist on type 'Databases'. Did you mean 'getCollection'?
      return await db.getDatabaseCollection(database_id, collection_id);
                        ~~~~~~~~~~~~~~~~~~~~
        at file:///path/to/script.ts:15:21
  explanation: |-
    The code is broken due to the following reasons:

    1. The import statement is missing the specific version of the `appwrite` package. Without specifying the version, Deno might not be able to resolve the correct package.

    2. The type `Appwrite` was renamed to `AppwriteConfig`, which is not an error by itself, but it could lead to confusion if other parts of the codebase are expecting the original `Appwrite` type.

    3. The function `main` was renamed to `mainFunction`. If other parts of the code or external scripts are expecting a function named `main`, this will cause an error when they try to call it.

    4. The method `getDatabaseCollection` does not exist on the `Databases` class. The correct method name is `getCollection`, as per the original code.
  id: |-
    hubfix_hub_331
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.getCollection(database_id, collection_id);
    }
  original_instructions: |-
    Get Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    export async function main(url: number, request_type: string) {
      const req = new Request(url, {
        method: request_type,
      });
      let resp = await fetch(req);

      return { response: await resp.texty() };
    }
  error: |-
    TypeError: req.texty is not a function
  explanation: |-
    There are two breaking changes in the code:

    1. The `url` parameter type has been changed from `string` to `number`. The `Request` constructor expects the first argument to be a string representing the URL, so passing a number will cause a type error.

    2. The method `texty()` does not exist on the `Response` object. The correct method to retrieve the body as text is `text()`. Calling `texty()` will result in a runtime error because it is not a valid method of the `Response` object.
  id: |-
    hubfix_hub_26
  lang: |-
    deno
  original_code: |
    export async function main(url: string, request_type: string) {
      const req = new Request(url, {
        method: request_type,
      });
      let resp = await fetch(req);

      return { response: await resp.text() };
    }
  original_instructions: |-
    Send any HTTP Request in http
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      requestId: number, // Changed from string to number
      drive_name: string,
    ) {
      const supportsAllDrives = true;
      const CREATE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?requestId=${requestId}`;

      const token = gdrive_auth["token"];
      const body = {
        name: drive_name,
        supportsAllDrives, // Added a property that is not expected by the API
      };
      const response = await fetch(CREATE_SHARED_DRIVE_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json(); // Changed from text() to json()
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Request with GET/HEAD method cannot have body.
  explanation: |-
    The error message indicates that a fetch request with the GET or HEAD method cannot have a body. However, in the provided code, the fetch request is using the POST method, which can indeed have a body. This error message might not be the actual error that would occur with the provided code changes. Instead, the real issues with the code are:

    1. The `requestId` parameter type was changed from `string` to `number`, which could cause a problem if the API expects a string. This might not immediately cause a runtime error but could lead to an API error response.

    2. The `supportsAllDrives` property was added to the body of the request. If the Google Drive API does not expect this property, it could ignore it or, worse, return an error response due to an unexpected parameter.

    3. The return statement was changed from `response.text()` to `response.json()`. If the response from the API is not in JSON format, this could cause a runtime error when trying to parse it as JSON.

    The error message provided does not correspond to the actual changes made in the code, and the real issues would likely result in API errors rather than the TypeError mentioned.
  id: |-
    hubfix_hub_60
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      requestId: string,
      drive_name: string,
    ) {
      const supportsAllDrives = true;
      const CREATE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/?requestId=${requestId}`;

      const token = gdrive_auth["token"];
      const body = {
        name: drive_name,
      };
      const response = await fetch(CREATE_SHARED_DRIVE_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Create Shared Drive in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import {
      MongoClient,
      ObjectId,
    } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      document_id: string,
      projection?: Record<string, number>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const db = client.database(database);
      return await db
        .collection(collection)
        .findOne(
          { _id: new ObjectId(document_id) },
          removeObjectEmptyFields({ project: projection }),
        );
    }
  error: |-
    TypeError: Data must be a string or a buffer
  explanation: |-
    The error occurs because the `ObjectId` constructor from the `atlas_sdk` expects a string that represents a valid hexadecimal MongoDB ObjectId. If the `document_id` passed to the `ObjectId` constructor is not a valid hexadecimal string, it will throw a `TypeError`. In the broken code, there is no validation to ensure that `document_id` is a valid hexadecimal string, so if an invalid string is passed, it will cause the script to break with the given error message.
  id: |-
    hubfix_hub_255
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import {
      MongoClient,
      ObjectId,
    } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      document_id: string,
      projection?: Record<string, number>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const db = client.database(database);
      return await db
        .collection(collection)
        .findOne(
          { _id: new ObjectId(document_id) },
          removeObjectEmptyFields({ projection }),
        );
    }
  original_instructions: |-
    Find Document by Id in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    import type { Base64 } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { decode } from "https://deno.land/std@0.152.0/encoding/base64.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      image: Base64,
      channel: string,
      slack: Slack,
      imagename: string = "image.png",
    ) {
      const formData = new FormData();
      formData.append("token", slack.token);
      formData.append("file", new File([decode(image)], imagename));
      formData.append("channels", channel);
      formData.append("filename", "image.png");
      formData.append("filetype", imagename);

      return await (
        await fetch("https://slack.com/api/files.upload", {
          method: "POST",
          body: formData,
        })
      ).json();
    }

    main("not_base64", "#general", { token: "xoxb-..." }, "image.jpg");
  error: |-
    TypeError: The first argument must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object. Received type boolean (false)
  explanation: |-
    The error occurs because the `decode` function from the `base64` module expects a string argument that represents base64-encoded data. However, in the `main` function call at the bottom, the first argument `"not_base64"` is not a valid Base64 string, and thus when it is passed to the `decode` function, it causes a type error. To fix this, the first argument should be a valid Base64-encoded string.
  id: |-
    hubfix_hub_110
  lang: |-
    deno
  original_code: |
    import type { Base64 } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { decode } from "https://deno.land/std@0.152.0/encoding/base64.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      image: Base64,
      channel: string,
      slack: Slack,
      imagename: string = "image.png",
    ) {
      const formData = new FormData();
      formData.append("token", slack.token);
      formData.append("file", new File([decode(image)], imagename));
      formData.append("channels", channel);
      formData.append("filename", "image.png");
      formData.append("filetype", imagename);

      return await (
        await fetch("https://slack.com/api/files.upload", {
          method: "POST",
          body: formData,
        })
      ).json();
    }
  original_instructions: |-
    Send an image to channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventText: number,
    ) {
      const sendUpdates = "all";

      const QUICK_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/quickAdd/?text=${eventText}&sendUpdates=${sendUpdates}`;

      const token = gcal_auth["token"];

      const response = await fetch(QUICK_EVENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  error: |-
    TypeError: eventText must be a string, but was number
  explanation: |-
    The `eventText` parameter in the function signature has been changed from `string` to `number`, which is incorrect because the `eventText` is being interpolated into a URL string. URLs must be composed of strings, so passing a number to this parameter will cause a type error when attempting to construct the `QUICK_EVENT_URL`. The TypeScript compiler will throw an error because the `eventText` is expected to be a string when used in a template literal for a URL.
  id: |-
    hubfix_hub_46
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventText: string,
    ) {
      const sendUpdates = "all";

      const QUICK_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/quickAdd/?text=${eventText}&sendUpdates=${sendUpdates}`;

      const token = gcal_auth["token"];

      const response = await fetch(QUICK_EVENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Create Quick Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      file: string,
      count?: number,
      page?: number,
    ) {
      const web = new WebClient(slack_auth);

      let response = await web.fileInfo({
        files: file,
        counts: count,
        pages: page,
      });

      return { responses: response };
    }
  error: |-
    TypeError: web.fileInfo is not a function
  explanation: |-
    The code is broken because of the following reasons:
    - The method `fileInfo` does not exist on the `WebClient` object. The correct method name is `files.info`.
    - The properties `files`, `counts`, and `pages` are incorrect. The correct property names are `file`, `count`, and `page`.
    - The return object uses `responses` instead of `response`. While this wouldn't cause a runtime error, it would not match the expected structure of the return value.
  id: |-
    hubfix_hub_16
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    /*
    @param: {string} file - file ID
    @param: {number} count - Number of items to return per page
    @param: {numb} page - number of pages to return
    */

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      file: string,
      count?: number,
      page?: number,
    ) {
      const web = new WebClient(slack_auth);

      let response = await web.files.info({
        file: file,
        count: count,
        page: page,
      });

      return { response: response };
    }
  original_instructions: |-
    Get File in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, cancel_id: number) {
      const STRIPE_CANCEL_PAYOUT_URL = `https://api.stripe.com/v1/payouts/:${cancel_id}/cancel`;

      const token = stripe_con["apikey"];

      const response = await fetch(STRIPE_CANCEL_PAYOUT_URL, {
        method: "GET", // This should be POST
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'apikey')
  explanation: |-
    The code is trying to access a property `apikey` on the `stripe_con` object, which does not exist. The correct property name is `token`. Additionally, the `cancel_id` parameter type was changed from `string` to `number`, which could cause issues if the API expects a string. The HTTP method was also changed from "POST" to "GET", which might not be supported by the API endpoint for cancelling payouts. Lastly, the function is returning `response.text()` instead of `response.json()`, which might not be the expected return type if the API responds with JSON data.
  id: |-
    hubfix_hub_117
  lang: |-
    deno
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, cancel_id: string) {
      const STRIPE_CANCEL_PAYOUT_URL = `https://api.stripe.com/v1/payouts/:${cancel_id}/cancel`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_CANCEL_PAYOUT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Cancel a Payment Intent in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      campaign_id: string,
      fields?: string[],
      exclude_fields?: string[],
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/reports/${campaign_id}`,
      );
      const params = {
        fields,
        exclude_fields,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value?.length) {
          url.searchParams.append(key, value.join(","));
        }
      }

      const response = await fetch(url, {
        method: "POST", // Changed from "GET" to "POST"
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Request with GET/HEAD method cannot have body.
  explanation: |-
    The error occurs because the `fetch` function is called with the "POST" method, but the original code and the Mailchimp API endpoint are designed to be used with the "GET" method. The "POST" method is typically used when you want to send a request body to the server, which is not the case here. The Mailchimp reports endpoint expects a "GET" request to retrieve data, not a "POST" request to submit data. Changing the method to "POST" without providing a request body or changing the endpoint to one that accepts "POST" requests will cause the fetch to fail.
  id: |-
    hubfix_hub_206
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      campaign_id: string,
      fields?: string[],
      exclude_fields?: string[],
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/reports/${campaign_id}`,
      );
      const params = {
        fields,
        exclude_fields,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value?.length) {
          url.searchParams.append(key, value.join(","));
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Get A Campaign Report in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite/mod.ts"; // Removed the version number

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_data: Record<string | number, any>,
      document_id?: string,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(
        database_id,
        collection_id,
        document_id || ID.unique(),
        document_data,
        document_permissions,
      );
    }

    main({
      endpoint: "https://example.com",
      project: "project_id",
      key: "secret_key",
      self_signed: false,
    }, "database_id", "collection_id", { name: "John Doe" });
  error: |-
    error: Uncaught (in promise) TypeError: Failed to fetch dynamically imported module: https://deno.land/x/appwrite/mod.ts
  explanation: |-
    The code is trying to import the `appwrite` module without specifying a version number. In Deno, it is important to include the version number in the import URL to ensure that the correct version of the module is fetched. Without the version number, Deno does not know which version of the module to download, leading to a failure in fetching the module. This is a common mistake when working with Deno, as it enforces the use of versioned URLs for module imports.
  id: |-
    hubfix_hub_334
  lang: |-
    deno
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param document_id ID of the document to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_data: Record<string | number, any>,
      document_id?: string,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(
        database_id,
        collection_id,
        document_id || ID.unique(),
        document_data,
        document_permissions,
      );
    }
  original_instructions: |-
    Create Document in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: string) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoices = await stripe.invoices.retrieve({
        id: limit,
      });

      return await invoices.text();
    }
  error: |-
    TypeError: stripe.invoices.retrieve is not a function
  explanation: |-
    The code is attempting to call a method `retrieve` on `stripe.invoices` which does not exist in the Stripe API. The correct method for listing invoices is `list`, not `retrieve`. Additionally, the `retrieve` method would expect an invoice ID as a string, not an object with an `id` property. The `limit` parameter is also incorrectly typed as a `string` when it should be a `number`. Lastly, the method `text()` is being called on the `invoices` object, which is incorrect because the `list` method (if it were used correctly) would return a promise that resolves to an object, not a response object with a `text()` method.
  id: |-
    hubfix_hub_130
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoices = await stripe.invoices.list({
        limit: limit,
      });

      return await invoices.json();
    }
  original_instructions: |-
    List Invoices in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      title: string,
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            addSheet: {
              properties: {
                title: title,
                gridProperties: {
                  rowCount: 20,
                  columnCount: 12,
                },
                tabColor: {
                  red: 1.0,
                  green: 0.3,
                  blue: 0.4,
                },
              },
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }

    main({ token: 'your_token_here' }, 'spreadsheetId', 'New Sheet Title');
  error: |-
    TypeError: Argument of type '{ token: string; }' is not assignable to parameter of type 'Gsheets'.
      Object literal may only specify known properties, and 'token' does not exist in type 'Gsheets'.
  explanation: |-
    The error occurs because the `main` function is being called with an object that has a property `token`, which is expected to match the `Gsheets` type. However, the error message indicates that the `token` property does not exist in type `Gsheets`, which is contradictory because the `Gsheets` type is clearly defined with a `token` property.

    This error message is misleading and would not actually occur given the provided code. The code is valid TypeScript and should not produce a type error regarding the `token` property on the `Gsheets` type.

    If the intention was to introduce a breaking change, it could be done by changing the `Gsheets` type to not include the `token` property, or by calling the `main` function with an object that has a property not defined in `Gsheets`. However, the provided error message does not match the code, and the code as given should not produce an error.
  id: |-
    hubfix_hub_65
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      title: string,
    ) {
      const token = gsheets_auth["token"];

      const ADD_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            addSheet: {
              properties: {
                title: title,
                gridProperties: {
                  rowCount: 20,
                  columnCount: 12,
                },
                tabColor: {
                  red: 1.0,
                  green: 0.3,
                  blue: 0.4,
                },
              },
            },
          },
        ],
      };

      const response = await fetch(ADD_WORKSHEET_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Create Worksheet in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      type: string,
      state_key?: string,
      json_content: string,
    ) {
      let url = `${matrix_res.baseUrll}/_matrix/client/v3/rooms/${encodeURIComponent(
        room_id,
      )}/state/${encodeURIComponent(type)}/`;
      if (state_key) {
        url += encodeURIComponent(state_key);
      }
      const resp = await fetch(url, {
        method: "PUTT",
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
          "Content-Type": "application/json",
        },
        body: json_content,
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Invalid name
  explanation: |-
    The code is broken because of two errors:

    1. The property `baseUrll` does not exist on the `Matrix` type. The correct property name is `baseUrl`. The extra 'l' at the end of `baseUrll` is a typo and will result in a runtime error because `matrix_res.baseUrll` is undefined.

    2. The method "PUTT" is not a valid HTTP method. The correct method should be "PUT". Using "PUTT" will cause the `fetch` function to throw a TypeError because it is not a recognized HTTP method.
  id: |-
    hubfix_hub_190
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      type: string,
      state_key?: string,
      json_content: string,
    ) {
      let url = `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
        room_id,
      )}/state/${encodeURIComponent(type)}/`;
      if (state_key) {
        url += encodeURIComponent(state_key);
      }
      const resp = await fetch(url, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
          "Content-Type": "application/json",
        },
        body: json_content,
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  original_instructions: |-
    Set room state in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    type AppwriteConfig = {
      endpoint: string;
      project: string;
      api_key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: AppwriteConfig,
      database_id: string,
      collection_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.api_key);
      const db = new Databases(client);

      return await db.removeCollection(database_id, collection_id);
    }
  error: |-
    TypeError: db.removeCollection is not a function
  explanation: |-
    The code is broken because of the following reasons:

    1. The import statement has been changed to import from "https://deno.land/x/appwrite/mod.ts" instead of "https://deno.land/x/appwrite@7.0.0/mod.ts". This could potentially import a different version of the library or fail if the specific path does not exist.

    2. The type `Appwrite` has been renamed to `AppwriteConfig`, which is not necessarily a breaking change by itself, but it could lead to issues if other parts of the codebase are expecting the original `Appwrite` type.

    3. The property `key` in the `AppwriteConfig` type has been renamed to `api_key`. This will cause a runtime error because the `setKey` method expects a property named `key` in the `auth` object, but it has been renamed to `api_key`.

    4. The method `db.deleteCollection` has been changed to `db.removeCollection`, which does not exist on the `Databases` class. This will result in a runtime error because the script is trying to call a method that is not defined.
  id: |-
    hubfix_hub_333
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.deleteCollection(database_id, collection_id);
    }
  original_instructions: |-
    Delete Collection in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    type Hubspot = {
      apiKey: string;
    };
    export async function main(
      auth: Hubspot,
      objectType: string,
      propertyName: string,
    ) {
      const res = await fetch(
        `https://api.hubapi.com/crm/v3/properties/${objectType}/${propertyName}?archived=false`,
        {
          headers: {
            Authorization: `Bearer ${auth.token}`,
            Accept: "application/json",
          },
          method: "GET",
        },
      );
      const jsonRes = await res.json();
      if (jsonRes.status == "error") {
        console.error(jsonRes);
        throw new Error(jsonRes.message);
      }
      return jsonRes;
    }
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The code is trying to access a property `token` on the `auth` object, but the `Hubspot` type has been changed to have an `apiKey` property instead of `token`. Since `auth.token` does not exist on the `Hubspot` type, trying to access it will result in a `TypeError` when the code is executed.
  id: |-
    hubfix_hub_361
  lang: |-
    deno
  original_code: |
    // Ctrl+. to cache dependencies on imports hover, Ctrl+S to format.

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      objectType: string,
      propertyName: string,
    ) {
      const res = await fetch(
        `https://api.hubapi.com/crm/v3/properties/${objectType}/${propertyName}?archived=false`,
        {
          headers: {
            Authorization: `Bearer ${auth.token}`,
            Accept: "application/json",
          },
          method: "GET",
        },
      );
      const jsonRes = await res.json();
      if (jsonRes.status == "error") {
        console.error(jsonRes);
        throw new Error(jsonRes.message);
      }
      return jsonRes;
    }
  original_instructions: |-
    Get a properties configuration from hubspot crm in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    export async function main(url: number) {
      const response = await fetch(url);

      return {
        ok: response.success,
        status: response.statusCode,
        text: await response.getText(),
      };
    }
  error: |-
    TypeError: Argument 1 of Window.fetch is not an object.
  explanation: |-
    There are multiple issues with the modified code:

    1. The `url` parameter type has been changed from `string` to `number`, which is incorrect because the `fetch` function expects a string URL as its first argument.
    2. The property `success` does not exist on the `Response` object returned by `fetch`. The correct property is `ok`.
    3. Similarly, `statusCode` is not a property of the `Response` object; the correct property is `status`.
    4. The method `getText()` does not exist on the `Response` object. The correct method to retrieve the response body as text is `text()`.
  id: |-
    hubfix_hub_98
  lang: |-
    deno
  original_code: |
    export async function main(url: string) {
      const resp = await fetch(url);

      return {
        ok: resp.ok,
        status: resp.status,
        text: await resp.text(),
      };
    }
  original_instructions: |-
    Send GET Request in http
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arg: number) {
      return { arg: arg.toString() };
    }
  error: |-
    TS2322: Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function `main` was initially expecting a parameter of type `string`, but it has been changed to expect a parameter of type `number`. However, the function is still being used as if it expects a string, which would cause a type error when trying to pass a number where a string is expected. The error message indicates that a value of type 'number' is being assigned to a variable or parameter that is expected to be of type 'string'.
  id: |-
    hubfix_hub_25
  lang: |-
    deno
  original_code: |
    //

    export async function main(arg: string) {
      return { arg };
    }
  original_instructions: |-
    Echo argument in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      startCell: string,
      values: Array<Array<any>>,
      majorDimension: "ROWS" | "COLUMNS" = "ROWS",
      valueInputOption: "RAW" | "USER_ENTERED" = "USER_ENTERED",
      responseValueRenderOption:
        | "FORMATTED_VALUE"
        | "UNFORMATTED_VALUE"
        | "FORMULA" = "FORMATTED_VALUE",
      responseDateTimeRenderOption:
        | "SERIAL_NUMBER"
        | "FORMATTED_STRING" = "SERIAL_NUMBER",
    ) {
      const token = gsheets_auth["token"];
      let UPDATE_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${startCell}?includeValuesInResponse=true`;
      UPDATE_VALUES_URL += `&valueInputOption=${valueInputOption}`;
      UPDATE_VALUES_URL += `&responseValueRenderOption=${responseValueRenderOption}`;
      UPDATE_VALUES_URL += `&responseDateTimeRenderOption=${responseDateTimeRenderOption}`;
      const body = {
        values,
        majorDimension,
      };

      const response = await fetch(UPDATE_VALUES_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const json = await response.json();
      if (json.error) {
        let { code, status, message } = json.error;
        throw Error(`\n${code} ${status} - "${message}"\n`);
      }
      return json;
    }

    main({}, 'spreadsheetId', 'A1', [[1, 2], [3, 4]]);
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The `main` function is called with an empty object `{}` as the first argument, which is supposed to be of type `Gsheets`. Since the `Gsheets` type requires a `token` property, passing an empty object will result in `undefined` when trying to access `gsheets_auth["token"]`. This will cause a TypeError when the script attempts to construct the `Authorization` header because it expects a string value for the token, not `undefined`.
  id: |-
    hubfix_hub_187
  lang: |-
    deno
  original_code: |
    /** Update values(s) in the given range.
     *
     * @param startCell Use 'A1' notation.
     * https://developers.google.com/sheets/api/guides/concepts#cell
     *
     * @param responseValueRenderOption Determines how values in the response should be rendered.
     * https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption
     *
     * @param responseDateTimeRenderOption Determines how dates, times, and durations in the response should be rendered.
     * This is ignored if `responseValueRenderOption` is `FORMATTED_VALUE`.
     * https://developers.google.com/sheets/api/reference/rest/v4/DateTimeRenderOption
     */
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      startCell: string,
      values: Array<Array<any>>,
      majorDimension: "ROWS" | "COLUMNS" = "ROWS",
      valueInputOption: "RAW" | "USER_ENTERED" = "USER_ENTERED",
      responseValueRenderOption:
        | "FORMATTED_VALUE"
        | "UNFORMATTED_VALUE"
        | "FORMULA" = "FORMATTED_VALUE",
      responseDateTimeRenderOption:
        | "SERIAL_NUMBER"
        | "FORMATTED_STRING" = "SERIAL_NUMBER",
    ) {
      const token = gsheets_auth["token"];
      let UPDATE_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${startCell}?includeValuesInResponse=true`;
      UPDATE_VALUES_URL += `&valueInputOption=${valueInputOption}`;
      UPDATE_VALUES_URL += `&responseValueRenderOption=${responseValueRenderOption}`;
      UPDATE_VALUES_URL += `&responseDateTimeRenderOption=${responseDateTimeRenderOption}`;
      const body = {
        values,
        majorDimension,
      };

      const response = await fetch(UPDATE_VALUES_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const json = await response.json();
      if (json.error) {
        let { code, status, message } = json.error;
        throw Error(`\n${code} ${status} - "${message}"\n`);
      }
      return json;
    }
  original_instructions: |-
    Update Values in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      columns?: string,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      head?: boolean,
      filter?: {
        column: string;
        operator: string;
        value: any;
      },
      order?: {
        column: string;
        foreignTable: string;
        ascending?: boolean;
        nullsFirst?: boolean;
      },
      limit?: {
        count: number;
        foreignTable?: string;
      },
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        const options = head || count ? { head, count } : undefined;
        let query = client.from(table).select(columns || undefined, options);
        if (filter?.column) {
          query = query.filter(filter.column, filter.operator, filter.value);
        }
        if (order?.column) {
          const { column, ...options } = order;
          query = query.order(column, options);
        }
        if (limit?.count) {
          const { count, foreignTable } = limit;
          query = query.limit(count, foreignTable ? { foreignTable } : undefined);
        }

        return query.execute();
      });
    }
  error: |-
    TypeError: query.execute is not a function
  explanation: |-
    The error occurs because the method `execute()` does not exist on the `query` object. The original code did not attempt to call `execute()` on the `query` object, as it was likely meant to return the query builder object itself or a promise that resolves with the result of the query. By adding the non-existent `execute()` method call, the code now attempts to invoke a method that is not defined on the `query` object, resulting in a `TypeError`.
  id: |-
    hubfix_hub_311
  lang: |-
    deno
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     *
     * @param head When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param filter Learn more at https://supabase.com/docs/reference/javascript/filter
     *
     * @param order Learn more at https://supabase.com/docs/reference/javascript/order
     *
     * @param limit Learn more at https://supabase.com/docs/reference/javascript/limit
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      columns?: string,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
      head?: boolean,
      filter?: {
        column: string;
        operator: string;
        value: any;
      },
      order?: {
        column: string;
        foreignTable: string;
        ascending?: boolean;
        nullsFirst?: boolean;
      },
      limit?: {
        count: number;
        foreignTable?: string;
      },
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        const options = head || count ? { head, count } : undefined;
        let query = client.from(table).select(columns || undefined, options);
        if (filter?.column) {
          query = query.filter(filter.column, filter.operator, filter.value);
        }
        if (order?.column) {
          const { column, ...options } = order;
          query = query.order(column, options);
        }
        if (limit?.count) {
          const { count, foreignTable } = limit;
          query = query.limit(count, foreignTable ? { foreignTable } : undefined);
        }

        return query;
      });
    }
  original_instructions: |-
    Fetch data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- broken_code: |-
    type Gdocs = {
      token: string;
    };
    export async function main(
      gdocs_auth: Gdocs,
      documentId: string,
      text: string,
    ) {
      const token = gdocs_auth["token"];

      const APPEND_TEXT_URL = `https://docs.googleapis.com/v1/documents/${documentId}:batchUpdate`;

      const body = {
        requests: [
          {
            insertText: { content: text }, // Changed 'text' to 'content'
          },
        ],
      };
      const response = await fetch(APPEND_TEXT_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Request with GET/HEAD method cannot have body.
  explanation: |-
    The error message provided is incorrect for the change made. The actual error would not be a runtime error but rather a logical error. The Google Docs API expects the property name to be 'text' for inserting text, but the code has been changed to use 'content' instead. This would result in a bad request error from the Google Docs API because the request body does not match the expected schema. The API would likely return an error message indicating that the request is malformed or that the 'insertText' field is missing or incorrect.
  id: |-
    hubfix_hub_56
  lang: |-
    deno
  original_code: |
    type Gdocs = {
      token: string;
    };
    export async function main(
      gdocs_auth: Gdocs,
      documentId: string,
      text: string,
    ) {
      const token = gdocs_auth["token"];

      const APPEND_TEXT_URL = `https://docs.googleapis.com/v1/documents/${documentId}:batchUpdate`;

      const body = {
        requests: [
          {
            insertText: { text },
          },
        ],
      };
      const response = await fetch(APPEND_TEXT_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Append Text in gdocs
  resource_type: |-
    Gdocs
  resource_type_def: |-
    type Gdocs = {
      token: string;
    }
- broken_code: |-
    import { encode } from "https://deno.land/std@0.82.0/encoding/base64.ts";

    type Gdrive = {
      accessToken: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const DOWNLOAD_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;

      const token = gdrive_auth["token"];

      const response = await fetch(DOWNLOAD_FILE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          Accept: "application/json",
        },
      });

      if (response) {
        const arrayBuffer = await response.arrayBuffer();
        return encode(arrayBuffer);
      }
    }
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The code is trying to access the property `token` on the `gdrive_auth` object, but the type `Gdrive` has been changed to have a property `accessToken` instead of `token`. This means that when the code tries to access `gdrive_auth["token"]`, it will return `undefined` because there is no `token` property on the `gdrive_auth` object. The correct property name should be used to match the type definition, which is `gdrive_auth["accessToken"]`.
  id: |-
    hubfix_hub_90
  lang: |-
    deno
  original_code: |
    import { encode } from "https://deno.land/std@0.82.0/encoding/base64.ts";

    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive, fileId: string) {
      const DOWNLOAD_FILE_URL = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;

      const token = gdrive_auth["token"];

      const response = await fetch(DOWNLOAD_FILE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          Accept: "application/json",
        },
      });

      if (response) {
        const arrayBuffer = await response.arrayBuffer();
        return encode(arrayBuffer);
      }
    }
  original_instructions: |-
    Download a file in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
      queries?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.getDoc(database_id, collection_id, document_id, queries);
    }
  error: |-
    error: TS2305 [ERROR]: Module '"https://deno.land/x/appwrite/mod.ts"' has no exported member 'Databases'.
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";
  explanation: |-
    The code is broken because of two reasons:

    1. The import statement is incorrect. The version tag `@7.0.0` is missing from the URL, which could lead to importing a non-existent or wrong version of the module that might not have the `Databases` class.

    2. The method `getDoc` does not exist on the `Databases` class. The correct method name should be `getDocument` as per the original code.
  id: |-
    hubfix_hub_336
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
      queries?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.getDocument(database_id, collection_id, document_id, queries);
    }
  original_instructions: |-
    Get Document in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: AirtableConfig,
      atTable: AirtableTable,
      newRecord: object,
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      const createOne = await airtable.create(newRecord);

      return createOne.id;
    }
  error: |-
    TypeError: Cannot read property 'id' of undefined
  explanation: |-
    The code is attempting to access the `id` property of the result of `airtable.create(newRecord)`. If the `create` method does not return an object with an `id` property, or if it returns `undefined` (for example, due to an error or incorrect usage of the API), trying to access `createOne.id` will result in a `TypeError` because you cannot read the property 'id' of `undefined`.
  id: |-
    hubfix_hub_1024
  lang: |-
    deno
  original_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      newRecord: object,
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      const createOne = await airtable.create(newRecord);

      return createOne;
    }
  original_instructions: |-
    Create single record in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- broken_code: |-
    export async function main(url: number, body: object = {}) {
      const response = await fetch(url, {
        method: "PUTT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });

      return {
        ok: response.ok,
        status: response.status,
        text: await response.txt(),
      };
    }
  error: |-
    TypeError: Only absolute URLs are supported
  explanation: |-
    There are multiple issues with the modified code:

    1. The `url` parameter type has been changed from `string` to `number`, which is incorrect because the `fetch` function expects a URL as a string, not a number.

    2. The HTTP method has been misspelled as "PUTT" instead of "PUT". This would likely result in a `TypeError` because "PUTT" is not a valid HTTP method.

    3. The method `response.txt()` does not exist on the `Response` object. It should be `response.text()` to correctly retrieve the response body as text.
  id: |-
    hubfix_hub_99
  lang: |-
    deno
  original_code: |
    export async function main(url: string, body: object = {}) {
      const resp = await fetch(url, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });

      return {
        ok: resp.ok,
        status: resp.status,
        text: await resp.text(),
      };
    }
  original_instructions: |-
    Send PUT Request in http
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type SlackAuth = {
      token: string;
    };
    export async function main(slack_auth: SlackAuth, channel: string, user: string) {
      const web = new WebClient(slack_auth.token);

      await web.conversations.eject({
        channel: channel,
        user: user,
      });

      return "Successfully Kicked user";
    }
  error: |-
    TypeError: web.conversations.eject is not a function
  explanation: |-
    The code is attempting to call a method `eject` on `web.conversations` which does not exist in the Slack Web API client. The correct method to use for removing a user from a channel is `kick`, not `eject`. Additionally, the `WebClient` constructor expects an object with a `token` property, but the broken code is passing just the `token` string instead of the whole `slack_auth` object.
  id: |-
    hubfix_hub_14
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(slack_auth: Slack, channel: string, user: string) {
      const web = new WebClient(slack_auth);

      await web.conversations.kick({
        channel: channel,
        user: user,
      });

      return { message: "Successfully Kicked user" };
    }
  original_instructions: |-
    Kick User in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    // Set indented to true for pretty JSON.
    export async function main(value: object, indented = false) {
      return JSON.serialise(value, null, indented ? 2 : null);
    }
  error: |-
    TypeError: JSON.serialise is not a function
  explanation: |-
    The code is attempting to call `JSON.serialise`, which is a non-existent method on the JSON object. The correct method name is `JSON.stringify`. This is a common mistake where a developer might confuse method names or make a typo.
  id: |-
    hubfix_hub_102
  lang: |-
    deno
  original_code: |
    // Set indented to true for pretty JSON.
    export async function main(value: object, indented = false) {
      return JSON.stringify(value, null, indented ? 2 : null);
    }
  original_instructions: |-
    Convert JavaScript Object to JSON String in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      channel: number,
      timestamp: string,
    ) {
      const web = new WebClient(slack_auth);

      let response = await web.chat.delete({
        channel: channel,
        ts: timestamp,
      });

      return { response: response };
    }
  error: |-
    TS2345: Argument of type '{ channel: number; ts: string; }' is not assignable to parameter of type 'ChatDeleteArguments'.
      Types of property 'channel' are incompatible.
        Type 'number' is not assignable to type 'string'.
  explanation: |-
    The code is broken because the `channel` parameter in the `main` function is incorrectly typed as a `number` when it should be a `string`. The Slack API expects the channel ID to be a string, not a number. This type mismatch causes a TypeScript compilation error.
  id: |-
    hubfix_hub_18
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    /*
    @param: {string} channel - Channel containing the message to be deleted.
    @param: {string} timestamp - Timestamp of the message to be deleted.
    */

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      channel: string,
      timestamp: string,
    ) {
      const web = new WebClient(slack_auth);

      let response = await web.chat.delete({
        channel: channel,
        timestamp: timestamp,
      });

      return { response: response };
    }
  original_instructions: |-
    Delete Message in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    export async function main(value: object | string, indentation = 2) {
      if (typeof value === "string") {
        value = JSON.parse(value);
      }
      return JSON.stringify(value, null, indent);
    }
  error: |-
    ReferenceError: indent is not defined
  explanation: |-
    The variable `indent` is not defined within the scope of the function. The original code uses `indentation` as the parameter name and as the argument in the `JSON.stringify` function, but the broken code attempts to use `indent`, which has not been declared or defined anywhere in the function, leading to a `ReferenceError`.
  id: |-
    hubfix_hub_103
  lang: |-
    deno
  original_code: |
    export async function main(value: object | string, indentation = 2) {
      if (typeof value === "string") {
        value = JSON.parse(value);
      }
      return JSON.stringify(value, null, indentation);
    }
  original_instructions: |-
    Pretty Print JSON in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(atCon: AirtableConfig, atTable: AirtableTable) {
      const airtable = new Airtable({ ...atCon, ...atTable });
      const result_list = await airtable.query();

      return { result: result_list };
    }
  error: |-
    TypeError: airtable.query is not a function
  explanation: |-
    The code is attempting to call a method `query` on the `airtable` object, which does not exist in the Airtable API provided by the library. The correct method to retrieve records is `select`, not `query`. This is a common mistake when a developer confuses the method names of an API or assumes that a method exists based on their experience with other APIs or libraries.
  id: |-
    hubfix_hub_8
  lang: |-
    deno
  original_code: |
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(atCon: Airtable, atTable: AirtableTable) {
      const airtable = new Airtable({ ...atCon, ...atTable });
      const result_list = await airtable.select();

      return { results: result_list };
    }
  original_instructions: |-
    List Records in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: number, // Changed the type from string to number
      useDomainAdminAccess: boolean = false,
    ) {
      const GET_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const response = await fetch(GET_SHARED_DRIVE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json(); // Changed from text() to json()
    }
  error: |-
    TypeError: driveId must be a string, but was given a number.
  explanation: |-
    The error is caused by changing the type of the `driveId` parameter from `string` to `number`. The `driveId` is expected to be a string because it is part of a URL, and URLs are composed of strings. By changing the type to `number`, the code will break if a number is passed to the function, as it will not correctly concatenate with the URL string.

    Additionally, the function now returns a promise that resolves with the response body parsed as JSON instead of text. If the API does not return a JSON response, this could also cause an error or unexpected behavior.
  id: |-
    hubfix_hub_64
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: string,
      useDomainAdminAccess: boolean = false,
    ) {
      const GET_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const response = await fetch(GET_SHARED_DRIVE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Get Shared Drive in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      name: string,
      static_segment?: string[],
      options?: {
        match: string;
        conditions: any[];
      },
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments`,
      );
      const body = {
        name,
        static_segment,
        options,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.jason();
    }
  error: |-
    TypeError: response.jason is not a function
  explanation: |-
    The error is caused by a typo in the method name when trying to parse the JSON response. The correct method name is `json`, not `jason`. This typo leads to an attempt to call a method that does not exist on the `response` object, resulting in a `TypeError`.
  id: |-
    hubfix_hub_210
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * @param static_segment *(optional but either `static_segment` or `options` is required)*
     * An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * Passing an empty array will create a static segment without any subscribers.
     * This field cannot be provided with the options field.
     *
     * @param options *(optional but either `static_segment` or `options` is required)*
     * The conditions of the segment. Static and fuzzy segments don't have conditions.
     * Find more information about conditions at
     * https://mailchimp.com/developer/marketing/docs/alternative-schemas/#segment-condition-schemas
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      name: string,
      static_segment?: string[],
      options?: {
        match: string;
        conditions: any[];
      },
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments`,
      );
      const body = {
        name,
        static_segment,
        options,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Create a Segment in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type TelegramAuth = {
      token: string;
    };
    export async function main(
      auth: TelegramAuth,
      chat_id: string | number,
      message_id: number,
      text: string,
      inline_message_id?: string,
    ) {
      const client = new Telegram(auth.apiKey);
      return await client.updateMessageText(
        chat_id,
        message_id,
        inline_message_id,
        text,
      );
    }
  error: |-
    TypeError: client.updateMessageText is not a function
  explanation: |-
    The code is broken because of two reasons:

    1. The property `apiKey` is being accessed on the `auth` object, but the `TelegramAuth` type defines a property named `token`, not `apiKey`. This would result in `undefined` being passed to the `Telegram` constructor, which would likely cause an authentication error when trying to use the `client`.

    2. The method `updateMessageText` is being called on the `client` object. However, this method does not exist in the Telegraf library. The correct method name should be `editMessageText`, as it was in the original code. Calling a non-existent method will result in a TypeError, indicating that the function does not exist.
  id: |-
    hubfix_hub_235
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string | number,
      message_id: number,
      text: string,
      inline_message_id?: string,
    ) {
      const client = new Telegram(auth.token);
      return await client.editMessageText(
        chat_id,
        message_id,
        inline_message_id,
        text,
      );
    }
  original_instructions: |-
    Edit a Text Message in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(auth: Mailchimp, campaign_id: number) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}/actions/cancel-sent`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.text();
    }
  error: |-
    TypeError: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The code is broken because the `campaign_id` parameter type was changed from `string` to `number`. The Mailchimp API expects the campaign ID to be a string, not a number. Additionally, the endpoint has been changed from `cancel-send` to `cancel-sent`, which is likely incorrect and would result in a 404 error if the endpoint does not exist. Lastly, the function is now returning `response.text()` instead of `response.json()`, which may not be a breaking change but could be incorrect depending on the expected return type.
  id: |-
    hubfix_hub_204
  lang: |-
    deno
  original_code: |
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(auth: Mailchimp, campaign_id: string) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}/actions/cancel-send`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Cancel a Campaign in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, customer_id: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const deleted = await stripe.customers.deleteCustomer(`${customer_id}`);

      return await deleted.json();
    }
  error: |-
    TypeError: stripe.customers.deleteCustomer is not a function
  explanation: |-
    The code is attempting to call a method `deleteCustomer` on `stripe.customers`, which does not exist in the Stripe API. The correct method name is `del` as used in the original code. Additionally, the `customer_id` parameter type was changed from `string` to `number`, which is incorrect because Stripe customer IDs are strings, not numbers.
  id: |-
    hubfix_hub_128
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, customer_id: string) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const deleted = await stripe.customers.del(`${customer_id}`);

      return await deleted.json();
    }
  original_instructions: |-
    Delete a Customer in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.removeOne(filter);
    }
  error: |-
    TypeError: documents.removeOne is not a function
  explanation: |-
    The error is caused by calling a non-existent method `removeOne` on the `documents` object. The correct method to delete a single document from a MongoDB collection is `deleteOne`, not `removeOne`. By changing `deleteOne` to `removeOne`, we are attempting to call a method that does not exist on the `documents` object, which results in a `TypeError`.
  id: |-
    hubfix_hub_257
  lang: |-
    deno
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     *
     * @param filter For example: `{ "_id": "01234" }`
     * Find out more at:
     * https://www.mongodb.com/docs/manual/reference/method/db.collection.deleteOne/
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.deleteOne(filter);
    }
  original_instructions: |-
    Delete a Document in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    export async function main(
      response_url: number,
      text: string,
    ) {
      const x = await fetch(response_url, {
        method: 'POST',
        body: JSON.stringify({ text: `ROGER ${text}` }),
      });
      const username = await Deno.env.fetch('WM_USERNAME')
      console.log(`user = ${username}`)
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'RequestInfo'.
    error TS2339: Property 'fetch' does not exist on type 'typeof Deno.env'.
  explanation: |-
    The code is broken for two reasons:

    1. The `response_url` parameter is changed from `string` to `number`, which is not a valid type for the URL parameter expected by the `fetch` function. The `fetch` function expects its first argument to be a `RequestInfo` type, which can be a string representing the URL or a `Request` object.

    2. The `Deno.env.fetch` method does not exist. The correct method to get an environment variable in Deno is `Deno.env.get`.
  id: |-
    hubfix_hub_416
  lang: |-
    deno
  original_code: |-
    export async function main(
      response_url: string,
      text: string,
    ) {
      const x = await fetch(response_url, {
        method: 'POST',
        body: JSON.stringify({ text: `ROGER ${text}` }),
      });
      const username = await Deno.env.get('WM_USERNAME')
      console.log(`user = ${username}`)
  original_instructions: |-
    Example of responding to a slack command in slack
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(channel: string, slack: Slack, approvers: string[]) {
      const web = new WebClient(slack.token);
      const jobUrl = new URL(
        `/run/${Deno.env.get("WM_FLOW_JOB_ID")}`,
        Deno.env.get("WM_BASE_URL"),
      );
      const text = `Flow job ${jobUrl} (${Deno.env.get(
        "WM_FLOW_PATH",
      )}) run by ${Deno.env.get("WM_USERNAME")} was approved by ${approvers.join(
        ", ",
      )}`;

      await web.chat.postMessage({
        channel,
        text,
        icon_emoji: ':thumbsup:',
      });
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'postMessage')
  explanation: |-
    The error occurs because the `web.chat` object does not have a property `postMessage`. The `postMessage` method is supposed to be called directly on the `web` object, not on `web.chat`. The correct usage should be `await web.postMessage({ channel, text });`. By attempting to call `postMessage` on `web.chat`, the code is trying to access a property of `undefined`, which results in a `TypeError`.
  id: |-
    hubfix_hub_180
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(channel: string, slack: Slack, approvers: string[]) {
      const web = new WebClient(slack.token);
      const jobUrl = new URL(
        `/run/${Deno.env.get("WM_FLOW_JOB_ID")}`,
        Deno.env.get("WM_BASE_URL"),
      );
      const text = `Flow job ${jobUrl} (${Deno.env.get(
        "WM_FLOW_PATH",
      )}) run by ${Deno.env.get("WM_USERNAME")} was approved by ${approvers.join(
        ", ",
      )}`;

      await web.chat.postMessage({
        channel,
        text,
      });
    }
  original_instructions: |-
    Send information about approved job to channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      from_chat_id: string,
      to_chat_id: string,
      message_id: string,
    ) {
      const client = new Telegram(auth.token);
      return await client.forwardMessage(to_chat_id, from_chat_id, parseInt(message_id));
    }
  error: |-
    TypeError: message_id is not a number
  explanation: |-
    The `message_id` parameter in the `main` function has been changed from `number` to `string`, which is incorrect because the `forwardMessage` method expects a number for the `message_id` parameter. The `parseInt` function is used to convert the `message_id` from a string to a number, but this is a workaround for a mistake in the type declaration. The correct approach would be to ensure that `message_id` is passed as a number to the function, and the type declaration for `message_id` should remain `number`.
  id: |-
    hubfix_hub_241
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      from_chat_id: string,
      to_chat_id: string,
      message_id: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.forwardMessage(to_chat_id, from_chat_id, message_id);
    }
  original_instructions: |-
    Forward a Message in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      scriptPathExact?: string,
      onlySuspendedJobs: boolean,
    ) {
      return wmill.JobService.listQueue({
        workspace: wmill.getWorkplace(), // This is the intentional error
        suspended: onlySuspendedJobs,
        perPage: "fifty", // This is another intentional error
        scriptPathExact,
      });
    }
  error: |-
    TypeError: wmill.getWorkplace is not a function
  explanation: |-
    The code is trying to call a function `getWorkplace` on the `wmill` object, which does not exist. The correct function name is `getWorkspace`. Additionally, the `perPage` parameter is expected to be a number, but the string "fifty" is passed instead, which would also cause a type error if the first error was fixed.
  id: |-
    hubfix_hub_269
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      scriptPathExact?: string,
      onlySuspendedJobs: boolean,
    ) {
      return wmill.JobService.listQueue({
        workspace: wmill.getWorkspace(),
        suspended: onlySuspendedJobs,
        perPage: 50,
        scriptPathExact,
      });
    }
  original_instructions: |-
    List Queued Jobs in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import {
      refreshAndRetryIfExpired,
      removeObjectEmptyFields,
    } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      on_conflict?: string,
      ignore_duplicates: boolean = true,
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .upsert(
            values,
            removeObjectEmptyFields({ on_conflict, ignore_duplicates, count }),
          );
        if (return_updated) {
          query = query.select();
        }

        return query.execute();
      });
    }
  error: |-
    TypeError: query.execute is not a function
  explanation: |-
    The error occurs because the method `execute()` is being called on the `query` object, but this method does not exist on the object returned by the `upsert` or `select` methods. The original code did not call `execute()` because it is not a valid method for the query object in the context of the used library. The correct usage would be to simply return the `query` object without calling `execute()`, as the query execution is handled internally by the library.
  id: |-
    hubfix_hub_288
  lang: |-
    deno
  original_code: |
    import {
      refreshAndRetryIfExpired,
      removeObjectEmptyFields,
    } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param on_conflict Comma-separated UNIQUE column(s) to specify how duplicate
     * rows are determined. Two rows are duplicates if all the onConflict columns are equal.
     *
     * @param ignore_duplicates If true, duplicate rows are ignored. If false, duplicate
     * rows are merged with existing rows.
     *
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      on_conflict?: string,
      ignore_duplicates: boolean = true,
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .upsert(
            values,
            removeObjectEmptyFields({ on_conflict, ignore_duplicates, count }),
          );
        if (return_updated) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Upsert data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- broken_code: |-
    type Currencyapi = {
      apiKey: string;
    };
    export async function main(
      currencyApiResource: Currencyapi,
      base_currency: string,
      currencies: string,
    ) {
      const paramString = new URLSearchParams({
        base: base_currency, // Changed the parameter name from base_currency to base
        currencies: currencies,
      }).toString();

      const res = await fetch(
        `https://api.currencyapi.com/v3/latest?${paramString}`,
        {
          headers: {
            apikey: currencyApiResource.apiKey,
          },
        },
      );
      const data = await res.json();
      const currency = data?.datum; // Changed the property name from data to datum
      return currency;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'datum')
  explanation: |-
    The code is broken because of two changes:

    1. The URLSearchParams object is constructed with a parameter name `base` instead of `base_currency`. If the API expects the parameter name to be `base_currency`, changing it to `base` would result in the API not recognizing the parameter, which could lead to incorrect behavior or an error response from the API.

    2. The property `datum` is being accessed on the `data` object, but the correct property name according to the original code is `data`. Since `datum` does not exist on the `data` object, trying to access it results in `undefined`, and attempting to read a property of `undefined` throws a TypeError.
  id: |-
    hubfix_hub_322
  lang: |-
    deno
  original_code: |
    type Currencyapi = {
      apiKey: string;
    };
    export async function main(
      currencyApiResource: Currencyapi,
      base_currency: string,
      currencies: string,
    ) {
      const paramString = new URLSearchParams({
        base_currency: base_currency,
        currencies: currencies,
      }).toString();

      const res = await fetch(
        `https://api.currencyapi.com/v3/latest?${paramString}`,
        {
          headers: {
            apikey: currencyApiResource.apiKey,
          },
        },
      );
      const data = await res.json();
      const currency = data?.data;
      return currency;
    }
  original_instructions: |-
    Latest exchange rate from CurrencyApi.com in currencyapi
  resource_type: |-
    Currencyapi
  resource_type_def: |-
    type Currencyapi = {
      apiKey: string;
    }
- broken_code: |-
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(discord_webhook: DiscordWebhook, message: number) {
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.createMessage(message);
      return ret;
    }
  error: |-
    error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `createMessage` function expects a string as its parameter, but a number is being passed instead. The `message` parameter in the `main` function is incorrectly typed as `number` when it should be `string`. This causes TypeScript to throw an error because it is expecting a string argument for the `createMessage` function.
  id: |-
    hubfix_hub_77
  lang: |-
    deno
  original_code: |
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(discord_webhook: DiscordWebhook, message: string) {
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.createMessage(message);
      return ret;
    }
  original_instructions: |-
    Send a message to discord using webhook in discord
  resource_type: |-
    DiscordWebhook
  resource_type_def: |-
    type DiscordWebhook = {
      webhook_url: string;
    }
- broken_code: |-
    type Gsheets = {
      accessToken: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      worksheet_name: string,
    ) {
      const token = gsheets_auth["token"];

      const GET_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${worksheet_name}`;

      const response = await fetch(GET_VALUES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'token')
  explanation: |-
    The code is trying to access a property `token` on the `gsheets_auth` object, but the type `Gsheets` has been changed to have a property `accessToken` instead of `token`. Since `token` is not a property of `Gsheets`, trying to access `gsheets_auth["token"]` results in `undefined`, and the subsequent attempt to read from `undefined` throws a TypeError.
  id: |-
    hubfix_hub_53
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      worksheet_name: string,
    ) {
      const token = gsheets_auth["token"];

      const GET_VALUES_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${worksheet_name}`;

      const response = await fetch(GET_VALUES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Get Values in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    // Schedule error handler template

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      started_at: string, // The start datetime of the latest job that failed
      failed_times: string, // Minimum number of times the schedule failed before calling the error handler
    ) {
      console.log(
        `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${started_at}:`, error);
      return error;
    }

    main("/path/to/script", true, "/path/to/schedule", new Error("Something went wrong"), "2023-04-01T00:00:00Z", "3");
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `failed_times` parameter is expected to be a number, but in the call to `main` at the bottom, it is being passed as a string ("3"). TypeScript expects strict type adherence, so passing a string where a number is expected will cause a type error.
  id: |-
    hubfix_hub_401
  lang: |-
    deno
  original_code: |
    // Schedule error handler template

    export async function main(
      path: string, // The path of the script or flow that errored
      is_flow: boolean, // Whether the runnable is a flow
      schedule_path: string, // The path of the schedule
      error: object, // The error details
      started_at: string, // The start datetime of the latest job that failed
      failed_times: number, // Minimum number of times the schedule failed before calling the error handler
    ) {
      console.log(
        `Schedule ${schedule_path} failed ${
          failed_times > 1 ? (failed_times + " times in a row") : ""
        }\n${is_flow ? "Flow" : "Script"}: ${path}`,
      );
      console.log(`Last failure at ${started_at}:`, error);
      return error;
    }
  original_instructions: |-
    Schedule error handler template in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
      document_data?: Record<string | number, any>,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.updateDocuments( // Incorrect method name
        database_id,
        collection_id,
        document_id,
        document_data,
        document_permissions,
      );
    }
  error: |-
    TypeError: db.updateDocuments is not a function
  explanation: |-
    The error is caused by calling a non-existent method `updateDocuments` on the `db` object. The correct method name should be `updateDocument` as per the original code. The incorrect method name `updateDocuments` does not exist in the `Databases` class from the Appwrite SDK, hence the TypeError is thrown when trying to call it.
  id: |-
    hubfix_hub_337
  lang: |-
    deno
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      document_id: string,
      document_data?: Record<string | number, any>,
      document_permissions?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.updateDocument(
        database_id,
        collection_id,
        document_id,
        document_data,
        document_permissions,
      );
    }
  original_instructions: |-
    Update Document in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      user_id: string,
    ) {
      const url = `${
        matrix_res.baseUri
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/joined_members`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to fetch joined member list: Error HTTP${resp.status}`);
      }
      const data = await resp.json();
      return {
        is_joined: user_id in data?.joined,
        user_info: data?.joined?.[user_id],
      };
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseUri')
  explanation: |-
    The code is trying to access a property `baseUri` on the `matrix_res` object, which does not exist. The correct property name is `baseUrl`. Since `baseUri` is not defined in the `Matrix` type, trying to access it results in a `TypeError` because it is `undefined`.
  id: |-
    hubfix_hub_191
  lang: |-
    deno
  original_code: |
    /**
     * This function throws an error, if you're not a room member.
     *
     * Expected return values:
     *
     * {
     *   "is_joined": false,
     *   "user_info": null
     * }
     *
     * or
     *
     * {
     *   "is_member": true,
     *   "user_info": {
     *     "avatar_url": "mxc://matrix.org/abc123",
     *     "display_name": "Jane Doe"
     *   }
     * }
     */
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      user_id: string,
    ) {
      const url = `${
        matrix_res.baseUrl
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/joined_members`;
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to fetch joined member list: Error HTTP${resp.status}`);
      }
      const data = await resp.json();
      return {
        is_joined: user_id in data?.joined,
        user_info: data?.joined?.[user_id],
      };
    }
  original_instructions: |-
    Is a Matrix user X a joined member of a Matrix room Y? in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      segment_id: number, // Changed the type from string to number
      members_to_add?: string[],
      members_to_remove?: string[],
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments/${segment_id}`,
      );
      const body = {
        members_to_add,
        members_to_remove,
      };
      removeObjectEmptyFields(body, true, false);
      if (!Object.keys(body).length) {
        return "No members were declared to be added or removed.";
      }

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: segment_id.toString is not a function
  explanation: |-
    The error occurs because the `segment_id` parameter was changed from a string to a number. The `URL` constructor expects a string as part of the URL path, but when it tries to concatenate the `segment_id` number with the rest of the URL string, it implicitly calls `toString()` on the number, which should work in JavaScript. However, if there's any other part of the code or the URL class that explicitly expects a string and tries to call a string-specific method (not shown in the provided code), it could lead to a TypeError. In TypeScript, this would also cause a type error during compilation because the URL path parts are expected to be strings, not numbers.

    It's important to note that in JavaScript, calling `toString()` on a number should not cause an error, as numbers do have a `toString` method. However, if the code or environment has a custom implementation or handling of URL concatenation that does not handle non-string values correctly, it could lead to a runtime error. In a strict TypeScript environment, this would be caught at compile time, and the error message would be related to type incompatibility.
  id: |-
    hubfix_hub_213
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";

    /**
     * @param members_to_add *(optional)* An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * A maximum of 500 members can be sent.
     *
     * @param members_to_remove *(optional)* An array of emails to be used for a static segment.
     * Any emails provided that are not present on the list will be ignored.
     * A maximum of 500 members can be sent.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      segment_id: string,
      members_to_add?: string[],
      members_to_remove?: string[],
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments/${segment_id}`,
      );
      const body = {
        members_to_add,
        members_to_remove,
      };
      removeObjectEmptyFields(body, true, false);
      if (!Object.keys(body).length) {
        return "No members were declared to be added or removed.";
      }

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Add Or Remove Members Tags in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import { SmtpClient } from "https://deno.land/x/smtp/mod.ts";

    type Smtp = {
      host: string;
      port: number;
      user: string;
      password: string;
    };
    export async function main(
      smtp_res: Smtp,
      to_email: string,
      from_email: string,
      subject: string,
      content: string,
    ) {
      const client = new SmtpClient();

      await client.connectTLS({
          hostname: smtp_res.host,
          username: smtp_res.user,
          port: smtp_res.port,
          password: smtp_res.password
      });

      await client.send({
        from: from_email,
        to: to_email,
        subject: subject,
        content: content,
      });

      await client.close();
      return `Email sent from ${from_email} to ${to_email}`;
    }

    main({
      host: "smtp.example.com",
      port: "25", // This should be a number, not a string
      user: "user@example.com",
      password: "password"
    }, "recipient@example.com", "sender@example.com", "Test Subject", "Test Content");
  error: |-
    TypeError: Argument of type '{ host: string; port: string; user: string; password: string; }' is not assignable to parameter of type 'Smtp'.
      Types of property 'port' are incompatible.
        Type 'string' is not assignable to type 'number'.
  explanation: |-
    The error occurs because the `port` property in the `Smtp` type is defined as a number, but in the `main` function call, a string is passed instead of a number. TypeScript expects the `port` property to be a number as defined in the `Smtp` type, so passing a string causes a type mismatch error.
  id: |-
    hubfix_hub_106
  lang: |-
    deno
  original_code: |
    import { SmtpClient } from "https://deno.land/x/smtp/mod.ts";

    type Smtp = {
      host: string;
      port: number;
      user: string;
      password: string;
    };
    export async function main(
      smtp_res: Smtp,
      to_email: string,
      from_email: string,
      subject: string,
      content: string,
    ) {
      const client = new SmtpClient();

      await client.connectTLS({
          hostname: smtp_res.host,
          username: smtp_res.user,
          port: smtp_res.port,
          password: smtp_res.password
      });

      await client.send({
        from: from_email,
        to: to_email,
        subject: subject,
        content: content,
      });

      await client.close();
      return `Email sent from ${from_email} to ${to_email}`;
    }
  original_instructions: |-
    Send Email in smtp
  resource_type: |-
    Smtp
  resource_type_def: |-
    type Smtp = {
      host: string;
      port: number;
      user: string;
      password: string;
    }
- broken_code: |-
    export async function main(endpoint: number) {
      try {
        const response = await fetch(endpoint);
        return { status: response.status, statusText: response.statusText };
      } catch (e) {
        return { status: -1, statusText: e.toString() };
      }
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': The provided value is not of type '(RequestInfo | URL)'
  explanation: |-
    The `fetch` function expects its first argument to be either a `string` representing a URL or a `Request` object. In the broken code, the `endpoint` parameter type has been changed from `string` to `number`, which is not a valid type for the `fetch` function's argument. This will cause a TypeError at runtime when the `fetch` function is called with a number instead of a string or a `Request` object.
  id: |-
    hubfix_hub_199
  lang: |-
    deno
  original_code: |
    export async function main(endpoint: string) {
      try {
        const res = await fetch(endpoint);
        return { status: res.status, statusText: res.statusText };
      } catch (e) {
        return { status: -1, statusText: e.toString() };
      }
    }
  original_instructions: |-
    Get an endpoint status and statusText in http
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(api_token: Sendgrid, query: number) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/contacts/search`,
        method: "POST",
        body: { query },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: query must be a string, but got number
  explanation: |-
    The `query` parameter in the `main` function has been changed from `string` to `number`. The SendGrid API expects the query to be a string in SGQL format, but the modified code attempts to pass a number instead, which would result in a type error when trying to use this parameter in the API request.
  id: |-
    hubfix_hub_221
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param query The search query in SGQL format. An example query to get
     * all contacts with a Gmail address would look like the following:
     * `email LIKE '%gmail.com'`
     *
     * You can read more about SGQL at
     * https://docs.sendgrid.com/for-developers/sending-email/segmentation-query-language.
     *
     * You can read more about the endpoint at
     * https://docs.sendgrid.com/api-reference/contacts/search-contacts.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(api_token: Sendgrid, query: string) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/contacts/search`,
        method: "POST",
        body: { query },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Search Contacts in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import {
      MongoClient,
      ObjectId,
    } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      const lastCheck = (await getState()) || 0;
      await setState(Date.now() / 1000);
      const id = ObjectId.createFromTime(lastCheck);
      return await documents.find({ _id: { $gt: id } }).toArray(); // Added .toArray() which doesn't exist
    }
  error: |-
    TypeError: documents.find(...).toArray is not a function
  explanation: |-
    The error occurs because the method `toArray()` is being called on the result of `documents.find()`, which is assumed to be a cursor or similar iterable object. However, in the context of the provided code, the `toArray()` method does not exist on the returned object from `documents.find()`. This is a common mistake when developers switch between different database drivers or libraries, as some may provide a `toArray()` method to convert cursor results to arrays, while others may not. The correct usage depends on the actual API provided by the `atlas_sdk` library, and if such a method does not exist, the developer should use the appropriate method to retrieve the documents from the cursor.
  id: |-
    hubfix_hub_262
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import {
      MongoClient,
      ObjectId,
    } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      const lastCheck = (await getState()) || 0;
      await setState(Date.now() / 1000);
      const id = ObjectId.createFromTime(lastCheck);
      return await documents.find({ _id: { $gt: id } });
    }
  original_instructions: |-
    Get recently inserted documents in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    import { Client } from "npm:@notionhq/client";
    import type { BlockObjectRequest } from "npm:@notionhq/client/2.2.4/build/src/api-endpoints.js";

    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      block_id: string,
      children: object[] = [],
    ) {
      const client = new Client({ auth: auth.token });
      return await client.blocks.children.add({
        block_id,
        children: children as BlockObjectRequest,
      });
    }
  error: |-
    TypeError: client.blocks.children.add is not a function
  explanation: |-
    The error occurs because the method `add` is being called on `client.blocks.children`, but such a method does not exist in the Notion client API. The correct method to use is `append`, as it was in the original code. By changing `append` to `add`, the code attempts to call a non-existent method, resulting in a `TypeError` when the script is run.
  id: |-
    hubfix_hub_355
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@notionhq/client";
    import type { BlockObjectRequest } from "npm:@notionhq/client/2.2.4/build/src/api-endpoints.js";

    /**
     * Learn more at
     * https://developers.notion.com/reference/patch-block-children
     */
    type Notion = {
      token: string;
    };
    export async function main(
      auth: Notion,
      block_id: string,
      children: object[] = [],
    ) {
      const client = new Client({ auth: auth.token });
      return await client.blocks.children.append({
        block_id,
        children: children as BlockObjectRequest,
      });
    }
  original_instructions: |-
    Append Block Children in notion
  resource_type: |-
    Notion
  resource_type_def: |-
    type Notion = {
      token: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(
      subreddit: string,
      mentions: string[],
      max_number_of_posts: number = 100,
    ) {
      mentions = mentions?.map((m) => m.trim().toLowerCase())?.filter(Boolean);
      if (!mentions?.length) {
        throw Error("\nAt least one mentioned phrase is needed to search for.");
      }

      const url = new URL(`https://www.reddit.com/r/${subreddit}/new.json`);
      if (max_number_of_posts < 1) {
        max_number_of_posts = 1;
      }
      const limit = max_number_of_posts < 100 ? max_number_of_posts : 100;
      const processedPosts: Post[] = [];
      let runLoop = true;

      do {
        const lastPostId = await getState();
        url.searchParams.append("limit", limit.toString());
        lastPostId && url.searchParams.append("before", lastPostId);
        const result = await fetch(url);
        if (!result.ok) {
          throw Error("\n" + (await result.text()));
        }
        const data = (await result.json()).data;
        const posts: Post[] = data.children.map(
          ({ data: { name, title, selftext, url, invalidProperty } }: { data: Post }) => {
            return { name, title, selftext, url, invalidProperty };
          },
        );
        if (!posts.length) {
          return processedPosts;
        } else if (posts.length < limit) {
          runLoop = false;
        }

        await setState(posts[0].name);
        const temp: Post[] = [];
        for (let i = 0; i < posts.length; i++) {
          const post = posts[i];
          const mention =
            mentions.find((mention) =>
              post.title.toLowerCase().includes(mention),
            ) ||
            mentions.find((mention) =>
              post.selftext.toLowerCase().includes(mention),
            );
          mention && temp.push(post);
          if (processedPosts.length + temp.length >= max_number_of_posts) {
            break;
          }
        }
        processedPosts.push(...temp.reverse());
        if (processedPosts.length >= max_number_of_posts) {
          runLoop = false;
        }
      } while (runLoop);

      return processedPosts;
    }

    interface Post {
      name: string;
      title: string;
      selftext: string;
      url: string;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'invalidProperty')
  explanation: |-
    The code is trying to access a property `invalidProperty` on the `Post` type that does not exist. This property is not defined in the `Post` interface, and it is not present in the data structure returned by the Reddit API. Therefore, when the code attempts to access this non-existent property, it results in a `TypeError`.
  id: |-
    hubfix_hub_249
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    /**
     * @returns A list of posts that mentioned given phrases in ascending order
     * of date of publication.
     *
     * @param mentions Case **insensitive** phrases that should be searched for.
     */
    export async function main(
      subreddit: string,
      mentions: string[],
      max_number_of_posts: number = 100,
    ) {
      mentions = mentions?.map((m) => m.trim().toLowerCase())?.filter(Boolean);
      if (!mentions?.length) {
        throw Error("\nAt least one mentioned phrase is needed to search for.");
      }

      const url = new URL(`https://www.reddit.com/r/${subreddit}/new.json`);
      if (max_number_of_posts < 1) {
        max_number_of_posts = 1;
      }
      const limit = max_number_of_posts < 100 ? max_number_of_posts : 100;
      const processedPosts: Post[] = [];
      let runLoop = true;

      do {
        const lastPostId = await getState();
        url.searchParams.append("limit", limit.toString());
        lastPostId && url.searchParams.append("before", lastPostId);
        const result = await fetch(url);
        if (!result.ok) {
          throw Error("\n" + (await result.text()));
        }
        const data = (await result.json()).data;
        const posts: Post[] = data.children.map(
          ({ data: { name, title, selftext, url } }: { data: Post }) => {
            return { name, title, selftext, url };
          },
        );
        if (!posts.length) {
          return processedPosts;
        } else if (posts.length < limit) {
          runLoop = false;
        }

        await setState(posts[0].name);
        const temp: Post[] = [];
        for (let i = 0; i < posts.length; i++) {
          const post = posts[i];
          const mention =
            mentions.find((mention) =>
              post.title.toLowerCase().includes(mention),
            ) ||
            mentions.find((mention) =>
              post.selftext.toLowerCase().includes(mention),
            );
          mention && temp.push(post);
          if (processedPosts.length + temp.length >= max_number_of_posts) {
            break;
          }
        }
        processedPosts.push(...temp.reverse());
        if (processedPosts.length >= max_number_of_posts) {
          runLoop = false;
        }
      } while (runLoop);

      return processedPosts;
    }

    interface Post {
      name: string;
      title: string;
      selftext: string;
      url: string;
    }
  original_instructions: |-
    Trigger everytime a new item post on reddit matches at least one mention  in reddit
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      email: string,
      source?: string,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/validations/email`,
        method: "POST",
        body: {
          email,
          source,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return bodi;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    ReferenceError: bodi is not defined
  explanation: |-
    The code is trying to return a variable named `bodi`, which does not exist. The correct variable name should be `body`, as defined in the destructuring assignment `const [_, body] = await sendgrid.request(request);`. The typo in the variable name `bodi` instead of `body` is causing the ReferenceError.
  id: |-
    hubfix_hub_218
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      email: string,
      source?: string,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/validations/email`,
        method: "POST",
        body: {
          email,
          source,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Validate Email in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;
    const PAGE_SIZE = 50;

    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const newIssues: Issue[] = [];
      const lastUpdate = await getState();

      let runLoop = true;
      let page = 1;
      do {
        const result = await octokit.issues.listForRepo({
          owner,
          repo,
          filter: "all",
          state: "open",
          sort: "created",
          direction: "desc",
          per_page: PAGE_SIZE,
          page: page++,
        });
        const issues = result.data.filter((i) => i && !i.pull_request);

        for (let i = 0; i < issues.length; i++) {
          const issue = issues[i];
          if (new Date(issue.created_at).getTime() <= lastUpdate) {
            runLoop = false;
            break;
          }
          newIssues.push({
            title: issue.title,
            url: issue.html_url,
            created_at: issue.created_at,
            user: {
              login: issue.user?.login,
              url: issue.user?.html_url,
            },
            labels: <string[]>(
              issue.labels
                .map((l) => (typeof l === "string" ? l : l.name))
                .filter(Boolean)
            ),
          });
          if (newIssues.length >= MAX_ITEMS) {
            runLoop = false;
            break;
          }
        }

        if (result.data.length < PAGE_SIZE) {
          break;
        }
      } while (runLoop);

      if (newIssues.length) {
        await setState(new Date(newIssues[0].created_at).getTime());
      }
      return newIssues.reverse();
    }

    interface Issue {
      title: string;
      url: string;
      created_at: string;
      user: {
        login?: string;
        url?: string;
      };
      labels: string[];
    }

    main({ token: "ghp_exampleToken" }, "octocat", "Hello-World").then(console.log);
  error: |-
    TypeError: Cannot read properties of undefined (reading 'getTime')
  explanation: |-
    The error occurs because the `getState` function is expected to return a value that can be used in the comparison `new Date(issue.created_at).getTime() <= lastUpdate`, but it seems that `getState` is returning `undefined`. This could be due to the `getState` function not being properly implemented or not returning a valid timestamp. To fix this error, ensure that `getState` returns a valid timestamp or handle the case where `getState` might return `undefined`.
  id: |-
    hubfix_hub_251
  lang: |-
    deno
  original_code: |
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;
    const PAGE_SIZE = 50;

    /**
     * @returns A list of issues in ascending order of creation date.
     *
     * The maximum number of returned items is 500 and therefore you'll miss
     * the issues that are older than the 500th one. Please choose your
     * scheduling accordingly.
     */
    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const newIssues: Issue[] = [];
      const lastUpdate = await getState();

      let runLoop = true;
      let page = 1;
      do {
        const result = await octokit.issues.listForRepo({
          owner,
          repo,
          filter: "all",
          state: "open",
          sort: "created",
          direction: "desc",
          per_page: PAGE_SIZE,
          page: page++,
        });
        const issues = result.data.filter((i) => i && !i.pull_request);

        for (let i = 0; i < issues.length; i++) {
          const issue = issues[i];
          if (new Date(issue.created_at).getTime() <= lastUpdate) {
            runLoop = false;
            break;
          }
          newIssues.push({
            title: issue.title,
            url: issue.html_url,
            created_at: issue.created_at,
            user: {
              login: issue.user?.login,
              url: issue.user?.html_url,
            },
            labels: <string[]>(
              issue.labels
                .map((l) => (typeof l === "string" ? l : l.name))
                .filter(Boolean)
            ),
          });
          if (newIssues.length >= MAX_ITEMS) {
            runLoop = false;
            break;
          }
        }

        if (result.data.length < PAGE_SIZE) {
          break;
        }
      } while (runLoop);

      if (newIssues.length) {
        await setState(new Date(newIssues[0].created_at).getTime());
      }
      return newIssues.reverse();
    }

    interface Issue {
      title: string;
      url: string;
      created_at: string;
      user: {
        login?: string;
        url?: string;
      };
      labels: string[];
    }
  original_instructions: |-
    List newly added issues in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      documents: Record<string, any>[],
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);

      let items: Record<string, any>[];
      try {
        items = documents.map((doc) =>
          typeof doc === "string" ? JSON.parse(doc) : doc,
        );
      } catch (err) {
        throw Error(`\nReceived array of strings in the 'documents' argument.
    Attempted to parse them into objects but the process failed with the following error:\n${err}`);
      }

      return await docs.insertMany(items);
    }

    main({
      endpoint: "https://example.mongodb.com",
      api_key: "my-api-key",
    }, "Cluster0", "myDatabase", "myCollection", "This is not an array");
  error: |-
    TypeError: documents.map is not a function
        at main (file:///path/to/script.ts:XX:XX)
  explanation: |-
    The error occurs because the `documents` parameter is expected to be an array of `Record<string, any>`, but in the call to `main`, a string (`"This is not an array"`) is passed instead. The `.map` function is an array method, and since a string is not an array, it does not have a `.map` method, which leads to the `TypeError`.
  id: |-
    hubfix_hub_260
  lang: |-
    deno
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      documents: Record<string, any>[],
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const docs = client.database(database).collection(collection);

      let items: Record<string, any>[];
      try {
        items = documents.map((doc) =>
          typeof doc === "string" ? JSON.parse(doc) : doc,
        );
      } catch (err) {
        throw Error(`\nReceived array of strings in the 'documents' argument.
    Attempted to parse them into objects but the process failed with the following error:\n${err}`);
      }

      return await docs.insertMany(items);
    }
  original_instructions: |-
    Create Many New Documents in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import { doc, getFirestore, setDoc } from "npm:firebase/firestore/lite";

    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      document_path: string[],
      document: Record<string, any>,
      merge?: boolean,
      mergeFields?: string[],
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const docRef = doc(store, collection_id, ...document_path);
      await setDoc(docRef, document, {
        merge: typeof merge === "boolean" ? merge : undefined,
        mergeFields:
          Array.isArray(mergeFields) && mergeFields.length
            ? mergeFields
            : undefined,
      });

      return store.getDoc(docRef); // This line is incorrect
    }
  error: |-
    TypeError: store.getDoc is not a function
  explanation: |-
    The error occurs because `getDoc` is not a method of the `store` object. The `store` object is an instance of Firestore, and the correct method to retrieve a document is `getDoc` from the `firebase/firestore/lite` module, which should be imported and used with the `docRef` as an argument. The incorrect code attempts to call `getDoc` as if it were a method on the `store` object, which is not the case. The correct usage would be to import `getDoc` and call it as a standalone function, passing `docRef` as the argument.
  id: |-
    hubfix_hub_359
  lang: |-
    deno
  original_code: |
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import { doc, getFirestore, setDoc } from "npm:firebase/firestore/lite";

    /**
     * Overwrites or updates a document.
     *
     * @param document_path Path to the document.
     * If you want to update a top-level document by ID, pass in an array with only
     * the ID in it.
     * *eg:* `[ 'my-id' ]`
     *
     * @param merge If `true`, the document will be updated with provided fields,
     * otherwise the document will be completely overwritten.
     * **WARNING:** Overwriting a document may result in data loss.
     *
     * @param mergeFields Controls which fields should be merged.
     */
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      document_path: string[],
      document: Record<string, any>,
      merge?: boolean,
      mergeFields?: string[],
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const docRef = doc(store, collection_id, ...document_path);
      await setDoc(docRef, document, {
        merge: typeof merge === "boolean" ? merge : undefined,
        mergeFields:
          Array.isArray(mergeFields) && mergeFields.length
            ? mergeFields
            : undefined,
      });
    }
  original_instructions: |-
    Set Document in firebase
  resource_type: |-
    Firebase
  resource_type_def: |-
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      contacts: {
        email: string;
        custom_fields: Record<string, string | number>;
      }[],
      list_ids?: string[],
    ) {
      sendgrid.setApiKey(api_token.token);

      try {
        contacts = contacts.map((c) => {
          return typeof c === "string" ? JSON.parse(c) : c;
        });
      } catch (error) {
        throw Error(`Tried to parse "contacts" argument because
        it was an array of strings but failed with error:\n${error}`);
      }

      const body = removeObjectEmptyFields({
        contacts,
        list_ids,
      });
      const request = {
        url: `/v3/marketing/contacts`,
        method: "PUT",
        body,
      };

      try {
        const [_, responseBody] = await sendgrid.makeRequest(request);
        return responseBody;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: sendgrid.makeRequest is not a function
  explanation: |-
    The error occurs because the method `makeRequest` does not exist on the `sendgrid` object. The original code used `sendgrid.request`, which is the correct method to make a request with the SendGrid client. By changing `.request` to `.makeRequest`, the code is now trying to call a method that doesn't exist, resulting in a `TypeError`.
  id: |-
    hubfix_hub_219
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * According to Sendgrid documentation, this is an asynchronous
     * process and the response will NOT contain immediate feedback,
     * only a `job_id` which then can be used to get the status
     * of the job.
     * The following script from WindmillHub performs this status check:
     * https://hub.windmill.dev/scripts/sendgrid/1449/get-contacts-import-status-sendgrid
     *
     * You can read more of the Sendgrid documentation at
     * https://docs.sendgrid.com/api-reference/contacts/add-or-update-a-contact
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      contacts: {
        email: string;
        custom_fields: Record<string, string | number>;
      }[],
      list_ids?: string[],
    ) {
      sendgrid.setApiKey(api_token.token);

      try {
        contacts = contacts.map((c) => {
          return typeof c === "string" ? JSON.parse(c) : c;
        });
      } catch (error) {
        throw Error(`Tried to parse "contacts" argument because
        it was an array of strings but failed with error:\n${error}`);
      }

      const body = removeObjectEmptyFields({
        contacts,
        list_ids,
      });
      const request = {
        url: `/v3/marketing/contacts`,
        method: "PUT",
        body,
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Add or Update Contact in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.delete(filter);
    }
  error: |-
    TypeError: documents.delete is not a function
  explanation: |-
    The error occurs because the method `delete` does not exist on the `documents` object. The correct method to delete multiple documents according to the MongoDB API is `deleteMany`. By changing `deleteMany` to `delete`, the code attempts to call a non-existent method, resulting in a `TypeError`.
  id: |-
    hubfix_hub_258
  lang: |-
    deno
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     *
     * @param filter For example: `{ "_id": "01234" }`
     * Find out more at:
     * https://www.mongodb.com/docs/manual/reference/method/db.collection.deleteMany/
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter: Record<string, any>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.deleteMany(filter);
    }
  original_instructions: |-
    Delete Many Documents in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe) {
      const STRIPE_CREATE_CUSTOMER_URL = `https://api.stripe.com/v1/customers`;

      const token = stripe_con["tokens"]; // Incorrect property name

      const response = await fetch(STRIPE_CREATE_CUSTOMER_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text(); // Changed from .json() to .text()
    }
  error: |-
    TypeError: Cannot read property 'tokens' of undefined
  explanation: |-
    The code is trying to access a property 'tokens' on the `stripe_con` object, which does not exist. The correct property name is 'token'. Additionally, the function is expected to return a JSON response, but the `.text()` method is used instead of `.json()`. This might not cause a runtime error, but it would be a logical error if the calling code expects a JSON object.
  id: |-
    hubfix_hub_120
  lang: |-
    deno
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe) {
      const STRIPE_CREATE_CUSTOMER_URL = `https://api.stripe.com/v1/customers`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_CREATE_CUSTOMER_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Create a Customer in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    // https://docs.nextcloud.com/server/latest/developer_manual/client_apis/OCS/ocs-api-overview.html#user-metadata
    // Should return an XML document on success.
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    };
    export async function main(nextcloud_res: Nextcloud, userId: number) {
      const resp = await fetch(
        `${nextcloud_res.baseUrl}/ocs/v1.php/cloud/users/${encodeURIComponent(
          userId,
        )}`,
        {
          headers: {
            Authorization:
              "Basic " +
              btoa(nextcloud_res.user + ":" + nextcloud_res.password),
            "OCS-APIRequest": "true",
          },
        },
      );
      if (!resp.ok) {
        throw Error(`HTTP Error ${resp.status} - ${await resp.text()}`);
      }
      return await resp.blob();
    }
  error: |-
    TypeError: Failed to execute 'encodeURIComponent' on 'Window': parameter 1 is not of type 'string'.
  explanation: |-
    The code is broken for two reasons:

    1. The `userId` parameter type was changed from `string` to `number`, which is incorrect because `encodeURIComponent` expects a string argument. When `encodeURIComponent` is called with a number, it throws a TypeError.

    2. The property `user` is being accessed on `nextcloud_res` instead of `username`. The `Nextcloud` type does not have a `user` property, so trying to access it will result in `undefined`, which will lead to an incorrect `Authorization` header being constructed.
  id: |-
    hubfix_hub_164
  lang: |-
    deno
  original_code: |
    // https://docs.nextcloud.com/server/latest/developer_manual/client_apis/OCS/ocs-api-overview.html#user-metadata
    // Should return an XML document on success.
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    };
    export async function main(nextcloud_res: Nextcloud, userId: string) {
      const resp = await fetch(
        `${nextcloud_res.baseUrl}/ocs/v1.php/cloud/users/${encodeURIComponent(
          userId,
        )}`,
        {
          headers: {
            Authorization:
              "Basic " +
              btoa(nextcloud_res.username + ":" + nextcloud_res.password),
            "OCS-APIRequest": "true",
          },
        },
      );
      if (!resp.ok) {
        throw Error(`HTTP Error ${resp.status} - ${await resp.text()}`);
      }
      return await resp.text();
    }
  original_instructions: |-
    Get user metadata in ocs
  resource_type: |-
    Nextcloud
  resource_type_def: |-
    type Nextcloud = {
      baseUrl: string;
      username: string;
      password: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      amount: number,
      currency: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const payout = await stripe.payments.create({
        amount: amount,
        currency: `${currency}`,
      });

      return await payout.json();
    }
  error: |-
    TypeError: stripe.payments is undefined
  explanation: |-
    The error is caused by calling a non-existent property `payments` on the `stripe` object. The original code called `stripe.payouts.create`, which is presumably a correct method on the Stripe object. By changing `payouts` to `payments`, the code attempts to access a property that does not exist, leading to a runtime error.
  id: |-
    hubfix_hub_124
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      amount: number,
      currency: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const payout = await stripe.payouts.create({
        amount: amount,
        currency: `${currency}`,
      });

      return await payout.json();
    }
  original_instructions: |-
    Create a Payout in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import { addDoc, collection, getFirestore } from "npm:firebase/firestore/lite";

    export async function main(
      auth: Firebase,
      collection_id: string,
      document: Record<string, any>,
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const colRef = collection(store, collection_id);
      const res = await addDoc(colRef, document);

      return res.documentID;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'documentID')
  explanation: |-
    The error is caused by attempting to access a property `documentID` on the `res` object that does not exist. The correct property name should be `id`, as in the original code. The `addDoc` function returns an object with an `id` property, not `documentID`.
  id: |-
    hubfix_hub_358
  lang: |-
    deno
  original_code: |
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import { addDoc, collection, getFirestore } from "npm:firebase/firestore/lite";

    /**
     * Learn more about adding documents at
     * https://firebase.google.com/docs/firestore/manage-data/add-data
     *
     * @returns The ID of the new document.
     */
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      document: Record<string, any>,
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const colRef = collection(store, collection_id);
      const res = await addDoc(colRef, document);

      return res.id;
    }
  original_instructions: |-
    Create Document in firebase
  resource_type: |-
    Firebase
  resource_type_def: |-
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      list_id: number, // Changed list_id type from string to number
      contact_sample?: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists/${list_id}`,
        method: "GET",
        qs: {
          contact_sample,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: list_id (number) must be a string.
  explanation: |-
    The `list_id` parameter was originally expected to be a string, as it is used to construct a URL. In the broken code, the type of `list_id` was changed from `string` to `number`, which is incorrect because URL paths must be strings. When TypeScript compiles this code, it will throw a type error because the `list_id` is being used in a template literal to construct a string, and TypeScript expects all values interpolated into strings to be of type `string`, not `number`.
  id: |-
    hubfix_hub_224
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param contact_sample If `true` then `contact_sample` will be returned with the result.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      list_id: string,
      contact_sample?: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists/${list_id}`,
        method: "GET",
        qs: {
          contact_sample,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Get A Contact List in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      email: number, // Changed email type from string to number
      on_behalf_of?: string,
    ) {
      sendgrid.setApiKey(api_token.token);
      const headers: Record<string, string> = { Accept: "application/json" };
      if (on_behalf_of) {
        headers["on-behalf-of"] = on_behalf_of;
      }

      const request = {
        url: `/v3/suppression/bounces/${email}`, // Using email as a number in a template string
        method: "GET",
        headers,
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: Cannot convert a Symbol value to a string
        at String (native)
        at main (/path/to/script.ts:xx:xx)
  explanation: |-
    The error occurs because the `email` parameter type was changed from `string` to `number`, and then it is used in a template string to construct a URL. While numbers can be coerced into strings implicitly in JavaScript/TypeScript, if `email` were to be a more complex type (like a Symbol, which cannot be converted to a string), it would cause a TypeError when attempting to convert it to a string within the template literal. Additionally, the API likely expects an email address as a string, not a number, so even if the number were converted to a string, it would not be a valid email address and would cause the API call to fail.
  id: |-
    hubfix_hub_217
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param on_behalf_of The subuser's username. This header generates the
     * API call as if the subuser account was making the call.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      email: string,
      on_behalf_of?: string,
    ) {
      sendgrid.setApiKey(api_token.token);
      const headers: Record<string, string> = { Accept: "application/json" };
      if (on_behalf_of) {
        headers["on-behalf-of"] = on_behalf_of;
      }

      const request = {
        url: `/v3/suppression/bounces/${email}`,
        method: "GET",
        headers,
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Get A Bounce in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      on_behalf_of?: string,
      start_time?: number,
      end_time?: number,
      limit?: number,
      offset?: number,
    ) {
      sendgrid.setApiKey(api_token.token);
      const headers: Record<string, string> = { Accept: "application/json" };
      if (on_behalf_of) {
        headers["on-behalf-of"] = on_behalf_of;
      }

      const request = {
        url: `/v3/suppression/bounces`,
        method: "GET",
        headers,
        qs: {
          start_time,
          end_time,
          limit,
          offset,
        },
      };

      try {
        const [_, body] = await sendgrid.makeRequest(request); // Changed from request to makeRequest
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: sendgrid.makeRequest is not a function
  explanation: |-
    The code is attempting to call a method `makeRequest` on the `sendgrid` object, which does not exist in the SendGrid client library. The correct method name is `request`, and by changing it to `makeRequest`, the code is trying to call a function that isn't defined, resulting in a `TypeError`.
  id: |-
    hubfix_hub_216
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param on_behalf_of The subuser's username. This header generates the
     * API call as if the subuser account was making the call.
     *
     * @param start_time The start of the time range in unix timestamp
     * when a bounce was created (inclusive).
     *
     * @param end_time The end of the time range in unix timestamp
     * when a bounce was created (inclusive).
     *
     * @param limit Limit the number of returned elements. Default is 500.
     *
     * @param offset Pagination.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      on_behalf_of?: string,
      start_time?: number,
      end_time?: number,
      limit?: number,
      offset?: number,
    ) {
      sendgrid.setApiKey(api_token.token);
      const headers: Record<string, string> = { Accept: "application/json" };
      if (on_behalf_of) {
        headers["on-behalf-of"] = on_behalf_of;
      }

      const request = {
        url: `/v3/suppression/bounces`,
        method: "GET",
        headers,
        qs: {
          start_time,
          end_time,
          limit,
          offset,
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Get All Bounces in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";
    import type { AssociationSpec } from "npm:@hubspot/api-client@^8.1.0/lib/codegen/crm/contacts/index.js";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: number,
      to_object_type: string,
      to_object_id: number,
      associations: AssociationSpec[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        associations =
          associations?.map((c) => {
            return typeof c === "string" ? JSON.parse(c) : c;
          }) || [];
      } catch (error) {
        throw Error(`Tried to parse "associations" argument because
        it was an array of strings but failed with error:\n${error}
        Associations must have the following shape:
          {
            associationCategory: 'HUBSPOT_DEFINED' | 'USER_DEFINED' | 'INTEGRATOR_DEFINED',
            associationTypeId: number
          }
        `);
      }

      try {
        return await client.crm.contacts.associationsApi.create(
          contact_id,
          to_object_type,
          to_object_id,
          associations,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.message || e}\n
        `);
      }
    }

    const result = await main({ token: 'fake_token' }, 123, 'company', 456, [{ associationCategory: 'HUBSPOT_DEFINED', associationTypeId: 1 }]);
    console.log(result);
  error: |-
    TypeError: Cannot read properties of undefined (reading 'associationsApi')
  explanation: |-
    The error occurs because the script is trying to access `associationsApi` on `client.crm.contacts`, which is undefined. This could be due to a number of reasons, such as the API client not being properly initialized, the `associationsApi` not being a part of the `contacts` object, or the `contacts` object itself not existing on the `crm` object of the client. It's also possible that the version of the `@hubspot/api-client` being used does not support the method being called, or that there is a typo in the method name. The error message indicates that the script is trying to access a property of an undefined object, which is a common mistake when working with JavaScript objects and APIs.
  id: |-
    hubfix_hub_228
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";
    import type { AssociationSpec } from "npm:@hubspot/api-client@^8.1.0/lib/codegen/crm/contacts/index.js";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: number,
      to_object_type: string,
      to_object_id: number,
      associations: AssociationSpec[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        associations =
          associations?.map((c) => {
            return typeof c === "string" ? JSON.parse(c) : c;
          }) || [];
      } catch (error) {
        throw Error(`Tried to parse "associations" argument because
        it was an array of strings but failed with error:\n${error}
        Associations must have the following shape:
          {
            associationCategory: 'HUBSPOT_DEFINED' | 'USER_DEFINED' | 'INTEGRATOR_DEFINED',
            associationTypeId: number
          }
        `);
      }

      try {
        return await client.crm.contacts.associationsApi.create(
          contact_id,
          to_object_type,
          to_object_id,
          associations,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }
  original_instructions: |-
    Create Associations in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      channel: string = undefined,
      timestamp: string = undefined,
      file: string = undefined,
    ) {
      const web = new WebClient(slack_auth.token);

      let response = await web.stars.add({
        channel: channel,
        timestamp: timestamp,
        file: file,
        foo: "bar", // This property does not exist in the expected parameters
      });

      return { response: response };
    }
  error: |-
    TypeError: Unknown argument: foo
  explanation: |-
    The error is caused by passing an object with a property `foo` to the `web.stars.add` method, which is not a valid parameter for the Slack API method `stars.add`. The Slack API client expects specific parameters, and `foo` is not one of them, so it throws a TypeError indicating that an unknown argument was provided.
  id: |-
    hubfix_hub_22
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      channel: string = undefined, // Channel to add star to, or channel where the message to add star to was posted (used with timestamp)
      timestamp: string = undefined, // Timestamp of the message to add star to
      file: string = undefined, // File to add star to
    ) {
      const web = new WebClient(slack_auth);

      let response = await web.stars.add({
        channel: channel,
        timestamp: timestamp,
        file: file,
      });

      return { response: response };
    }
  original_instructions: |-
    Add Star in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string,
      subject: string,
      message: string,
      is_message_html: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, string> = { to, from, subject };
      messageObject[is_message_html ? "html" : "text"] = message;

      try {
        return await sendgrid.sendEmail(messageObject);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: sendgrid.sendEmail is not a function
  explanation: |-
    The code is attempting to call a method `sendEmail` on the `sendgrid` object, which does not exist. The correct method name according to the SendGrid library is `send`, not `sendEmail`. This is a common mistake where a developer might confuse the method name with a similar or expected name.
  id: |-
    hubfix_hub_214
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/mail@^7.7.0";

    /**
     * @param is_message_html If `true` then the message will be sent and parsed as HTML,
     * otherwise it will be sent as plain text.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      from: string,
      to: string,
      subject: string,
      message: string,
      is_message_html: boolean,
    ) {
      sendgrid.setApiKey(api_token.token);
      const messageObject: Record<string, string> = { to, from, subject };
      messageObject[is_message_html ? "html" : "text"] = message;

      try {
        return await sendgrid.send(messageObject);
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Send Email Single Recipient in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      apiKey: string;
    };
    export async function main(api_token: Sendgrid, job_id: string) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/contacts/imports/${job_id}`,
        method: "POST", // Changed from "GET" to "POST"
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: sendgrid.setApiKey is not a function
  explanation: |-
    The code is broken because of the following reasons:

    1. The `Sendgrid` type has a property named `apiKey`, but in the `main` function, `api_token.token` is used instead of `api_token.apiKey`. This will result in `undefined` being passed to `setApiKey`, which is not the correct usage.

    2. The `setApiKey` function is being called as if it is a method of the `sendgrid` object, but if the `sendgrid` module does not export such a method, this will result in a TypeError stating that `sendgrid.setApiKey` is not a function.

    3. The method of the request was changed from "GET" to "POST". If the API endpoint does not support the "POST" method for the given URL, this could result in an error response from the SendGrid API, although this would not cause a TypeScript compilation error.
  id: |-
    hubfix_hub_220
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(api_token: Sendgrid, job_id: string) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/contacts/imports/${job_id}`,
        method: "GET",
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Get Contacts Job Status in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };

    export async function main(
      auth: Telegram,
      chat_id: string | number,
      image: string,
      reply_to_message_id?: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.sendImage(chat_id, image, {
        reply_to_message_id,
      });
    }
  error: |-
    TypeError: client.sendImage is not a function
  explanation: |-
    The code is attempting to call a method `sendImage` on the `client` object, which is an instance of `Telegram`. However, the `Telegram` class from the `telegraf` library does not have a method called `sendImage`. The correct method name should be `sendPhoto`, as it was in the original code. By changing `sendPhoto` to `sendImage`, the code is now trying to call a non-existent method, which results in a `TypeError` when the code is executed.
  id: |-
    hubfix_hub_236
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";
    /**
     * @param photo The path or URL to the image.
     */
    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string | number,
      photo: string,
      reply_to_message_id?: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.sendPhoto(chat_id, photo, {
        reply_to_message_id,
      });
    }
  original_instructions: |-
    Send a Photo in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(gsheets_auth: Gsheets, spreadsheetId: number) {
      const token = gsheets_auth["token"];

      const GET_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?&fields=sheets.properties`;

      const response = await fetch(GET_WORKSHEET_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.json();

      let list = [];
      for (let i in text["sheets"]) {
        list.push({
          sheetId: text["sheets"][i]["properties"]["sheetId"],
          title: text["sheets"][i]["properties"]["title"],
        });
      }

      return list;
    }
  error: |-
    TypeError: spreadsheetId is not a string.
  explanation: |-
    The error is caused by changing the type of the `spreadsheetId` parameter from `string` to `number`. The `spreadsheetId` should be a string because it is used to construct a URL, and URLs are strings. By changing the type to `number`, the code will break if a number is passed instead of a string, resulting in an invalid URL.
  id: |-
    hubfix_hub_68
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(gsheets_auth: Gsheets, spreadsheetId: string) {
      const token = gsheets_auth["token"];

      const GET_WORKSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?&fields=sheets.properties`;

      const response = await fetch(GET_WORKSHEET_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.json();

      let list = [];
      for (let i in text["sheets"]) {
        list.push({
          sheetId: text["sheets"][i]["properties"]["sheetId"],
          title: text["sheets"][i]["properties"]["title"],
        });
      }

      return list;
    }
  original_instructions: |-
    List Worksheets in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(auth: Telegram, chat_id: number) {
      const client = new Telegram(auth.token);
      return await client.getChatMembersCount();
    }
  error: |-
    TypeError: client.getChatMembersCount is not a function
  explanation: |-
    The code is broken because of two reasons:

    1. The `chat_id` parameter type has been changed from `string` to `number`. The `getChatMembersCount` method expects a string as its argument, representing the chat ID.

    2. The `getChatMembersCount` method is called without any arguments, but it requires the `chat_id` parameter to be passed to it. The absence of the required argument will lead to a runtime error.
  id: |-
    hubfix_hub_242
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(auth: Telegram, chat_id: string) {
      const client = new Telegram(auth.token);
      return await client.getChatMembersCount(chat_id);
    }
  original_instructions: |-
    Get the Number of Members in a Chat in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    import { encode as base64UrlEncode } from "https://deno.land/std@0.82.0/encoding/base64url.ts";

    type Gmail = {
      token: string;
    };
    export async function main(
      gmail_auth: Gmail,
      to_email: string,
      subject: string,
      message: string,
      user_id: string = "me",
    ) {
      const token = gmail_auth["token"];
      if (!token) {
        throw Error(`
        No authentication token was found.
        Go to "https://app.windmill.dev/resources?connect_app=gmail" to connect Gmail,
        then select your token from the dropdown in the arguments window.
        (Click "Refresh" if you don't see your resource in the list.)\n`);
      }

      const text = `From: <${user_id}>\nTo: <${to_email}>\nSubject: ${subject}\n\r ${message}`;
      const textEncoder = new TextEncoder();
      const email = base64UrlEncode(textEncoder.encode(text));
      const body = JSON.stringify({
        raw: email,
      });
      const SEND_URL = `https://gmail.googleapis.com/gmail/v1/users/${user_id}/messages/send`;

      const response = await fetch(SEND_URL, {
        method: "POST",
        headers: { Authorization: "Bearer " + token },
        body,
      });

      const result = await handleSendEmailResult(await response.json(), to_email);
      return result;
    }

    async function handleSendEmailResult(result: object, to_email: string) {
      if (Object.keys(result).includes("error")) {
        return Promise.reject({ wm_to_email: to_email, ...result });
      }

      return result;
    }

    main({ token: null }, "example@example.com", "Subject", "Message").catch(console.error);
  error: |-
    TypeError: Cannot read properties of null (reading 'token')
  explanation: |-
    The error occurs because the `token` property of the `gmail_auth` object is explicitly set to `null` when calling the `main` function at the bottom of the script. In TypeScript, `null` is not a valid value for a string type, and the `token` property is expected to be a string according to the `Gmail` type definition. When the script tries to access `gmail_auth["token"]`, it throws a TypeError because it's trying to read the 'token' property of `null`, which is not possible.
  id: |-
    hubfix_hub_194
  lang: |-
    deno
  original_code: |
    import { encode as base64UrlEncode } from "https://deno.land/std@0.82.0/encoding/base64url.ts";

    /**
     * @param user_id User's email address. The special value `me` can be used to indicate the authenticated user.
     */
    type Gmail = {
      token: string;
    };
    export async function main(
      gmail_auth: Gmail,
      to_email: string,
      subject: string,
      message: string,
      user_id: string = "me",
    ) {
      const token = gmail_auth["token"];
      if (!token) {
        throw Error(`
        No authentication token was found.
        Go to "https://app.windmill.dev/resources?connect_app=gmail" to connect Gmail,
        then select your token from the dropdown in the arguments window.
        (Click "Refresh" if you don't see your resource in the list.)\n`);
      }

      const text = `From: <${user_id}>\nTo: <${to_email}>\nSubject: ${subject}\n\r ${message}`;
      const textEncoder = new TextEncoder();
      const email = base64UrlEncode(textEncoder.encode(text));
      const body = JSON.stringify({
        raw: email,
      });
      const SEND_URL = `https://gmail.googleapis.com/gmail/v1/users/${user_id}/messages/send`;

      const response = await fetch(SEND_URL, {
        method: "POST",
        headers: { Authorization: "Bearer " + token },
        body,
      });

      const result = await handleSendEmailResult(await response.json(), to_email);
      return result;
    }

    async function handleSendEmailResult(result: object, to_email: string) {
      if (Object.keys(result).includes("error")) {
        return Promise.reject({ wm_to_email: to_email, ...result });
      }

      return result;
    }
  original_instructions: |2-
     Send Email in gmail
  resource_type: |-
    Gmail
  resource_type_def: |-
    type Gmail = {
      token: string;
    }
- broken_code: "import { S3Client } from \"https://deno.land/x/s3_lite_client@0.5.0/mod.ts\"\
    ;\nimport { format } from \"https://deno.land/std@0.89.0/datetime/mod.ts\";\n\
    import { mime } from \"https://deno.land/x/mimetypes@v1.0.0/mod.ts\";\n\nconst\
    \ MESSAGES_I9 = {\n  en: {\n    error_mimetype: \"File type could not be identified\"\
    ,\n    error_file_upload: \"Error uploading file (S3)\",\n  },\n  pt_br: {\n \
    \   error_mimetype: \"Tipo do arquivo n\xE3o p\xF4de ser identificado\",\n   \
    \ error_file_upload: \"Erro ao enviar arquivo (S3)\",\n  },\n};\nconst MESSAGES\
    \ = MESSAGES_I9.en;\n\nfunction base64MimeType(encoded: string) {\n  let result\
    \ = null;\n\n  if (typeof encoded !== \"string\") {\n    return result;\n  }\n\
    \n  const match = encoded.match(/data:([a-zA-Z0-9]+\\/[a-zA-Z0-9-.+]+).*,.*/);\n\
    \  if (match && match.length) {\n    result = {\n      mimetype: match[1],\n \
    \     extension: mime.getExtension(match[1]),\n    };\n  }\n\n  return result;\n\
    }\n\ntype S3 = {\n  endPoint: string;\n  port: number;\n  useSSL: boolean;\n \
    \ pathStyle: boolean;\n  bucket: string;\n  accessKey: string;\n  secretKey: string;\n\
    \  region: string;\n};\nexport async function main(s3: S3, files: string[]) {\n\
    \  if (files.length <= 0) {\n    return;\n  }\n\n  const s3client = new S3Client(s3);\n\
    \n  const out: any[] = [];\n  let error_count = 0;\n\n  await Promise.all(\n \
    \   files.map(async (file: string) => {\n      try {\n        const mime_data\
    \ = base64MimeType(file)!;\n        if (mime_data) {\n          const file_name\
    \ =\n            format(new Date(), \"yyyy-MM-dd-HH-mm-ss\") +\n            \"\
    -\" +\n            Math.random().toString(36).substring(2, 8) +\n            \"\
    .\" +\n            mime_data.extension;\n          const base64Data = file.replace(/^data:\\\
    w+\\/\\w+;base64,/, \"\");\n          const bytes = Uint8Array.from(atob(base64Data),\
    \ (c) =>\n            c.charCodeAt(0),\n          );\n\n          await s3client.putObject(file_name,\
    \ bytes, {\n            metadata: {\n              \"Content-Type\": mime_data.mimetype,\n\
    \            },\n          });\n\n          const url = `https://${s3[\"endpoint\"\
    ]}/${s3[\"bucket\"]}/${file_name}`;\n          out.push({\n            success:\
    \ true,\n            url,\n          });\n        } else {\n          out.push({\n\
    \            success: false,\n            message: MESSAGES.error_mimetype,\n\
    \          });\n          error_count++;\n        }\n      } catch (error) {\n\
    \        out.push({\n          success: false,\n          message: `${MESSAGES.error_file_upload}\
    \ (S3): ${error.message}`,\n        });\n        error_count++;\n      }\n   \
    \ }),\n  );\n\n  return { error_count, files: out };\n}"
  error: |-
    TypeError: Cannot read properties of undefined (reading 'endpoint')
  explanation: |-
    The code is trying to access a property `endpoint` on the `s3` object, but the actual property name defined in the `S3` type is `endPoint` with a capital 'P'. JavaScript property names are case-sensitive, so `s3["endpoint"]` is undefined because there is no property with that exact name. The correct property name to use is `s3["endPoint"]`.
  id: |-
    hubfix_hub_309
  lang: |-
    deno
  original_code: "import { S3Client } from \"https://deno.land/x/s3_lite_client@0.5.0/mod.ts\"\
    ;\nimport { format } from \"https://deno.land/std@0.89.0/datetime/mod.ts\";\n\
    import { mime } from \"https://deno.land/x/mimetypes@v1.0.0/mod.ts\";\n\nconst\
    \ MESSAGES_I9 = {\n  en: {\n    error_mimetype: \"File type could not be identified\"\
    ,\n    error_file_upload: \"Error uploading file (S3)\",\n  },\n  pt_br: {\n \
    \   error_mimetype: \"Tipo do arquivo n\xE3o p\xF4de ser identificado\",\n   \
    \ error_file_upload: \"Erro ao enviar arquivo (S3)\",\n  },\n};\nconst MESSAGES\
    \ = MESSAGES_I9.en;\n\n/****\n * Returns the mimetype and extension of a base64\
    \ encoded file\n * @param encoded Base64 encoded file\n * @returns Object with\
    \ mimetype and extension\n */\nfunction base64MimeType(encoded: string) {\n  let\
    \ result = null;\n\n  if (typeof encoded !== \"string\") {\n    return result;\n\
    \  }\n\n  const match = encoded.match(/data:([a-zA-Z0-9]+\\/[a-zA-Z0-9-.+]+).*,.*/);\n\
    \  if (match && match.length) {\n    result = {\n      mimetype: match[1],\n \
    \     extension: mime.getExtension(match[1]),\n    };\n  }\n\n  return result;\n\
    }\n\n/****\n * Uploads a list of files to S3\n * @param s3 S3 resource\n * @param\
    \ files Array of base64 encoded files\n * @returns Object with error_count and\
    \ array of results (files URLs or error messages)\n *\n * Detects file type/extension\
    \ using base64 header (e.g. \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAA...\"\
    ).\n * The output of File Input component can be used as parameter for this function.\n\
    \ */\ntype S3 = {\n  endPoint: string;\n  port: number;\n  useSSL: boolean;\n\
    \  pathStyle: boolean;\n  bucket: string;\n  accessKey: string;\n  secretKey:\
    \ string;\n  region: string;\n};\nexport async function main(s3: S3, files: string[])\
    \ {\n  if (files.length <= 0) {\n    return;\n  }\n\n  const s3client = new S3Client(s3);\n\
    \n  const out: any[] = [];\n  let error_count = 0;\n\n  await Promise.all(\n \
    \   files.map(async (file: string) => {\n      try {\n        const mime_data\
    \ = base64MimeType(file)!;\n        if (mime_data) {\n          const file_name\
    \ =\n            format(new Date(), \"yyyy-MM-dd-HH-mm-ss\") +\n            \"\
    -\" +\n            Math.random().toString(36).substring(2, 8) +\n            \"\
    .\" +\n            mime_data.extension;\n          const base64Data = file.replace(/^data:\\\
    w+\\/\\w+;base64,/, \"\");\n          const bytes = Uint8Array.from(atob(base64Data),\
    \ (c) =>\n            c.charCodeAt(0),\n          );\n\n          await s3client.putObject(file_name,\
    \ bytes, {\n            metadata: {\n              \"Content-Type\": mime_data.mimetype,\n\
    \            },\n          });\n\n          const url = `https://${s3[\"endPoint\"\
    ]}/${s3[\"bucket\"]}/${file_name}`;\n          out.push({\n            success:\
    \ true,\n            url,\n          });\n        } else {\n          out.push({\n\
    \            success: false,\n            message: MESSAGES.error_mimetype,\n\
    \          });\n          error_count++;\n        }\n      } catch (error) {\n\
    \        out.push({\n          success: false,\n          message: `${MESSAGES.error_file_upload}\
    \ (S3): ${error.message}`,\n        });\n        error_count++;\n      }\n   \
    \ }),\n  );\n\n  return { error_count, files: out };\n}\n"
  original_instructions: |-
    Put a list of objects in a bucket in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- broken_code: |-
    export async function main() {
      const keys = await window.crypto.subtle.generateKey(
        {
          name: "RSA-PSS",
          modulusLength: 1024,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: "SHA-256",
        },
        true,
        ["sign", "verify"],
      );
      return {
        private: await exportKey(keys.privateKey, true),
        public: await exportKey(keys.publicKey, false),
      };
    }

    async function exportKey(key: CryptoKey, isPrivateKey: boolean) {
      const exported = await window.crypto.subtle.exportKey(
        isPrivateKey ? "pkcs8" : "spki",
        key,
      );
      const exportedAsString = ab2str(exported);
      const exportedAsBase64 = window.btoa(exportedAsString);
      const pemExported = `-----BEGIN ${
        isPrivateKey ? "PRIVATE" : "PUBLIC"
      } KEY-----\n${exportedAsBase64}\n-----END PRIVATE KEY-----`;

      return pemExported;
    }

    function ab2str(buf: ArrayBuffer) {
      return String.fromCharCode.apply(null, new Uint16Array(buf));
    }
  error: |-
    Uncaught (in promise) TypeError: The string to be encoded contains characters outside of the Latin1 range.
  explanation: |-
    The error occurs because the `ab2str` function is trying to convert an `ArrayBuffer` to a string using `String.fromCharCode.apply`, but it's using `Uint16Array` instead of `Uint8Array`. The `Uint16Array` will include characters outside of the Latin1 range, which cannot be encoded by `window.btoa` since it only supports Latin1 (ISO/IEC 8859-1) characters. To fix the error, `Uint8Array` should be used instead of `Uint16Array` to ensure that the characters are within the Latin1 range.
  id: |-
    hubfix_hub_279
  lang: |-
    deno
  original_code: |
    export async function main() {
      const keys = await window.crypto.subtle.generateKey(
        {
          name: "RSA-PSS",
          modulusLength: 1024,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: "SHA-256",
        },
        true,
        ["sign", "verify"],
      );
      return {
        private: await exportKey(keys.privateKey, true),
        public: await exportKey(keys.publicKey, false),
      };
    }

    async function exportKey(key: CryptoKey, isPrivateKey: boolean) {
      const exported = await window.crypto.subtle.exportKey(
        isPrivateKey ? "pkcs8" : "spki",
        key,
      );
      const exportedAsString = ab2str(exported);
      const exportedAsBase64 = window.btoa(exportedAsString);
      const pemExported = `-----BEGIN ${
        isPrivateKey ? "PRIVATE" : "PUBLIC"
      } KEY-----\n${exportedAsBase64}\n-----END PRIVATE KEY-----`;

      return pemExported;
    }

    function ab2str(buf: ArrayBuffer) {
      return String.fromCharCode.apply(null, new Uint8Array(buf));
    }
  original_instructions: |-
    Generate an RSA PSS key pair in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(client: string) {
      const encoded = new TextEncoder().encode(client);

      let privateKey = await importPrivateKey(
        (await wmill.getVariable("u/user/your_private_key"))!,
      );
      let signature = await crypto.subtle.sign(
        {
          name: "RSA-PSS",
          saltLength: "32", // Changed saltLength from number to string
        },
        privateKey,
        encoded,
      );

      const licenseKey = `${btoa(client)}.${abToBase64(signature)}`;

      return licenseKey;
    }

    function abToBase64(arrayBuffer: ArrayBuffer) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));
    }

    function importPrivateKey(pem: string) {
      const binaryDerString = window.atob(pem);
      const binaryDer = str2ab(binaryDerString);

      return window.crypto.subtle.importKey(
        "pkcs8",
        binaryDer,
        {
          name: "RSA-PSS",
          hash: "SHA-256",
        },
        true,
        ["sign"],
      );
    }

    function str2ab(str: string) {
      const buf = new ArrayBuffer(str.length);
      const bufView = new Uint8Array(buf);
      for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }
  error: |-
    TypeError: Failed to execute 'sign' on 'SubtleCrypto': The provided value '32' is not a valid enum value of type RsaPssParams.
  explanation: |-
    The error is caused by changing the `saltLength` from a number to a string in the `sign` method's parameters. The `saltLength` should be a number, not a string. In cryptographic functions, parameters like salt lengths are expected to be numeric values, as they represent the number of bytes to be used. By providing a string instead of a number, the code violates the expected parameter type, leading to a type error when the `sign` method is called.
  id: |-
    hubfix_hub_278
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(client: string) {
      const encoded = new TextEncoder().encode(client);

      // key generated by https://hub.windmill.dev/scripts/helper/1509/generate-an-rsa-pss-key-pair-helper
      let privateKey = await importPrivateKey(
        (await wmill.getVariable("u/user/your_private_key"))!,
      );
      let signature = await crypto.subtle.sign(
        {
          name: "RSA-PSS",
          saltLength: 32,
        },
        privateKey,
        encoded,
      );

      // Combine the encoded data and signature to create a license key
      const licenseKey = `${btoa(client)}.${abToBase64(signature)}`;

      return licenseKey;
    }

    function abToBase64(arrayBuffer: ArrayBuffer) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));
    }

    function importPrivateKey(pem: string) {
      const binaryDerString = window.atob(pem);
      const binaryDer = str2ab(binaryDerString);

      return window.crypto.subtle.importKey(
        "pkcs8",
        binaryDer,
        {
          name: "RSA-PSS",
          hash: "SHA-256",
        },
        true,
        ["sign"],
      );
    }

    function str2ab(str: string) {
      const buf = new ArrayBuffer(str.length);
      const bufView = new Uint8Array(buf);
      for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }
  original_instructions: |-
    Generate a license key using RSA PSS for a customer in helper
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(
      discord_webhook: DiscordWebhook,
      message: string,
      name: string,
    ) {
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      message = `Flow [${flow_id}](${Deno.env.get(
        "WM_BASE_URL",
      )}/run/${flow_id}?workspace=${Deno.env.get(
        "WM_WORKSPACE",
      )}) had an error:\n${name}: ${message}`;
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.createMessage(message, {username: name});
      return ret;
    }
  error: |-
    TypeError: webhook.createMessage is not a function
  explanation: |-
    The error occurs because the `createMessage` method is being called with an additional parameter `{username: name}` which does not match the expected signature of the `createMessage` method in the `discordwebhook` module. The `discordwebhook` module's `createMessage` method expects only one argument, which is the message string. By passing an object as the second argument, the code is attempting to call a method that does not exist with that signature, resulting in a `TypeError`.
  id: |-
    hubfix_hub_291
  lang: |-
    deno
  original_code: |
    import discordwebhook from "https://deno.land/x/discordwebhook/mod.ts";

    type DiscordWebhook = {
      webhook_url: string;
    };
    export async function main(
      discord_webhook: DiscordWebhook,
      message: string,
      name: string,
    ) {
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      message = `Flow [${flow_id}](${Deno.env.get(
        "WM_BASE_URL",
      )}/run/${flow_id}?workspace=${Deno.env.get(
        "WM_WORKSPACE",
      )}) had an error:\n${name}: ${message}`;
      const webhook = new discordwebhook(discord_webhook.webhook_url);
      const ret = await webhook.createMessage(message);
      return ret;
    }
  original_instructions: |-
    Send the error to discord in discord
  resource_type: |-
    DiscordWebhook
  resource_type_def: |-
    type DiscordWebhook = {
      webhook_url: string;
    }
- broken_code: |-
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, username: number) {
      const octokit = new Octocat({ auth: gh_auth.token });

      return await octokit.request("GET /users/{username}", {
        user: username,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  error: |-
    TypeError: Octocat is not a constructor
  explanation: |-
    The code is broken for several reasons:

    1. The import statement is incorrect. The original code imports `Octokit` from the `@octokit/rest` package, but the broken code attempts to import `Octocat`, which does not exist in the package. This will result in a `TypeError` because `Octocat` is not a constructor.

    2. The `username` parameter type has been changed from `string` to `number`, which is incorrect because the GitHub API expects a username as a string, not a number.

    3. The `octokit.request` method is called with an incorrect parameter name. The original code uses `username`, but the broken code uses `user`, which is not recognized by the `octokit.request` method.

    These changes will cause the code to fail to compile and run.
  id: |-
    hubfix_hub_316
  lang: |-
    deno
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, username: string) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request("GET /users/{username}", {
        username,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });
    }
  original_instructions: |-
    Get a user in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(gsheets_auth: Gsheets, spreadsheetId: number) {
      const token = gsheets_auth["token"];

      const GET_SPREADSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}`;

      const response = await fetch(GET_SPREADSHEET_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Invalid name
  explanation: |-
    The code is broken for several reasons:

    1. The `spreadsheetId` parameter type has been changed from `string` to `number`. The URL construction requires a string, and using a number will cause the URL to be invalid, leading to a fetch error.

    2. The `fetch` method is changed from "GET" to "POST". If the API endpoint only supports GET requests for retrieving spreadsheet data, using POST will result in an error.

    3. The return type of the function is changed from `json()` to `text()`. If the API returns JSON data, using `text()` will not parse the JSON, which could lead to issues if the calling code expects a JSON object.

    The error message provided is a generic fetch error message and may not accurately reflect the specific errors introduced in the code. In a real-world scenario, the error message would depend on the actual response from the API server and the runtime environment.
  id: |-
    hubfix_hub_51
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(gsheets_auth: Gsheets, spreadsheetId: string) {
      const token = gsheets_auth["token"];

      const GET_SPREADSHEET_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}`;

      const response = await fetch(GET_SPREADSHEET_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Get Spreadsheet in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter?: Record<string, any>,
      projection?: Record<string, number>,
      sort?: Record<string, number>,
      limit?: number,
      skip?: number,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.find(
        filter,
        removeObjectEmptyFields({ projection, sort, limit, skip, extraField: true }),
      );
    }
  error: |-
    TypeError: An object literal cannot have multiple properties with the same name in strict mode.
  explanation: |-
    The code is trying to pass an object with an extra field `extraField` to the `removeObjectEmptyFields` function, which is not expected by the function's signature. This is not a valid change because the `removeObjectEmptyFields` function does not accept an `extraField` property, and it is not part of the original code. The error message provided is incorrect for this situation; the actual error would likely be a runtime error stating that the `extraField` is not a recognized property or parameter for the function, depending on how the `removeObjectEmptyFields` function is implemented.
  id: |-
    hubfix_hub_256
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     *
     * @param filter For example: `{ "_id": "01234" }`
     * Find out more at:
     * https://www.mongodb.com/docs/manual/reference/method/db.collection.find/
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      filter?: Record<string, any>,
      projection?: Record<string, number>,
      sort?: Record<string, number>,
      limit?: number,
      skip?: number,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.find(
        filter,
        removeObjectEmptyFields({ projection, sort, limit, skip }),
      );
    }
  original_instructions: |-
    Search Documents in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { QueryOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      topK: number,
      vector?: number[],
      id?: string,
      namespace?: string,
      include_values?: boolean,
      include_metadata?: boolean,
      filter?: object,
      raw?: boolean,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const queryRequest: QueryOperationRequest = removeObjectEmptyFields({
        topK,
        vector,
        id,
        namespace,
        includeValues: include_values,
        includeMetadata: include_metadata,
        filter,
      });
      return await index[raw ? "queryRaw" : "query"]({ queryRequests: queryRequest });
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'queryRaw')
  explanation: |-
    The error occurs because the property `queryRequests` does not exist on the object passed to the `index[raw ? "queryRaw" : "query"]` method. The correct property name should be `queryRequest` as defined in the original code. By changing it to `queryRequests`, the code is trying to access a property that does not exist, which leads to a runtime error when trying to execute the query.
  id: |-
    hubfix_hub_340
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { QueryOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    /**
     *
     * @param topK The number of results to return for each query.
     *
     * @param vector _(Conditionally Optional)_ The query vector. This should be the same length as the dimension
     * of the index being queried.
     * **Each query request can contain only one of the parameters "id" or "vector".**
     *
     * @param id _(Conditionally Optional)_ The unique ID of the vector to be used as a query vector.
     * **Each query request can contain only one of the parameters "vector" or "id".**
     *
     * @param namespace _(Optional)_ The namespace to query.
     *
     * @param includeValues _(Optional)_ Indicates whether vector values are included in the response.
     * Defaults to `false`.
     *
     * @param includeMetadata _(Optional)_ Indicates whether metadata is included in the response as well as the ids.
     * Defaults to `false`.
     *
     * @param filter _(Optional)_ The filter to apply. You can use vector metadata to limit your search.
     * See https://www.pinecone.io/docs/metadata-filtering/.
     */
    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      topK: number,
      vector?: number[],
      id?: string,
      namespace?: string,
      include_values?: boolean,
      include_metadata?: boolean,
      filter?: object,
      raw?: boolean,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const queryRequest: QueryOperationRequest = removeObjectEmptyFields({
        topK,
        vector,
        id,
        namespace,
        includeValues: include_values,
        includeMetadata: include_metadata,
        filter,
      });
      return await index[raw ? "queryRaw" : "query"]({ queryRequest });
    }
  original_instructions: |-
    Query Index in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- broken_code: |-
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     *
     * @param since_created_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param before_created_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param since_updated_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param before_updated_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      type?: string,
      since_created_at?: string,
      before_created_at?: string,
      since_updated_at?: string,
      before_updated_at?: string,
      include_cleaned?: boolean,
      include_transactional?: boolean,
      include_unsubscribed?: boolean,
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments`,
      );
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        type,
        since_created_at,
        before_created_at,
        since_updated_at,
        before_updated_at,
        include_cleaned,
        include_transactional,
        include_unsubscribed,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorizations: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'append' on 'URLSearchParams': The provided value is not of type '(string or sequence<string>)'.
  explanation: |-
    The error is caused by the incorrect header name used in the fetch request. The correct header for authorization should be "Authorization", but in the broken code, it is mistakenly written as "Authorizations". This typo would not cause a TypeScript error, but it would result in a runtime error because the server would not recognize the incorrect header and therefore could not authenticate the request properly.

    Additionally, the error message provided is not the one that would be generated by the typo in the header. The actual error message would be related to the server's response to the unauthorized request, which could vary depending on the server's implementation. The provided error message seems to be related to an issue with the URLSearchParams.append method, which is not the case here.
  id: |-
    hubfix_hub_211
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     *
     * @param since_created_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param before_created_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param since_updated_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param before_updated_at *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      type?: string,
      since_created_at?: string,
      before_created_at?: string,
      since_updated_at?: string,
      before_updated_at?: string,
      include_cleaned?: boolean,
      include_transactional?: boolean,
      include_unsubscribed?: boolean,
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments`,
      );
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        type,
        since_created_at,
        before_created_at,
        since_updated_at,
        before_updated_at,
        include_cleaned,
        include_transactional,
        include_unsubscribed,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Search Segments in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      campaign_id: string,
      fields?: string[],
      exclude_fields?: string[],
    ) {
      let url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}?`;
      if (fields?.length) {
        url += `fields=${fields.join(",")}`;
      }
      if (exclude_fields?.length) {
        url += `${fields?.length ? "&" : ""}exclude_fields=${exclude_fields.connect(
          ",",
        )}`;
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.blob();
    }
  error: |-
    TypeError: exclude_fields.connect is not a function
  explanation: |-
    The code is attempting to call a method `connect` on the array `exclude_fields`, which does not exist in JavaScript. The correct method for joining array elements into a string is `join`. Additionally, the function is returning `response.blob()` instead of `response.json()`, which would be incorrect if the expected response is JSON data. The correct method should be `response.json()`.
  id: |-
    hubfix_hub_200
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      campaign_id: string,
      fields?: string[],
      exclude_fields?: string[],
    ) {
      let url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}?`;
      if (fields?.length) {
        url += `fields=${fields.join(",")}`;
      }
      if (exclude_fields?.length) {
        url += `${fields?.length ? "&" : ""}exclude_fields=${exclude_fields.join(
          ",",
        )}`;
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Get Campaign in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      segment_id: string,
      fields?: string[],
      exclude_fields?: string[],
      include_cleaned?: boolean,
      include_transactional?: boolean,
      include_unsubscribed?: boolean,
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments/${segment_id}`,
      );
      const params = {
        fields,
        exclude_fields,
        include_cleaned,
        include_transactional,
        include_unsubscribed,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.connect(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: value.connect is not a function
  explanation: |-
    In the code block provided, the method `connect` is called on the `value` variable when it is an array. However, there is no `connect` method on arrays in JavaScript or TypeScript. The correct method to join array elements into a string is `join`. This is a common mistake where a developer might confuse the method name with something similar or from a different programming language.
  id: |-
    hubfix_hub_212
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      segment_id: string,
      fields?: string[],
      exclude_fields?: string[],
      include_cleaned?: boolean,
      include_transactional?: boolean,
      include_unsubscribed?: boolean,
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}/segments/${segment_id}`,
      );
      const params = {
        fields,
        exclude_fields,
        include_cleaned,
        include_transactional,
        include_unsubscribed,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Get Segment in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, name: string, id?: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.createDocument(id || ID.unique(), name);
    }
  error: |-
    TypeError: db.createDocument is not a function
  explanation: |-
    The error occurs because the method `createDocument` does not exist on the `db` object of type `Databases`. The correct method to create a database according to the Appwrite SDK is `create`, not `createDocument`. By calling a non-existent method, the script will throw a TypeError when executed.
  id: |-
    hubfix_hub_326
  lang: |-
    deno
  original_code: |
    import {
      Client,
      Databases,
      ID,
    } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param id ID of the user to be created. Leave blank to generate a unique ID.
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(auth: Appwrite, name: string, id?: string) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.create(id || ID.unique(), name);
    }
  original_instructions: |-
    Create Database in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    import { Client, Databases } from "https://deno.land/x/appwrite/mod.ts";

    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      queries?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
       setKey(auth.key); // Missing dot before setKey
      const db = new Databases(client);

      return await db.listDocuments(database_id, collection_id, queries);
    }
  error: |-
    TypeError: client.setProject(...).setKey is not a function
  explanation: |-
    The code is trying to chain method calls on the `client` object, but there is a missing dot before `setKey(auth.key)`. This causes the TypeScript compiler to think that `setKey` is being called on the result of `setProject(auth.project)`, which is not a function but the `client` object itself. To fix this, a dot should be added before `setKey(auth.key)` to properly chain the method call.
  id: |-
    hubfix_hub_335
  lang: |-
    deno
  original_code: |
    import { Client, Databases } from "https://deno.land/x/appwrite@7.0.0/mod.ts";

    /**
     * @param queries Array of query strings. Learn more about queries here:
     * https://appwrite.io/docs/queries
     */
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    };
    export async function main(
      auth: Appwrite,
      database_id: string,
      collection_id: string,
      queries?: string[],
    ) {
      const client = new Client()
        .setEndpoint(auth.endpoint)
        .setProject(auth.project)
        .setKey(auth.key);
      const db = new Databases(client);

      return await db.listDocuments(database_id, collection_id, queries);
    }
  original_instructions: |-
    List Documents in appwrite
  resource_type: |-
    Appwrite
  resource_type_def: |-
    type Appwrite = {
      endpoint: string;
      project: string;
      key: string;
      self_signed: boolean;
    }
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
      maxAttendees: number = 2, // Removed the optional parameter '?'
    ) {
      const sendNotifications = true;
      const sendUpdates = "all";
      const supportsAttachments = true;

      const CREATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/?maxAttendees=${maxAttendees}&sendNotifications=${sendNotifications}&sendUpdates=${sendUpdates}&supportsAttachments${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
      };

      const response = await fetch(CREATE_EVENT_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'json')
  explanation: |-
    The error message indicates that the `response` object does not have a `json` method. This could be due to several reasons, such as the `fetch` function not being available in the Deno runtime environment, the `fetch` call failing and returning an undefined `response`, or the `response` object not being what is expected.

    However, the provided code does not have an obvious error that would lead to this specific error message. The `fetch` function is a standard part of the Fetch API, which is available in Deno, and the `response` object should have a `json` method if the `fetch` call is successful.

    It's possible that the error message provided does not match the broken code example. If the `fetch` call fails due to network issues or an incorrect URL, the `response` object might still exist but not have a successful HTTP status, which could lead to issues when trying to parse the response as JSON. In such a case, it would be better to check the response status before attempting to call `response.json()`.
  id: |-
    hubfix_hub_42
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
      maxAttendees?: number = 2,
    ) {
      const sendNotifications = true;
      const sendUpdates = "all";
      const supportsAttachments = true;

      const CREATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/?maxAttendees=${maxAttendees}&sendNotifications=${sendNotifications}&sendUpdates=${sendUpdates}&supportsAttachments${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
      };

      const response = await fetch(CREATE_EVENT_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Create Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripeAuth: Stripe) {
      let has_more = true;
      let starting_after = "";
      const products = [];

      while (has_more) {
        const res = await getStripeProductsIds(stripeAuth.apiKey, starting_after);
        has_more = res.has_more;
        starting_after = res.data[res.data.length - 1].id;
        products.concat(res.data);
      }

      return products;
    }

    async function getStripeProductsIds(stripeKey: string, starting_after = "") {
      let url = "https://api.stripe.com/v1/products?limit=10";
      if (starting_after) {
        url += `&starting_after=${starting_after}`;
      }
      const products = await fetch(url, {
        headers: {
          Authorization: `Bearer ${stripeKey}`,
        },
      }).then((res) => res.json());

      return products;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'apiKey')
  explanation: |-
    The code is trying to access a property `apiKey` on the `stripeAuth` object, which does not exist. The correct property name is `token`, as defined in the `Stripe` type. This results in a `TypeError` because `stripeAuth.apiKey` is `undefined`.
  id: |-
    hubfix_hub_375
  lang: |-
    deno
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripeAuth: Stripe) {
      let has_more = true;
      let starting_after = "";
      const products = [];

      // if you have a lot of products (> 200), you may want to consider to throttle.
      while (has_more) {
        const res = await getStripeProductsIds(stripeAuth.token, starting_after);
        has_more = res.has_more;
        starting_after = res.data[res.data.length - 1].id;
        products.push(...res.data);
      }

      return products;
    }

    async function getStripeProductsIds(stripeKey: string, starting_after = "") {
      let url = "https://api.stripe.com/v1/products?limit=10";
      if (starting_after) {
        url += `&starting_after=${starting_after}`;
      }
      const products = await fetch(url, {
        headers: {
          Authorization: `Bearer ${stripeKey}`,
        },
      }).then((res) => res.json());

      return products;
    }
  original_instructions: |-
    Get all active stripe products from your account in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(approver?: string) {
      const endpoints = await wmill.getResumeUrls();
      console.log(`Approval page at ${endpoints.approvalPages}`);
      return endpoints;
    }
  error: |-
    error TS2554: Expected 1 arguments, but got 0.
  explanation: |-
    The `getResumeUrls` function is expected to be called with one argument, but in the broken code, it is called without any arguments. Additionally, the property `approvalPages` does not exist on the `endpoints` object; the correct property name is `approvalPage`.
  id: |-
    hubfix_hub_172
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(approver?: string) {
      const endpoints = await wmill.getResumeUrls(approver);
      console.log(`Approval page at ${endpoints.approvalPage}`);
      return endpoints;
    }
  original_instructions: |-
    Return resume and cancel endpoints in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      workflow_id: string,
      ref: string,
      inputs?: Record<string | number, any>,
    ) {
      const octokit = new Octocat({ auth: gh_auth.token });

      return await octokit.request(
        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
        {
          owner,
          repo,
          workflow_id,
          ref,
          inputs: inputs || {},
          headers: {
            "X-GitHub-Api-Version": "2022-11-28",
            Accept: "application/vnd.github+json",
          },
        },
      );
    }
  error: |-
    error: TS2305 [ERROR]: Module '"https://cdn.skypack.dev/@octokit/rest"' has no exported member 'Octocat'.
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";
             ~~~~~~~
  explanation: |-
    The code is trying to import `Octocat` from the `@octokit/rest` package, but no such export exists in the package. The correct class name that should be imported is `Octokit`. This is a common mistake where a developer might mistype the name of an import.
  id: |-
    hubfix_hub_312
  lang: |-
    deno
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     *
     * @param workflow_id The ID of the workflow. You can also pass the workflow file
     * name as a string.
     *
     * @param ref The git reference for the workflow. The reference can be a branch or
     * tag name.
     *
     * @param inputs Input keys and values configured in the workflow file. The maximum
     * number of properties is 10. Any default properties configured in the workflow
     * file will be used when inputs are omitted.
     */
    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      workflow_id: string,
      ref: string,
      inputs?: Record<string | number, any>,
    ) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request(
        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
        {
          owner,
          repo,
          workflow_id,
          ref,
          inputs: inputs || {},
          headers: {
            "X-GitHub-Api-Version": "2022-11-28",
            Accept: "application/vnd.github+json",
          },
        },
      );
    }
  original_instructions: |-
    Dispatch Workflow Run in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    const MAX_LOOKBACK = 100;

    export async function main(mentions: string[]) {
      let lastState = await getState();
      let maxItem = await getMaxItem();

      if (!lastState) {
        lastState = maxItem - MAX_LOOKBACK;
      }
      maxItem = Math.min(maxItem, lastState + MAX_LOOKBACK);

      const items = [];
      for (let i = lastState; i < maxItem; i++) {
        const item = await getItem(i);
        if (
          mentions.find((mention) => {
            if (!item.text) return false;

            const m = mention.trim().toLowerCase();
            return item.text.toLowercase().includes(m);
          })
        ) {
          items.push(item);
        }
      }
      await setState(maxItem);

      return items;
    }

    export async function getMaxItem() {
      const res = await fetch("https://hacker-news.firebaseio.com/v0/maxitem.json");
      return Number(await res.text());
    }

    export async function getItem(id: number) {
      const res = await fetch(
        `https://hacker-news.firebaseio.com/v0/item/${id}.json`,
      );
      return res.json();
    }
  error: |-
    TypeError: item.text.toLowercase is not a function
  explanation: |-
    The error is caused by a typo in the method name. The correct method name is `toLowerCase`, not `toLowercase`. JavaScript is case-sensitive, so it is important to use the correct case when calling methods on objects.
  id: |-
    hubfix_hub_88
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    const MAX_LOOKBACK = 100;

    /**
     * @param mentions Case **insensitive** phrases that should be searched for.
     */
    export async function main(mentions: string[]) {
      let lastState = await getState();
      let maxItem = await getMaxItem();

      if (!lastState) {
        lastState = maxItem - MAX_LOOKBACK;
      }
      maxItem = Math.min(maxItem, lastState + MAX_LOOKBACK);

      const items = [];
      for (let i = lastState; i < maxItem; i++) {
        const item = await getItem(i);
        if (
          mentions.find((mention) => {
            if (!item.text) return false;

            const m = mention.trim().toLowerCase();
            return item.text.toLowerCase().includes(m);
          })
        ) {
          items.push(item);
        }
      }
      await setState(maxItem);

      return items;
    }

    export async function getMaxItem() {
      const res = await fetch("https://hacker-news.firebaseio.com/v0/maxitem.json");
      return Number(await res.text());
    }

    export async function getItem(id: number) {
      const res = await fetch(
        `https://hacker-news.firebaseio.com/v0/item/${id}.json`,
      );
      return res.json();
    }
  original_instructions: |-
    Trigger everytime a new item text on HackerNews match at least one mention in hackernews
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, charge_id: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const refund = await stripe.refunds.create({
        payment_intent: `${charge_id}`,
      });

      return await refund.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'create')
  explanation: |-
    The code is trying to call `Stripe.createFetchHttpClient()`, but `Stripe` is a type, not an object with methods. Types in TypeScript are used for static type checking and do not exist at runtime. Therefore, trying to access a method on a type will result in a runtime error because the type does not have any properties or methods.

    Additionally, the `charge_id` parameter type was changed from `string` to `number`, which is incorrect because the `stripe.refunds.create` method expects a string for the `charge` property, not a number. This would also cause a type error if TypeScript's type checking were run before executing the code.

    Lastly, the `stripe.refunds.create` method is being called with a property `payment_intent` instead of `charge`. If the Stripe API does not have a `payment_intent` property for the refunds.create method, this would result in an incorrect API call and potentially an API error response.
  id: |-
    hubfix_hub_125
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, charge_id: string) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const refund = await stripe.refunds.create({
        charge: `${charge_id}`,
      });

      return await refund.json();
    }
  original_instructions: |-
    Create a Refund in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      type: string,
      state_key?: string,
    ) {
      let url = `${matrix_res.baseUri}/_matrix/client/v3/rooms/${encodeURIComponent(
        room_id,
      )}/state/${encodeURIComponent(type)}/`;
      if (state_key) {
        url += encodeURIComponent(state_key);
      }
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.apiToken}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return {
        content: await resp.text(),
      };
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseUri')
  explanation: |-
    The code is trying to access a property `baseUri` on the `matrix_res` object, which does not exist. The correct property name is `baseUrl`. Additionally, the code is trying to use `matrix_res.apiToken`, which is also incorrect because the correct property name is `token`. Lastly, the function is returning an object with a property `content` that is the result of `await resp.text()`, which may not be a breaking change but could be incorrect if the expected return type is supposed to be JSON, as the original code used `await resp.json()`.
  id: |-
    hubfix_hub_159
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      type: string,
      state_key?: string,
    ) {
      let url = `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
        room_id,
      )}/state/${encodeURIComponent(type)}/`;
      if (state_key) {
        url += encodeURIComponent(state_key);
      }
      const resp = await fetch(url, {
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
        },
      });
      if (!resp.ok) {
        throw Error(`Failed to read room state: Error HTTP${resp.status}`);
      }
      return {
        content: await resp.json(),
      };
    }
  original_instructions: |-
    Get room state by type and state_key in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: number, // Changed type from string to number
      eventId: string,
    ) {
      const sendUpdates = "all";

      const DELETE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?sendUpdates=${sendUpdates}`;

      const token = gcal_auth["token"];

      const response = await fetch(DELETE_EVENT_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return response.json(); // Changed from returning the response to returning the parsed JSON
    }
  error: |-
    TypeError: calendarId is not a string.
  explanation: |-
    The `calendarId` parameter was changed from a string to a number, which is incorrect because the URL requires a string. The `calendarId` is part of the URL path, and URLs are always strings. Additionally, the function now returns `response.json()` instead of `response`, which changes the return type from a `Response` object to a `Promise` of the parsed JSON body. This might not be a breaking change if the calling code expects the parsed JSON, but it is a change in behavior that could break existing code that expects a `Response` object.
  id: |-
    hubfix_hub_44
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
    ) {
      const sendUpdates = "all";

      const DELETE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?sendUpdates=${sendUpdates}`;

      const token = gcal_auth["token"];

      const response = await fetch(DELETE_EVENT_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return response;
    }
  original_instructions: |-
    Delete Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(auth: Mailchimp, campaign_id: number) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}/triggers/send`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.text();
    }
  error: |-
    TypeError: campaign_id (number) is not assignable to parameter of type string.
  explanation: |-
    The error is caused by changing the type of the `campaign_id` parameter from `string` to `number`. The URL construction relies on `campaign_id` being a string that can be concatenated with other strings to form the endpoint URL. By changing the type to `number`, TypeScript will throw a type error because it expects a string in that context.

    Additionally, the endpoint `/actions/send` was changed to `/triggers/send`, which may not exist in the Mailchimp API, leading to a runtime error if that endpoint is not defined. However, the TypeScript compiler won't catch this error because it's an API-specific issue.

    Lastly, the function's return type was implicitly changed from `Promise<any>` (as `response.json()` returns a promise that resolves with any type) to `Promise<string>` because `response.text()` returns a promise that resolves with a string. This might not be an error per se, but it could lead to issues if the calling code expects a JSON object instead of a string.
  id: |-
    hubfix_hub_203
  lang: |-
    deno
  original_code: |
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(auth: Mailchimp, campaign_id: string) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}/actions/send`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Send a Campaign in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    export async function main() {
      const url = "https://hub.windmill.dev/searchAppData";
      const response = await fetch(url);
      const data = await response.json();
      return data.appsData;
    }
  error: |-
    TypeError: Cannot read property 'appsData' of undefined
  explanation: |-
    The property `appsData` does not exist on the object returned by `response.json()`. The original code expects the JSON to have a structure that includes an `apps` property at the top level, but the modified code is trying to access a non-existent `appsData` property, which will result in a `TypeError` when attempting to access it if it's not present in the JSON structure.
  id: |-
    hubfix_hub_167
  lang: |-
    deno
  original_code: "// Should return {apps: [{\u2026},\u2026]}\n\nexport async function\
    \ main() {\n  const url = \"https://hub.windmill.dev/searchAppData\";\n  const\
    \ response = await fetch(url);\n  return await response.json();\n}\n"
  original_instructions: |-
    List Apps in windmillhub
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type SlackAuth = {
      token: string;
    };
    export async function main(slackAuth: SlackAuth, channel: string) {
      const web = new WebClient(slackAuth.token);

      let response = await web.conversations.leave({
        channel_id: channel,
      });

      return { response: response };
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'conversations')
  explanation: |-
    The code is broken because of two reasons:

    1. The type `Slack` was renamed to `SlackAuth`, but the parameter `slack_auth` in the `main` function was not updated to match the new type name. It should be `slackAuth: SlackAuth`.

    2. The `WebClient` constructor expects an object with a `token` property, but `slackAuth.token` is passed directly, which is incorrect. The correct way to pass the token is by providing an object: `new WebClient({ token: slackAuth.token })`.

    3. The property `channel_id` is used in the `web.conversations.leave` method call, but the Slack Web API expects the property to be named `channel`. The correct parameter should be `{ channel: channel }`.

    These changes cause the script to break because the `WebClient` instance is not properly initialized with the required token, and the incorrect parameter is passed to the `leave` method, which would result in a runtime error when trying to access the `conversations` property of `undefined`.
  id: |-
    hubfix_hub_23
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(slack_auth: Slack, channel: string) {
      const web = new WebClient(slack_auth);

      let response = await web.conversations.leave({
        channel: channel,
      });

      return { response: response };
    }
  original_instructions: |-
    Leave Channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      apiKey: string;
    };
    export async function main(
      auth: Hubspot,
      company?: string,
      email?: string,
      firstname?: string,
      lastname?: string,
      phone?: string,
      website?: string,
    ) {
      const client = new Client({
        accessToken: auth.apiKey,
      });
      const properties = removeObjectEmptyFields({
        company,
        email,
        firstname,
        lastname,
        phone,
        website,
      });
      try {
        return await client.crm.contacts.basicApi.create({ properties });
      } catch (e) {
        throw Error(`
          ${e.code} - ${e.body.category}\n
          Message: ${e.body.message}\n
          Correlation ID: ${e.body.correlationId}
        `);
      }
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'category')
  explanation: |-
    The error occurs because the `e.body` is likely undefined when trying to access `e.body.category`, `e.body.message`, and `e.body.correlationId`. This could happen if the error object `e` does not have a `body` property with the expected structure. The error handling assumes that the caught error will always have a `body` property with `category`, `message`, and `correlationId` fields, which might not be the case for all errors thrown by the `client.crm.contacts.basicApi.create` method. If the error object has a different structure or the `body` property is missing, trying to access these nested properties will result in a TypeError.
  id: |-
    hubfix_hub_226
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      company?: string,
      email?: string,
      firstname?: string,
      lastname?: string,
      phone?: string,
      website?: string,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });
      const properties = removeObjectEmptyFields({
        company,
        email,
        firstname,
        lastname,
        phone,
        website,
      });
      try {
        return await client.crm.contacts.basicApi.create({ properties });
      } catch (e) {
        throw Error(`
          ${e.code} - ${e.body.category}\n
          Message: ${e.body.message}\n
          Correlation ID: ${e.body.correlationId}
        `);
      }
    }
  original_instructions: |-
    Create Contact in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(text: string, channel: number, slack: Slack) {
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel: channel.toString(),
        text: text,
        as_user: true,
      });
    }
  error: |-
    TypeError: Argument of type '{ channel: string; text: string; as_user: boolean; }' is not assignable to parameter of type 'ChatPostMessageArguments'.
      Object literal may only specify known properties, and 'as_user' does not exist in type 'ChatPostMessageArguments'.
  explanation: |-
    The error occurs because the `as_user` property is not a valid property of the `ChatPostMessageArguments` type expected by the `postMessage` method of the `WebClient` class from the Slack Web API module. The `as_user` property was either removed from the API or was never a part of the `ChatPostMessageArguments` type, and thus, passing it as part of the arguments object is incorrect and causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_hub_72
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(text: string, channel: string, slack: Slack) {
      const web = new WebClient(slack.token);

      await web.chat.postMessage({
        channel,
        text,
      });
    }
  original_instructions: |-
    Send Message to Channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .update(values, { count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_updated) {
          query = query.select();
        }

        return query.execute(); // This method does not exist
      });
    }
  error: |-
    TypeError: query.execute is not a function
  explanation: |-
    The error occurs because the method `execute()` is called on the `query` object, but this method does not exist on the `query` object as defined by the API used in the script. The original code did not call `execute()`, and it is likely that the API expects the query to be executed without this method call. The correct usage would be to simply return the `query` object, which would be executed by the caller or by the API internally.
  id: |-
    hubfix_hub_284
  lang: |-
    deno
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param filter Learn more at https://supabase.com/docs/reference/javascript/filter
     *
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: any,
      filter: {
        column: string;
        operator: string;
        value: any;
      },
      return_updated: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client
          .from(table)
          .update(values, { count })
          .filter(filter.column, filter.operator, filter.value);

        if (return_updated) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Update data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: string) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const balanceTransactions = await stripe.balanceTransactions.retrieve({
        id: limit,
      });

      return await balanceTransactions.json();
    }
  error: |-
    TypeError: stripe.balanceTransactions.retrieve is not a function
  explanation: |-
    The code is attempting to call a method `retrieve` on `stripe.balanceTransactions` which does not exist in the Stripe API. The correct method to list balance transactions is `list`, not `retrieve`. Additionally, the `limit` parameter is expected to be a number, but it has been changed to a string, which would also cause a type error if the incorrect method call was not already causing the script to break.
  id: |-
    hubfix_hub_126
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const balanceTransactions = await stripe.balanceTransactions.list({
        limit: limit,
      });

      return await balanceTransactions.json();
    }
  original_instructions: |-
    List Balance History in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import stripe from "npm:stripe@^11";

    type Stripe = {
      apiKey: string;
    };
    export async function main(
      sk: Stripe,
      subscriptionId: string,
      quantity: number,
    ) {
      const client = new stripe.Stripe(sk.token, {
        apiVersion: "2022-11-15",
        httpClient: stripe.createFetchHttpClient(),
      });

      return await client.subscriptionItems.recordUsage(subscriptionId, {
        quantity,
      });
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'recordUsage')
  explanation: |-
    The code is trying to call a method `recordUsage` on `client.subscriptionItems`, which does not exist. The correct method name should be `createUsageRecord`. Additionally, the `Stripe` type has been changed to have an `apiKey` property instead of `token`, but the code is still trying to access `sk.token`, which will result in an undefined property access error.
  id: |-
    hubfix_hub_127
  lang: |-
    deno
  original_code: |
    import stripe from "npm:stripe@^11";

    type Stripe = {
      token: string;
    };
    export async function main(
      sk: Stripe,
      subscriptionId: string,
      quantity: number,
    ) {
      const client = new stripe.Stripe(sk.token, {
        apiVersion: "2022-11-15",
        httpClient: stripe.createFetchHttpClient(),
      });

      return await client.subscriptionItems.createUsageRecord(subscriptionId, {
        quantity,
      });
    }
  original_instructions: |-
    Create Usage Record in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import { IncomingWebhook } from "npm:ms-teams-webhook@2.0.2";

    type MsTeamsWebhook = {
      webhook_url: string;
    };
    export async function main(
      ms_teams_webhook: MsTeamsWebhook,
      messageCard: object,
    ) {
      const webhook = new IncomingWebhook(ms_teams_webhook.webhook_url);
      const ret = await webhook.post(messageCard); // Changed 'send' to 'post'
      return ret;
    }

    const example_card = {
      "@type": "MessageCard",
      "@context": "https://schema.org/extensions",
      summary: "This is a test summary",
      themeColor: "0078D7",
      title: "This is a test title",
      sections: [
        {
          activityTitle: "Windmill Webhook",
          activitySubtitle: "2023-05-25 17:57:55",
          activityImage:
            "https://connectorsdemo.azurewebsites.net/images/MSC12_Oscar_002.jpg",
          text: "This is a test text",
        },
      ],
    };
  error: |-
    TypeError: webhook.post is not a function
  explanation: |-
    The error occurs because the `IncomingWebhook` class does not have a method named `post`. The original code used `webhook.send`, which is the correct method to send the message card to the Microsoft Teams webhook. By changing `.send` to `.post`, we are attempting to call a method that does not exist on the `IncomingWebhook` object, resulting in a `TypeError`.
  id: |-
    hubfix_hub_373
  lang: |-
    deno
  original_code: |
    import { IncomingWebhook } from "npm:ms-teams-webhook@2.0.2";

    // See below for an example card you can pass in

    type MsTeamsWebhook = {
      webhook_url: string;
    };
    export async function main(
      ms_teams_webhook: MsTeamsWebhook,
      messageCard: object,
    ) {
      const webhook = new IncomingWebhook(ms_teams_webhook.webhook_url);
      const ret = await webhook.send(messageCard);
      return ret;
    }

    const example_card = {
      "@type": "MessageCard",
      "@context": "https://schema.org/extensions",
      summary: "This is a test summary",
      themeColor: "0078D7",
      title: "This is a test title",
      sections: [
        {
          activityTitle: "Windmill Webhook",
          activitySubtitle: "2023-05-25 17:57:55",
          activityImage:
            "https://connectorsdemo.azurewebsites.net/images/MSC12_Oscar_002.jpg",
          text: "This is a test text",
        },
      ],
    };
  original_instructions: |-
    Send a message to MS Teams channel via webhook in msteams
  resource_type: |-
    MsTeamsWebhook
  resource_type_def: |-
    type MsTeamsWebhook = {
      webhook_url: string;
    }
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
      attendees: Array<object>,
    ) {
      const alwaysIncludeEmail = true;
      const sendUpdates = "all";
      const supportsAttachments = true;
      const UPDATE_EVENT_ATTENDEES_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?alwaysIncludeEmail=${alwaysIncludeEmail}&sendUpdates=${sendUpdates}&supportsAttachments=${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        attendees: attendees,
      };

      const response = await fetch(UPDATE_EVENT_ATTENDEES_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.jason();

      return result;
    }
  error: |-
    TypeError: response.jason is not a function
  explanation: |-
    The error is caused by a typo in the method name. The correct method to parse the JSON response is `json()`, not `jason()`. The incorrect method name `jason` does not exist on the `Response` object, which leads to the `TypeError` when the script is run.
  id: |-
    hubfix_hub_47
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
      attendees: Array<object>,
    ) {
      const alwaysIncludeEmail = true;
      const sendUpdates = "all";
      const supportsAttachments = true;
      const UPDATE_EVENT_ATTENDEES_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?alwaysIncludeEmail=${alwaysIncludeEmail}&sendUpdates=${sendUpdates}&supportsAttachments=${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        attendees: attendees,
      };

      const response = await fetch(UPDATE_EVENT_ATTENDEES_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Update Attendees of an Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: Record<string, any> | Record<string, any>[],
      returnInserted: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client.from(table).insert(values, { count });
        if (returnInserted) {
          query = query.select();
        }

        return query.execute();
      });
    }
  error: |-
    TypeError: query.execute is not a function
  explanation: |-
    The error occurs because the method `execute()` does not exist on the `query` object. The original code was correct in that it did not call `execute()` on the `query` object. The `query` object is likely a chainable query builder that does not require an explicit `execute()` call to run the query. Instead, the query is executed when the promise chain is resolved. By adding `query.execute()`, we are trying to call a method that does not exist on the `query` object, which results in a `TypeError`.
  id: |-
    hubfix_hub_283
  lang: |-
    deno
  original_code: |
    import { refreshAndRetryIfExpired } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";

    /**
     * @param token Supabase `access_token` and `refresh_token`. `expires_at` (optional) is a UNIX
     * timestamp in seconds.
     *
     * @param count Count algorithm to use to count rows in the table or view.
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the hood.
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres statistics under the hood.
     * `"estimated"`: Uses exact count for low numbers and planned count for high numbers.
     */
    type Supabase = {
      url: string;
      key: string;
    };
    export async function main(
      auth: Supabase,
      table: string,
      values: Record<string, any> | Record<string, any>[],
      returnInserted: boolean = false,
      token?: {
        access: string;
        refresh: string;
        expires_at?: number;
      },
      count?: "exact" | "planned" | "estimated",
    ) {
      return await refreshAndRetryIfExpired(auth, token, async (client) => {
        let query: any = client.from(table).insert(values, { count });
        if (returnInserted) {
          query = query.select();
        }

        return query;
      });
    }
  original_instructions: |-
    Insert data in supabase
  resource_type: |-
    Supabase
  resource_type_def: |-
    type Supabase = {
      url: string;
      key: string;
    }
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(auth: Mailchimp, campaign_id: number) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}`;
      const response = await fetch(url, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });
      if (!response.ok) {
        throw Error(await response.text());
      }
      return `Successfully deleted campaign with ID '${campaign_id}'`;
    }
  error: |-
    TypeError: campaign_id (number) is not assignable to parameter of type 'string'.
  explanation: |-
    The `campaign_id` parameter in the `main` function was changed from type `string` to `number`. The URL construction relies on `campaign_id` being a string to concatenate it with the rest of the URL. Since URLs are strings, using a number for `campaign_id` without converting it to a string will cause a type error in TypeScript. The type of `campaign_id` should remain `string` to match the expected type for URL concatenation.
  id: |-
    hubfix_hub_202
  lang: |-
    deno
  original_code: |
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(auth: Mailchimp, campaign_id: string) {
      const url = `https://${auth.server}.api.mailchimp.com/3.0/campaigns/${campaign_id}`;
      const response = await fetch(url, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });
      if (!response.ok) {
        throw Error(await response.text());
      }
      return `Successfully deleted campaign with ID '${campaign_id}'`;
    }
  original_instructions: |-
    Delete Campaign in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import { deleteDocument, doc, getFirestore } from "npm:firebase/firestore/lite";

    export async function main(
      auth: FirebaseConfig,
      collection_id: string,
      document_path: string[],
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const docRef = doc(store, collection_id, ...document_path);
      await deleteDocument(docRef);
    }
  error: |-
    TypeError: deleteDocument is not a function
  explanation: |-
    The code is trying to import `deleteDocument` from `npm:firebase/firestore/lite`, which is not a function provided by the Firebase library. The correct function name is `deleteDoc`, not `deleteDocument`. Additionally, the type `Firebase` has been incorrectly renamed to `FirebaseConfig`, which does not exist in the given context. The correct type name should be `Firebase`.
  id: |-
    hubfix_hub_360
  lang: |-
    deno
  original_code: |
    import { initializeApp } from "npm:firebase@9.20.0/app";
    import { deleteDoc, doc, getFirestore } from "npm:firebase/firestore/lite";

    /**
     * Deletes a document.
     */
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    };
    export async function main(
      auth: Firebase,
      collection_id: string,
      document_path: string[],
    ) {
      const app = initializeApp(auth);
      const store = getFirestore(app);

      const docRef = doc(store, collection_id, ...document_path);
      await deleteDoc(docRef);
    }
  original_instructions: |-
    Delete Document in firebase
  resource_type: |-
    Firebase
  resource_type_def: |-
    type Firebase = {
      apiKey: string;
      authDomain: string;
      projectId: string;
      storageBucket: string;
      messagingSenderId: string;
      appId: string;
      measurementId: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(
      s3: S3,
      prefix?: string,
      bucketName?: string,
      maxResults?: number,
      pageSize?: number,
    ) {
      const s3client = new S3Client(s3);
      const options = removeObjectEmptyFields({
        prefix,
        bucketName,
        maxResults,
        pageSize,
      });
      const objects = s3client.listObjects(options);

      const result: any[] = [];
      for await (const obj of objects) {
        result.push(obj);
      }

      return result;
    }

    main({
      endPoint: "https://example.com",
      port: 443,
      useSSL: true,
      pathStyle: false,
      bucket: "my-bucket",
      accessKey: "my-access-key",
      secretKey: "my-secret-key",
      region: "us-east-1",
      extraField: "unexpected", // This line is added
    });
  error: |-
    TS2322 [ERROR]: Type '{ endPoint: string; port: number; useSSL: boolean; pathStyle: boolean; bucket: string; accessKey: string; secretKey: string; region: string; extraField: string; }' is not assignable to type 'S3'.
      Object literal may only specify known properties, and 'extraField' does not exist in type 'S3'.
  explanation: |-
    The error occurs because an object with an extra property `extraField` is passed to the `main` function, which expects an argument of type `S3`. The `S3` type does not have a property named `extraField`, so TypeScript raises an error indicating that the object literal may only specify known properties of the `S3` type. To fix this error, the `extraField` property should be removed from the object passed to the `main` function.
  id: |-
    hubfix_hub_107
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.5.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(
      s3: S3,
      prefix?: string,
      bucketName?: string,
      maxResults?: number,
      pageSize?: number,
    ) {
      const s3client = new S3Client(s3);
      const options = removeObjectEmptyFields({
        prefix,
        bucketName,
        maxResults,
        pageSize,
      });
      const objects = s3client.listObjects(options);

      const result: any[] = [];
      for await (const obj of objects) {
        result.push(obj);
      }

      return result;
    }
  original_instructions: |-
    List objects in a bucket in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room: string, body: number) {
      if (!matrix_res.token) {
        throw Error("Sending a message requires an access token.");
      }
      const roomId = await resolveRoomAlias(matrix_res, room);
      const txnId = `${Math.random()}`;
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          roomId,
        )}/send/m.room.message/${txnId}`,
        {
          method: "PUT",
          headers: {
            Accept: "application/json",
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            body,
            msgtype: "m.text",
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to send message: Error HTTP${resp.status}`);
      }
      const eventId = (await resp.json())["event_id"];
      if (typeof eventId !== "string") {
        throw Error(
          `Faulty Matrix server implementation: Server didn't provide event_id for this message.`,
        );
      }
      return eventId;
    }

    async function resolveRoomAlias(
      matrix_res: Matrix,
      room: string,
    ): Promise<string> {
      if (room.startsWith("!")) {
        return room;
      }
      const resp = await fetch(
        `${
          matrix_res.baseUrl
        }/_matrix/client/v3/directory/room/${encodeURIComponent(room)}`,
        {
          headers: {
            Accept: "application/json",
            ...(matrix_res.token && {
              Authorization: `Bearer ${matrix_res.token}`,
            }),
          },
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to resolve room alias: Error HTTP${resp.status}`);
      }
      const roomId = (await resp.json())["room_id"];
      if (typeof roomId !== "string") {
        throw Error(
          `Faulty Matrix server implementation: Server didn't provide room_id for this alias.`,
        );
      }
      return roomId;
    }
  error: |-
    Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The error occurs because the `body` parameter in the `main` function has been changed from `string` to `number`. The `JSON.stringify` method expects a string value for the `body` property, but it is being passed a number instead. This is a type mismatch and TypeScript will throw an error because the types are not compatible.
  id: |-
    hubfix_hub_95
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, room: string, body: string) {
      if (!matrix_res.token) {
        throw Error("Sending a message requires an access token.");
      }
      const roomId = await resolveRoomAlias(matrix_res, room);
      const txnId = `${Math.random()}`;
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          roomId,
        )}/send/m.room.message/${txnId}`,
        {
          method: "PUT",
          headers: {
            Accept: "application/json",
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            body,
            msgtype: "m.text",
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to send message: Error HTTP${resp.status}`);
      }
      const eventId = (await resp.json())["event_id"];
      if (typeof eventId !== "string") {
        throw Error(
          `Faulty Matrix server implementation: Server didn't provide event_id for this message.`,
        );
      }
      return eventId;
    }

    /**
     * Resolves a room alias to a room id.
     * This is basically like resolving a domain name to an IP address.
     */
    async function resolveRoomAlias(
      matrix_res: Matrix,
      room: string,
    ): Promise<string> {
      // Is it already a room ID?
      if (room.startsWith("!")) {
        return room;
      }
      const resp = await fetch(
        `${
          matrix_res.baseUrl
        }/_matrix/client/v3/directory/room/${encodeURIComponent(room)}`,
        {
          headers: {
            Accept: "application/json",
            ...(matrix_res.token && {
              Authorization: `Bearer ${matrix_res.token}`,
            }),
          },
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to resolve room alias: Error HTTP${resp.status}`);
      }
      const roomId = (await resp.json())["room_id"];
      if (typeof roomId !== "string") {
        throw Error(
          `Faulty Matrix server implementation: Server didn't provide room_id for this alias.`,
        );
      }
      return roomId;
    }
  original_instructions: |-
    Post an unencrypted message in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      sort_dir?: "" | "ASC" | "DESC",
      before_date_created?: string,
      since_date_created?: string,
      before_campaign_last_sent?: string,
      since_campaign_last_sent?: string,
      email?: string,
      sort_field?: "" | "date_created",
      has_ecommerce_store?: boolean,
      include_total_contacts?: boolean,
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/lists`);
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        before_date_created,
        since_date_created,
        before_campaign_last_sent,
        since_campaign_last_sent,
        email,
        sort_field,
        has_ecommerce_store,
        include_total_contacts,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorizations: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'append' on 'URLSearchParams': The provided value cannot be converted to a sequence.
  explanation: |-
    The error occurs because the `Authorizations` header is misspelled. The correct header name is `Authorization`. This would not cause the code to break, but it would likely result in an authentication error when the request is made to the API. The actual breaking change is the use of `"" + value` to convert a value to a string. If `value` is `false`, `0`, or `null`, it will be coerced to a string and appended to the URL parameters, which is not the intended behavior. The correct behavior should only append parameters that are truthy, excluding `false`, `0`, and `null`. The code should check for `value != null` instead of just `value` to avoid appending these falsy values.
  id: |-
    hubfix_hub_207
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     *
     * @param before_date_created *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param since_date_created *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param before_campaign_last_sent *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     * @param since_campaign_last_sent *(optional)* Uses ISO 8601 time format: `2022-10-21T15:41:36+00:00`.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      sort_dir?: "" | "ASC" | "DESC",
      before_date_created?: string,
      since_date_created?: string,
      before_campaign_last_sent?: string,
      since_campaign_last_sent?: string,
      email?: string,
      sort_field?: "" | "date_created",
      has_ecommerce_store?: boolean,
      include_total_contacts?: boolean,
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/lists`);
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        before_date_created,
        since_date_created,
        before_campaign_last_sent,
        since_campaign_last_sent,
        email,
        sort_field,
        has_ecommerce_store,
        include_total_contacts,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Search Lists in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(auth: Telegram, chat_id: number) {
      const client = new Telegram(auth.token);
      return await client.createChatInviteLink(chat_id.toString());
    }
  error: |-
    TypeError: chat_id.toString is not a function
  explanation: |-
    The code is attempting to call the `toString` method on `chat_id`, which is now typed as a `number`. However, the error message suggests that `toString` is not a function, which is incorrect because all JavaScript numbers have a `toString` method. The real issue here is likely to be a runtime error due to a different problem, such as `chat_id` being `undefined` or `null`, or an issue with the `createChatInviteLink` method not existing or being called with the wrong type of argument (since it likely expects a string, not a number). The error message provided does not match the actual code change, so it's possible that the error message is from a different runtime error not shown in the provided code snippet.
  id: |-
    hubfix_hub_237
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(auth: Telegram, chat_id: string) {
      const client = new Telegram(auth.token);
      return await client.createChatInviteLink(chat_id);
    }
  original_instructions: |-
    Create Chat Invite Link in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: string,
      properties?: string[],
      properties_with_history?: string[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.crm.contacts.basicApi.getById(
          contact_id,
          getProp(properties),
          getProp(properties_with_history),
          "extra_param", // This is the breaking change
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }

    function getProp(prop?: string[]) {
      return Array.isArray(prop) && prop.length ? prop : undefined;
    }
  error: |-
    TypeError: The `getById` method does not accept 4 arguments. Expected 3 arguments.
  explanation: |-
    The `getById` method of the `basicApi` object in the HubSpot API client is expected to take only three arguments: the contact ID, an array of properties, and an array of properties with history. By adding a fourth argument, "extra_param", the code is passing an unexpected parameter to the function, which would result in a TypeError because the method signature does not support this additional argument.
  id: |-
    hubfix_hub_227
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    /**
     * @param properties List of the properties to be returned in the response.
     *
     * @param properties_with_history List of the properties to be returned
     * along with their history of previous values.
     */
    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      contact_id: string,
      properties?: string[],
      properties_with_history?: string[],
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.crm.contacts.basicApi.getById(
          contact_id,
          getProp(properties),
          getProp(properties_with_history),
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }

    function getProp(prop?: string[]) {
      return Array.isArray(prop) && prop.length ? prop : undefined;
    }
  original_instructions: |-
    Get Contact in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.3.0/mod.ts";

    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, bucket?: string) {
      const client = new S3Client(s3);
      const generator = client.listObjects({
        bucketName: bucket || undefined,
      });

      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const newlyUpdated = [];

      while (true) {
        const obj = await generator.next();
        if (obj.done) break;

        const lastMod = new Date(obj.value.lastModified).getTime();
        if (lastMod > lastCheck) {
          newlyUpdated.push(obj.value);
        }
      }

      return newlyUpdated;
    }

    main({ endPoint: "https://example.com", port: 443, useSSL: true, pathStyle: false, bucket: "my-bucket", accessKey: "my-access-key", secretKey: "my-secret-key", region: "us-east-1" }, "another-bucket");
  error: |-
    TypeError: Cannot read properties of undefined (reading 'lastModified')
  explanation: |-
    The error occurs because the `obj.value` is `undefined`. This can happen if the `generator.next()` call does not return an object with a `value` property that has a `lastModified` property. This could be due to the `listObjects` method not returning the expected format or because the end of the iteration has been reached and `obj.value` is `undefined`. To fix this, the code should check if `obj.value` is not `undefined` before trying to access its `lastModified` property.
  id: |-
    hubfix_hub_254
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { S3Client } from "https://deno.land/x/s3_lite_client@0.3.0/mod.ts";

    /**
     * Tested on 10 000 objects, which got processed in 2.3-2.6 seconds.
     */
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    };
    export async function main(s3: S3, bucket?: string) {
      const client = new S3Client(s3);
      const generator = client.listObjects({
        bucketName: bucket || undefined,
      });

      const lastCheck = (await getState()) || 0;
      await setState(Date.now());
      const newlyUpdated = [];

      while (true) {
        const obj = await generator.next();
        if (obj.done) break;

        const lastMod = new Date(obj.value.lastModified).getTime();
        if (lastMod > lastCheck) {
          newlyUpdated.push(obj.value);
        }
      }

      return newlyUpdated;
    }
  original_instructions: |-
    Get recently updated objects in s3
  resource_type: |-
    S3
  resource_type_def: |-
    type S3 = {
      endPoint: string;
      port: number;
      useSSL: boolean;
      pathStyle: boolean;
      bucket: string;
      accessKey: string;
      secretKey: string;
      region: string;
    }
- broken_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: AirtableConfig,
      atTable: AirtableTable,
      recordId: string,
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      const deleteSingleRecord = await airtable.deleteRecord(recordId);

      return deleteSingleRecord;
    }
  error: |-
    TypeError: airtable.deleteRecord is not a function
  explanation: |-
    The error occurs because the method `deleteRecord` does not exist on the `Airtable` instance. The original method name should be `delete` as per the working code provided. By changing the method name to `deleteRecord`, the code attempts to call a method that is not defined in the Airtable class, resulting in a TypeError when the script is run.
  id: |-
    hubfix_hub_1023
  lang: |-
    deno
  original_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordId: string,
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      const deleteSingleRecord = await airtable.delete(recordId);

      return deleteSingleRecord;
    }
  original_instructions: |-
    Delete Record in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      name: string,
      dimension: number,
      metric?: "" | "euclidean" | "cosine" | "dotproduct",
      pods?: number,
      replicas?: number,
      pod_type?: "" | "s1" | "p1" | "p2",
      pod_size?: "" | "x1" | "x2" | "x4" | "x8",
      metadata_config?: Record<string, string>,
      source_collection?: number,
    ) {
      const client = new PineconeClient();
      await client.initialize(auth); // Changed from init to initialize

      const createRequest = removeObjectEmptyFields({
        name,
        dimension,
        metric,
        pods,
        replicas,
        pod_type: pod_type ? `${pod_type}.${pod_size || "x1"}` : undefined,
        metadata_config,
        source_collection,
      });
      return await client.createIndex({ createRequest });
    }
  error: |-
    TypeError: client.initialize is not a function
  explanation: |-
    The error occurs because the method `initialize` does not exist on the `PineconeClient` object. The original code used `client.init(auth)`, which is presumably the correct method to initialize the client. By changing `init` to `initialize`, the code is now calling a non-existent method, resulting in a `TypeError`.
  id: |-
    hubfix_hub_343
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    /**
     * @param name The name of the index to be created. The maximum length is 45 characters.
     *
     * @param dimension The dimensions of the vectors to be inserted in the index.
     *
     * @param metric _(Optional)_ The distance metric to be used for similarity search.
     *
     * @param pods _(Optional)_ The number of pods for the index to use, including replicas.
     *
     * @param replicas _(Optional)_ The number of replicas.
     *
     * @param pod_type _(Optional)_ The pod type for the index.
     * `s1`: Best storage capacity.
     * `p1`: Faster queries.
     * `p2`: Lowest latency and highest throughput.
     *
     * @param pod_size _(Optional)_ The size of the pod. You can increase (but not decrease) the pod size on running indexes.
     * If `pod_type` is not set, this will be ignored.
     *
     * @param metadata_config _(Optional)_ Configuration for the behavior of Pinecone's internal metadata index.
     * By default, all metadata is indexed; when `metadata_config` is present, only specified metadata fields are indexed.
     *
     * @param source_collection _(Optional)_ The name of the collection to create an index from.
     */
    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      name: string,
      dimension: number,
      metric?: "" | "euclidean" | "cosine" | "dotproduct",
      pods?: number,
      replicas?: number,
      pod_type?: "" | "s1" | "p1" | "p2",
      pod_size?: "" | "x1" | "x2" | "x4" | "x8",
      metadata_config?: Record<string, string>,
      source_collection?: number,
    ) {
      const client = new PineconeClient();
      await client.init(auth);

      const createRequest = removeObjectEmptyFields({
        name,
        dimension,
        metric,
        pods,
        replicas,
        pod_type: pod_type ? `${pod_type}.${pod_size || "x1"}` : undefined,
        metadata_config,
        source_collection,
      });
      return await client.createIndex({ createRequest });
    }
  original_instructions: |-
    Create Index in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- broken_code: |-
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { drive } from "npm:@googleapis/drive@4";

    const PAGE_SIZE = 500 as const;

    type Gdrive = {
      token: string;
    };
    export async function main(auth: Gdrive) {
      const client = drive({
        version: "v3",
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const lastCheck = await getState();
      await setState(new Date().toISOString());
      const response = await client.files.list({
        q: lastCheck ? `createdTime > '${lastCheck}'` : undefined,
        orderBy: "createdTime asc",
        pageSize: PAGE_SIZE,
      });
      if (response.data.nextPageToken && response?.data?.files?.at(-1)) {
        const lastItem = await client.files.get({
          fileId: response.data.files.at(-1)?.id || undefined,
          fields: "createdTime",
        });
        const date = lastItem?.data?.createdTime;
        if (date) {
          await setState(date);
        }
      }

      return response.data.folders; // This line is changed
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'folders')
  explanation: |-
    The error occurs because the property `folders` does not exist on the `response.data` object. The correct property that should be accessed is `files`, as the Google Drive API returns a list of files, not folders, in the `files` property of the response object. By attempting to access `response.data.folders`, the code is trying to read a property that is not defined, resulting in a `TypeError`.
  id: |-
    hubfix_hub_252
  lang: |-
    deno
  original_code: |
    import {
      getState,
      setState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { drive } from "npm:@googleapis/drive@4";

    const PAGE_SIZE = 500 as const;

    /**
     * @returns A list of newly uploaded files in ascending order
     * of creation date.
     * Maximum number of returned items is set to `500` for each run.
     */
    type Gdrive = {
      token: string;
    };
    export async function main(auth: Gdrive) {
      const client = drive({
        version: "v3",
        headers: {
          Authorization: `Bearer ${auth.token}`,
        },
      });

      const lastCheck = await getState();
      await setState(new Date().toISOString());
      const response = await client.files.list({
        q: lastCheck ? `createdTime > '${lastCheck}'` : undefined,
        orderBy: "createdTime asc",
        pageSize: PAGE_SIZE,
      });
      if (response.data.nextPageToken && response?.data?.files?.at(-1)) {
        const lastItem = await client.files.get({
          fileId: response.data.files.at(-1)?.id || undefined,
          fields: "createdTime",
        });
        const date = lastItem?.data?.createdTime;
        if (date) {
          await setState(date);
        }
      }

      return response.data.files;
    }
  original_instructions: |-
    Get new files in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      customer_id: number, // Changed the type from string to number
      price_id: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoiceItem = await stripe.invoiceItems.create({
        customer: customer_id, // Removed the template literal
        price: `${price_id}`,
      });

      return await invoiceItem.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'create')
  explanation: |-
    The code is trying to call a method `create` on `stripe.invoiceItems`, but `stripe.invoiceItems` is undefined. This is because the `Stripe` import is being shadowed by the `type Stripe` declaration, causing the actual Stripe object not to be initialized correctly. Additionally, the `customer_id` parameter type was changed from `string` to `number`, which is incorrect because the Stripe API expects a string for the customer ID. The template literal was also removed when passing `customer_id` to `stripe.invoiceItems.create`, which could cause a type error if the Stripe API strictly requires a string.
  id: |-
    hubfix_hub_121
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      customer_id: string,
      price_id: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoiceItem = await stripe.invoiceItems.create({
        customer: `${customer_id}`,
        price: `${price_id}`,
      });

      return await invoiceItem.json();
    }
  original_instructions: |-
    Create Invoice in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(gcal_auth: Gcal) {
      const CALENDAR_LIST_URL = `https://www.googleapis.com/calendar/v3/users/me/calendarList`;

      const token = gcal_auth["apikey"];

      const response = await fetch(CALENDAR_LIST_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.text();

      return result;
    }
  error: |-
    TypeError: Cannot read property 'apikey' of undefined
  explanation: |-
    The code is trying to access a property `apikey` on the `gcal_auth` object, which does not exist. The correct property name should be `token` as defined in the `Gcal` type. This would cause a runtime error if `gcal_auth` is passed as `undefined` or if the property `apikey` is not present on the object.
  id: |-
    hubfix_hub_40
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(gcal_auth: Gcal) {
      const CALENDAR_LIST_URL = `https://www.googleapis.com/calendar/v3/users/me/calendarList`;

      const token = gcal_auth["token"];

      const response = await fetch(CALENDAR_LIST_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Get Calendar List in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      drive_id: string,
      webhook_address: string,
      channelId: any,
    ) {
      const SUPPORT_ALL_DRIVES = true;
      const SUPPORT_TEAM_DRIVES = true;
      const INCLUDE_ITEMS_FROM_ALL_DRIVES = true;
      const START_PAGE_URL = `https://www.googleapis.com/drive/v3/changes/startPageToken/?driveId=${drive_id}&supportsAllDrives=${SUPPORT_ALL_DRIVES}`;

      const token = gdrive_auth["token"];

      const response_sp = await fetch(START_PAGE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const start_page_result = await response_sp.json();
      const START_PAGE_TOKEN = start_page_result["startPageToken"];

      const WATCH_URL = `https://www.googleapis.com/drive/v3/changes/watch/?pageToken=${START_PAGE_TOKEN}&supportsAllDrives=${SUPPORT_ALL_DRIVES}&supportsTeamDrives=${SUPPORT_TEAM_DRIVES}&includeItemsFromAllDrives=${INCLUDE_ITEMS_FROM_ALL_DRIVES}`;

      const requestBody = {
        kind: "api#channel",
        type: "webhook",
        address: webhook_address,
        id: channelId,
      };

      const response = await fetch(WATCH_URL, {
        method: "POST",
        body: JSON.stringify(requestBody),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const message = await response.json();

      return message;
    }

    main({ token: 'example_token' }, 'drive_id_example', 'webhook_address_example', undefined);
  error: |-
    TypeError: Cannot read properties of undefined (reading 'json')
  explanation: |-
    The error occurs because the `response_sp` object does not have a `.json()` method. This could be due to a number of reasons, such as the `fetch` call failing and returning an undefined object, or the `fetch` call returning a response object that does not have a `.json()` method because the response is not in JSON format or because the server returned an error status code.

    In this case, the error is likely due to the fact that the `fetch` call is made to an incorrect URL or with incorrect parameters, causing the Google API server to return an error response. The `fetch` call is made to the Google Drive API to get the start page token, but if the `drive_id` is invalid or the `token` is incorrect, the API will return an error response that does not include a `.json()` method.

    To fix this error, you would need to ensure that the `fetch` call is made with the correct URL and parameters, and that the server is returning a successful response with a JSON body. Additionally, it's good practice to check the response status before attempting to parse the JSON body to handle any potential errors more gracefully.
  id: |-
    hubfix_hub_39
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      drive_id: string,
      webhook_address: string,
      channelId: any,
    ) {
      const SUPPORT_ALL_DRIVES = true;
      const SUPPORT_TEAM_DRIVES = true;
      const INCLUDE_ITEMS_FROM_ALL_DRIVES = true;
      const START_PAGE_URL = `https://www.googleapis.com/drive/v3/changes/startPageToken/?driveId=${drive_id}&supportsAllDrives=${SUPPORT_ALL_DRIVES}`;

      const token = gdrive_auth["token"];

      const response_sp = await fetch(START_PAGE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const start_page_result = await response_sp.json();
      const START_PAGE_TOKEN = start_page_result["startPageToken"];

      const WATCH_URL = `https://www.googleapis.com/drive/v3/changes/watch/?pageToken=${START_PAGE_TOKEN}&supportsAllDrives=${SUPPORT_ALL_DRIVES}&supportsTeamDrives=${SUPPORT_TEAM_DRIVES}&includeItemsFromAllDrives=${INCLUDE_ITEMS_FROM_ALL_DRIVES}`;

      const requestBody = {
        kind: "api#channel",
        type: "webhook",
        address: webhook_address,
        id: channelId,
      };

      const response = await fetch(WATCH_URL, {
        method: "POST",
        body: JSON.stringify(requestBody),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const message = await response.json();

      return message;
    }
  original_instructions: |-
    Subscribe to Watch Changes in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { UpsertOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      vectors: { id: string; values: number[]; metadata?: Record<string, any> }[],
      namespace?: string,
      raw?: boolean,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const upsertRequest: UpsertOperationRequest = removeObjectEmptyFields({
        vectors,
        namespace,
      });
      return await index[raw ? "upsertRaw" : "upsert"]({ upsertRequest, extraParam: 123 });
    }
  error: |-
    TypeError: Argument of type '{ upsertRequest: UpsertOperationRequest; extraParam: number; }' is not assignable to parameter of type 'UpsertRequest'.
      Object literal may only specify known properties, and 'extraParam' does not exist in type 'UpsertRequest'.
  explanation: |-
    The error occurs because an object with an extra property `extraParam` that does not exist in the expected type `UpsertRequest` is being passed to the `upsert` or `upsertRaw` method. The `UpsertRequest` type does not have a property named `extraParam`, so adding this property to the object causes a type error. The TypeScript compiler expects an object that matches the `UpsertRequest` type without any additional properties.
  id: |-
    hubfix_hub_344
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.1.1/mod.ts";
    import { PineconeClient } from "npm:@pinecone-database/pinecone";
    import { UpsertOperationRequest } from "npm:@pinecone-database/pinecone/0.0.12/dist/pinecone-generated-ts-fetch/index.js";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      vectors: { id: string; values: number[]; metadata?: Record<string, any> }[],
      namespace?: string,
      raw?: boolean,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      const upsertRequest: UpsertOperationRequest = removeObjectEmptyFields({
        vectors,
        namespace,
      });
      return await index[raw ? "upsertRaw" : "upsert"]({ upsertRequest });
    }
  original_instructions: |-
    Upsert Vectors in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive) {
      const START_PAGE_URL = `https://www.googleapis.com/drive/v3/changes/startPageToken/`;

      let last_start_page_token: string | undefined =
        await wmill.getInternalState();

      const token = gdrive_auth["token"];

      if (last_start_page_token == undefined) {
        const START_PAGE_URL = `https://www.googleapis.com/drive/v3/changes/startPageToken`;

        const response_sp = await fetch(START_PAGE_URL, {
          method: "GET",
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });
        const start_page_result = await response_sp.json();

        last_start_page_token = start_page_result["startPageToken"];
      }

      const CHECK_CHANGES_URL = `https://www.googleapis.com/drive/v3/changes/?pageToken=${last_start_page_token}`;

      const changes_response = await fetch(CHECK_CHANGES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result_changes = await changes_response.json();

      await wmill.setInternalState(result_changes["newStartPageToken"]);

      return result_changes["change"];
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'change')
  explanation: |-
    The error occurs because the script is trying to access a property `change` on the `result_changes` object, which does not exist. The correct property name should be `changes`, as indicated in the original script. By changing `return result_changes["changes"];` to `return result_changes["change"];`, the script attempts to return a non-existent property, resulting in a `TypeError` when the property is accessed.
  id: |-
    hubfix_hub_38
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    type Gdrive = {
      token: string;
    };
    export async function main(gdrive_auth: Gdrive) {
      const START_PAGE_URL = `https://www.googleapis.com/drive/v3/changes/startPageToken/`;

      let last_start_page_token: string | undefined =
        await wmill.getInternalState();

      const token = gdrive_auth["token"];

      if (last_start_page_token == undefined) {
        const START_PAGE_URL = `https://www.googleapis.com/drive/v3/changes/startPageToken`;

        const response_sp = await fetch(START_PAGE_URL, {
          method: "GET",
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
        });
        const start_page_result = await response_sp.json();

        last_start_page_token = start_page_result["startPageToken"];
      }

      const CHECK_CHANGES_URL = `https://www.googleapis.com/drive/v3/changes/?pageToken=${last_start_page_token}`;

      const changes_response = await fetch(CHECK_CHANGES_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result_changes = await changes_response.json();

      await wmill.setInternalState(result_changes["newStartPageToken"]);

      return result_changes["changes"];
    }
  original_instructions: |-
    Get Changes in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(gsheets_auth: Gsheets) {
      const CREATE_URL = `https://sheets.googleapis.com/v4/spreadsheets`;

      const token = gsheets_auth["token"];

      const response = await fetch(CREATE_URL, {
        method: "PUSH",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.text();

      return { result: result, status: response.status };
    }
  error: |-
    TypeError: Failed to execute 'fetch' on 'Window': Invalid request method
  explanation: |-
    The error is caused by using an invalid HTTP method "PUSH" in the fetch request. The correct method should be "POST" or another valid HTTP method such as "GET", "PUT", "DELETE", etc. The "PUSH" method does not exist in the context of HTTP requests, which is why the code breaks.
  id: |-
    hubfix_hub_36
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(gsheets_auth: Gsheets) {
      const CREATE_URL = `https://sheets.googleapis.com/v4/spreadsheets`;

      const token = gsheets_auth["token"];

      const response = await fetch(CREATE_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return { result: result };
    }
  original_instructions: |-
    Create Spreadsheet in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type SlackAuth = {
      token: string;
    };
    export async function main(slackAuth: SlackAuth, channel: string) {
      const web = new WebClient(slackAuth.token);

      let response = await web.conversations.join({
        channels: channel,
      });

      return { response: response.ok };
    }
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The code is broken for several reasons:

    1. The type `Slack` was renamed to `SlackAuth`, but the parameter `slack_auth` in the `main` function was not updated to match the new type name. It should be `slackAuth` to match the type definition.

    2. The `WebClient` constructor expects an object with a `token` property, but `slackAuth.token` is being passed directly, which would be just the string token. The correct usage is to pass the entire `slackAuth` object.

    3. The `conversations.join` method expects a parameter named `channel`, but the code is passing `channels` which is incorrect and would result in an API error if the code were to execute that far.

    4. The return statement is attempting to access `response.ok`, which is not a property of the response object returned by the `conversations.join` method. The correct property to access would be `response.ok` if it existed, but since the API call would fail due to the incorrect parameter name (`channels` instead of `channel`), this line would also cause an error if reached.
  id: |-
    hubfix_hub_20
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(slack_auth: Slack, channel: string) {
      const web = new WebClient(slack_auth);

      let response = await web.conversations.join({
        channel: channel,
      });

      return { response: response };
    }
  original_instructions: |-
    Join Channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, id: number) {
      const STRIPE_CAPTURE_PAYMENT_URL = `https://api.stripe.com/v1/payment_intents/:${id}/capture`;

      const token = stripe_con["tokens"];

      const response = await fetch(STRIPE_CAPTURE_PAYMENT_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Cannot read property 'tokens' of undefined
  explanation: |-
    The code is broken for several reasons:

    1. The `id` parameter type was changed from `string` to `number`, which might not be an error by itself, but it could lead to issues if the API expects a string.
    2. The property `tokens` is being accessed on `stripe_con` instead of `token`. Since `tokens` does not exist on the `Stripe` type, this will result in `undefined`.
    3. The `fetch` method is changed from "POST" to "GET", which is incorrect for a payment capture operation that typically requires a "POST" request.
    4. The return statement is changed from `response.json()` to `response.text()`, which might not be an error but could be problematic if the expected return type is JSON and not plain text.
  id: |-
    hubfix_hub_118
  lang: |-
    deno
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, id: string) {
      const STRIPE_CAPTURE_PAYMENT_URL = `https://api.stripe.com/v1/payment_intents/:${id}/capture`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_CAPTURE_PAYMENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Capture a Payment Intent in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      customer_id: number,
      order_id: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const customer = await stripe.customers.update(`${customer_id}`, {
        metadata: { order_id: order_id },
      });

      return await customer.text();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'update')
  explanation: |-
    The code is broken because the `customer_id` parameter type was changed from `string` to `number`. The Stripe API expects a string for the customer ID, not a number. Additionally, the `customer.json()` method was changed to `customer.text()`, which might not be appropriate if the expected return type is JSON. The `text()` method would return a string, which could cause issues if the calling code expects a JSON object. Furthermore, the error message indicates that the `update` method is being called on `undefined`, which suggests that the `stripe.customers` object might not be initialized correctly, possibly due to incorrect instantiation of the `Stripe` object or a problem with the imported Stripe module.
  id: |-
    hubfix_hub_131
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      customer_id: string,
      order_id: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const customer = await stripe.customers.update(`${customer_id}`, {
        metadata: { order_id: order_id },
      });

      return await customer.json();
    }
  original_instructions: |-
    Update a Customer in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: number,
      user_id: string,
      reason = "",
    ) {
      if (!matrix_res.token) {
        throw Error("Inviting a user requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          room_id,
        )}/invite`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            user_identification: user_id,
            ...(reason && { reason }),
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to invite: Error HTTP${resp.status}`);
      }
    }
  error: |-
    TypeError: URIError: URI malformed at encodeURIComponent (<anonymous>)
  explanation: |-
    The code is broken due to the following reasons:

    1. The `room_id` parameter type has been changed from `string` to `number`. The `encodeURIComponent` function expects a string argument, but it is being passed a number, which will cause a URIError when the function tries to encode a number as part of the URI.

    2. The `JSON.stringify` method is using `user_identification` as a property name instead of `user_id`. Since the API likely expects a property named `user_id`, this change will cause the API to not recognize the user identifier, leading to a failure in the invite operation.
  id: |-
    hubfix_hub_104
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      user_id: string,
      reason = "",
    ) {
      if (!matrix_res.token) {
        throw Error("Inviting a user requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          room_id,
        )}/invite`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            user_id,
            ...(reason && { reason }),
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to invite: Error HTTP${resp.status}`);
      }
    }
  original_instructions: |-
    Invite user to a room in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      path?: string,
      ref?: string,
      result_format: "github_object" | "json" = "github_object",
    ) {
      const octokit = new Octocat({ auth: gh_auth.token });

      return await octokit.request(
        `GET /repos/{owner}/{repo}/contents/{path}${ref ? "?{ref}" : ""}`,
        {
          owner,
          repo,
          path,
          headers: {
            "X-GitHub-Api-Version": "2022-11-28",
            Accept: `application/${
              result_format === "json" ? "vnd.github+json" : "vnd.github.object"
            }`,
          },
        },
      );
    }
  error: |-
    TypeError: Octocat is not a constructor
  explanation: |-
    The code is trying to import `Octocat` from the `@octokit/rest` package, but the correct class name is `Octokit`. Since `Octocat` does not exist in the package, trying to instantiate it with `new Octocat(...)` will result in a `TypeError` because it is not a constructor function.
  id: |-
    hubfix_hub_345
  lang: |-
    deno
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     *
     * @param path The path to the file or directory.
     * If omitted, the contents of the repository's root directory will be returned.
     *
     * @param ref The name of the commit/branch/tag. Defaults to the default branch of the repository.
     *
     * @param result_format The kind of data to be returned. This controls how the result is structured.
     * Learn more at https://docs.github.com/en/rest/repos/contents#get-repository-content
     */
    type Github = {
      token: string;
    };
    export async function main(
      gh_auth: Github,
      owner: string,
      repo: string,
      path?: string,
      ref?: string,
      result_format: "github_object" | "json" = "github_object",
    ) {
      const octokit = new Octokit({ auth: gh_auth.token });

      return await octokit.request(
        `GET /repos/{owner}/{repo}/contents/{path}${ref ? "?{ref}" : ""}`,
        {
          owner,
          repo,
          path,
          headers: {
            "X-GitHub-Api-Version": "2022-11-28",
            Accept: `application/${
              result_format === "json" ? "vnd.github+json" : "vnd.github.object"
            }`,
          },
        },
      );
    }
  original_instructions: |-
    Get Repo Content in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      document: Record<string, any>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.insert(document);
    }
  error: |-
    TypeError: documents.insert is not a function
  explanation: |-
    The error is caused by calling a non-existent method `insert` on the `documents` object. The correct method to insert a document into a MongoDB collection using the MongoClient should be `insertOne` or `insertMany`, depending on the use case. By changing `insertOne` to `insert`, the code attempts to call a method that does not exist on the `documents` object, resulting in a `TypeError`.
  id: |-
    hubfix_hub_259
  lang: |-
    deno
  original_code: |
    import { MongoClient } from "https://deno.land/x/atlas_sdk@v1.0.3/mod.ts";

    /**
     * @param data_source For example: `Cluster0`
     */
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    };
    export async function main(
      auth: MongodbRest,
      data_source: string,
      database: string,
      collection: string,
      document: Record<string, any>,
    ) {
      const client = new MongoClient({
        endpoint: auth.endpoint,
        dataSource: data_source,
        auth: { apiKey: auth.api_key },
      });
      const documents = client.database(database).collection(collection);
      return await documents.insertOne(document);
    }
  original_instructions: |-
    Create New Document in mongodb
  resource_type: |-
    MongodbRest
  resource_type_def: |-
    type MongodbRest = {
      endpoint: string;
      api_key: string;
    }
- broken_code: |-
    import {
      pgClient,
      type Sql,
    } from "https://deno.land/x/windmill@v1.88.1/mod.ts";

    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    };
    export async function main(db: Postgresql, query: Sql = "SELECT * FROM demo;") {
      if (!query) {
        throw Error("Query must not be empty.");
      }
      const { rows } = await pgClient(db).queryObject(query);
      return data;
    }
  error: |-
    ReferenceError: data is not defined
  explanation: |-
    In the return statement, the variable `data` is used, but it is not defined anywhere in the code. The correct variable that holds the query result is `rows`, so the return statement should be `return rows;` instead of `return data;`.
  id: |-
    hubfix_hub_82
  lang: |-
    deno
  original_code: |
    import {
      pgClient,
      type Sql,
    } from "https://deno.land/x/windmill@v1.88.1/mod.ts";

    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    };
    export async function main(db: Postgresql, query: Sql = "SELECT * FROM demo;") {
      if (!query) {
        throw Error("Query must not be empty.");
      }
      const { rows } = await pgClient(db).queryObject(query);
      return rows;
    }
  original_instructions: |-
    Execute Query and return results in postgresql
  resource_type: |-
    Postgresql
  resource_type_def: |-
    type Postgresql = {
      host: string;
      port: number;
      user: string;
      dbname: string;
      sslmode: string;
      password: string;
    }
- broken_code: |-
    export async function main() {
      const url = "https://hub.windmill.dev/searchFlowData";
      const response = await fetch(url);
      const data = await response.jason();
      return data;
    }
  error: |-
    TypeError: response.jason is not a function
  explanation: |-
    The error is caused by a typo in the method name. The correct method to parse the JSON response is `json()`, not `jason()`. This typo leads to an attempt to call a method that does not exist on the `response` object, resulting in a `TypeError`.
  id: |-
    hubfix_hub_169
  lang: |-
    deno
  original_code: "// Should return {flows: [{\u2026},\u2026]}\n\nexport async function\
    \ main() {\n  const url = \"https://hub.windmill.dev/searchFlowData\";\n  const\
    \ response = await fetch(url);\n  return await response.json();\n}\n"
  original_instructions: |-
    List Flows in windmillhub
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: number, // Changed the type from string to number
      useDomainAdminAccess: boolean = true,
    ) {
      const UPDATE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const body = {
        name: "Update Drive Test",
        restrictions: {
          adminManagedRestrictions: false,
          copyRequiresWriterPermission: false,
          domainUsersOnly: false,
          driveMembersOnly: false,
        },
        colorRgb: "#ff0000",
      };
      const response = await fetch(UPDATE_SHARED_DRIVE_URL, {
        method: "PATCH",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The error occurs because the `driveId` parameter type was changed from `string` to `number`. The `driveId` is expected to be a string as it is part of a URL, and URLs are composed of strings. By changing the type to `number`, TypeScript will throw an error because it is not a valid type for a URL component.
  id: |-
    hubfix_hub_63
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: string,
      useDomainAdminAccess: boolean = true,
    ) {
      const UPDATE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const body = {
        name: "Update Drive Test",
        restrictions: {
          adminManagedRestrictions: false,
          copyRequiresWriterPermission: false,
          domainUsersOnly: false,
          driveMembersOnly: false,
        },
        colorRgb: "#ff0000",
      };
      const response = await fetch(UPDATE_SHARED_DRIVE_URL, {
        method: "PATCH",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Update Shared Drive in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      customer_id: string,
      price_id: number, // Changed price_id type to number
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoiceItem = await stripe.invoiceItems.create({
        customer: `${customer_id}`,
        price: price_id, // Removed template literal
      });

      return await invoiceItem.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'create')
  explanation: |-
    The code is trying to call a method `create` on `stripe.invoiceItems`, but `stripe.invoiceItems` is undefined. This could be because the `Stripe` object imported from the module does not have an `invoiceItems` property with a `create` method, or because the `Stripe` object was not properly initialized due to incorrect parameters or a failure in the initialization process.

    Additionally, there is a type mismatch where `price_id` is expected to be a string (as it is used in a template literal), but it has been changed to a number. This could cause issues if the `stripe.invoiceItems.create` method expects a string for the `price` property.
  id: |-
    hubfix_hub_122
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(
      stripe_con: Stripe,
      customer_id: string,
      price_id: string,
    ) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoiceItem = await stripe.invoiceItems.create({
        customer: `${customer_id}`,
        price: `${price_id}`,
      });

      return await invoiceItem.json();
    }
  original_instructions: |-
    Create Invoice Line Item in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: number, // Changed the type from string to number
      allowItemDeletion: boolean = false,
      useDomainAdminAccess: boolean = false,
    ) {
      const DELETE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId.toString()}/?allowItemDeletion=${allowItemDeletion}&useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_SHARED_DRIVE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return "Deleted shared drive.";
    }
  error: |-
    TypeError: driveId.toString is not a function
  explanation: |-
    The error occurs because the `driveId` parameter type was changed from `string` to `number`. In the original code, `driveId` is interpolated directly into a string, which is a valid operation for a string type. However, after changing the type to `number`, the `toString()` method is explicitly called on `driveId` to convert it to a string. If `driveId` were to be `null` or `undefined`, calling `toString()` on it would result in a `TypeError` because `null` and `undefined` do not have a `toString` method. To fix this, the type of `driveId` should remain `string`, or the code should handle the case where `driveId` could be `null` or `undefined`.
  id: |-
    hubfix_hub_62
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      driveId: string,
      allowItemDeletion: boolean = false,
      useDomainAdminAccess: boolean = false,
    ) {
      const DELETE_SHARED_DRIVE_URL = `https://www.googleapis.com/drive/v3/drives/${driveId}/?allowItemDeletion=${allowItemDeletion}&useDomainAdminAccess=${useDomainAdminAccess}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DELETE_SHARED_DRIVE_URL, {
        method: "DELETE",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return "Deleted shared drive.";
    }
  original_instructions: |-
    Delete Shared Drive in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";

    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      name: string,
      permission_reminder: string,
      campaign_from_name: string,
      campaign_from_email: string,
      campaign_subject: string,
      campaign_language: string,
      email_type_option: boolean,
      contact_company: string,
      contact_country: string,
      contact_city: string,
      contact_address1: string,
      contact_address2?: string,
      contact_state?: string,
      contact_zip?: string,
      contact_phone?: string,
      notify_on_subscribe?: string,
      notify_on_unsubscribe?: string,
      use_archive_bar?: boolean,
      double_optin?: boolean,
      marketing_permissions?: boolean,
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/lists`);
      const body = {
        name,
        contact: {
          company: contact_company,
          country: contact_country,
          city: contact_city,
          address1: contact_address1,
          address2: contact_address2,
          state: contact_state,
          zip: contact_zip,
          phone: contact_phone,
        },
        permission_reminder,
        campaign_defaults: {
          from_name: campaign_from_name,
          from_email: campaign_from_email,
          subject: campaign_subject,
          language: campaign_language,
        },
        email_type_option,
        use_archive_bar,
        notify_on_subscribe,
        notify_on_unsubscribe,
        double_optin,
        marketing_permissions,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.apiKey}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'apiKey')
  explanation: |-
    The error is caused by trying to access a property `apiKey` on the `auth` object, which does not exist. The correct property name as defined in the `Mailchimp` type is `api_key`. This is a common mistake where a developer might confuse the naming convention between camelCase and snake_case.
  id: |-
    hubfix_hub_209
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";

    /**
     * Find more information about the parameters at
     * https://mailchimp.com/developer/marketing/api/lists/add-list/
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      name: string,
      permission_reminder: string,
      campaign_from_name: string,
      campaign_from_email: string,
      campaign_subject: string,
      campaign_language: string,
      email_type_option: boolean,
      contact_company: string,
      contact_country: string,
      contact_city: string,
      contact_address1: string,
      contact_address2?: string,
      contact_state?: string,
      contact_zip?: string,
      contact_phone?: string,
      notify_on_subscribe?: string,
      notify_on_unsubscribe?: string,
      use_archive_bar?: boolean,
      double_optin?: boolean,
      marketing_permissions?: boolean,
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/lists`);
      const body = {
        name,
        contact: {
          company: contact_company,
          country: contact_country,
          city: contact_city,
          address1: contact_address1,
          address2: contact_address2,
          state: contact_state,
          zip: contact_zip,
          phone: contact_phone,
        },
        permission_reminder,
        campaign_defaults: {
          from_name: campaign_from_name,
          from_email: campaign_from_email,
          subject: campaign_subject,
          language: campaign_language,
        },
        email_type_option,
        use_archive_bar,
        notify_on_subscribe,
        notify_on_unsubscribe,
        double_optin,
        marketing_permissions,
      };

      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
        body: JSON.stringify(removeObjectEmptyFields(body)),
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Create List in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(gcal_auth: Gcal, calendarId: number) {
      const CALENDAR_LIST_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}`;

      const token = gcal_auth["apikey"];

      const response = await fetch(CALENDAR_LIST_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.text();

      return result;
    }
  error: |-
    TypeError: Cannot read property 'apikey' of undefined
  explanation: |-
    The code is broken for several reasons:

    1. The `calendarId` parameter type was changed from `string` to `number`, which is incorrect because the calendar ID in the URL should be a string.
    2. The property `apikey` is being accessed on `gcal_auth` instead of `token`. The `Gcal` type does not have an `apikey` property, so this will result in `undefined`.
    3. The `response.text()` method is used instead of `response.json()`. While this might not cause a runtime error, it is a logical error if the expected result should be a JSON object.
  id: |-
    hubfix_hub_41
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(gcal_auth: Gcal, calendarId: string) {
      const CALENDAR_LIST_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}`;

      const token = gcal_auth["token"];

      const response = await fetch(CALENDAR_LIST_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Get Calendar Metadata in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    export async function main(baseUrl: number) {
      const response = await fetch(`${baseUrl}/ocs/v1.php/cloud/capabilities`, {
        headers: {
          "OCS-APIRequest": "true",
        },
      });
      if (!response.ok) {
        throw Error(`HTTP Error ${response.status} - ${await response.text()}`);
      }
      return await response.json();
    }
  error: |-
    TypeError: baseUrl is not a string.
  explanation: |-
    The `baseUrl` parameter was changed from a string to a number, which is incorrect because the `fetch` function expects a URL as a string, not a number. Additionally, the function is now trying to return the response as JSON with `response.json()`, but the comment in the original code indicates that it should return an XML document, so the correct method should be `response.text()`.
  id: |-
    hubfix_hub_162
  lang: |-
    deno
  original_code: |
    // https://docs.nextcloud.com/server/latest/developer_manual/client_apis/OCS/ocs-api-overview.html#capabilities-api
    // Should return an XML document on success.
    export async function main(baseUrl: string) {
      const resp = await fetch(`${baseUrl}/ocs/v1.php/cloud/capabilities`, {
        headers: {
          "OCS-APIRequest": "true",
        },
      });
      if (!resp.ok) {
        throw Error(`HTTP Error ${resp.status} - ${await resp.text()}`);
      }
      return await resp.text();
    }
  original_instructions: |-
    Get API capabilities in ocs
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      namespace?: string,
    ) {
      const client = new PineconeClient();
      await client.initialize(auth); // Changed init to initialize
      const index = client.Index(index_name);

      return await index.delete1({
        deleteAll: true,
        namespace,
        extraParam: "unnecessary" // Added an extra parameter that doesn't exist
      });
    }
  error: |-
    TypeError: client.initialize is not a function
  explanation: |-
    The code is attempting to call a method `initialize` on the `client` object, which does not exist. The correct method name is `init`, as per the original code. Additionally, an extra parameter `extraParam` is passed to the `delete1` method, which is not expected by the method's signature and would likely cause an error if the method existed and was called with this unexpected parameter.
  id: |-
    hubfix_hub_346
  lang: |-
    deno
  original_code: |
    import { PineconeClient } from "npm:@pinecone-database/pinecone";

    type Pinecone = {
      apiKey: string;
      environment: string;
    };
    export async function main(
      auth: Pinecone,
      index_name: string,
      namespace?: string,
    ) {
      const client = new PineconeClient();
      await client.init(auth);
      const index = client.Index(index_name);

      return await index.delete1({
        deleteAll: true,
        namespace,
      });
    }
  original_instructions: |-
    Delete All Vectors in pinecone
  resource_type: |-
    Pinecone
  resource_type_def: |-
    type Pinecone = {
      apiKey: string;
      environment: string;
    }
- broken_code: |-
    type Gsheets = {
      accessToken: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      sheet_id: string,
      spreadsheet_id_1: string,
      spreadsheet_id_2: string,
    ) {
      const token = gsheets_auth["token"];

      const COPY_TO_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheet_id_1}/sheets/${sheet_id}:copyTo`;

      const req = {
        destinationSpreadsheetId: spreadsheet_id_2,
      };

      const response = await fetch(COPY_TO_URL, {
        method: "POST",
        body: JSON.stringify(req),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The code is trying to access the property 'token' on the 'gsheets_auth' object, but the type definition for 'Gsheets' has been changed to have a property 'accessToken' instead of 'token'. This means that when the code tries to access 'gsheets_auth["token"]', it will return undefined because there is no 'token' property on the 'gsheets_auth' object. The correct property name should be 'accessToken' to match the type definition.

    Additionally, the function is now returning `response.json()` instead of `response.text()`. If the response from the API is not in JSON format, this will cause a parsing error. The original code was correct in assuming the response should be treated as text.
  id: |-
    hubfix_hub_50
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      sheet_id: string,
      spreadsheet_id_1: string,
      spreadsheet_id_2: string,
    ) {
      const token = gsheets_auth["token"];

      const COPY_TO_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheet_id_1}/sheets/${sheet_id}:copyTo`;

      const req = {
        destinationSpreadsheetId: spreadsheet_id_2,
      };

      const response = await fetch(COPY_TO_URL, {
        method: "POST",
        body: JSON.stringify(req),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Copy Worksheet in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;

    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const lastUpdate = (await getState()) || 0;

      const starCount = (await octokit.repos.get({ owner, repo })).data
        .stargazers_count;
      let lastPage =
        +(starCount / 100).toFixed(0) + (starCount % 100 === 0 ? 0 : 1);
      const newStarrers: Stargazer[] = [];

      await setState(Date.now());
      let runLoop = true;
      do {
        const response = await octokit.activity.listStargazersForRepo({
          owner,
          repo,
          per_page: 100,
          page: lastPage--,
          headers: {
            accept: "application/vnd.github.star+json",
          },
        });
        for (let i = response.data.length - 1; i >= 0; i--) {
          const entry = response.data[i];
          if (!entry || !entry.user) continue;
          const starredAt = new Date(entry.starred_at).getTime();
          if (starredAt < lastUpdate) {
            runLoop = false;
            break;
          }
          const { id, login, type, url, email, name } = entry.user;
          newStarrers.push({ id, starredAt, login, type, url, email, name });
          if (newStarrers.length >= MAX_ITEMS) {
            await setState(newStarrers.at(-1)?.starredAt);
            runLoop = false;
            break;
          }
        }
      } while (runLoop);
      console.log(newStarrers.length);
      return newStarrers;
    }

    interface Stargazer {
      id: number;
      login: string;
      type: string;
      url: string;
      starredAt: number;
      email?: string | null;
      name?: string | null;
    }
  error: |-
    TS2322: Type 'Starrer[]' is not assignable to type 'Stargazer[]'.
      Type 'Starrer' is missing the following properties from type 'Stargazer': email, name
  explanation: |-
    The error occurs because the type `Starrer` was changed to `Stargazer` in the array declaration `const newStarrers: Stargazer[] = [];`, but the interface `Starrer` was not renamed accordingly. TypeScript expects an array of `Stargazer` objects, but the code is trying to push objects of type `Starrer` into the array. To fix this error, the interface should be renamed to `Stargazer` or the array declaration should use the original `Starrer` type.
  id: |-
    hubfix_hub_247
  lang: |-
    deno
  original_code: |
    import {
      setState,
      getState,
    } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { Octokit } from "npm:@octokit/rest@19.0.5";

    const MAX_ITEMS = 500;

    /**
     * @returns A list of starrers in descending order of when they starred.
     * The maximum number of returned items is 500.
     */
    type Github = {
      token: string;
    };
    export async function main(auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({
        auth: auth.token,
      });
      const lastUpdate = (await getState()) || 0;

      const starCount = (await octokit.repos.get({ owner, repo })).data
        .stargazers_count;
      let lastPage =
        +(starCount / 100).toFixed(0) + (starCount % 100 === 0 ? 0 : 1);
      const newStarrers: Starrer[] = [];

      await setState(Date.now());
      let runLoop = true;
      do {
        const response = await octokit.activity.listStargazersForRepo({
          owner,
          repo,
          per_page: 100,
          page: lastPage--,
          headers: {
            accept: "application/vnd.github.star+json",
          },
        });
        for (let i = response.data.length - 1; i >= 0; i--) {
          const entry = response.data[i];
          if (!entry || !entry.user) continue;
          const starredAt = new Date(entry.starred_at).getTime();
          if (starredAt < lastUpdate) {
            runLoop = false;
            break;
          }
          const { id, login, type, url, email, name } = entry.user;
          newStarrers.push({ id, starredAt, login, type, url, email, name });
          if (newStarrers.length >= MAX_ITEMS) {
            await setState(newStarrers.at(-1)?.starredAt);
            runLoop = false;
            break;
          }
        }
      } while (runLoop);
      console.log(newStarrers.length);
      return newStarrers;
    }

    interface Starrer {
      id: number;
      login: string;
      type: string;
      url: string;
      starredAt: number;
      email?: string | null;
      name?: string | null;
    }
  original_instructions: |-
    Notify of new Github repo stars in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    export async function main(
      path: string,
      email: number, // Changed the type from string to number
      error: object,
      job_id: string,
      is_flow: boolean,
      workspace_id: string,
    ) {
      const run_type = is_flow ? "flow" : "script";
      console.log(
        `An error occured with ${run_type} ${path} run by ${email.toUpperCase()} in workspace ${workspace_id}`,
      );
      console.log(error);
      return error.toString(); // Changed the return type from object to string
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
    TS2339: Property 'toUpperCase' does not exist on type 'number'.
    TS2352: Conversion of type 'object' to type 'string' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
  explanation: |-
    The code is broken for the following reasons:
    - The `email` parameter type was changed from `string` to `number`, which is incorrect because an email address should be a string.
    - The `toUpperCase()` method is being called on `email`, which is now incorrectly typed as a number. The `toUpperCase()` method does not exist on type `number`.
    - The `error` object is being returned as a string using `toString()`, which is not correct because the original function signature expects an object to be returned, not a string. If you want to convert an object to a string, you should first ensure that the conversion is meaningful and intentional.
  id: |-
    hubfix_hub_402
  lang: |-
    deno
  original_code: |
    // Global / workspace error handler template

    export async function main(
      path: string, // The path of the script or flow that errored
      email: string, // The email of the user who ran the script or flow that errored
      error: object, // The error details
      job_id: string, // The job id
      is_flow: boolean, // Whether the error comes from a flow
      workspace_id: string, // The workspace id of the failed script or flow
    ) {
      const run_type = is_flow ? "flow" : "script";
      console.log(
        `An error occured with ${run_type} ${path} run by ${email} in workspace ${workspace_id}`,
      );
      console.log(error);
      return error;
    }
  original_instructions: |-
    Global / workspace error handler template in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      fields?: string[],
      exclude_fields?: string[],
      include_total_contacts?: boolean,
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}`,
      );
      const params = {
        fields,
        exclude_fields,
        include_total_contacts,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.connect(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.blob();
    }
  error: |-
    TypeError: value.connect is not a function
  explanation: |-
    The error is caused by attempting to call a non-existent method `connect` on an array object. The correct method for joining array elements into a string is `join`. The incorrect method `connect` should be replaced with `join` to fix the error.
  id: |-
    hubfix_hub_208
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      list_id: string,
      fields?: string[],
      exclude_fields?: string[],
      include_total_contacts?: boolean,
    ) {
      const url = new URL(
        `https://${auth.server}.api.mailchimp.com/3.0/lists/${list_id}`,
      );
      const params = {
        fields,
        exclude_fields,
        include_total_contacts,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Get List in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string | number,
      text: string,
      reply_to_message_id?: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.sendText(chat_id, text, {
        reply_to_message_id,
      });
    }
  error: |-
    TypeError: client.sendText is not a function
  explanation: |-
    The error occurs because the method `sendText` does not exist on the `Telegram` class from the `telegraf` library. The correct method name should be `sendMessage`. By changing `sendMessage` to `sendText`, we are attempting to call a method that isn't defined, which results in a `TypeError`.
  id: |-
    hubfix_hub_234
  lang: |-
    deno
  original_code: |
    import { Telegram } from "npm:telegraf@4.11";

    type Telegram = {
      token: string;
    };
    export async function main(
      auth: Telegram,
      chat_id: string | number,
      text: string,
      reply_to_message_id?: number,
    ) {
      const client = new Telegram(auth.token);
      return await client.sendMessage(chat_id, text, {
        reply_to_message_id,
      });
    }
  original_instructions: |-
    Send a Text Message or Reply in telegram
  resource_type: |-
    Telegram
  resource_type_def: |-
    type Telegram = {
      token: string;
    }
- broken_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, payout_id: number) {
      const STRIPE_REVERSE_PAYOUT_URL = `https://api.stripe.com/v1/payouts/:${payout_id}/reverse`;

      const token = stripe_con["apikey"];

      const response = await fetch(STRIPE_REVERSE_PAYOUT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Cannot read property 'apikey' of undefined
  explanation: |-
    The code is broken for two reasons:

    1. The `payout_id` parameter type was changed from `string` to `number`, which is incorrect because the URL requires a string interpolation and payout IDs are typically strings, not numbers.

    2. The property `apikey` is being accessed on `stripe_con` instead of `token`. The `Stripe` type does not have an `apikey` property, so trying to access it will result in `undefined`. The original code correctly accessed the `token` property.
  id: |-
    hubfix_hub_116
  lang: |-
    deno
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, payout_id: string) {
      const STRIPE_REVERSE_PAYOUT_URL = `https://api.stripe.com/v1/payouts/:${payout_id}/reverse`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_REVERSE_PAYOUT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Cancel Or Reverse a Payout in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateChatCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.2.1";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      messages: {
        role: "assistant" | "system" | "user";
        content: string;
        name?: string;
      }[],
      model: "gpt-3.5-turbo" | "gpt-3.5-turbo-0301" = "gpt-3.5-turbo",
      frequency_penalty?: number,
      logit_bias?: object,
      max_tokens?: number,
      n?: number,
      presence_penalty?: number,
      stop?: string,
      stream?: boolean,
      temperature?: number,
      top_p?: number,
      user?: string,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request: CreateChatCompletionRequest = {
        messages,
        model,
        frequency_penalty,
        logit_bias,
        max_tokens,
        n,
        presence_penalty,
        stop,
        stream,
        temperature,
        top_p,
        user,
      };
      const response = await openai.createChatCompletion(
        removeObjectEmptyFields(request),
      );
      return response.data;
    }

    main({
      api_key: "example-api-key",
      organization_id: "example-organization-id",
    }, [{
      role: "user",
      content: "Hello, who are you?",
    }], "gpt-3.5-turbo", undefined, { "50256": 1 }, 150);
  error: |-
    TypeError: openai.createChatCompletion is not a function
  explanation: |-
    The error message indicates that `createChatCompletion` is not a function. This could happen if the `openai` object does not have a method called `createChatCompletion`, which could be the case if the OpenAI API has been updated and the method has been renamed or removed, or if the version of the `openai` package being used does not include this method. Another possibility is that there is a typo in the method name when calling it. However, in the provided code, the method name is correct according to the OpenAI API version `3.2.1`, so the error would likely be due to a version mismatch or an API change after the knowledge cutoff date.
  id: |-
    hubfix_hub_347
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import {
      Configuration,
      CreateChatCompletionRequest,
      OpenAIApi,
    } from "npm:openai@3.2.1";

    /**
     * You can read about the parameters at
     * https://platform.openai.com/docs/api-reference/chat/create
     */
    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      messages: {
        role: "assistant" | "system" | "user";
        content: string;
        name?: string;
      }[],
      model: "gpt-3.5-turbo" | "gpt-3.5-turbo-0301" = "gpt-3.5-turbo",
      frequency_penalty?: number,
      logit_bias?: object,
      max_tokens?: number,
      n?: number,
      presence_penalty?: number,
      stop?: string,
      stream?: boolean,
      temperature?: number,
      top_p?: number,
      user?: string,
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const request: CreateChatCompletionRequest = {
        messages,
        model,
        frequency_penalty,
        logit_bias,
        max_tokens,
        n,
        presence_penalty,
        stop,
        stream,
        temperature,
        top_p,
        user,
      };
      const response = await openai.createChatCompletion(
        removeObjectEmptyFields(request),
      );
      return response.data;
    }
  original_instructions: |-
    Create Chat Completion in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- broken_code: |-
    import { Client } from "https://deno.land/x/mysql/mod.ts";

    type Mysql = {
      host: string;
      port: number;
      user: string;
      database: string;
      password: string;
      ssl: boolean;
    };
    export async function main(mysql_conn: Mysql, query: string) {
      mysql_conn.db = mysql_conn.database;
      mysql_conn.hostname = mysql_conn.host;
      mysql_conn.username = mysql_conn.user;

      const client = await new Client().connect(mysql_conn);

      return await client.query(query);
    }
  error: |-
    TypeError: client.query is not a function
  explanation: |-
    The error occurs because the method `query` does not exist on the `client` object. The correct method to execute a query with the MySQL client in the provided code is `execute`, not `query`. By changing `client.execute(query)` to `client.query(query)`, we are attempting to call a method that does not exist on the `client` object, which results in a `TypeError`.
  id: |-
    hubfix_hub_28
  lang: |-
    deno
  original_code: |
    import { Client } from "https://deno.land/x/mysql/mod.ts";

    type Mysql = {
      host: string;
      port: number;
      user: string;
      database: string;
      password: string;
      ssl: boolean;
    };
    export async function main(mysql_conn: Mysql, query: string) {
      mysql_conn.db = mysql_conn.database;
      mysql_conn.hostname = mysql_conn.host;
      mysql_conn.username = mysql_conn.user;

      const client = await new Client().connect(mysql_conn);

      return await client.execute(query);
    }
  original_instructions: |-
    Execute Query in mysql
  resource_type: |-
    Mysql
  resource_type_def: |-
    type Mysql = {
      host: string;
      port: number;
      user: string;
      database: string;
      password: string;
      ssl: boolean;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(email: string, slack: Slack) {
      const web = new WebClient(slack.token);

      let response = await web.users.lookupByEmail({
        emailAddress: email,
      });

      return { response: response };
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'lookupByEmail')
  explanation: |-
    The code is attempting to call a method `lookupByEmail` on the `web.users` object with a parameter named `emailAddress`. However, the actual parameter expected by the `lookupByEmail` method is `email`, not `emailAddress`. This mismatch in parameter names causes the method to not recognize the provided argument, leading to a runtime error where the method is not executed as expected. The error message indicates that the `lookupByEmail` method is not found because the incorrect parameter name essentially makes the call signature incorrect, and thus the method is not matched and executed.
  id: |-
    hubfix_hub_21
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(email: string, slack: Slack) {
      const web = new WebClient(slack.token);

      let response = await web.users.lookupByEmail({
        email: email,
      });

      return { response: response };
    }
  original_instructions: |-
    Find User by Email in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import {
      SendEmailRequest,
      SES,
    } from "https://aws-api.deno.dev/v0.4/services/ses.ts";
    import { ApiFactory } from "https://deno.land/x/aws_api@v0.8.1/client/mod.ts";

    type Aws = {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      region: string;
    };
    export async function main(
      toAddresses: string[],
      htmlData: string,
      textData: string,
      subject: string,
      source: string,
      credentials: Aws,
    ) {
      var params = {
        Destination: {
          ToAddresses: toAddresses,
        },
        Message: {
          Body: {
            Html: {
              Charset: "UTF-8",
              Data: htmlData,
            },
            Text: {
              Charset: "UTF-8",
              Data: textData,
            },
          },
          Subject: {
            Charset: "UTF-8",
            Data: subject,
          },
        },
        Source: source /* required */,
      };

      const apiFac = new ApiFactory({
        credentials: {
          awsAccessKeyId: credentials.awsAccessKeyId,
          awsSecretKey: credentials.awsSecretAccessKey,
        },
        region: credentials.region,
      });
      const ses = new SES(apiFac);
      return await ses.sendEmail(params as SendEmailRequest);
    }
  error: |-
    TypeError: ses.sendEmail is not a function
  explanation: |-
    The error occurs because the `sendEmail` method is being called on the `ses` object as if it were a function, but it is not defined as such in the SES class. This could happen if the SES class does not have a `sendEmail` method, or if the method name is incorrect or has been changed in the library. The code is assuming that the `sendEmail` method exists and is callable, but if the actual SES class does not have this method, it will result in a TypeError when trying to invoke it.
  id: |-
    hubfix_hub_371
  lang: |-
    deno
  original_code: |
    import {
      SendEmailRequest,
      SES,
    } from "https://aws-api.deno.dev/v0.4/services/ses.ts";
    // import the base client library
    import { ApiFactory } from "https://deno.land/x/aws_api@v0.8.1/client/mod.ts";

    // Create sendEmail params
    type Aws = {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      region: string;
    };
    export async function main(
      toAddresses: string[],
      htmlData: string,
      textData: string,
      subject: string,
      source: string,
      credentials: Aws,
    ) {
      var params = {
        Destination: {
          ToAddresses: toAddresses,
        },
        Message: {
          Body: {
            Html: {
              Charset: "UTF-8",
              Data: htmlData,
            },
            Text: {
              Charset: "UTF-8",
              Data: textData,
            },
          },
          Subject: {
            Charset: "UTF-8",
            Data: subject,
          },
        },
        Source: source /* required */,
      };

      // Create the promise and SES service object
      const apiFac = new ApiFactory({
        credentials: {
          awsAccessKeyId: credentials.awsAccessKeyId,
          awsSecretKey: credentials.awsSecretAccessKey,
        },
        region: credentials.region,
      });
      const ses = new SES(apiFac);
      return await ses.sendEmail(params);
    }
  original_instructions: |-
    send an email with aws ses  in aws-ses
  resource_type: |-
    Aws
  resource_type_def: |-
    type Aws = {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      region: string;
    }
- broken_code: |-
    type Linkedin = {
      accessToken: string;
    };
    export async function main(
      auth: Linkedin,
      content: string,
      visibility: "PUBLIC" | "CONNECTIONS" = "PUBLIC",
    ) {
      const entityResponse = await fetch("https://api.linkedin.com/v2/me", {
        headers: { Authorization: "Bearer " + auth.token },
      });
      const entityId = (await entityResponse.json()).identifier;

      const url = new URL("https://api.linkedin.com/v2/ugcPosts");
      const body = JSON.stringify({
        author: `urn:li:person:${entityId}`,
        lifecycleState: "PUBLISHED",
        specificContent: {
          "com.linkedin.ugc.ShareContent": {
            shareCommentary: {
              text: content,
            },
            shareMediaCategory: "NONE",
          },
        },
        visibility: {
          "com.linkedin.ugc.MemberNetworkVisibility": visibility,
        },
      });
      const response = await fetch(url, {
        method: "PUT", // This should be POST
        headers: {
          Authorization: "Bearer " + auth.token,
          "X-Restli-Protocol-Version": "2.0.0",
        },
        body,
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'token')
  explanation: |-
    The code is broken due to the following reasons:

    1. The property `token` is being accessed on the `auth` object, but the `Linkedin` type has been changed to have an `accessToken` property instead. The correct property should be accessed using `auth.accessToken`.

    2. The `entityId` is being accessed using `.identifier` on the JSON response, but the original code suggests that the correct property should be `.id`.

    3. The `fetch` method is using the "PUT" method instead of "POST". The LinkedIn API expects a "POST" request for creating a new UGC post, and using "PUT" could result in an incorrect API call or an error from the API.

    These changes will cause the script to break and not function as intended.
  id: |-
    hubfix_hub_243
  lang: |-
    deno
  original_code: |
    type Linkedin = {
      token: string;
    };
    export async function main(
      auth: Linkedin,
      content: string,
      visibility: "PUBLIC" | "CONNECTIONS" = "PUBLIC",
    ) {
      const entityResponse = await fetch("https://api.linkedin.com/v2/me", {
        headers: { Authorization: "Bearer " + auth.token },
      });
      const entityId = (await entityResponse.json()).id;

      const url = new URL("https://api.linkedin.com/v2/ugcPosts");
      const body = JSON.stringify({
        author: `urn:li:person:${entityId}`,
        lifecycleState: "PUBLISHED",
        specificContent: {
          "com.linkedin.ugc.ShareContent": {
            shareCommentary: {
              text: content,
            },
            shareMediaCategory: "NONE",
          },
        },
        visibility: {
          "com.linkedin.ugc.MemberNetworkVisibility": visibility,
        },
      });
      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + auth.token,
          "X-Restli-Protocol-Version": "2.0.0",
        },
        body,
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Create a Simple Post (User) in linkedin
  resource_type: |-
    Linkedin
  resource_type_def: |-
    type Linkedin = {
      token: string;
    }
- broken_code: |-
    type Gdocs = {
      accessToken: string;
    };
    export async function main(gdocs_auth: Gdocs, title: string) {
      const token = gdocs_auth["token"];

      const body = {
        name: title,
      };
      const CREATE_DOC_URL = `https://docs.googleapis.com/v1/documents`;

      const response = await fetch(CREATE_DOC_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: Cannot read property 'token' of undefined
  explanation: |-
    The code is trying to access the property 'token' on the `gdocs_auth` object, but the type definition for `Gdocs` has been changed to have a property named `accessToken` instead of `token`. This means that when the code tries to access `gdocs_auth["token"]`, it will return `undefined`, and when it attempts to use this undefined value to create the Authorization header, it will fail.

    Additionally, the `body` object has a property `name` instead of `title`, which may not be correct depending on the API's expected parameters. This might not cause an immediate error but could result in an API error response.

    Lastly, the function is returning `response.json()` instead of `response.text()`. If the API does not return JSON, this will result in a parsing error. However, this change alone would not break the code if the API does return JSON.
  id: |-
    hubfix_hub_54
  lang: |-
    deno
  original_code: |
    type Gdocs = {
      token: string;
    };
    export async function main(gdocs_auth: Gdocs, title: string) {
      const token = gdocs_auth["token"];

      const body = {
        title: title,
      };
      const CREATE_DOC_URL = `https://docs.googleapis.com/v1/documents`;

      const response = await fetch(CREATE_DOC_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Create a New Document in gdocs
  resource_type: |-
    Gdocs
  resource_type_def: |-
    type Gdocs = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      message: string,
      name: String,
      channel: string,
      slack: Slack,
    ) {
      const web = new WebClient(slack.token);
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      const text = (message = `Flow [${flow_id}](${Deno.env.get(
        "WM_BASE_URL",
      )}/run/${flow_id}?workspace=${Deno.env.get(
        "WM_WORKSPACE",
      )}) had an error:\n${name}: ${message}`);
      await web.chat.postMessage({
        channel,
        text,
        icon_emoji: ':exclamation:', // This property is not expected by the postMessage method
      });
      return { message, flow_id };
    }
  error: |-
    TypeError: Unknown argument: icon_emoji
  explanation: |-
    The `postMessage` method of the `WebClient` class from the Slack Web API is being called with an argument `icon_emoji`, which is not expected by the method. The Slack Web API's `chat.postMessage` method does not accept `icon_emoji` as a parameter in the object passed to it. This is an example of passing incorrect parameters to a function, which would result in a runtime error when the script is executed.
  id: |-
    hubfix_hub_293
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.0/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      message: string,
      name: String,
      channel: string,
      slack: Slack,
    ) {
      const web = new WebClient(slack.token);
      const flow_id = Deno.env.get("WM_FLOW_JOB_ID");
      const text = (message = `Flow [${flow_id}](${Deno.env.get(
        "WM_BASE_URL",
      )}/run/${flow_id}?workspace=${Deno.env.get(
        "WM_WORKSPACE",
      )}) had an error:\n${name}: ${message}`);
      await web.chat.postMessage({
        channel,
        text,
      });
      return { message, flow_id };
    }
  original_instructions: |-
    Send error to slack channel in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      deal_id: string,
      properties?: string[],
      properties_with_history?: string[],
      associations?: string[],
      archived?: boolean,
      id_property?: string,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.crm.deals.basicApi.getById(
          deal_id,
          getProp(properties),
          getProp(properties_with_history),
          getProp(associations),
          archived || undefined,
          id_property || undefined,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.description || e.body}\n
        `);
      }
    }

    function getProp(prop?: string[]) {
      return Array.isArray(prop) && prop.length ? prop : undefined;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'description')
  explanation: |-
    The error occurs because the catch block is trying to access `e.description`, which is not a property of the error object `e`. The original code correctly accessed `e.body.message` as a fallback if `e.body` was not present. By changing it to `e.description`, the code is trying to access a property that does not exist on the error object, resulting in a `TypeError`.
  id: |-
    hubfix_hub_230
  lang: |-
    deno
  original_code: |
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    /**
     * @param deal_id You may find it in the HubSpot App under the name of `Record ID`
     *
     * @param properties List of the properties to be returned in the response.
     *
     * @param properties_with_history List of the properties to be returned
     * along with their history of previous values.
     *
     * @param id_property The name of a property whose values are unique for this object type.
     */
    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      deal_id: string,
      properties?: string[],
      properties_with_history?: string[],
      associations?: string[],
      archived?: boolean,
      id_property?: string,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });

      try {
        return await client.crm.deals.basicApi.getById(
          deal_id,
          getProp(properties),
          getProp(properties_with_history),
          getProp(associations),
          archived || undefined,
          id_property || undefined,
        );
      } catch (e) {
        throw Error(`
          ${e.code}\n
          Message: ${e.body.message || e.body}\n
        `);
      }
    }

    function getProp(prop?: string[]) {
      return Array.isArray(prop) && prop.length ? prop : undefined;
    }
  original_instructions: |-
    Get Deal in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      is_direct = false,
      name = "",
      room_alias_name = "",
      room_version = "",
      topic = "",
      visibility: "public" | "private" = "private",
    ) {
      if (!matrix_res.apiKey) {
        throw Error("Creating a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          room_id,
        )}/invite`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            is_direct,
            ...(name && { name }),
            ...(room_alias_name && { room_alias_name }),
            ...(room_version && { room_version }),
            ...(topic && { topic }),
            visibility,
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to create room: Error HTTP${resp.status}`);
      }
    }
  error: |-
    TypeError: Cannot read property 'apiKey' of undefined
  explanation: |-
    The code is trying to access a property `apiKey` on the `matrix_res` object, which does not exist. The original property that should be checked is `token`. This change breaks the code because it is trying to access a non-existent property on the `matrix_res` object.
  id: |-
    hubfix_hub_105
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      is_direct = false,
      name = "",
      room_alias_name = "",
      room_version = "",
      topic = "",
      visibility: "public" | "private" = "private",
    ) {
      if (!matrix_res.token) {
        throw Error("Creating a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          room_id,
        )}/invite`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            is_direct,
            ...(name && { name }),
            ...(room_alias_name && { room_alias_name }),
            ...(room_version && { room_version }),
            ...(topic && { topic }),
            visibility,
          }),
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to create room: Error HTTP${resp.status}`);
      }
    }
  original_instructions: |-
    Create room in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    /**
     * Set the name of a Matrix room.
     *
     * HTTP endpoint: https://spec.matrix.org/v1.5/client-server-api/#put_matrixclientv3roomsroomidstateeventtypestatekey
     *
     * State event description: https://spec.matrix.org/v1.5/client-server-api/#mroomname
     */
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      name: string = "",
    ) {
      const url = `${
        matrix_res.baseUri
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state/m.room.name/`;
      const resp = await fetch(url, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name,
        }),
      });
      if (!resp.ok) {
        throw Error(`Failed to set room name: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseUri')
  explanation: |-
    The code is trying to access a property `baseUri` on the `matrix_res` object, which does not exist. The correct property name is `baseUrl`. Since `baseUri` is not defined in the `Matrix` type, trying to access it results in a `TypeError` because it is `undefined`.
  id: |-
    hubfix_hub_286
  lang: |-
    deno
  original_code: |
    /**
     * Set the name of a Matrix room.
     *
     * HTTP endpoint: https://spec.matrix.org/v1.5/client-server-api/#put_matrixclientv3roomsroomidstateeventtypestatekey
     *
     * State event description: https://spec.matrix.org/v1.5/client-server-api/#mroomname
     */
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      name: string = "",
    ) {
      const url = `${
        matrix_res.baseUrl
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state/m.room.name/`;
      const resp = await fetch(url, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name,
        }),
      });
      if (!resp.ok) {
        throw Error(`Failed to set room name: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  original_instructions: |-
    Set room name in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    const emailResults = await main({ token: "fake-token" }, ["invalid-email"]);
  error: |-
    TypeError: sendEmail is not a function
        at main (script.ts:14:5)
        at script.ts:58:25
  explanation: |-
    The breaking change introduced is the attempt to call the `main` function without awaiting its result. Since `main` is an async function, it returns a Promise, and we should use `await` to wait for the Promise to resolve before using its result. Additionally, the `main` function is exported, so if we are calling it from within the same module, we should not attempt to call it as if it were a global function. Instead, we should call it with the appropriate syntax for invoking exported functions.

    To fix this, we should use the `await` keyword and ensure we are calling the function correctly:

    ```typescript
    const emailResults = await main({ token: "fake-token" }, ["invalid-email"]);
    ```

    Note that this fix assumes that the code snippet is part of an async function or top-level await is enabled in the environment where the code is running.
  id: |-
    hubfix_hub_178
  lang: |-
    deno
  original_code: |
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { encode as base64UrlEncode } from "https://deno.land/std@0.82.0/encoding/base64url.ts";

    type Gmail = {
      token: string;
    };
    export async function main(
      gmail_auth: Gmail,
      approver_emails: string[],
      subject = "Resume Windmill flow",
    ) {
      throwOnInvalidApprovers(approver_emails);

      const token = gmail_auth["token"];
      const email_promises = approver_emails.map((to_email) =>
        sendEmail(token, to_email, subject),
      );
      const results = await Promise.all(email_promises);

      return results;
    }

    async function sendEmail(
      gmail_token: string,
      to_email: string,
      subject: string,
    ): Promise<object> {
      const email = await getEmailBody(to_email, subject);
      const SEND_EMAIL_URL = `https://gmail.googleapis.com/gmail/v1/users/me/messages/send`;
      const body = {
        raw: email,
      };
      const response = await fetch(SEND_EMAIL_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: `Bearer ${gmail_token}`,
        },
      });
      const response_json = await response.json();

      return handleSendEmailResult(response_json, to_email);
    }

    async function getEmailBody(to_email: string, subject: string) {
      const { approvalPage } = await getResumeUrls(to_email);
      const message = `There is a Windmill flow at ${Deno.env.get(
        "WM_FLOW_PATH",
      )} run by ${Deno.env.get("WM_USERNAME")} waiting for your approval to resume.

    In order to resume or cancel the flow go to ${approvalPage}`;
      const email_body = `From: <me>\nTo: <${to_email}>\nSubject: ${subject}\n\r ${message}`;

      return base64UrlEncode(email_body);
    }

    function throwOnInvalidApprovers(approvers: string[]) {
      if (!Array.isArray(approvers) || approvers.length === 0) {
        throw new Error("Expected at least one approver email");
      }
    }

    async function handleSendEmailResult(result: object, to_email: string) {
      if (Object.keys(result).includes("error")) {
        return Promise.reject({ wm_to_email: to_email, ...result });
      }

      return result;
    }
  original_instructions: |-
    Suspend/resume a flow by sending approval URL via email in gmail
  resource_type: |-
    Gmail
  resource_type_def: |-
    type Gmail = {
      token: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: string) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const customers = await stripe.customers.retrieve({
        id: limit,
      });

      return await customers.text();
    }
  error: |-
    TypeError: stripe.customers.retrieve is not a function
  explanation: |-
    The code is attempting to call a method `retrieve` on `stripe.customers` which does not exist in the Stripe API. The Stripe API has a `retrieve` method, but it is used to retrieve a single customer by ID, not a list of customers, and it should not be called with an object containing an `id` property. Instead, it should be called with a single string argument representing the customer ID.

    Additionally, the `limit` parameter is expected to be a number, but it has been changed to a string, which is incorrect for the `list` method that expects a numerical limit. The `await customers.text();` line is also incorrect because the `list` method returns a promise that resolves with a list of customers, not a response object with a `text` method.

    To fix the code, the `retrieve` method should be changed back to `list`, the `limit` parameter should be of type `number`, and the return statement should be `return await customers.json();` to correctly parse the JSON response.
  id: |-
    hubfix_hub_129
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, limit: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const customers = await stripe.customers.list({
        limit: limit,
      });

      return await customers.json();
    }
  original_instructions: |-
    List Customers in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Gdocs = {
      token: string;
    };
    export async function main(gdocs_auth: Gdocs, documentId: number) {
      const token = gdocs_auth["token"];

      const GET_DOC_URL = `https://docs.googleapis.com/v1/documents/${documentId}`;

      const response = await fetch(GET_DOC_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  error: |-
    TypeError: documentId (number) is not assignable to parameter of type string.
  explanation: |-
    The `documentId` parameter in the `main` function was changed from `string` to `number`. The `documentId` is expected to be a string because it is part of a URL. URLs must be composed of strings, not numbers. Therefore, when the `documentId` is interpolated into the `GET_DOC_URL` string, it causes a type error since TypeScript expects a string at that position.
  id: |-
    hubfix_hub_55
  lang: |-
    deno
  original_code: |
    type Gdocs = {
      token: string;
    };
    export async function main(gdocs_auth: Gdocs, documentId: string) {
      const token = gdocs_auth["token"];

      const GET_DOC_URL = `https://docs.googleapis.com/v1/documents/${documentId}`;

      const response = await fetch(GET_DOC_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  original_instructions: |-
    Get Document in gdocs
  resource_type: |-
    Gdocs
  resource_type_def: |-
    type Gdocs = {
      token: string;
    }
- broken_code: |-
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, id: number) {
      const STRIPE_CONFIRM_PAYMENT_URL = `https://api.stripe.com/v1/payment_intents/:${id}/confirm`;

      const token = stripe_con["apikey"];

      const response = await fetch(STRIPE_CONFIRM_PAYMENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.text();
    }
  error: |-
    TypeError: Cannot read property 'apikey' of undefined
  explanation: |-
    The code is broken for several reasons:

    1. The `id` parameter type was changed from `string` to `number`, which is incorrect because the `id` in the URL should be a string.
    2. The property `apikey` is being accessed on `stripe_con`, but the `Stripe` type only defines a `token` property, not an `apikey`. This would result in `undefined` being used for the Authorization header, which would not authenticate correctly with the Stripe API.
    3. The function is returning `response.text()` instead of `response.json()`. While this might not break the code, it changes the expected return type from a JSON object to a plain text string, which could cause issues if the calling code expects a JSON object.
  id: |-
    hubfix_hub_119
  lang: |-
    deno
  original_code: |
    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, id: string) {
      const STRIPE_CONFIRM_PAYMENT_URL = `https://api.stripe.com/v1/payment_intents/:${id}/confirm`;

      const token = stripe_con["token"];

      const response = await fetch(STRIPE_CONFIRM_PAYMENT_URL, {
        method: "POST",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      return await response.json();
    }
  original_instructions: |-
    Confirm a Payment Intent in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      fileId: string,
      mimeType: string,
    ) {
      const DOWNLOAD_FILE_URL = `https://www.googleapis.com/drive/v3/files/fileId=${fileId}/export/?mimeType=${mimeType}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DOWNLOAD_FILE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.text();

      return result;
    }
  error: |-
    TypeError: response.text is not a function
  explanation: |-
    The error message indicates that `response.text` is not a function. This is incorrect because `response.text` is actually a function in the Fetch API that returns a promise that resolves to a text representation of the response body. However, if the `fetch` function was incorrectly imported or not available in the runtime environment, it could lead to this error. In the context of Deno, which uses the standard Fetch API, this error message would not occur unless the runtime environment is somehow compromised or the `fetch` function is overridden with an incorrect implementation. The provided code block does not contain any changes that would inherently break the code, so the error message does not correspond to the changes made.
  id: |-
    hubfix_hub_48
  lang: |-
    deno
  original_code: |
    type Gdrive = {
      token: string;
    };
    export async function main(
      gdrive_auth: Gdrive,
      fileId: string,
      mimeType: string,
    ) {
      const DOWNLOAD_FILE_URL = `https://www.googleapis.com/drive/v3/files/fileId=${fileId}/export/?mimeType=${mimeType}`;

      const token = gdrive_auth["token"];

      const response = await fetch(DOWNLOAD_FILE_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Download Files (Google Docs, Sheets, Slides) in gdrive
  resource_type: |-
    Gdrive
  resource_type_def: |-
    type Gdrive = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(slack_auth: Slack, channel: number) {
      const web = new WebClient(slack_auth.token);

      let response = await web.conversations.history({
        channel: channel.toString(),
      });

      return { response: response.message };
    }
  error: |-
    TypeError: Cannot read property 'message' of undefined
  explanation: |-
    The code is attempting to access a property `message` on the `response` object that does not exist. The `response` object returned from `web.conversations.history` does not have a `message` property at the top level. The correct usage would be to return the entire `response` object or a specific property that exists within the `response` object, such as `response.messages` if you want to access the message history.

    Additionally, the `channel` parameter type was changed from `string` to `number`, which is incorrect because the Slack API expects a channel ID as a string, not a number. The `.toString()` method is used to convert the number back to a string, but this is an unnecessary step if the parameter type is kept as `string`.
  id: |-
    hubfix_hub_19
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    /*
    @param: {string} channel - Conversation ID to fetch history for.
    */

    type Slack = {
      token: string;
    };
    export async function main(slack_auth: Slack, channel: string) {
      const web = new WebClient(slack_auth);

      let response = await web.conversations.history({
        channel: channel,
      });

      return { response: response };
    }
  original_instructions: |-
    List Conversation History in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(approver_emails: string[], slack: Slack) {
      throwOnInvalidApprovers(approver_emails);

      const client = new WebClient(slack.token);
      const usersData = await Promise.all(
        approver_emails.map((email) => getUserData(client, email)),
      );
      console.log(usersData);
      const dmPromises = usersData.map((userData) =>
        sendDirectMessage(client, userData),
      );

      const results = await Promise.all(dmPromises);
      return results;
    }

    interface UserData {
      id: string;
      email: string;
      real_name: string;
    }

    async function getUserData(client: WebClient, email: string): UserData {
      try {
        const response = await client.users.lookupByEmail({ email: email });

        const { id, real_name } = response.user;
        return { id, email, real_name };
      } catch (err) {
        return handleApiResponse(email, err);
      }
    }

    async function sendDirectMessage(client: WebClient, userData: UserData) {
      const text = await getApprovalMsg(userData.email);

      const { ok, ts, channel } = await client.chat.postMessage({
        channel: userData.id,
        text,
      });
      return { ok, ts, channel, email: userData.email };
    }

    async function getApprovalMsg(to_email) {
      const { approvalPage } = await getResumeUrls(to_email);
      return `There is a Windmill flow at ${Deno.env.get(
        "WM_FLOW_PATH",
      )} run by ${Deno.env.get("WM_USERNAME")} waiting for your approval to resume.

    In order to resume or cancel the flow go to ${approvalPage}`;
    }

    function throwOnInvalidApprovers(approvers: string[]) {
      if (!Array.isArray(approvers) || approvers.length === 0) {
        throw new Error("Expected at least one approver email");
      }
    }

    function handleApiResponse(email, error) {
      return Promise.reject({ email, err_msg: error.message });
    }

    // Breaking change introduced here
    const result = main(["email@example.com"], { token: undefined });
  error: |-
    TypeError: Cannot read properties of undefined (reading 'token')
  explanation: |-
    The breaking change introduced in the code is passing an object with an `undefined` value for the `token` property to the `main` function. The `Slack` type expects a `token` property of type `string`, but `undefined` is being passed instead. This will cause a runtime error when trying to create a new `WebClient` instance with an `undefined` token, which is not a valid string.
  id: |-
    hubfix_hub_179
  lang: |-
    deno
  original_code: |
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(approver_emails: string[], slack: Slack) {
      throwOnInvalidApprovers(approver_emails);

      const client = new WebClient(slack.token);
      const usersData = await Promise.all(
        approver_emails.map((email) => getUserData(client, email)),
      );
      console.log(usersData);
      const dmPromises = usersData.map((userData) =>
        sendDirectMessage(client, userData),
      );

      const results = await Promise.all(dmPromises);
      return results;
    }

    interface UserData {
      id: string;
      email: string;
      real_name: string;
    }

    async function getUserData(client: WebClient, email: string): UserData {
      try {
        const response = await client.users.lookupByEmail({ email: email });

        const { id, real_name } = response.user;
        return { id, email, real_name };
      } catch (err) {
        return handleApiResponse(email, err);
      }
    }

    async function sendDirectMessage(client: WebClient, userData: UserData) {
      const text = await getApprovalMsg(userData.email);

      const { ok, ts, channel } = await client.chat.postMessage({
        channel: userData.id,
        text,
      });
      return { ok, ts, channel, email: userData.email };
    }

    async function getApprovalMsg(to_email) {
      const { approvalPage } = await getResumeUrls(to_email);
      return `There is a Windmill flow at ${Deno.env.get(
        "WM_FLOW_PATH",
      )} run by ${Deno.env.get("WM_USERNAME")} waiting for your approval to resume.

    In order to resume or cancel the flow go to ${approvalPage}`;
    }

    function throwOnInvalidApprovers(approvers: string[]) {
      if (!Array.isArray(approvers) || approvers.length === 0) {
        throw new Error("Expected at least one approver email");
      }
    }

    function handleApiResponse(email, error) {
      return Promise.reject({ email, err_msg: error.message });
    }
  original_instructions: |-
    Suspend/resume a flow by sending approval URL via slack direct message in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    /**
     * Set the topic of a Matrix room. A topic is a short message detailing what is currently being discussed in the room.
     *
     * HTTP endpoint: https://spec.matrix.org/v1.5/client-server-api/#put_matrixclientv3roomsroomidstateeventtypestatekey
     *
     * State event description: https://spec.matrix.org/v1.5/client-server-api/#mroomtopic
     */
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      topic: string = "",
    ) {
      const url = `${
        matrix_res.baseUri
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state/m.room.topic/`;
      const resp = await fetch(url, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          topic,
        }),
      });
      if (!resp.ok) {
        throw Error(`Failed to set room topic: Error HTTP${resp.status}`);
      }
      return await resp.text();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseUri')
  explanation: |-
    The code is trying to access a property `baseUri` on the `matrix_res` object, which does not exist. The correct property name is `baseUrl`. Since `baseUri` is not defined in the `Matrix` type, trying to access it results in a `TypeError` because it is `undefined`.
  id: |-
    hubfix_hub_287
  lang: |-
    deno
  original_code: |
    /**
     * Set the topic of a Matrix room. A topic is a short message detailing what is currently being discussed in the room.
     *
     * HTTP endpoint: https://spec.matrix.org/v1.5/client-server-api/#put_matrixclientv3roomsroomidstateeventtypestatekey
     *
     * State event description: https://spec.matrix.org/v1.5/client-server-api/#mroomtopic
     */
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(
      matrix_res: Matrix,
      room_id: string,
      topic: string = "",
    ) {
      const url = `${
        matrix_res.baseUrl
      }/_matrix/client/v3/rooms/${encodeURIComponent(room_id)}/state/m.room.topic/`;
      const resp = await fetch(url, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${matrix_res.token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          topic,
        }),
      });
      if (!resp.ok) {
        throw Error(`Failed to set room topic: Error HTTP${resp.status}`);
      }
      return await resp.json();
    }
  original_instructions: |-
    Set room topic in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    export async function main(
      baseUrl: string,
      accessToken: number, // Changed the type from string to number
      status: string,
      inReplyToId?: string,
      sensitive = false,
      spoilerText?: string,
      visibility: "public" | "unlisted" | "private" | "direct" = "public",
      language?: string,
    ) {
      const resp = await fetch(`${baseUrl}/api/v1/statuses`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`, // accessToken is now a number, which is incorrect
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          sensitive,
          status,
          visibility,
          ...(inReplyToId && {
            in_reply_to_id: inReplyToId,
          }),
          ...(spoilerText && {
            spoiler_text: spoilerText,
          }),
          ...(language && {
            language,
          }),
        }),
      });

      if (!resp.ok) {
        throw Error(`Failed to post status: Error HTTP${resp.status}`);
      }

      return await resp.json();
    }
  error: |-
    Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `accessToken` parameter was changed from `string` to `number`, which is incorrect because an access token should be a string, not a number. The `Authorization` header expects a string that includes the word "Bearer" followed by a space and the access token. By changing the type of `accessToken` to `number`, the code will fail to compile because TypeScript expects a string for the `Authorization` header value.
  id: |-
    hubfix_hub_100
  lang: |-
    deno
  original_code: |
    export async function main(
      baseUrl: string,
      accessToken: string,
      status: string,
      inReplyToId?: string,
      sensitive = false,
      spoilerText?: string,
      visibility: "public" | "unlisted" | "private" | "direct" = "public",
      language?: string,
    ) {
      const resp = await fetch(`${baseUrl}/api/v1/statuses`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          sensitive,
          status,
          visibility,
          ...(inReplyToId && {
            in_reply_to_id: inReplyToId,
          }),
          ...(spoilerText && {
            spoiler_text: spoilerText,
          }),
          ...(language && {
            language,
          }),
        }),
      });

      if (!resp.ok) {
        throw Error(`Failed to post status: Error HTTP${resp.status}`);
      }

      return await resp.json();
    }
  original_instructions: |-
    Post status in mastodon
  resource_type: null
  resource_type_def: null
- broken_code: |-
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
    ) {
      const alwaysIncludeEmail = true;
      const sendUpdates = "all";
      const supportsAttachments = true;
      const UPDATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?alwaysIncludeEmail=${alwaysIncludeEmail}&sendUpdates=${sendUpdates}&supportsAttachments=${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
      };

      const response = await fetch(UPDATE_EVENT_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.text();

      return result;
    }

    main({ token: 'abc123' }, 'primary', '12345', '2023-04-01', '2023-04-02', 'Meeting description', 'Meeting summary', '123 Main St', [{ email: 'attendee@example.com' }]);
  error: |-
    TypeError: Cannot read properties of undefined (reading 'json')
  explanation: |-
    The error occurs because the `response` object does not have a method called `text()`. The original code correctly used `response.json()` to parse the JSON response from the API call. By changing it to `response.text()`, the code is attempting to call a method that does not exist on the `response` object, resulting in a TypeError when trying to access the `json` property of `undefined`.
  id: |-
    hubfix_hub_45
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(
      gcal_auth: Gcal,
      calendarId: string,
      eventId: string,
      start_date?: string,
      end_date?: string,
      description?: string,
      summary: string,
      location?: string,
      attendees?: Array<object>,
    ) {
      const alwaysIncludeEmail = true;
      const sendUpdates = "all";
      const supportsAttachments = true;
      const UPDATE_EVENT_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}/?alwaysIncludeEmail=${alwaysIncludeEmail}&sendUpdates=${sendUpdates}&supportsAttachments=${supportsAttachments}`;

      const token = gcal_auth["token"];

      const body = {
        summary: summary,
        description: description,
        location: location,
        end: {
          date: end_date,
        },
        start: {
          date: start_date,
        },
        attendees: attendees,
      };

      const response = await fetch(UPDATE_EVENT_URL, {
        method: "PUT",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    Update Event in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, invoice_id: number) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoiceItem = await stripe.invoiceItems.retrieve(invoice_id);

      return await invoiceItem.text();
    }
  error: |-
    TypeError: invoice_id is not a string.
  explanation: |-
    The `invoice_id` parameter in the `main` function was changed from `string` to `number`, which is incorrect because the `stripe.invoiceItems.retrieve` method expects a string as its argument. Additionally, the `invoiceItem.json()` method was changed to `invoiceItem.text()`, which would not cause a TypeScript error but could potentially cause a runtime error if the `invoiceItem` object does not have a `text` method or if the expected return type is not a string.
  id: |-
    hubfix_hub_123
  lang: |-
    deno
  original_code: |
    import Stripe from "https://esm.sh/stripe?target=deno";

    type Stripe = {
      token: string;
    };
    export async function main(stripe_con: Stripe, invoice_id: string) {
      const token = stripe_con["token"];
      const stripe = Stripe(`${token}`, {
        httpClient: Stripe.createFetchHttpClient(),
      });

      const invoiceItem = await stripe.invoiceItems.retrieve(`${invoice_id}`);

      return await invoiceItem.json();
    }
  original_instructions: |-
    Retrieve Invoice Line Item in stripe
  resource_type: |-
    Stripe
  resource_type_def: |-
    type Stripe = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      amount?: string,
      closedate?: string,
      dealname?: string,
      dealstage?: string,
      hubspot_owner_id?: string,
      pipeline?: string,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });
      const properties = removeObjectEmptyFields({
        amount,
        closedate,
        dealname,
        dealstage,
        hubspot_owner_id,
        pipeline,
      });
      try {
        return await client.crm.deals.basicApi.create({ properties: properties.wrongProperty });
      } catch (e) {
        throw Error(`
          ${e.code} - ${e.body.category}\n
          Message: ${e.body.message}\n
          Correlation ID: ${e.body.correlationId}
        `);
      }
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'wrongProperty')
  explanation: |-
    The error occurs because the `properties` object does not have a property called `wrongProperty`. In the original code, `properties` is the object returned by `removeObjectEmptyFields`, which contains the fields `amount`, `closedate`, `dealname`, `dealstage`, `hubspot_owner_id`, and `pipeline`. By trying to access `properties.wrongProperty`, the code attempts to read a property that does not exist on the `properties` object, resulting in a `TypeError` because `undefined` does not have properties.
  id: |-
    hubfix_hub_229
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.0/mod.ts";
    import { Client } from "npm:@hubspot/api-client@^8.1.0";

    /**
     * @param closedate Uses the following date-time format:
     * `2019-12-07T16:50:06.678Z` but time value can be omitted.
     */
    type Hubspot = {
      token: string;
    };
    export async function main(
      auth: Hubspot,
      amount?: string,
      closedate?: string,
      dealname?: string,
      dealstage?: string,
      hubspot_owner_id?: string,
      pipeline?: string,
    ) {
      const client = new Client({
        accessToken: auth.token,
      });
      const properties = removeObjectEmptyFields({
        amount,
        closedate,
        dealname,
        dealstage,
        hubspot_owner_id,
        pipeline,
      });
      try {
        return await client.crm.deals.basicApi.create({ properties });
      } catch (e) {
        throw Error(`
          ${e.code} - ${e.body.category}\n
          Message: ${e.body.message}\n
          Correlation ID: ${e.body.correlationId}
        `);
      }
    }
  original_instructions: |-
    Create Deal in hubspot
  resource_type: |-
    Hubspot
  resource_type_def: |-
    type Hubspot = {
      token: string;
    }
- broken_code: |-
    import { Octocat } from "https://cdn.skypack.dev/@octokit/rest";

    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, owner: string, repo: number) {
      const octokit = new Octocat({ auth: gh_auth.token });

      const repository = await octokit.request("GET /repos/{owner}/{repository}", {
        owner,
        repository: repo,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });

      return repository?.data?.stars_count;
    }
  error: |-
    TypeError: Octocat is not a constructor
  explanation: |-
    The code is broken because of the following reasons:
    1. The import statement is incorrect. The class `Octokit` is being incorrectly imported as `Octocat`, which does not exist in the `@octokit/rest` package.
    2. The `repo` parameter in the `main` function is incorrectly typed as `number` when it should be `string`.
    3. The `octokit.request` method is being called with an incorrect parameter name `{repository}` instead of `{repo}`.
    4. The property `stars_count` does not exist on the `data` object returned by the `octokit.request` method. The correct property name is `stargazers_count`.
  id: |-
    hubfix_hub_314
  lang: |-
    deno
  original_code: |
    import { Octokit } from "https://cdn.skypack.dev/@octokit/rest";

    /**
     * @param owner The account owner of the repository. The name is not case sensitive.
     *
     * @param repo The name of the repository. The name is not case sensitive.
     */
    type Github = {
      token: string;
    };
    export async function main(gh_auth: Github, owner: string, repo: string) {
      const octokit = new Octokit({ auth: gh_auth.token });

      const repository = await octokit.request("GET /repos/{owner}/{repo}", {
        owner,
        repo,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28",
          Accept: "application/vnd.github+json",
        },
      });

      return repository?.data?.stargazers_count;
    }
  original_instructions: |-
    Get Repo Star Count in github
  resource_type: |-
    Github
  resource_type_def: |-
    type Github = {
      token: string;
    }
- broken_code: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    };
    export async function main(glab: Gitlab, projectId: number) {
      const url = `${glab.baseUri}/api/v4/projects/${projectId}/repository/commits`;
      const issue = await fetch(`${url}`, {
        headers: {
          Authorization: `Bearer: ${glab.token}`,
          "Content-Type": "application/json",
        },
      });
      return await issue.text();
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'baseUri')
  explanation: |-
    The code is trying to access a property `baseUri` on the `glab` object, which does not exist. The correct property name is `baseUrl`. Additionally, the `projectId` parameter type was changed from `string` to `number`, which may cause issues if the API expects a string, even if the string represents a number. Lastly, the function is returning `issue.text()` instead of `issue.json()`, which changes the return type from JSON to plain text. This might not be an error per se, but it could lead to unexpected behavior if the calling code expects a JSON object.
  id: |-
    hubfix_hub_165
  lang: |-
    deno
  original_code: |
    /*
    @param: {Gitlab} glab - Resource containing Gitlab Auth API Key
    Example:
    {
      baseUrl: "https://gitlab.com"
      token: gitlab_api_key
    }
    */
    type Gitlab = {
      baseUrl: string;
      token: string;
    };
    export async function main(glab: Gitlab, projectId: string) {
      const url = `${glab.baseUrl}/api/v4/projects/${projectId}/repository/commits`;
      const issue = await fetch(`${url}`, {
        headers: {
          Authorization: `Bearer: ${glab.token}`,
          "Content-Type": "application/json",
        },
      });
      return await issue.json();
    }
  original_instructions: |-
    List Commits in gitlab
  resource_type: |-
    Gitlab
  resource_type_def: |-
    type Gitlab = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    type Gcal = {
      accessToken: string;
    };
    export async function main(gcal_auth: Gcal, calendarId: string) {
      const LIST_EVENTS_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;

      const token = gcal_auth["token"];

      const response = await fetch(LIST_EVENTS_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.text();

      return result.items;
    }
  error: |-
    TypeError: Cannot read property 'items' of undefined
  explanation: |-
    The code is broken due to two issues:

    1. The `Gcal` type has been changed to have a property `accessToken` instead of `token`. However, the code still tries to access `gcal_auth["token"]`, which no longer exists in the `Gcal` type. This will not cause a TypeScript error but will result in `undefined` being used for the authorization header, which could lead to an authentication error when the API is called.

    2. The `response.text()` method is used instead of `response.json()`. This means that `result` will be a string instead of a JSON object. Trying to access `result.items` will throw a TypeError because `items` is not a property of a string. This is the direct cause of the error message provided.
  id: |-
    hubfix_hub_43
  lang: |-
    deno
  original_code: |
    type Gcal = {
      token: string;
    };
    export async function main(gcal_auth: Gcal, calendarId: string) {
      const LIST_EVENTS_URL = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;

      const token = gcal_auth["token"];

      const response = await fetch(LIST_EVENTS_URL, {
        method: "GET",
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });

      const result = await response.json();

      return result;
    }
  original_instructions: |-
    List Events in gcal
  resource_type: |-
    Gcal
  resource_type_def: |-
    type Gcal = {
      token: string;
    }
- broken_code: |-
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import {
      ClickHouseSettings,
      createClient,
      DataFormat,
      QueryParams,
    } from "npm:@clickhouse/client@0.0.10";

    type Clickhouse = {
      host: string;
      username: string;
      password: string;
    };
    export async function main(
      auth: Clickhouse,
      query: string,
      parse_into: "json" | "text" = "json",
      format?: DataFormat,
      clickhouse_settings?: ClickHouseSettings,
      query_params?: Record<string, unknown>,
      abort_signal?: AbortSignal,
    ) {
      const client = createClient(removeObjectEmptyFields(auth));

      const params = removeObjectEmptyFields({
        query,
        format,
        clickhouse_settings,
        query_params,
        abort_signal,
      }) as QueryParams;
      const result = await client.query(params);
      await client.close();

      return await result[parse_into]();
    }

    main({
      host: "localhost",
      username: "default",
      password: "secret",
    }, "SELECT * FROM table", "xml");
  error: |-
    TypeError: result[parse_into] is not a function
  explanation: |-
    The error occurs because the `parse_into` parameter is expected to be either "json" or "text", as defined by the type `"json" | "text"`. However, in the call to `main`, "xml" is passed as an argument for `parse_into`, which is not a valid option. The function `result[parse_into]()` tries to call a method named "xml" on the `result` object, which does not exist, leading to the TypeError.
  id: |-
    hubfix_hub_268
  lang: |-
    deno
  original_code: |
    import { removeObjectEmptyFields } from "https://deno.land/x/windmill_helpers@v1.0.1/mod.ts";
    import {
      ClickHouseSettings,
      createClient,
      DataFormat,
      QueryParams,
    } from "npm:@clickhouse/client@0.0.10";

    /**
     * @param parse_into Name of the method that should be used to parse the results.
     *
     * @param format Format of the resulting dataset. Wrap the format name with `"` in the
     * argument editor.
     *
     * @param clickhouse_settings ClickHouse settings that can be applied on query level.
     *
     * @param query_params Parameters for query binding.
     *
     * @param query_params AbortSignal instance to cancel a query in progress.
     */
    type Clickhouse = {
      host: string;
      username: string;
      password: string;
    };
    export async function main(
      auth: Clickhouse,
      query: string,
      parse_into: "json" | "text" = "json",
      format?: DataFormat,
      clickhouse_settings?: ClickHouseSettings,
      query_params?: Record<string, unknown>,
      abort_signal?: AbortSignal,
    ) {
      const client = createClient(removeObjectEmptyFields(auth));

      const params = removeObjectEmptyFields({
        query,
        format,
        clickhouse_settings,
        query_params,
        abort_signal,
      }) as QueryParams;
      const result = await client.query(params);
      await client.close();

      return await result[parse_into]();
    }
  original_instructions: |-
    Run Query in clickhouse
  resource_type: |-
    Clickhouse
  resource_type_def: |-
    type Clickhouse = {
      host: string;
      username: string;
      password: string;
    }
- broken_code: |-
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
      start_index: number,
      end_index: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_ROWS_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteDimension: {
              range: {
                sheetId: sheetId,
                dimension: "ROWS",
                startIndex: start_index,
                endIndex: end_index,
              },
            },
          },
        ],
      };
      const response = await fetch(DELETE_ROWS_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.text();

      return text.deleted;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'deleted')
  explanation: |-
    The error occurs because the `text` variable is expected to be an object with a `deleted` property, but `text` is actually a string since the `response.text()` method was used instead of `response.json()`. The `response.text()` method returns the full response body as a string, not an object that could have a `deleted` property. To fix the error, `response.json()` should be used to parse the response body as JSON, assuming the API returns a JSON object with a `deleted` property.
  id: |-
    hubfix_hub_69
  lang: |-
    deno
  original_code: |
    type Gsheets = {
      token: string;
    };
    export async function main(
      gsheets_auth: Gsheets,
      spreadsheetId: string,
      sheetId: number,
      start_index: number,
      end_index: number,
    ) {
      const token = gsheets_auth["token"];

      const DELETE_ROWS_URL = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

      const body = {
        requests: [
          {
            deleteDimension: {
              range: {
                sheetId: sheetId,
                dimension: "ROWS",
                startIndex: start_index,
                endIndex: end_index,
              },
            },
          },
        ],
      };
      const response = await fetch(DELETE_ROWS_URL, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          Authorization: "Bearer " + token,
          "Content-Type": "application/json",
        },
      });
      const text = await response.json();

      return "Rows deleted.";
    }
  original_instructions: |-
    Clear Row in gsheets
  resource_type: |-
    Gsheets
  resource_type_def: |-
    type Gsheets = {
      token: string;
    }
- broken_code: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, roomId: number) {
      if (!matrix_res.apiToken) {
        throw Error("Leaving a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          roomId,
        )}/leave`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
          },
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to leave room: Error HTTP${resp.status}`);
      }
    }
  error: |-
    TypeError: roomId.toString is not a function
  explanation: |-
    The code is broken because of two issues:

    1. The `roomId` parameter type was changed from `string` to `number`, but `encodeURIComponent` expects a string argument. Since `roomId` is now a number, it does not have the `toString` method that `encodeURIComponent` internally calls, leading to a `TypeError`.

    2. The property `apiToken` is being checked for existence on the `matrix_res` object, but the actual property defined in the `Matrix` type is `token`. Since `apiToken` does not exist on `matrix_res`, the condition will always be false, and the error "Leaving a room requires an access token." will always be thrown, even if a valid token is provided.
  id: |-
    hubfix_hub_96
  lang: |-
    deno
  original_code: |
    type Matrix = {
      baseUrl: string;
      token: string;
    };
    export async function main(matrix_res: Matrix, roomId: string) {
      if (!matrix_res.token) {
        throw Error("Leaving a room requires an access token.");
      }
      const resp = await fetch(
        `${matrix_res.baseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(
          roomId,
        )}/leave`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${matrix_res.token}`,
          },
        },
      );
      if (!resp.ok) {
        throw Error(`Failed to leave room: Error HTTP${resp.status}`);
      }
    }
  original_instructions: |-
    Leave room in matrix
  resource_type: |-
    Matrix
  resource_type_def: |-
    type Matrix = {
      baseUrl: string;
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      channel: string,
      purpose: string,
    ) {
      const web = new WebClient(slack_auth.token);

      await web.conversations.setTopic({
        channel: channel,
        topic: purpose,
      });

      return { message: "Successfully updated channel topic" };
    }
  error: |-
    TypeError: web.conversations.setTopic is not a function
  explanation: |-
    The error occurs because the method `setTopic` is being called on `web.conversations`, but this method does not exist in the Slack Web API client. The original method `setPurpose` was replaced with `setTopic`, which is not a valid method of the `conversations` object. To fix the error, the method name should be reverted to `setPurpose`.
  id: |-
    hubfix_hub_15
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack_auth: Slack,
      channel: string,
      purpose: string,
    ) {
      const web = new WebClient(slack_auth);

      await web.conversations.setPurpose({
        channel: channel,
        purpose: purpose,
      });

      return { message: "Successfully updated channel purpose" };
    }
  original_instructions: |-
    Set Channel Purpose in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type AirtableConfig = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: AirtableConfig,
      atTable: AirtableTable,
      recordId?: string,
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      if (recordId) {
        const record = await airtable.find(recordId);
        return { result: record };
      } else {
        const records = await airtable.select().all();
        return { result: records };
      }
    }

    const result = await main({ apiKey: "key123" }, { baseId: "app123", tableName: "Table1" });
    console.log(result);
  error: |-
    TypeError: Airtable is not a constructor
  explanation: |-
    The code is attempting to instantiate an object of the `Airtable` class with the `new` keyword. However, the `Airtable` imported from the module is not a class but a type. Types in TypeScript are used only for static type checking and are not available at runtime. Therefore, trying to use a type as a class constructor will result in a runtime error, as types do not exist after the TypeScript code is compiled to JavaScript. The correct usage would be to import the actual class or function provided by the `airtable` module that is meant to be instantiated.
  id: |-
    hubfix_hub_357
  lang: |-
    deno
  original_code: |
    import { Airtable } from "https://deno.land/x/airtable/mod.ts";

    type Airtable = {
      apiKey: string;
    };

    type AirtableTable = {
      baseId: string;
      tableName: string;
    };
    export async function main(
      atCon: Airtable,
      atTable: AirtableTable,
      recordId?: string,
    ) {
      const airtable = new Airtable({ ...atCon, ...atTable });

      if (recordId) {
        const record = await airtable.find(recordId);
        return { result: record };
      } else {
        const records = await airtable.select().all();
        return { result: records };
      }
    }
  original_instructions: |-
    Get Record in airtable
  resource_type: |-
    Airtable
  resource_type_def: |-
    type Airtable = {
      apiKey: string;
    }
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(schedule_path: string, enabled: string) {
      const conf = wmill.createConf();
      const schedule_api = new wmill.ScheduleApi(conf);
      return await schedule_api.setScheduleEnabled(
        conf.workspace_id,
        schedule_path,
        {
          enable: enabled,
        },
      );
    }
  error: |-
    Argument of type 'string' is not assignable to parameter of type 'boolean'.
  explanation: |-
    The code is broken because the `enabled` parameter in the `main` function has been changed from a boolean to a string. The `setScheduleEnabled` method expects a boolean value for the `enabled` property in the options object, but it is being passed a string instead. Additionally, the property name within the object passed to `setScheduleEnabled` has been changed from `enabled` to `enable`, which does not match the expected property name.
  id: |-
    hubfix_hub_114
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(schedule_path: string, enabled: boolean) {
      const conf = wmill.createConf();
      const schedule_api = new wmill.ScheduleApi(conf);
      return await schedule_api.setScheduleEnabled(
        conf.workspace_id,
        schedule_path,
        {
          enabled,
        },
      );
    }
  original_instructions: |-
    Turn on/off a schedule in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack: Slack,
      channel: string,
      text = "A flow is requesting an approval to be resumed",
    ) {
      const web = new WebClient(slack.token);

      const { approvalPage } = await getResumeUrls(`channel-${channel}`);
      await web.chat.postMessage({
        channel,
        text: text + " <" + approvalPage + "|approval page>",
      });

      const result = await web.chat.publishMessage({
        channel,
        message: text + " <" + approvalPage + "|approval page>",
      });

      return result;
    }
  error: |-
    TypeError: web.chat.publishMessage is not a function
  explanation: |-
    The error occurs because the method `publishMessage` does not exist on the `web.chat` object. The correct method to call for sending a message to a Slack channel is `postMessage`, which is already being used correctly earlier in the code. The addition of the non-existent `publishMessage` method call causes the code to break.
  id: |-
    hubfix_hub_273
  lang: |-
    deno
  original_code: |
    import { getResumeUrls } from "https://deno.land/x/windmill@v1.85.0/mod.ts";
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(
      slack: Slack,
      channel: string,
      text = "A flow is requesting an approval to be resumed",
    ) {
      const web = new WebClient(slack.token);

      const { approvalPage } = await getResumeUrls(`channel-${channel}`);
      await web.chat.postMessage({
        channel,
        text: text + " <" + approvalPage + "|approval page>",
      });
    }
  original_instructions: |-
    Ask channel for approval in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      list_id: string,
      contact_ids: string[],
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists/${list_id}/contacts`,
        method: "DELETE",
        qs: {
          contact_ids: contact_ids?.join(",") || "",
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }

    main({ token: 12345 }, 'list-id', ['contact-id-1', 'contact-id-2']);
  error: |-
    TypeError: api_token.token is not a string
  explanation: |-
    The error occurs because the `api_token` parameter is expected to be of type `Sendgrid`, which should have a `token` property of type `string`. However, in the `main` function call at the bottom, the `token` is provided as a number (`12345`) instead of a string. TypeScript expects a string as per the `Sendgrid` type definition, so passing a number causes a type mismatch error.
  id: |-
    hubfix_hub_225
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    /**
     * @param contact_ids Important: contact IDs are not email addresses.
     */
    type Sendgrid = {
      token: string;
    };
    export async function main(
      api_token: Sendgrid,
      list_id: string,
      contact_ids: string[],
    ) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists/${list_id}/contacts`,
        method: "DELETE",
        qs: {
          contact_ids: contact_ids?.join(",") || "",
        },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Remove Contact From List in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      sort_dir?: "" | "ASC" | "DESC",
      type?: "" | "regular" | "plaintext" | "absplit" | "rss" | "variate",
      status?: "" | "save" | "paused" | "schedule" | "sending" | "sent",
      before_send_time?: string,
      since_send_time?: string,
      before_create_time?: string,
      since_create_time?: string,
      list_id?: string,
      folder_id?: string,
      member_id?: string,
      sort_field?: "" | "create_time" | "send_time",
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/campaigns`);
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        type,
        status,
        before_send_time,
        since_send_time,
        before_create_time,
        since_create_time,
        list_id,
        folder_id,
        member_id,
        sort_field,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorizations: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  error: |-
    TypeError: Failed to execute 'append' on 'URLSearchParams': The provided value cannot be converted to a sequence.
  explanation: |-
    The error is caused by the incorrect header name used in the fetch request. The correct header for authorization should be `Authorization`, but in the broken code, it is mistakenly written as `Authorizations`. This typo would not cause the TypeError mentioned in the error message, but it would result in an authentication error when trying to access the Mailchimp API.

    The TypeError mentioned in the error message would occur if the `value` passed to `URLSearchParams.append()` could not be converted to a string or a sequence of strings. However, the code provided ensures that `value` is either a string or a joined string from an array, so this error message does not correspond to the actual change made in the code. The correct error message for the typo would be related to an authentication failure when the Mailchimp API responds with an error due to the incorrect header name.
  id: |-
    hubfix_hub_205
  lang: |-
    deno
  original_code: |
    /**
     * @param fields *(optional)* A list of fields to return in the response.
     * Reference parameters of sub-objects with dot notation.
     *
     * @param exclude_fields *(optional)* A list of fields to exclude from the response.
     * Reference parameters of sub-objects with dot notation. If both `fields` and `exclude_fields`
     * are present, then only `exclude_fields` will be used.
     */
    type Mailchimp = {
      api_key: string;
      server: string;
    };
    export async function main(
      auth: Mailchimp,
      fields?: string[],
      exclude_fields?: string[],
      count?: number,
      offset?: number,
      sort_dir?: "" | "ASC" | "DESC",
      type?: "" | "regular" | "plaintext" | "absplit" | "rss" | "variate",
      status?: "" | "save" | "paused" | "schedule" | "sending" | "sent",
      before_send_time?: string,
      since_send_time?: string,
      before_create_time?: string,
      since_create_time?: string,
      list_id?: string,
      folder_id?: string,
      member_id?: string,
      sort_field?: "" | "create_time" | "send_time",
    ) {
      const url = new URL(`https://${auth.server}.api.mailchimp.com/3.0/campaigns`);
      const params = {
        fields,
        exclude_fields,
        count,
        offset,
        sort_dir,
        type,
        status,
        before_send_time,
        since_send_time,
        before_create_time,
        since_create_time,
        list_id,
        folder_id,
        member_id,
        sort_field,
      };
      for (const key in params) {
        const value = params[<keyof typeof params>key];
        if (value) {
          url.searchParams.append(
            key,
            Array.isArray(value) ? value.join(",") : "" + value,
          );
        }
      }

      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${auth.api_key}`,
        },
      });

      if (!response.ok) {
        throw Error(await response.text());
      }
      return await response.json();
    }
  original_instructions: |-
    Search Campaigns in mailchimp
  resource_type: |-
    Mailchimp
  resource_type_def: |-
    type Mailchimp = {
      api_key: string;
      server: string;
    }
- broken_code: |-
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(api_token: Sendgrid, name: number) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "POST",
        body: { name },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  error: |-
    TypeError: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The `name` parameter in the `main` function has been changed from type `string` to type `number`. The SendGrid API expects the `name` field in the request body to be a string, as it represents the name of a marketing list. By changing the type of `name` to `number`, the code will now fail to compile because TypeScript will detect that a number is being assigned to a property that should be a string.
  id: |-
    hubfix_hub_222
  lang: |-
    deno
  original_code: |
    import sendgrid from "npm:@sendgrid/client@^7.7.0";

    type Sendgrid = {
      token: string;
    };
    export async function main(api_token: Sendgrid, name: string) {
      sendgrid.setApiKey(api_token.token);

      const request = {
        url: `/v3/marketing/lists`,
        method: "POST",
        body: { name },
      };

      try {
        const [_, body] = await sendgrid.request(request);
        return body;
      } catch (error) {
        throw Error("\n" + JSON.stringify(error?.response?.body || error));
      }
    }
  original_instructions: |-
    Create Contact List in sendgrid
  resource_type: |-
    Sendgrid
  resource_type_def: |-
    type Sendgrid = {
      token: string;
    }
- broken_code: |-
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    import { isEmail } from "https://deno.land/x/isemail@v1.0.1/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(user_email: string, text: string, slack: Slack) {
      throwOnInvalidEmail(user_email);

      const client = new WebClient(slack.token);
      const userData = await getUserData(client, user_email);
      console.log(userData);
      const result = await sendDirectMessage(text, client, userData);

      return result;
    }

    interface UserData {
      id: string;
      email: string;
      real_name: string;
    }

    async function getUserData(
      client: WebClient,
      email: string,
    ): Promise<UserData> {
      try {
        const response = await client.users.lookupByEmail({ email: email });

        const { id, real_name } = response.user;
        return { id, email, real_name };
      } catch (err) {
        return handleApiResponse(email, err);
      }
    }

    async function sendDirectMessage(
      text: string,
      client: WebClient,
      userData: UserData,
    ) {
      const { ok, ts, channel } = await client.chat.postMessage({
        channel: userData.id,
        text,
      });
      return { ok, ts, channel, email: userData.email };
    }

    function throwOnInvalidEmail(email: string) {
      if (!isEmail(email)) {
        throw new Error("Expected user email");
      }
    }

    function handleApiResponse(email: string, error: Error) {
      return Promise.reject({ email, err_msg: error.message });
    }

    main("not-an-email", "Hello!", { token: "xoxb-your-slack-token" });
  error: |-
    TypeError: client.users.lookupByEmail is not a function
  explanation: |-
    The error occurs because the method `lookupByEmail` is assumed to exist on the `client.users` object, but it does not. This could be due to a change in the Slack API client library, where the method has been renamed, moved, or removed. To fix this error, one would need to consult the documentation for the Slack API client library being used and update the method call to the correct one.
  id: |-
    hubfix_hub_189
  lang: |-
    deno
  original_code: |
    import { WebClient } from "https://deno.land/x/slack_web_api@1.0.3/mod.ts";
    import { isEmail } from "https://deno.land/x/isemail@v1.0.1/mod.ts";

    type Slack = {
      token: string;
    };
    export async function main(user_email: string, text: string, slack: Slack) {
      throwOnInvalidEmail(user_email);

      const client = new WebClient(slack.token);
      const userData = await getUserData(client, user_email);
      console.log(userData);
      const result = await sendDirectMessage(text, client, userData);

      return result;
    }

    interface UserData {
      id: string;
      email: string;
      real_name: string;
    }

    async function getUserData(
      client: WebClient,
      email: string,
    ): Promise<UserData> {
      try {
        const response = await client.users.lookupByEmail({ email: email });

        const { id, real_name } = response.user;
        return { id, email, real_name };
      } catch (err) {
        return handleApiResponse(email, err);
      }
    }

    async function sendDirectMessage(
      text: string,
      client: WebClient,
      userData: UserData,
    ) {
      const { ok, ts, channel } = await client.chat.postMessage({
        channel: userData.id,
        text,
      });
      return { ok, ts, channel, email: userData.email };
    }

    function throwOnInvalidEmail(email: string) {
      if (!isEmail(email)) {
        throw new Error("Expected user email");
      }
    }

    function handleApiResponse(email: string, error: Error) {
      return Promise.reject({ email, err_msg: error.message });
    }
  original_instructions: |-
    Send direct message in slack
  resource_type: |-
    Slack
  resource_type_def: |-
    type Slack = {
      token: string;
    }
- broken_code: |-
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(scriptPathExact?: string) {
      return wmill.JobService.listQueue({
        workspace: wmill.getWorkplace(), // This is the intentional error
        suspend: true,
        perPage: "fifty", // This is another intentional error
        scriptPathExact,
      });
    }
  error: |-
    TypeError: wmill.getWorkplace is not a function
  explanation: |-
    The code is trying to call a function `getWorkplace` on the `wmill` object, but no such function exists in the imported module. The correct function name is `getWorkspace`. Additionally, the `perPage` parameter is expected to be a number, but the string "fifty" is passed instead, which would also cause a type error if the first error was fixed.
  id: |-
    hubfix_hub_270
  lang: |-
    deno
  original_code: |
    import * as wmill from "https://deno.land/x/windmill@v1.85.0/mod.ts";

    export async function main(scriptPathExact?: string) {
      return wmill.JobService.listQueue({
        workspace: wmill.getWorkspace(),
        suspend: true,
        perPage: 50,
        scriptPathExact,
      });
    }
  original_instructions: |-
    List Suspended Jobs in windmill
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { qrcodeGenerator } from "https://deno.land/x/qrcode@v2.0.0/mod.ts";

    export async function generateQR(qr_url: number) {
      const base64Image = qrcodeGenerator(`${qr_url}`); // data:image/gif;base64,...

      return base64Image;
    }
  error: |-
    error: TS2345 [ERROR]: Argument of type 'string' is not assignable to parameter of type 'number'.
      const base64Image = qrcodeGenerator(`${qr_url}`); // data:image/gif;base64,...
                                      ~~~~~~~~~~~~~~
        at file:///path/to/script.ts:4:35

    TS2739 [ERROR]: Type 'Promise<string>' is missing the following properties from type 'number': toFixed, toExponential, toPrecision, and 16 more.
      return base64Image;
             ~~~~~~~~~~~
        at file:///path/to/script.ts:6:10
  explanation: |-
    There are multiple issues with the code:

    1. The import statement is incorrect. The original code imports `qrcode` from the module, but the broken code attempts to import `qrcodeGenerator`, which does not exist in the module. This would result in a runtime error because `qrcodeGenerator` is not a valid export of the qrcode module.

    2. The `main` function has been renamed to `generateQR`. If there is code elsewhere that depends on a function named `main`, this change will break that code.

    3. The parameter `qr_url` has been changed from a string to a number, which is incorrect because a URL should be a string, not a number.

    4. The `qrcodeGenerator` function (which doesn't exist) is being called with a template literal that converts `qr_url` to a string, which contradicts the declared number type of `qr_url`.

    5. The return type of the function is implicitly a `Promise<string>` because the `qrcode` function is asynchronous and returns a promise that resolves to a string. However, the broken code implies that the return type should be a number, which is incorrect and would cause a type error.
  id: |-
    hubfix_hub_87
  lang: |-
    deno
  original_code: |
    import { qrcode } from "https://deno.land/x/qrcode@v2.0.0/mod.ts";

    export async function main(qr_url: string) {
      const base64Image = qrcode(`${qr_url}`); // data:image/gif;base64,...

      return base64Image;
    }
  original_instructions: |-
    Generate QR Code in qrcode
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import { Configurations, OpenAIApi } from "npm:openai@3.1.0";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      model: string = "text-embedding-ada-002",
    ) {
      const configurations = new Configurations({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configurations);

      const response = await openai.createEmbedding({
        models: model,
        inputs: prompt,
      });
      return response.data.data;
    }
  error: |-
    TypeError: Configurations is not a constructor
  explanation: |-
    The code is trying to import `Configurations` from the `openai` package, but the correct class name is `Configuration`. Additionally, the `createEmbedding` method is being called with incorrect parameters: `models` should be `model` and `inputs` should be `input`. The correct names of the parameters are singular, not plural.
  id: |-
    hubfix_hub_248
  lang: |-
    deno
  original_code: |
    import { Configuration, OpenAIApi } from "npm:openai@3.1.0";

    type Openai = {
      api_key: string;
      organization_id: string;
    };
    export async function main(
      auth: Openai,
      prompt: string,
      model: string = "text-embedding-ada-002",
    ) {
      const configuration = new Configuration({
        apiKey: auth.api_key,
        organization: auth.organization_id,
      });
      const openai = new OpenAIApi(configuration);

      const response = await openai.createEmbedding({
        model,
        input: prompt,
      });
      return response.data.data;
    }
  original_instructions: |-
    Create Embedding in openai
  resource_type: |-
    Openai
  resource_type_def: |-
    type Openai = {
      api_key: string;
      organization_id: string;
    }
- broken_code: |-
    import ApiClient from "https://deno.land/x/datadog_api/client.ts";
    import V1MonitorsApi from "https://deno.land/x/datadog_api/v1/monitors.ts";

    type Datadog = {
      apiKey: string;
      appKey: string;
      apiBase: string;
    };
    export async function main(dd_auth: Datadog) {
      let count = 0;
      // Set up a Monitors API client
      const datadog = new ApiClient(dd_auth);
      const monitorsApi = new V1MonitorsApi(datadog);

      let monitor_urls = [];
      // Search for relevant monitors via a metric filter
      for await (const monitor of monitorsApi.searchToEnd(`metric:trace*`)) {
        // Skip monitors that have a scoped environment set
        if (!monitor.query.includes("env:production")) continue;
        if (!monitor.query.includes("env:sandbox")) continue;

        // return the monitor URL for further manual inspection
        monitor_urls.push(`https://app.datadoghq.eu/monitors/${monitor.name}`);
        count++;
      }

      // Return number of matched monitors as a summary
      return { count: count, monitor_urls: monitor_urls };
    }
  error: |-
    TypeError: Cannot read property 'name' of undefined
  explanation: |-
    In the line where the URL is being pushed to the `monitor_urls` array, `monitor.name` is used instead of `monitor.id`. Assuming that the `monitor` object does not have a `name` property and only has an `id` property, this would result in a `TypeError` because `monitor.name` is undefined. The correct property to use should be `monitor.id` as in the original code.
  id: |-
    hubfix_hub_29
  lang: |-
    deno
  original_code: |
    import ApiClient from "https://deno.land/x/datadog_api/client.ts";
    import V1MonitorsApi from "https://deno.land/x/datadog_api/v1/monitors.ts";

    type Datadog = {
      apiKey: string;
      appKey: string;
      apiBase: string;
    };
    export async function main(dd_auth: Datadog) {
      let count = 0;
      // Set up a Monitors API client
      const datadog = new ApiClient(dd_auth);
      const monitorsApi = new V1MonitorsApi(datadog);

      let monitor_urls = [];
      // Search for relevant monitors via a metric filter
      for await (const monitor of monitorsApi.searchToEnd(`metric:trace*`)) {
        // Skip monitors that have a scoped environment set
        if (!monitor.query.includes("env:production")) continue;
        if (!monitor.query.includes("env:sandbox")) continue;

        // return the monitor URL for further manual inspection
        monitor_urls.push(`https://app.datadoghq.eu/monitors/${monitor.id}`);
        count++;
      }

      // Return number of matched monitors as a summary
      return { count: count, monitor_urls: monitor_urls };
    }
  original_instructions: |-
    Find Monitors in datadog
  resource_type: |-
    Datadog
  resource_type_def: |-
    type Datadog = {
      apiKey: string;
      appKey: string;
      apiBase: string;
    }
- broken_code: |-
    export async function main(
      type: string,
      table: string,
      record: object,
      schema: string,
      old_record: object,
    ) {
      console.log("type", type);
      console.log("table", table);
      console.log("record", record);
      console.log("schema", schema);
      console.log("old_record", old_record);
      return {
        typo,
        table,
        record,
        schema,
        old_record,
      };
    }
  error: |-
    ReferenceError: typo is not defined
  explanation: |-
    In the return statement, `typo` is used instead of `type`. Since `typo` is not a defined variable, the TypeScript compiler (or the JavaScript runtime in the case of Deno) will throw a ReferenceError indicating that `typo` is not defined.
  id: |-
    hubfix_hub_250
  lang: |-
    deno
  original_code: |
    export async function main(
      type: string,
      table: string,
      record: object,
      schema: string,
      old_record: object,
    ) {
      console.log("type", type);
      console.log("table", table);
      console.log("record", record);
      console.log("schema", schema);
      console.log("old_record", old_record);
      return {
        type,
        table,
        record,
        schema,
        old_record,
      };
    }
  original_instructions: |-
    preview supabase event in supabase
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(txt):

        if " " in txt:
            return txt.splt()
        elif "," in txt:
            return txt.replace(',',' ').splt()
        else:
            return len([i for i in txt if i.islower() and ord(i)%2 == 0])
  error: |-
    AttributeError: 'str' object has no attribute 'splt'
  explanation: |-
    The function `split` has been incorrectly renamed to `splt`, which is not a valid method for string objects in Python. This causes an AttributeError because Python cannot find a method named `splt` for string objects.
  id: |-
    hubfix_humaneval_py_HumanEval/125
  lang: |-
    python
  original_code: |2

    def main(txt):

        if " " in txt:
            return txt.split()
        elif "," in txt:
            return txt.replace(',',' ').split()
        else:
            return len([i for i in txt if i.islower() and ord(i)%2 == 0])
  original_instructions: "\n    Given a string of words, return a list of words split\
    \ on whitespace, if no whitespaces exists in the text you\n    should split on\
    \ commas ',' if no commas exists you should return the number of lower-case letters\
    \ with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n    Examples\n    split_words(\"Hello world!\") \u279E [\"Hello\", \"\
    world!\"]\n    split_words(\"Hello,world!\") \u279E [\"Hello\", \"world!\"]\n\
    \    split_words(\"abcdef\") == 3\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(s0: str, s1: int):
        return set(s0) == set(s2)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. It attempts to import a library named 'nonexistentlibrary', which does not exist.
    2. The `main` function is expecting an integer as the second parameter (`s1: int`), but it should be a string to compare sets of characters.
    3. Inside the `main` function, it tries to create a set from `s2`, which is not defined anywhere in the code. The correct variable name should be `s1`.
  id: |-
    hubfix_humaneval_py_HumanEval/54
  lang: |-
    python
  original_code: |2


    def main(s0: str, s1: str):

        return set(s0) == set(s1)
  original_instructions: "\n    Check if two words have the same characters.\n   \
    \ >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd',\
    \ 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n\
    \    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd',\
    \ 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n\
    \    False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(number):

        num = [1, 4, 5, 9, 10, 40, 50, 90,
               100, 400, 500, 900, 1000]
        sym = ["I", "IV", "V", "IX", "X", "XL",
               "L", "XC", "C", "CD", "D", "CM", "M"]
        i = 12
        res = ''
        while number:
            div = number // num[i]
            number %= num[i]
            while div:
                res += sym[i]
                div -= 1
            i -= 1
        return res.lowerr()
  error: |-
    AttributeError: 'str' object has no attribute 'lowerr'
  explanation: |-
    The error is caused by a typo in the method name. The correct method to convert a string to lowercase is `lower()`, but in the broken code, it is mistakenly written as `lowerr()`, which is not a valid string method and thus causes an AttributeError when the script is run.
  id: |-
    hubfix_humaneval_py_HumanEval/156
  lang: |-
    python
  original_code: |2

    def main(number):

        num = [1, 4, 5, 9, 10, 40, 50, 90,
               100, 400, 500, 900, 1000]
        sym = ["I", "IV", "V", "IX", "X", "XL",
               "L", "XC", "C", "CD", "D", "CM", "M"]
        i = 12
        res = ''
        while number:
            div = number // num[i]
            number %= num[i]
            while div:
                res += sym[i]
                div -= 1
            i -= 1
        return res.lower()
  original_instructions: "\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n\
    \    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(q,w):

        if sum(q) > x:
            return False

        i, j = 0, len(q)-1
        while i<j:
            if q[i] != q[j]:
                return False
            i+=1
            j-=1
        return True

    main([1, 2, 3], 6)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. This will cause a ModuleNotFoundError when the script is run. Additionally, inside the `main` function, the variable `x` is used in the comparison `sum(q) > x`, but `x` is not defined anywhere in the code, which would lead to a NameError if the import error was fixed and the code reached this point.
  id: |-
    hubfix_humaneval_py_HumanEval/72
  lang: |-
    python
  original_code: |2

    def main(q,w):

        if sum(q) > w:
            return False

        i, j = 0, len(q)-1
        while i<j:
            if q[i] != q[j]:
                return False
            i+=1
            j-=1
        return True
  original_instructions: "\n    Write a function that returns True if the object q\
    \ will fly, and False otherwise.\n    The object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279E\
    \ False\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\
    \n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279E\
    \ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    \n    will_it_fly([3], 5) \u279E True\n    # 3 is less than the maximum possible\
    \ weight, and it's balanced.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |
    def main(lst):

        def isPrime(n):
            for i in range(2,int(n**0.5)+1):
                if n%i==0:
                    return False

            return True
        maxx = 0
        i = 0
        while i < len(lst):
            if(lst[i] > maxx and isPrime(lst[i])):
                maxx = lst[i]
            i+=1
        result = sum(int(digit) for digit in str(maxx))
        return resul
  error: |-
    NameError: name 'resul' is not defined
  explanation: |-
    The error occurs because the variable `resul` is not defined in the code. The correct variable name should be `result`, but it was misspelled as `resul` in the return statement.
  id: |-
    hubfix_humaneval_py_HumanEval/94
  lang: |-
    python
  original_code: |2+


    def main(lst):

        def isPrime(n):
            for i in range(2,int(n**0.5)+1):
                if n%i==0:
                    return False

            return True
        maxx = 0
        i = 0
        while i < len(lst):
            if(lst[i] > maxx and isPrime(lst[i])):
                maxx = lst[i]
            i+=1
        result = sum(int(digit) for digit in str(maxx))
        return result

  original_instructions: "You are given a list of integers.\n    You need to find\
    \ the largest prime value and return the sum of its digits.\n\n    Examples:\n\
    \    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output\
    \ should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output\
    \ should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\
    \ the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\
    \ the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be\
    \ 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(txt):

        check = txt.splt(' ')[-1]
        return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
  error: |-
    AttributeError: 'str' object has no attribute 'splt'
  explanation: |-
    The function `splt` does not exist on the string object. The correct method name is `split`. This typo causes the AttributeError because Python cannot find a method named `splt` on the string object.
  id: |-
    hubfix_humaneval_py_HumanEval/134
  lang: |-
    python
  original_code: |2

    def main(txt):


        check = txt.split(' ')[-1]
        return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
  original_instructions: "\n    Create a function that returns True if the last character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and False otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\"\
    ) \u279E False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n\
    \    check_if_last_char_is_a_letter(\"apple pi e \") \u279E False\n    check_if_last_char_is_a_letter(\"\
    \") \u279E False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(nums):

        max_sum = 0
        s = 0
        for num in nums:
            s += -num
            if (s < 0):
                s = 0
            max_sum = max(s, max_sum)
        if max_sum == 0:
            max_sum = max(-i for i in nums)
        min_sum = -max_sum
        return min_sam
  error: |-
    NameError: name 'min_sam' is not defined
  explanation: |-
    The code attempts to return a variable named `min_sam`, which is not defined anywhere in the function. The correct variable name should be `min_sum`. This is a typo that causes the NameError when the function tries to return a non-existent variable.
  id: |-
    hubfix_humaneval_py_HumanEval/114
  lang: |-
    python
  original_code: |2

    def main(nums):

        max_sum = 0
        s = 0
        for num in nums:
            s += -num
            if (s < 0):
                s = 0
            max_sum = max(s, max_sum)
        if max_sum == 0:
            max_sum = max(-i for i in nums)
        min_sum = -max_sum
        return min_sum
  original_instructions: "\n    Given an array of integers nums, find the minimum\
    \ sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2,\
    \ 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(nums):

        count = 0
        for num in nums:
            if num > 10:
                odd_digits = (1, 3, 5, 7, 9)
                number_as_string = str(num)
                if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                    count += "one"

        return count
  error: |-
    TypeError: unsupported operand type(s) for +=: 'int' and 'str'
  explanation: |-
    The error occurs because the `+=` operator is used to add a string "one" to an integer `count`. In Python, you cannot add a string to an integer using the `+=` operator, as they are different data types. The `+=` operator expects both operands to be of the same type when used with numbers, so the correct way to increment `count` would be to use `count += 1` instead of `count += "one"`.
  id: |-
    hubfix_humaneval_py_HumanEval/146
  lang: |-
    python
  original_code: |2

    def main(nums):


        count = 0
        for num in nums:
            if num > 10:
                odd_digits = (1, 3, 5, 7, 9)
                number_as_string = str(num)
                if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                    count += 1

        return count
  original_instructions: "Write a function that takes an array of numbers as input\
    \ and returns\n    the number of elements in the array that are greater than 10\
    \ and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n \
    \   For example:\n    specialFilter([15, -73, 14, -15]) => 1\n    specialFilter([33,\
    \ -2, -3, 45, 21, 109]) => 2\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n):
        if n < 2:
            return False
        for k in range(2, n - 1):
            if n % k == 0:
                return False
        return True

    main("string")
  error: |-
    Traceback (most recent call last):
      File "script.py", line 8, in <module>
        main("string")
      File "script.py", line 5, in main
        for k in range(2, n - 1):
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
  explanation: |-
    The function `main` is designed to take an integer `n` and determine if it is a prime number. However, the function is called with a string `"string"` instead of an integer. This causes a `TypeError` because the `-` operator is not supported between instances of 'str' and 'int', which occurs when trying to calculate the range `2` to `n - 1`.
  id: |-
    hubfix_humaneval_py_HumanEval/31
  lang: |-
    python
  original_code: |2


    def main(n):

        if n < 2:
            return False
        for k in range(2, n - 1):
            if n % k == 0:
                return False
        return True
  original_instructions: "Return true if a given number is prime, and false otherwise.\n\
    \    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n\
    \    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n\
    \    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(lst):

        lst = srted(set(lst))
        return None if len(lst) < 2 else lst[2]
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 3, in <module>
      File "<stdin>", line 3, in main
    NameError: name 'srted' is not defined
  explanation: |-
    The code is broken because of two issues:

    1. The function `sorted` is misspelled as `srted`, which is not a defined function in Python, leading to a `NameError`.
    2. The index `lst[2]` is used to access the second element of the list, but in Python, indices are zero-based, so the second element should be accessed with `lst[1]`. Using `lst[2]` would attempt to access the third element, which could also lead to an `IndexError` if the list does not have at least three unique elements after being converted to a set and sorted.
  id: |-
    hubfix_humaneval_py_HumanEval/90
  lang: |-
    python
  original_code: |2

    def main(lst):

        lst = sorted(set(lst))
        return None if len(lst) < 2 else lst[1]
  original_instructions: "\n    You are given a list of integers.\n    Write a function\
    \ next_smallest() that returns the 2nd smallest element of the list.\n    Return\
    \ None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n\
    \    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1,\
    \ 1]) == None\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(string: str, substring: int) -> int:

        times = 0

        for i in range(len(string) - len(substring) + 1):
            if string[i:i+len(substring)] == substring:
                times += 1

        return times

    main(123, 'substring')
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:

    1. The script attempts to import a library called `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError`.
    2. The `main` function is expecting a `str` type for the `substring` parameter, but the type hint has been changed to `int`, which is incorrect and would cause a type hinting issue (although Python itself won't raise an error for this at runtime).
    3. The `main` function is called with an integer as the first argument, whereas it expects a string. This would cause a `TypeError` when `len(string)` is called if the script were to get past the import error.
    4. The `substring` parameter is expected to be a string, but the function is called with a string for `string` and an integer for `substring`. This would also cause a `TypeError` when `len(substring)` is called.
  id: |-
    hubfix_humaneval_py_HumanEval/18
  lang: |-
    python
  original_code: |2


    def main(string: str, substring: str) -> int:

        times = 0

        for i in range(len(string) - len(substring) + 1):
            if string[i:i+len(substring)] == substring:
                times += 1

        return times
  original_instructions: " Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n\
    \    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa',\
    \ 'aa')\n    3\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr, k):
        if k == 0:
            return []
        arr.sorty()
        ans = arr[-k:]
        return ans
  error: |-
    AttributeError: 'list' object has no attribute 'sorty'
  explanation: |-
    The code attempts to call a method `sorty()` on the list object `arr`, which does not exist. The correct method name is `sort()`. The incorrect method name `sorty()` causes the AttributeError.
  id: |-
    hubfix_humaneval_py_HumanEval/120
  lang: |-
    python
  original_code: |2

    def main(arr, k):

        if k == 0:
            return []
        arr.sort()
        ans = arr[-k:]
        return ans
  original_instructions: "\n    Given an array arr of integers and a positive integer\
    \ k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\
    \n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4,\
    \ -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n       \
    \ Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2,\
    \ 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array\
    \ will be in the range of [1, 1000].\n        2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(number, need, remaining):
        if(need <= remaining):
            return [ number + need , remaining-need ]
        else:
            return [ number + extra , 0]
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library called 'nonexistentlibrary', which does not exist. This will cause a ModuleNotFoundError when the script is run. Additionally, the variable 'extra' is used in the else block without being defined, which would cause a NameError if the import statement did not already cause the script to fail.
  id: |-
    hubfix_humaneval_py_HumanEval/159
  lang: |-
    python
  original_code: |2

    def main(number, need, remaining):

        if(need <= remaining):
            return [ number + need , remaining-need ]
        else:
            return [ number + remaining , 0]
  original_instructions: "\n    You're a hungry rabbit, and you already have eaten\
    \ a certain number of carrots,\n    but now you need to eat more carrots to complete\
    \ the day's meals.\n    you should return an array of [ total number of eaten\
    \ carrots after your meals,\n                                    the number of\
    \ carrots left after your meals ]\n    if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n\n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n\n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n\n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List


    def main(numbers: List[float], threshold: str) -> int:

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    distance = abs(elem - elem2)
                    if distance < threshold:
                        return True

        return "False"
  error: |-
    Traceback (most recent call last):
      File "script.py", line 12, in <module>
        main([1.0, 2.0, 3.0], '0.5')
      File "script.py", line 8, in main
        if distance < threshold:
    TypeError: '<' not supported between instances of 'float' and 'str'
  explanation: |-
    The code is broken because of two reasons:

    1. The `threshold` parameter is annotated as a `str` (string) instead of `float`, which is incorrect because the comparison in the `if distance < threshold:` line expects `threshold` to be a numeric type (float or int).

    2. The return type of the function is changed to `int`, but the function returns a boolean value `True` and a string `"False"`. The return type should be `bool` to match the returned values.

    The error message indicates that the '<' operator is not supported between instances of 'float' and 'str', which occurs because the `threshold` parameter is passed as a string, and the comparison is made between a float (`distance`) and a string (`threshold`).
  id: |-
    hubfix_humaneval_py_HumanEval/0
  lang: |-
    python
  original_code: |
    from typing import List


    def main(numbers: List[float], threshold: float) -> bool:

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    distance = abs(elem - elem2)
                    if distance < threshold:
                        return True

        return False
  original_instructions: " Check if in given list of numbers, are any two numbers\
    \ closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr):
        ans = 0
        for i in range(len(arr) // 2):
            if arr[i] != arr[len(lst) - i - 1]:
                ans += 1
        return ans

    main([1, 2, 3])
  error: |-
    NameError: name 'lst' is not defined
  explanation: |-
    The code attempts to use a variable named `lst` which has not been defined anywhere in the script. The original code used `arr` to refer to the list being passed to the function, but the broken code incorrectly tries to use `lst` instead of `arr` when calculating the length of the list in the comparison `arr[len(lst) - i - 1]`. This results in a `NameError` because `lst` does not exist in the current scope.
  id: |-
    hubfix_humaneval_py_HumanEval/73
  lang: |-
    python
  original_code: |2

    def main(arr):

        ans = 0
        for i in range(len(arr) // 2):
            if arr[i] != arr[len(arr) - i - 1]:
                ans += 1
        return ans
  original_instructions: "\n    Given an array arr of integers, find the minimum number\
    \ of elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(num):

        even_count = 0
        odd_count = 0
        for i in str(abs(num)):
            if int(i)%2==0:
                even_count +=1
            else:
                odd_count +=1
        return (even_count, odd_count)

    main("string_instead_of_int")
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
    TypeError: bad operand type for abs(): 'str'
  explanation: |-
    The code is broken for two reasons:

    1. The script attempts to import a library named `nonexistentlibrary`, which does not exist. This will raise a `ModuleNotFoundError` when Python tries to import it.

    2. The `main` function is called with a string `"string_instead_of_int"` instead of an integer, which will cause a `TypeError` because the `abs()` function expects a number, not a string. The error message for the `TypeError` would be encountered only if the import error is fixed or the nonexistent import is removed.
  id: |-
    hubfix_humaneval_py_HumanEval/155
  lang: |-
    python
  original_code: |2

    def main(num):

        even_count = 0
        odd_count = 0
        for i in str(abs(num)):
            if int(i)%2==0:
                even_count +=1
            else:
                odd_count +=1
        return (even_count, odd_count)
  original_instructions: "Given an integer. return a tuple that has the number of\
    \ even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12)\
    \ ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(value):

        from math import flor, ceel

        if value.count('.') == 1:
            # remove trailing zeros
            while (value[-1] == '0'):
                value = value[:-1]

        num = float(value)
        if value[-2:] == '.5':
            if num > 0:
                res = ceel(num)
            else:
                res = flor(num)
        elif len(value) > 0:
            res = int(round(num))
        else:
            res = 0

        return result
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 3, in <module>
    ImportError: cannot import name 'flor' from 'math' (unknown location)
  explanation: |-
    The code is broken because:
    - The `math` module functions `floor` and `ceil` are incorrectly spelled as `flor` and `ceel`, respectively, which do not exist in the `math` module.
    - The variable `result` is returned, but it is never defined in the function. The correct variable name should be `res`.
  id: |-
    hubfix_humaneval_py_HumanEval/99
  lang: |-
    python
  original_code: |2+

    def main(value):

        from math import floor, ceil

        if value.count('.') == 1:
            # remove trailing zeros
            while (value[-1] == '0'):
                value = value[:-1]

        num = float(value)
        if value[-2:] == '.5':
            if num > 0:
                res = ceil(num)
            else:
                res = floor(num)
        elif len(value) > 0:
            res = int(round(num))
        else:
            res = 0

        return res

  original_instructions: "\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(number: str) -> float:
        return number % 1.0
  error: |-
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The function `main` is now expecting a parameter of type `str` (string) instead of `float`. Inside the function, it attempts to use the modulus operator `%` with a string and a float, which is not a valid operation in Python. The modulus operator can only be used with numeric types, not with a string and a number. This results in a `TypeError`.
  id: |-
    hubfix_humaneval_py_HumanEval/2
  lang: |-
    python
  original_code: |2


    def main(number: float) -> float:

        return number % 1.0
  original_instructions: " Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List, Tuple


    def main(numbers: List[float]) -> Tuple[float, float]:

        closest_pair = None
        distance = None

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    if distance is None:
                        distance = abs(elem - elem2)
                        closest_pair = tuple(sorted([elem, elem2]))
                    else:
                        new_distance = abs(elem - elem2)
                        if new_distance < distance:
                            distance = new_distance
                            closest_pair = tuple(sorted([elem, elem2]))

        return closest_pair, distance
  error: |-
    TypeError: cannot unpack non-iterable NoneType object
  explanation: |-
    The function `main` is declared to return a `Tuple[float, float]`, but the actual return statement `return closest_pair, distance` is returning a tuple with the first element being another tuple (the `closest_pair`) and the second element being a float (`distance`). This does not match the declared return type. The error message indicates that the function is trying to unpack a `NoneType` object, which suggests that the function is being called with an empty list or not being called at all, resulting in `closest_pair` being `None`. To fix the code, ensure that the function is called with a non-empty list and that the return type matches the actual returned value.
  id: |-
    hubfix_humaneval_py_HumanEval/20
  lang: |-
    python
  original_code: |
    from typing import List, Tuple


    def main(numbers: List[float]) -> Tuple[float, float]:

        closest_pair = None
        distance = None

        for idx, elem in enumerate(numbers):
            for idx2, elem2 in enumerate(numbers):
                if idx != idx2:
                    if distance is None:
                        distance = abs(elem - elem2)
                        closest_pair = tuple(sorted([elem, elem2]))
                    else:
                        new_distance = abs(elem - elem2)
                        if new_distance < distance:
                            distance = new_distance
                            closest_pair = tuple(sorted([elem, elem2]))

        return closest_pair
  original_instructions: " From a supplied list of numbers (of length at least two)\
    \ select and return two that are the closest to each\n    other and return them\
    \ in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr):
        ind=-1
        i=1
        while i<len(arr):
          if arr[i]<arr[i-1]:
            ind=i
          i+=1
        return idx
  error: |-
    NameError: name 'idx' is not defined
  explanation: |-
    The variable `idx` is used in the return statement, but it is not defined anywhere in the function. The correct variable name should be `ind`, which is defined and used to track the index within the loop.
  id: |-
    hubfix_humaneval_py_HumanEval/135
  lang: |-
    python
  original_code: |2

    def main(arr):

        ind=-1
        i=1
        while i<len(arr):
          if arr[i]<arr[i-1]:
            ind=i
          i+=1
        return ind
  original_instructions: "Create a function which returns the largest index of an\
    \ element which\n    is not greater than or equal to the element immediately preceding\
    \ it. If\n    no such element exists then return -1. The given array will not\
    \ contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5])\
    \ = 3\n    can_arrange([1,2,3]) = -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s):

        return ' '.join([''.join(sorted(list(i))) for i in s.split()])

    main(123)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 5, in <module>
        main(123)
      File "script.py", line 3, in main
        return ' '.join([''.join(sorted(list(i))) for i in s.split()])
    AttributeError: 'int' object has no attribute 'split'
  explanation: |-
    The function `main` is expecting a string as its parameter because it uses the `split` method, which is a string method. However, the function is called with an integer (`123`) instead of a string. This causes an AttributeError because integers do not have a `split` method.
  id: |-
    hubfix_humaneval_py_HumanEval/86
  lang: |-
    python
  original_code: |2

    def main(s):

        return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
  original_instructions: "\n    Write a function that takes a string and returns an\
    \ ordered version of it.\n    Ordered version of string, is a string where all\
    \ words (separated by space)\n    are replaced by a new word where all the characters\
    \ arranged in\n    ascending order based on ascii value.\n    Note: You should\
    \ keep the order of words and blank spaces in the sentence.\n\n    For example:\n\
    \    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n\
    \    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(lst):

        smallest = list(filter(lambda x: x < 0, lst))
        largest = list(filter(lambda x: x > 0, lst))
        return (max(smallest) if smallest else None, min(bigger) if larger else None)
  error: |-
    NameError: name 'bigger' is not defined
  explanation: |-
    In the return statement, the variable `bigger` is used, but it is not defined anywhere in the code. The correct variable name should be `largest`, as defined earlier in the function. Additionally, the condition `if larger else None` also uses an incorrect variable name; it should be `if largest else None`.
  id: |-
    hubfix_humaneval_py_HumanEval/136
  lang: |-
    python
  original_code: |2

    def main(lst):

        smallest = list(filter(lambda x: x < 0, lst))
        largest = list(filter(lambda x: x > 0, lst))
        return (max(smallest) if smallest else None, min(largest) if largest else None)
  original_instructions: "\n    Create a function that returns a tuple (a, b), where\
    \ 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of\
    \ positive integers in a list.\n    If there is no negative or positive integers,\
    \ return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n\
    \    largest_smallest_integers([0]) == (None, None)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n):

        if n%2==0:
            odd_collatz = []
        else:
            odd_collatz = [n]
        while n > 1:
            if n % 2 == 0:
                n = n/2
            else:
                n = n*3 + 1

            if n%2 == 1:
                odd_collatz.append(int(n))

        return sorted(odd_collatz)

    main("string input")
  error: |-
    Traceback (most recent call last):
      File "script.py", line 15, in <module>
        main("string input")
      File "script.py", line 4, in main
        if n%2==0:
    TypeError: not all arguments converted during string formatting
  explanation: |-
    The code is broken because the `main` function is being called with a string argument "string input" instead of an integer. The modulo operation `%` and the arithmetic operations inside the function expect an integer, so passing a string causes a `TypeError`.
  id: |-
    hubfix_humaneval_py_HumanEval/123
  lang: |-
    python
  original_code: |2

    def main(n):

        if n%2==0:
            odd_collatz = []
        else:
            odd_collatz = [n]
        while n > 1:
            if n % 2 == 0:
                n = n/2
            else:
                n = n*3 + 1

            if n%2 == 1:
                odd_collatz.append(int(n))

        return sorted(odd_collatz)
  original_instructions: "\n    Given a positive integer n, return a sorted list that\
    \ has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a\
    \ conjecture in mathematics that concerns a sequence defined\n    as follows:\
    \ start with any positive integer n. Then each term is obtained from the\n   \
    \ previous term as follows: if the previous term is even, the next term is one\
    \ half of\n    the previous term. If the previous term is odd, the next term is\
    \ 3 times the previous\n    term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1)\
    \ is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(operator, operand):
        expression = str(operand[0])
        for oprt, oprn in zip(operator, operand[1:]):
            expression += oprt + str(oprn)
        return evl(expression)
  error: |-
    NameError: name 'evl' is not defined
  explanation: |-
    The function `evl` does not exist. The correct function name is `eval`. By changing `eval` to `evl`, the code attempts to call a function that has not been defined, resulting in a `NameError`.
  id: |-
    hubfix_humaneval_py_HumanEval/160
  lang: |-
    python
  original_code: |2

    def main(operator, operand):

        expression = str(operand[0])
        for oprt, oprn in zip(operator, operand[1:]):
            expression+= oprt + str(oprn)
        return eval(expression)
  original_instructions: "\n    Given two lists operator, and operand. The first list\
    \ has basic algebra operations, and\n    the second list is a list of integers.\
    \ Use the two given lists to build the algebric\n    expression and return the\
    \ evaluation of this expression.\n\n    The basic algebra operations:\n    Addition\
    \ ( + )\n    Subtraction ( - )\n    Multiplication ( * )\n    Floor division (\
    \ // )\n    Exponentiation ( ** )\n\n    Example:\n    operator['+', '*', '-']\n\
    \    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n \
    \   Note:\n        The length of operator list is equal to the length of operand\
    \ list minus one.\n        Operand is a list of of non-negative integers.\n  \
    \      Operator list has at least one operator, and operand list has at least\
    \ two operands.\n\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(sentence):

        new_lst = []
        for word in sentence.split():
            flg = 0
            if len(word) == 1:
                flg = 1
            for i in range(2, len(word)):
                if len(word)%i == 0:
                    flg = 1
            if flg == 0 or len(word) == 2:
                new_lst.append(word)
        return " ".join(new_list)
  error: |-
    NameError: name 'new_list' is not defined
  explanation: |-
    The variable `new_list` is not defined in the function. The correct variable name should be `new_lst` as used earlier in the function. The error occurs because the code attempts to join a list called `new_list`, which has not been declared or assigned any value, instead of the intended `new_lst`.
  id: |-
    hubfix_humaneval_py_HumanEval/143
  lang: |-
    python
  original_code: |2

    def main(sentence):

        new_lst = []
        for word in sentence.split():
            flg = 0
            if len(word) == 1:
                flg = 1
            for i in range(2, len(word)):
                if len(word)%i == 0:
                    flg = 1
            if flg == 0 or len(word) == 2:
                new_lst.append(word)
        return " ".join(new_lst)
  original_instructions: "\n    You are given a string representing a sentence,\n\
    \    the sentence contains some words separated by a space,\n    and you have\
    \ to return a string that contains the words from the original sentence,\n   \
    \ whose lengths are prime numbers,\n    the order of the words in the new string\
    \ should be the same as the original one.\n\n    Example 1:\n        Input: sentence\
    \ = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input:\
    \ sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n\
    \        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List
    import non_existent_library  # This library does not exist

    def main(operations: List[str]) -> int:  # Changed the type of operations to List[str] and return type to int

        balance = 0

        for op in operations:
            balance += op  # This will cause a TypeError because you cannot add an integer and a string
            if balance < 0:
                return "True"  # Changed the return type to string

        return False  # This is still a boolean, which is inconsistent with the return type specified in the function signature
  error: |-
    Traceback (most recent call last):
      File "script.py", line 2, in <module>
        import non_existent_library
    ModuleNotFoundError: No module named 'non_existent_library'
  explanation: |-
    The code is broken for several reasons:

    1. The script attempts to import a library named `non_existent_library`, which does not exist. This will raise a `ModuleNotFoundError`.
    2. The type of the `operations` parameter has been changed from `List[int]` to `List[str]`, which is inconsistent with the intended use of the function.
    3. The return type of the function has been changed from `bool` to `int`, but the function still returns a string `"True"` and a boolean `False`, which are not of type `int`.
    4. Inside the loop, the code attempts to add a string to an integer (`balance += op`), which will raise a `TypeError` because these types cannot be added together.
  id: |-
    hubfix_humaneval_py_HumanEval/3
  lang: |-
    python
  original_code: |
    from typing import List


    def main(operations: List[int]) -> bool:

        balance = 0

        for op in operations:
            balance += op
            if balance < 0:
                return True

        return False
  original_instructions: " You're given a list of deposit and withdrawal operations\
    \ on a bank account that starts with\n    zero balance. Your task is to detect\
    \ if at any point the balance of account fallls below zero, and\n    at that point\
    \ function should return True. Otherwise it should return False.\n    >>> below_zero([1,\
    \ 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(lst):

        import math
        squared = 0
        for i in lst:
            squared += math.ceiling(i)**2
        return squared
  error: |-
    AttributeError: module 'math' has no attribute 'ceiling'
  explanation: |-
    The code attempts to call a function `math.ceiling()` which does not exist in the `math` module. The correct function name is `math.ceil()`. The incorrect function name `math.ceiling()` causes an AttributeError because the `math` module does not have an attribute with that name.
  id: |-
    hubfix_humaneval_py_HumanEval/133
  lang: |-
    python
  original_code: |2


    def main(lst):

        import math
        squared = 0
        for i in lst:
            squared += math.ceil(i)**2
        return squared
  original_instructions: "You are given a list of numbers.\n    You need to return\
    \ the sum of squared numbers in the given list,\n    round each element in the\
    \ list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3]\
    \ the output should be 14\n    For lst = [1,4,9] the output should be 98\n   \
    \ For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output\
    \ should be 29\n    For lst = [-2.4,1,1] the output should be 6\n\n\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str):

        def is_prime(k):
            if k < 2:
                return False
            for i in range(2, k - 1):
                if k % i == 0:
                    return False
            return True
        largest = 1
        for j in range(2, n + 1):
            if n % j == 0 and is_prime(j):
                largest = max(largest, j)
        return largest
  error: |-
    TypeError: '<=' not supported between instances of 'int' and 'str'
  explanation: |-
    The function `main` was originally expecting an integer parameter `n`, but the type hint was changed to `str`, which indicates that it should be a string. When the `range` function is called with `n + 1`, it will raise a `TypeError` because you cannot use the `+` operator between an integer and a string. Similarly, the expression `n % j` will also raise a `TypeError` for attempting to use the modulus operator between a string and an integer.
  id: |-
    hubfix_humaneval_py_HumanEval/59
  lang: |-
    python
  original_code: |2


    def main(n: int):

        def is_prime(k):
            if k < 2:
                return False
            for i in range(2, k - 1):
                if k % i == 0:
                    return False
            return True
        largest = 1
        for j in range(2, n + 1):
            if n % j == 0 and is_prime(j):
                largest = max(largest, j)
        return largest
  original_instructions: "Return the largest prime factor of n. Assume n > 1 and is\
    \ not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n\
    \    2\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(x):
        odd_digit_elements = []
        for i in x:
            if all (int(c) % 2 == 1 for c in str(i)):
                odd_digit_elements.append(i)
        return sorted(odd_digit_elements)

    main("12345")
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the `main` function is called with a string "12345" instead of a list of numbers, which would also cause a `TypeError` if the `ModuleNotFoundError` was resolved.
  id: |-
    hubfix_humaneval_py_HumanEval/104
  lang: |-
    python
  original_code: |2

    def main(x):

        odd_digit_elements = []
        for i in x:
            if all (int(c) % 2 == 1 for c in str(i)):
                odd_digit_elements.append(i)
        return sorted(odd_digit_elements)
  original_instructions: "Given a list of positive integers x. return a sorted list\
    \ of all\n    elements that hasn't any even digit.\n\n    Note: Returned list\
    \ should be sorted in increasing order.\n\n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str) -> int:
        return ' '.join([str(x) for x in range(m + 1)])
  error: |-
    NameError: name 'm' is not defined
  explanation: |-
    The variable `m` is used inside the list comprehension, but it is not defined anywhere in the code. The correct variable to use is `n`, which is the parameter of the `main` function. Additionally, the function's signature has been changed incorrectly: the parameter `n` is now expected to be a string (`n: str`), which will cause a TypeError when `range` is called with a string argument. Also, the return type of the function has been changed to `int`, but the function is still returning a string, which is another error.
  id: |-
    hubfix_humaneval_py_HumanEval/15
  lang: |-
    python
  original_code: |2


    def main(n: int) -> str:

        return ' '.join([str(x) for x in range(n + 1)])
  original_instructions: " Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n\
    \    '0 1 2 3 4 5'\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(lst):

        return sum([i**2 for i in lst if i > 0 and i%2!=0 and "," not in str(i)])

    main("test")
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 5, in <module>
      File "<stdin>", line 3, in main
      File "<stdin>", line 3, in <listcomp>
    TypeError: '>' not supported between instances of 'str' and 'int'
  explanation: |-
    The code is broken because the `main` function expects a list of numbers as its parameter, but it is being called with a string ("test"). When the list comprehension tries to perform the comparison `i > 0`, it fails because it is attempting to compare a string (each character of "test") to an integer (0), which is not a valid operation in Python. This results in a `TypeError`.
  id: |-
    hubfix_humaneval_py_HumanEval/151
  lang: |-
    python
  original_code: |2

    def main(lst):

        return sum([i**2 for i in lst if i > 0 and i%2!=0 and "." not in str(i)])
  original_instructions: "\n    Given a list of numbers, return the sum of squares\
    \ of the numbers\n    in the list that are odd. Ignore numbers that are negative\
    \ or not integers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0\
    \ = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9,\
    \ -2]) == 81\n    double_the_difference([0]) == 0\n\n    If the input list is\
    \ empty, return 0.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(l1: list, l2: list):

        ret = set()
        for e1 in l1:
            for e2 in l2:
                if e1 == e2:
                    ret.add(e1)
        return sorted(list(res))
  error: |-
    NameError: name 'res' is not defined
  explanation: |-
    The variable `res` is not defined anywhere in the code. The correct variable name should be `ret`, which is defined as a set to store the common elements. The error occurs because the `return` statement is trying to convert a non-existent variable `res` to a list and sort it, instead of the correct variable `ret`.
  id: |-
    hubfix_humaneval_py_HumanEval/58
  lang: |-
    python
  original_code: |2


    def main(l1: list, l2: list):

        ret = set()
        for e1 in l1:
            for e2 in l2:
                if e1 == e2:
                    ret.add(e1)
        return sorted(list(ret))
  original_instructions: "Return sorted unique common elements for two lists.\n  \
    \  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5,\
    \ 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str):

        results = [0, 0, 2, 0]
        if n < 4:
            return results[n]

        for _ in range(4, n + 1):
            results.append(results[-1] + results[-2] + results[-3] + results[-4])
            results.pop(0)

        return results[-1]

    main("five")
  error: |-
    TypeError: '<' not supported between instances of 'str' and 'int'
  explanation: |-
    The code is broken because the `main` function now expects a parameter of type `str` (string) instead of `int` (integer). The comparison `n < 4` is invalid because it attempts to compare a string with an integer, which is not allowed in Python. Additionally, the function is called with a string argument `"five"`, which would not be valid even if the function parameter type was correct, as the function logic expects an integer to work with numerical indices and ranges.
  id: |-
    hubfix_humaneval_py_HumanEval/46
  lang: |-
    python
  original_code: |2


    def main(n: int):

        results = [0, 0, 2, 0]
        if n < 4:
            return results[n]

        for _ in range(4, n + 1):
            results.append(results[-1] + results[-2] + results[-3] + results[-4])
            results.pop(0)

        return results[-1]
  original_instructions: "The Fib4 number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n  \
    \  fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4).\n    Please write a function to efficiently compute the n-th element\
    \ of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n\
    \    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List


    def main(strings: List[int]) -> int:

        return ''.append(strings)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 6, in <module>
        main(["hello", "world"])
      File "script.py", line 4, in main
        return ''.append(strings)
    AttributeError: 'str' object has no attribute 'append'
  explanation: |-
    There are two issues with the code:

    1. The `main` function is now expecting a list of integers (`List[int]`) as its parameter, but it should be expecting a list of strings (`List[str]`). This would cause a type error if type checking was enforced, but Python's runtime does not enforce type annotations, so this would not cause an immediate runtime error.

    2. The method `append` is being called on an empty string literal `''`. Strings in Python do not have an `append` method; this method is specific to lists. The correct method to concatenate strings is `join`, which was used in the original code. The use of `append` here will cause an `AttributeError` at runtime.
  id: |-
    hubfix_humaneval_py_HumanEval/28
  lang: |-
    python
  original_code: |
    from typing import List


    def main(strings: List[str]) -> str:

        return ''.join(strings)
  original_instructions: " Concatenate list of strings into a single string\n    >>>\
    \ concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n \
    \   "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(x, y):
        if x > y:
            return -1
        if y % 2 == 0:
            return y
        if x == y:
            return -1
        return y - "1"
  error: |-
    TypeError: unsupported operand type(s) for -: 'int' and 'str'
  explanation: |-
    The code is trying to subtract a string "1" from the integer `y`, which is not allowed in Python. Python does not support arithmetic operations between integers and strings, which causes a TypeError.
  id: |-
    hubfix_humaneval_py_HumanEval/102
  lang: |-
    python
  original_code: |2

    def main(x, y):

        if x > y:
            return -1
        if y % 2 == 0:
            return y
        if x == y:
            return -1
        return y - 1
  original_instructions: "This function takes two positive numbers x and y and returns\
    \ the\n    biggest even integer number that is in the range [x, y] inclusive.\
    \ If\n    there's no such number, then the function should return -1.\n\n    For\
    \ example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(arr):

        if len(arr)==0:
          return True
        sorted_array=sorted(arr)
        my_arr=[]

        min_value=min(arr)
        min_index=arr.index(min_value)
        my_arr=arr[min_index:]+arr[0:min_index]
        for i in range(len(arr)):
          if my_arr[i]!=sorted_array[i]:
            return False
        return True

    main("This is not a list")
  error: |-
    Traceback (most recent call last):
      File "script.py", line 14, in <module>
        main("This is not a list")
      File "script.py", line 5, in main
        sorted_array=sorted(arr)
    TypeError: '<' not supported between instances of 'str' and 'str'
  explanation: |-
    The code is broken because the `main` function is designed to work with a list of elements that can be compared and sorted (typically numbers). However, the function is called with a string argument `"This is not a list"`. When Python tries to sort the characters in the string, it encounters a `TypeError` because the sorting operation expects an iterable of elements that can be compared with each other, such as a list of numbers, not a single string. To fix this, the function should be called with a list of comparable elements, like `main([3, 1, 2])`.
  id: |-
    hubfix_humaneval_py_HumanEval/109
  lang: |-
    python
  original_code: |2

    def main(arr):

        if len(arr)==0:
          return True
        sorted_array=sorted(arr)
        my_arr=[]

        min_value=min(arr)
        min_index=arr.index(min_value)
        my_arr=arr[min_index:]+arr[0:min_index]
        for i in range(len(arr)):
          if my_arr[i]!=sorted_array[i]:
            return False
        return True
  original_instructions: "We have an array 'arr' of N integers arr[1], arr[2], ...,\
    \ arr[N].The\n    numbers in the array will be randomly ordered. Your task is\
    \ to determine if\n    it is possible to get an array sorted in non-decreasing\
    \ order by performing\n    the following operation on the given array:\n     \
    \   You are allowed to perform right shift operation any number of times.\n\n\
    \    One right shift operation means shifting all elements of the array by one\n\
    \    position in the right direction. The last element of the array will be moved\
    \ to\n    the starting position in the array i.e. 0th index.\n\n    If it is possible\
    \ to obtain the sorted array by performing the above operation\n    then return\
    \ True else return False.\n    If the given array is empty then return True.\n\
    \n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\
    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n                 be achieved for\
    \ the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It\
    \ is not possible to get non-decreasing order for the given\n                array\
    \ by performing any number of right shift operations.\n\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(a, b, c):

        if a + b <= c or a + c <= b or b + c <= a:
            return -1
        s = (a + b + c)/2
        area = (s * (s - a) * (s - b) * (s - d)) ** 0.5
        area = round(are, 2)
        return area
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, there is a typo in the calculation of the area where 's - d' is used instead of 's - c', and 'd' is not defined anywhere in the code. Finally, there is another typo when rounding the area where 'are' is used instead of 'area'.
  id: |-
    hubfix_humaneval_py_HumanEval/71
  lang: |-
    python
  original_code: |2

    def main(a, b, c):

        if a + b <= c or a + c <= b or b + c <= a:
            return -1
        s = (a + b + c)/2
        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
        area = round(area, 2)
        return area
  original_instructions: "\n    Given the lengths of the three sides of a triangle.\
    \ Return the area of\n    the triangle rounded to 2 decimal points if the three\
    \ sides form a valid triangle.\n    Otherwise return -1\n    Three sides make\
    \ a valid triangle when the sum of any two sides is greater\n    than the third\
    \ side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1,\
    \ 2, 10) == -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main_function_changed(a, b):
        return abs(a % 10) * abs(c % 10)

    main_function_changed('5', 3)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. The script attempts to import a library named 'nonexistentlibrary', which does not exist.
    2. The main function has been renamed to 'main_function_changed', which would cause an error if the original 'main' function was called elsewhere.
    3. Inside the function, 'c' is used instead of 'b', but 'c' is not defined anywhere in the code.
    4. The function is called with a string '5' and an integer 3, which would cause a TypeError because the modulus operator (%) expects two numbers, not a string and a number.
  id: |-
    hubfix_humaneval_py_HumanEval/97
  lang: |-
    python
  original_code: |2

    def main(a, b):

        return abs(a % 10) * abs(b % 10)
  original_instructions: "Complete the function that takes two integers and returns\n\
    \    the product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28)\
    \ should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15)\
    \ should return 20.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s, n):

        result = []
        for word in s.split():
            n_consonants = 0
            for i in range(0, len(word)):
                if word[i].lower() not in ["a","e","i","o","u"]:
                    n_consonants += 1
            if n_consonants == n:
                result.append(word)
        return result

    main(1234, 2)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 12, in <module>
        main(1234, 2)
      File "script.py", line 5, in main
        for word in s.split():
    AttributeError: 'int' object has no attribute 'split'
  explanation: |-
    The function `main` expects its first parameter `s` to be a string, as it calls the `split` method on it. However, in the broken code, an integer `1234` is passed to the function instead of a string. Since integers do not have a `split` method, this results in an AttributeError when the code attempts to call `split` on an integer.
  id: |-
    hubfix_humaneval_py_HumanEval/117
  lang: |-
    python
  original_code: |2+

    def main(s, n):

        result = []
        for word in s.split():
            n_consonants = 0
            for i in range(0, len(word)):
                if word[i].lower() not in ["a","e","i","o","u"]:
                    n_consonants += 1
            if n_consonants == n:
                result.append(word)
        return result

  original_instructions: "Given a string s and a natural number n, you have been tasked\
    \ to implement\n    a function that returns a list of all words from string s\
    \ that contain exactly\n    n consonants, in order these words appear in the string\
    \ s.\n    If the string s is empty then the function should return an empty list.\n\
    \    Note: you may assume the input string contains only letters and spaces.\n\
    \    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    \    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello\
    \ world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"\
    ]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |
    from typing import List


    def main(music_string: int) -> List[str]:

        note_map = {'o': 4, 'o|': 2, '.|': 1}
        return [note_map[x] for x in music_string.split(' ') if x]
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        main("o o| .|")
      File "script.py", line 5, in main
        return [note_map[x] for x in music_string.split(' ') if x]
    AttributeError: 'int' object has no attribute 'split'
  explanation: |-
    The code is broken because the `main` function now expects an integer (`int`) as its parameter instead of a string (`str`). The `split` method is being called on `music_string`, which is now expected to be an integer, but integers do not have a `split` method, hence the AttributeError. Additionally, the return type is changed to `List[str]` which is incorrect because the original function returns a list of integers (`List[int]`), not strings.
  id: |-
    hubfix_humaneval_py_HumanEval/17
  lang: |-
    python
  original_code: |
    from typing import List


    def main(music_string: str) -> List[int]:

        note_map = {'o': 4, 'o|': 2, '.|': 1}
        return [note_map[x] for x in music_string.split(' ') if x]
  original_instructions: " Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n    Your task is to parse this string and\
    \ return list of integers corresponding to how many beats does each\n    not last.\n\
    \n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half\
    \ note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s,c):
        s = ''.join([char for char in s if char not in c])
        return (s,s[::-1] == s)

    main(123, ['a', 'e', 'i', 'o', 'u'])
  error: |-
    TypeError: 'int' object is not iterable
  explanation: |-
    The function `main` expects the first parameter `s` to be a string, as it tries to iterate over it with a list comprehension. However, the function is called with an integer (`123`) as the first argument, which is not iterable. This causes a `TypeError` to be raised.
  id: |-
    hubfix_humaneval_py_HumanEval/112
  lang: |-
    python
  original_code: |2

    def main(s,c):

        s = ''.join([char for char in s if char not in c])
        return (s,s[::-1] == s)
  original_instructions: "Task\n    We are given two strings s and c, you have to\
    \ deleted all the characters in s that are equal to any character in c\n    then\
    \ check if the result string is palindrome.\n    A string is called palindrome\
    \ if it reads the same backward as forward.\n    You should return a tuple containing\
    \ the result string and True/False for the check.\n    Example\n    For s = \"\
    abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\"\
    , c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\",\
    \ c = \"ab\", the result should be ('cdedc',True)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n: str):
        return sum(range(n + 1))
  error: |-
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The function `main` is now expecting a string (`str`) as its parameter instead of an integer (`int`). The `range` function requires an integer argument, but it's being passed a string due to the incorrect parameter type in the function definition. This causes a `TypeError` because a string cannot be interpreted as an integer by the `range` function.
  id: |-
    hubfix_humaneval_py_HumanEval/60
  lang: |-
    python
  original_code: |2


    def main(n: int):

        return sum(range(n + 1))
  original_instructions: "sum_to_n is a function that sums numbers from 1 to n.\n\
    \    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n\
    \    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List


    def main(numbers: List[str]) -> List[int]:

        import nonexistentlibrary
        c = nonexistentlibrary.Counter(numbers)
        return [n for n in numbers if c[n] <= 1]
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken because it attempts to import a library named 'nonexistentlibrary', which does not exist. Additionally, the type hint for the `numbers` parameter in the `main` function has been changed from `List[int]` to `List[str]`, which is inconsistent with the expected input type and could lead to further errors if the function were to be called with a list of integers.
  id: |-
    hubfix_humaneval_py_HumanEval/26
  lang: |-
    python
  original_code: |
    from typing import List


    def main(numbers: List[int]) -> List[int]:

        import collections
        c = collections.Counter(numbers)
        return [n for n in numbers if c[n] <= 1]
  original_instructions: " From a list of integers, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(N):
        return bin(sum(int(i) for i in str(N)))[3:]
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the given name.
  id: |-
    hubfix_humaneval_py_HumanEval/84
  lang: |-
    python
  original_code: |2

    def main(N):

        return bin(sum(int(i) for i in str(N)))[2:]
  original_instructions: "Given a positive integer N, return the total sum of its\
    \ digits in binary.\n\n    Example\n        For N = 1000, the sum of digits will\
    \ be 1 the output should be \"1\".\n        For N = 150, the sum of digits will\
    \ be 6 the output should be \"110\".\n        For N = 147, the sum of digits will\
    \ be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a):
        a = abs(b)
        return int(round(a ** (1. / 3))) ** 3 == a
  error: |-
    NameError: name 'b' is not defined
  explanation: |-
    The variable `b` is used in the `abs` function without being defined beforehand. The original code used `a` as the parameter and variable within the function, but changing it to `b` without defining `b` causes a NameError.
  id: |-
    hubfix_humaneval_py_HumanEval/77
  lang: |-
    python
  original_code: |2

    def main(a):

        a = abs(a)
        return int(round(a ** (1. / 3))) ** 3 == a
  original_instructions: "\n    Write a function that takes an integer a and returns\
    \ True\n    if this ingeger is a cube of some integer number.\n    Note: you may\
    \ assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n \
    \   iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n  \
    \  iscube(0) ==> True\n    iscube(180) ==> False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(S):

        import nonexistentlib
        sentences = nonexistentlib.split(r'[.?!]\s*', S)
        return sum(sentence[0:2] == 'I ' for sentence in sentences)
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlib'
  explanation: |-
    The code attempts to import a library called `nonexistentlib`, which does not exist. Python raises a `ModuleNotFoundError` because it cannot find a module with that name.
  id: |-
    hubfix_humaneval_py_HumanEval/91
  lang: |-
    python
  original_code: |2

    def main(S):

        import re
        sentences = re.split(r'[.?!]\s*', S)
        return sum(sentence[0:2] == 'I ' for sentence in sentences)
  original_instructions: "\n    You'll be given a string of words, and your task is\
    \ to count the number\n    of boredoms. A boredom is a sentence that starts with\
    \ the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For\
    \ example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky\
    \ is blue. The sun is shining. I love this weather\")\n    1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(x, n):
        import nonexistentlibrary

        a, b = x.split("/")
        c, d = n.split("/")
        numerator = int(a) * int(c)
        denom = int(b) * int(d)
        if (numerator/denom == int(numerator/denom)):
            return "True"
        return False
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. Python raises a `ModuleNotFoundError` when it cannot find a module with the specified name. Additionally, the function is supposed to return a boolean value, but the string "True" is returned instead of the boolean `True`. This is not an error that would cause the script to break, but it is a logical error that changes the behavior of the function.
  id: |-
    hubfix_humaneval_py_HumanEval/144
  lang: |-
    python
  original_code: |2

    def main(x, n):

        a, b = x.split("/")
        c, d = n.split("/")
        numerator = int(a) * int(c)
        denom = int(b) * int(d)
        if (numerator/denom == int(numerator/denom)):
            return True
        return False
  original_instructions: "Your task is to implement a function that will simplify\
    \ the expression\n    x * n. The function returns True if x * n evaluates to a\
    \ whole number and False\n    otherwise. Both x and n, are string representation\
    \ of a fraction, and have the following format,\n    <numerator>/<denominator>\
    \ where both numerator and denominator are positive whole numbers.\n\n    You\
    \ can assume that x, and n are valid fractions, and do not have zero as denominator.\n\
    \n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n\
    \    simplify(\"7/10\", \"10/2\") = False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n):
        import nonexistentlibrary

        primes = []
        for i in range(2, n):
            is_prime = True
            for j in range(2, i):
                if i % j == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(i)
        return primes

    main("100")
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library named 'nonexistentlibrary', which does not exist. This will cause a ModuleNotFoundError when the script is run. Additionally, the function `main` is called with a string parameter "100" instead of an integer, which would cause a TypeError inside the range function if the import error was fixed.
  id: |-
    hubfix_humaneval_py_HumanEval/96
  lang: |-
    python
  original_code: |2+

    def main(n):

        primes = []
        for i in range(2, n):
            is_prime = True
            for j in range(2, i):
                if i % j == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(i)
        return primes

  original_instructions: "Implement a function that takes an non-negative integer\
    \ and returns an array of the first n\n    integers that are prime numbers and\
    \ less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11)\
    \ => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n):
        product = 1
        odd_count = 0
        for digit in str(n):
            int_digit = int(digit)
            if int_digit%2 == 1:
                product = product * int_digit
                odd_count += 1
        if odd_count == 0:
            return 0
        else:
            return product

    result = main("12345")
  error: |-
    Traceback (most recent call last):
      File "script.py", line 12, in <module>
        result = main("12345")
      File "script.py", line 5, in main
        int_digit = int(digit)
    ValueError: invalid literal for int() with base 10: '"'
  explanation: |-
    The code is broken because the `main` function is being called with a string argument `"12345"` instead of an integer. The `main` function expects an integer `n` as its parameter, and it converts this integer to a string within the function to iterate over its digits. By passing a string, the conversion `int(digit)` fails because the quotes are considered part of the string when iterating over it, leading to a `ValueError` when trying to convert a non-numeric character (the quote) to an integer.
  id: |-
    hubfix_humaneval_py_HumanEval/131
  lang: |-
    python
  original_code: |2

    def main(n):

        product = 1
        odd_count = 0
        for digit in str(n):
            int_digit = int(digit)
            if int_digit%2 == 1:
                product= product*int_digit
                odd_count+=1
        if odd_count ==0:
            return 0
        else:
            return product
  original_instructions: "Given a positive integer n, return the product of the odd\
    \ digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)\
    \  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(lst1, lst2):

        l1 = 0
        for st in lst1:
            l1 += len(st)

        l2 = 0
        for st in lst3:  # This is the line that was changed
            l2 += len(st)

        if l1 <= l2:
            return lst1
        else:
            return lst2
  error: |-
    NameError: name 'lst3' is not defined
  explanation: |-
    The variable `lst3` is used in the second for loop, but it was never defined. The original code used `lst2`, which was a parameter of the `main` function. Since `lst3` does not exist in the scope of the function, Python raises a `NameError`.
  id: |-
    hubfix_humaneval_py_HumanEval/74
  lang: |-
    python
  original_code: |2

    def main(lst1, lst2):

        l1 = 0
        for st in lst1:
            l1 += len(st)

        l2 = 0
        for st in lst2:
            l2 += len(st)

        if l1 <= l2:
            return lst1
        else:
            return lst2
  original_instructions: "\n    Write a function that accepts two lists of strings\
    \ and returns the list that has\n    total number of chars in the all strings\
    \ of the list less than the other list.\n\n    if the two lists have the same\
    \ number of chars, return the first list.\n\n    Examples\n    total_match([],\
    \ []) \u279E []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279E ['hI',\
    \ 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279E\
    \ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279E\
    \ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E\
    \ ['4']\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(s):

        if len(s) < 3:
          return False

        for i in range(len(s) - 2):

          if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+3]:
            return False
        return True
  error: |-
    Traceback (most recent call last):
      File "script.py", line 8, in <module>
        main("example")
      File "script.py", line 6, in main
        if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+3]:
    IndexError: string index out of range
  explanation: |-
    The code is trying to access an index `s[i+3]` that does not exist when `i` is at the end of the range. Since the loop runs until `len(s) - 2`, when `i` is equal to `len(s) - 3`, `s[i+3]` will attempt to access an element one position beyond the last index of the string, causing an `IndexError`.
  id: |-
    hubfix_humaneval_py_HumanEval/80
  lang: |-
    python
  original_code: |2

    def main(s):

        if len(s) < 3:
          return False

        for i in range(len(s) - 2):

          if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
            return False
        return True
  original_instructions: "You are given a string s.\n    Your task is to check if\
    \ the string is happy or not.\n    A string is happy if its length is at least\
    \ 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a)\
    \ => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb)\
    \ => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(text):

        new_text = ""
        i = 0
        start, end = 0, 0
        while i < len(text):
            if text[i] == " ":
                end += 1
            else:
                if end - start > 2:
                    new_text += "-"+text[i]
                elif end - start > 0:
                    new_text += "_"*(end - start)+text[i]
                else:
                    new_text += text[i]
                start, end = i+1, i+1
            i+=1
        if end - start > 2:
            new_text += "-"
        elif end - start > 0:
            new_text += "_"
        return new_text

    main(123)
  error: |-
    TypeError: object of type 'int' has no len()
  explanation: |-
    The error occurs because the `main` function is expecting a string as its parameter, but an integer (`123`) is passed instead. The `len()` function cannot be called on an integer, as it is designed to work with sequences (like strings, lists, tuples, etc.). This results in a `TypeError` because the `len()` function cannot determine the length of an integer.
  id: |-
    hubfix_humaneval_py_HumanEval/140
  lang: |-
    python
  original_code: |2

    def main(text):

        new_text = ""
        i = 0
        start, end = 0, 0
        while i < len(text):
            if text[i] == " ":
                end += 1
            else:
                if end - start > 2:
                    new_text += "-"+text[i]
                elif end - start > 0:
                    new_text += "_"*(end - start)+text[i]
                else:
                    new_text += text[i]
                start, end = i+1, i+1
            i+=1
        if end - start > 2:
            new_text += "-"
        elif end - start > 0:
            new_text += "_"
        return new_text
  original_instructions: "\n    Given a string text, replace all spaces in it with\
    \ underscores,\n    and if a string has more than 2 consecutive spaces,\n    then\
    \ replace all consecutive spaces with -\n\n    fix_spaces(\"Example\") == \"Example\"\
    \n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\"\
    ) == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    from typing import List


    def main(numbers: List[float]) -> str:

        mean = sum(numbers) / len(numbers)
        return sum(abs(x - mean) for x in numbers) / len(numbers)
  error: |-
    Traceback (most recent call last):
      File "script.py", line 8, in <module>
        main([1.0, 2.0, 3.0])
    TypeError: 'str' object cannot be interpreted as an integer
  explanation: |-
    The return type of the function `main` has been changed from `float` to `str`, which is incorrect because the function is returning a float value, not a string. The error message indicates a type mismatch, as the function is expected to return a string but is actually returning a float.
  id: |-
    hubfix_humaneval_py_HumanEval/4
  lang: |-
    python
  original_code: |
    from typing import List


    def main(numbers: List[float]) -> float:

        mean = sum(numbers) / len(numbers)
        return sum(abs(x - mean) for x in numbers) / len(numbers)
  original_instructions: " For a given list of input numbers, calculate Mean Absolute\
    \ Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation\
    \ is the average absolute difference between each\n    element and a centerpoint\
    \ (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n):
        return [n + 2*i for i in nonexistent_variable]
  error: |-
    NameError: name 'nonexistent_variable' is not defined
  explanation: |-
    The code is trying to iterate over a variable called `nonexistent_variable` which has not been defined anywhere in the script. This results in a `NameError` because Python does not know what `nonexistent_variable` refers to.
  id: |-
    hubfix_humaneval_py_HumanEval/100
  lang: |-
    python
  original_code: |2

    def main(n):

        return [n + 2*i for i in range(n)]
  original_instructions: "\n    Given a positive integer n, you have to make a pile\
    \ of n levels of stones.\n    The first level has n stones.\n    The number of\
    \ stones in the next level is:\n        - the next odd number if n is odd.\n \
    \       - the next even number if n is even.\n    Return the number of stones\
    \ in each level in a list, where element at index\n    i represents the number\
    \ of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n   \
    \ [3, 5, 7]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(game, guess):
        return [abs(x-y) for x, y in zip(game, prediction)]
  error: |-
    NameError: name 'prediction' is not defined
  explanation: |-
    The variable `prediction` is used inside the list comprehension, but it is not defined anywhere in the code. The original code used `guess` as the second iterable in the `zip` function, but the broken code attempts to use `prediction`, which does not exist.
  id: |-
    hubfix_humaneval_py_HumanEval/152
  lang: |-
    python
  original_code: |2

    def main(game,guess):

        return [abs(x-y) for x,y in zip(game,guess)]
  original_instructions: "I think we all remember that feeling when the result of\
    \ some long-awaited\n    event is finally known. The feelings and thoughts you\
    \ have at that moment are\n    definitely worth noting down and comparing.\n \
    \   Your task is to determine if a person correctly guessed the results of a number\
    \ of matches.\n    You are given two arrays of scores and guesses of equal length,\
    \ where each index shows a match.\n    Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    the value is\
    \ 0, and if not, the value is the absolute difference between the guess and the\
    \ score.\n\n\n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n\
    \    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main(a, h):
        return a * h / 2.0

    main("3", [4])
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code attempts to import a library called 'nonexistentlibrary', which does not exist. This will raise a `ModuleNotFoundError` when Python cannot find the specified module. Additionally, the `main` function is called with incorrect types of parameters: a string and a list, instead of two numbers, which would raise a `TypeError` if the code execution reached that point.
  id: |-
    hubfix_humaneval_py_HumanEval/45
  lang: |-
    python
  original_code: |2


    def main(a, h):

        return a * h / 2.0
  original_instructions: "Given length of a side and high return area for a triangle.\n\
    \    >>> triangle_area(5, 3)\n    7.5\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(a, b):

        lower = max(2, min(c, b))  # 'c' is not defined
        upper = min(8, max(a, b))

        return [i for i in range(lower, upper+1) if i % 2 == 0]

    main(3, '5')  # '5' is a string, not an integer
  error: |-
    Traceback (most recent call last):
      File "script.py", line 7, in <module>
        main(3, '5')
      File "script.py", line 3, in main
        lower = max(2, min(c, b))  # 'c' is not defined
    NameError: name 'c' is not defined
  explanation: |-
    The code is broken because of two reasons:

    1. The variable `c` is used in the `min` function, but it is not defined anywhere in the code. This will raise a `NameError` because Python does not know what `c` refers to.

    2. The second argument `'5'` passed to the `main` function is a string, not an integer. This will cause a `TypeError` when the `min` or `max` function tries to compare a string with an integer, but this error will not be reached because the `NameError` will occur first.
  id: |-
    hubfix_humaneval_py_HumanEval/163
  lang: |-
    python
  original_code: |2

    def main(a, b):

        lower = max(2, min(a, b))
        upper = min(8, max(a, b))

        return [i for i in range(lower, upper+1) if i % 2 == 0]
  original_instructions: "\n    Given two positive integers a and b, return the even\
    \ digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2,\
    \ 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10,\
    \ 14) => []\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(planet1, planet2):

        planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
        if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
            return ()
        planet1_index = planet_names.index(planet1)
        planet2_index = planet_names.index(planet2)
        if planet1_index < planet2_index:
            return (planet_names[planet1_index + 1: planet2_index])
        else:
            return (planet_names[planet2_index + 1 : planet1_index])

    main("Pluto", "Earth")
  error: |-
    Traceback (most recent call last):
      File "<stdin>", line 11, in <module>
      File "<stdin>", line 6, in main
    ValueError: tuple.index(x): x not in tuple
  explanation: |-
    The code is broken because "Pluto" is passed as an argument to the `main` function, but "Pluto" is not in the `planet_names` tuple. When the code tries to find the index of "Pluto" in `planet_names` using `planet_names.index(planet1)`, it raises a `ValueError` because "Pluto" is not an element of the tuple.
  id: |-
    hubfix_humaneval_py_HumanEval/148
  lang: |-
    python
  original_code: |2

    def main(planet1, planet2):

        planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
        if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
            return ()
        planet1_index = planet_names.index(planet1)
        planet2_index = planet_names.index(planet2)
        if planet1_index < planet2_index:
            return (planet_names[planet1_index + 1: planet2_index])
        else:
            return (planet_names[planet2_index + 1 : planet1_index])
  original_instructions: "\n    There are eight planets in our solar system: the closerst\
    \ to the Sun\n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter,\
    \ Saturn,\n    Uranus, Neptune.\n    Write a function that takes two planet names\
    \ as strings planet1 and planet2.\n    The function should return a tuple containing\
    \ all planets whose orbits are\n    located between the orbit of planet1 and the\
    \ orbit of planet2, sorted by\n    the proximity to the sun.\n    The function\
    \ should return an empty tuple if planet1 or planet2\n    are not correct planet\
    \ names.\n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\"\
    )\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\"\
    ) ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    import nonexistentlibrary

    def main_function(n):
        return n%2 == 0 and n >= eight
  error: |-
    ModuleNotFoundError: No module named 'nonexistentlibrary'
  explanation: |-
    The code is broken for several reasons:
    1. It attempts to import a library named 'nonexistentlibrary', which does not exist.
    2. The function has been renamed from 'main' to 'main_function', which would cause an error if another part of the code tries to call 'main'.
    3. The variable 'eight' is used instead of the number 8, and since 'eight' is not defined anywhere in the code, it will result in a NameError.
  id: |-
    hubfix_humaneval_py_HumanEval/138
  lang: |-
    python
  original_code: |2

    def main(n):

        return n%2 == 0 and n >= 8
  original_instructions: "Evaluate whether the given number n can be written as the\
    \ sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4)\
    \ == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8)\
    \ == True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(n):

        def is_palindrome(n):
            return str(n) == str(n)[::1]

        even_palindrome_count = 0
        odd_palindrome_count = 0

        for i in range(1, n+1):
            if i%2 == 1 and is_palindrome(i):
                    odd_palindrome_count += 1
            elif i%2 == 0 and is_palindrome(i):
                even_palindrome_count += 1
        return (even_palindrome_count, odd_palindrome_count)

    main("ten")
  error: |-
    Traceback (most recent call last):
      File "script.py", line 14, in <module>
        main("ten")
      File "script.py", line 8, in main
        for i in range(1, n+1):
    TypeError: can only concatenate str (not "int") to str
  explanation: |-
    The code is broken because the `main` function is called with a string argument "ten" instead of an integer. The `range` function expects an integer value, but because `n` is a string, the expression `n+1` attempts to concatenate a string with an integer, which is not allowed in Python and results in a `TypeError`.
  id: |-
    hubfix_humaneval_py_HumanEval/107
  lang: |-
    python
  original_code: |2

    def main(n):

        def is_palindrome(n):
            return str(n) == str(n)[::-1]

        even_palindrome_count = 0
        odd_palindrome_count = 0

        for i in range(1, n+1):
            if i%2 == 1 and is_palindrome(i):
                    odd_palindrome_count += 1
            elif i%2 == 0 and is_palindrome(i):
                even_palindrome_count += 1
        return (even_palindrome_count, odd_palindrome_count)
  original_instructions: "\n    Given a positive integer n, return a tuple that has\
    \ the number of even and odd\n    integer palindromes that fall within the range(1,\
    \ n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n\
    \        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is\
    \ even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n    \
    \    Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n \
    \   Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number\
    \ of even and odd integer palindromes respectively.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(lst):

        lst.sorting()
        new_lst = []
        for i in lst:
            if len(i)%2 == 0:
                new_lst.append(i)
        return sorted(new_lst, key=lenght)
  error: |-
    AttributeError: 'list' object has no attribute 'sorting'
  explanation: |-
    The code attempts to call a method `sorting()` on a list object, which does not exist. The correct method for sorting a list in place is `sort()`. Additionally, the `sorted` function is called with a key function `lenght`, which is a typo and should be `len` to get the length of the items in the list.
  id: |-
    hubfix_humaneval_py_HumanEval/149
  lang: |-
    python
  original_code: |2

    def main(lst):

        lst.sort()
        new_lst = []
        for i in lst:
            if len(i)%2 == 0:
                new_lst.append(i)
        return sorted(new_lst, key=len)
  original_instructions: "Write a function that accepts a list of strings as a parameter,\n\
    \    deletes the strings that have odd lengths from it,\n    and returns the resulted\
    \ list with a sorted order,\n    The list is always a list of strings and never\
    \ an array of numbers,\n    and it may contain duplicates.\n    The order of the\
    \ list should be ascending by length of each word, and you\n    should return\
    \ the list sorted by that rule.\n    If two words have the same length, sort the\
    \ list alphabetically.\n    The function should return a list of strings in sorted\
    \ order.\n    You may assume that all words will have the same length.\n    For\
    \ example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(message):

        vowels = "aeiouAEIOU"
        vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
        message = message.swapcase()
        return ''.join([vowels_replace[i] if i in vowels else i for i in msg])
  error: |-
    NameError: name 'msg' is not defined
  explanation: |-
    The variable `msg` is used in the list comprehension, but it is not defined anywhere in the code. The correct variable name should be `message`, which is the parameter of the `main` function and is used earlier in the function to swap the case of the characters.
  id: |-
    hubfix_humaneval_py_HumanEval/93
  lang: |-
    python
  original_code: |2

    def main(message):

        vowels = "aeiouAEIOU"
        vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
        message = message.swapcase()
        return ''.join([vowels_replace[i] if i in vowels else i for i in message])
  original_instructions: "\n    Write a function that takes a message, and encodes\
    \ in such a\n    way that it swaps case of all letters, replaces all vowels in\n\
    \    the message with the letter that appears 2 places ahead of that\n    vowel\
    \ in the english alphabet.\n    Assume only letters.\n\n    Examples:\n    >>>\
    \ encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS\
    \ C MGSSCGG'\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    def main(word):

        if len(word) < 3:
            return ""

        vowels = {"a", "e", "i", "o", "u", "A", "E", 'O', 'U', 'I'}
        for i in range(len(word)-2, 0, -1):
            if word[i] in vowels:
                if (word[i+1] not in vowels) and (word[i-1] not in consonants):
                    return word[i]
        return ""
  error: |-
    NameError: name 'consonants' is not defined
  explanation: |-
    In the modified code, the variable `consonants` is used in the condition `if (word[i+1] not in vowels) and (word[i-1] not in consonants):`, but `consonants` is not defined anywhere in the code. This results in a `NameError` because Python cannot find a definition for the variable `consonants`.
  id: |-
    hubfix_humaneval_py_HumanEval/118
  lang: |-
    python
  original_code: |2

    def main(word):

        if len(word) < 3:
            return ""

        vowels = {"a", "e", "i", "o", "u", "A", "E", 'O', 'U', 'I'}
        for i in range(len(word)-2, 0, -1):
            if word[i] in vowels:
                if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                    return word[i]
        return ""
  original_instructions: "You are given a word. Your task is to find the closest vowel\
    \ that stands between\n    two consonants from the right side of the word (case\
    \ sensitive).\n\n    Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    find any vowel met the above condition.\n\n\
    \    You may assume that the given string contains English letter only.\n\n  \
    \  Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"\
    FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"\
    ab\") ==> \"\"\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(numbers: number[], threshold: string): Promise<boolean> {
        for (let idx = 0; idx < numbers.length; idx++) {
            for (let idx2 = 0; idx2 < numbers.length; idx2++) {
                if (idx !== idx2) {
                    const distance = Math.abs(numbers[idx] - numbers[idx2]);
                    if (distance < threshold) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the `threshold` parameter's type was changed from `number` to `string`. The `<` operator is used to compare `distance`, which is a number, with `threshold`. Since `threshold` is now a string, TypeScript throws an error because it expects a number for the comparison to make sense.
  id: |-
    hubfix_humaneval_ts_HumanEval/0
  lang: |-
    deno
  original_code: |-
    export async function main(numbers: number[], threshold: number): Promise<boolean> {
        for (let idx = 0; idx < numbers.length; idx++) {
            for (let idx2 = 0; idx2 < numbers.length; idx2++) {
                if (idx !== idx2) {
                    const distance = Math.abs(numbers[idx] - numbers[idx2]);
                    if (distance < threshold) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
  original_instructions: " Check if in given list of numbers, are any two numbers\
    \ closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(number: string): Promise<number> {
        return number % 1.0;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is attempting to use the modulus operator (%) with a string and a number, which is not allowed in TypeScript. The modulus operator is only applicable to numbers, so the parameter `number` should be of type `number`, not `string`. By changing the type of the `number` parameter to `string`, the code is now trying to perform an arithmetic operation on a type that is not compatible with the modulus operator, resulting in a compilation error.
  id: |-
    hubfix_humaneval_ts_HumanEval/2
  lang: |-
    deno
  original_code: |-
    export async function main(number: number): Promise<number> {
        return number % 1.0;
    }
  original_instructions: " Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(operations: string[]): Promise<boolean> {
        let balance: number = 0;

        for (const op of operations) {
            balance += Number(op);
            if (balance < 0) {
                return "true";
            }
        }

        return "false";
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'boolean'.
  explanation: |-
    The function `main` is expected to return a `Promise<boolean>`, but the return statements are returning string literals `"true"` and `"false"` instead of boolean values `true` and `false`. Additionally, the parameter `operations` is expected to be an array of `number` types, but it has been changed to an array of `string` types, which is not consistent with the original function's design.
  id: |-
    hubfix_humaneval_ts_HumanEval/3
  lang: |-
    deno
  original_code: |-
    export async function main(operations: number[]): Promise<boolean> {
        let balance: number = 0;

        for (const op of operations) {
            balance += op;
            if (balance < 0) {
                return true;
            }
        }

        return false;
    }
  original_instructions: " You're given a list of deposit and withdrawal operations\
    \ on a bank account that starts with\n    zero balance. Your task is to detect\
    \ if at any point the balance of account fallls below zero, and\n    at that point\
    \ function should return True. Otherwise it should return False.\n    >>> below_zero([1,\
    \ 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(numbers: string[]): Promise<number> {
        const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;
        return numbers.reduce((acc, val) => acc + Math.abs(val - mean), 0) / numbers.length;
    }
  error: |-
    error TS2345: Argument of type 'string | number' is not assignable to parameter of type 'number'.
      Type 'string' is not assignable to type 'number'.
  explanation: |-
    The code is broken because the `numbers` parameter is now expected to be an array of strings (`string[]`) instead of an array of numbers (`number[]`). The `reduce` function and the `Math.abs` function expect numerical arguments, but they are being passed strings due to the changed parameter type. This results in a type mismatch error because TypeScript expects numerical operations to be performed on numbers, not strings.
  id: |-
    hubfix_humaneval_ts_HumanEval/4
  lang: |-
    deno
  original_code: |-
    export async function main(numbers: number[]): Promise<number> {
        const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;
        return numbers.reduce((acc, val) => acc + Math.abs(val - mean), 0) / numbers.length;
    }
  original_instructions: " For a given list of input numbers, calculate Mean Absolute\
    \ Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation\
    \ is the average absolute difference between each\n    element and a centerpoint\
    \ (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0,\
    \ 2.0, 3.0, 4.0])\n    1.0\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        return [...Array(n + 1).keys()].map(x => x.toStr()).join(' ');
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    TS2339: Property 'toStr' does not exist on type 'number'.
  explanation: |-
    There are two errors in the modified code:

    1. The parameter `n` is changed from `number` to `string`, which is incorrect because the `Array` constructor expects a number, not a string. This causes the TypeScript error TS2345.

    2. The method `toStr` is called on the variable `x`, which is of type `number`. However, the correct method name is `toString`. The incorrect method name `toStr` does not exist on the `number` type, leading to TypeScript error TS2339.
  id: |-
    hubfix_humaneval_ts_HumanEval/15
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<string> {
        return [...Array(n + 1).keys()].map(x => x.toString()).join(' ');
    }
  original_instructions: " Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n\
    \    '0 1 2 3 4 5'\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(music_string: number): Promise<number[]> {
        const note_map: { [key: string]: number } = { 'o': 4, 'o|': 2, '.|': 1 };
        return music_string.split(' ').filter(x => x).map(x => note_map[x]);
    }
  error: |-
    TypeError: music_string.split is not a function
  explanation: |-
    The `main` function's parameter `music_string` was changed from `string` to `number`. The `split` method is a string method, and since `music_string` is now a number, it does not have a `split` method, which leads to a TypeError when trying to call `music_string.split(' ')`.
  id: |-
    hubfix_humaneval_ts_HumanEval/17
  lang: |-
    deno
  original_code: |-
    export async function main(music_string: string): Promise<number[]> {
        const note_map: { [key: string]: number } = { 'o': 4, 'o|': 2, '.|': 1 };
        return music_string.split(' ').filter(x => x).map(x => note_map[x]);
    }
  original_instructions: " Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n    Your task is to parse this string and\
    \ return list of integers corresponding to how many beats does each\n    not last.\n\
    \n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half\
    \ note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o\
    \ o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(string: string, substring: number): Promise<string> {
        let times = 0;

        for (let i = 0; i <= string.length - substring; i++) {
            if (string.substring(i, i + substring) === substring) {
                times += 1;
            }
        }

        return times.toString();
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The code is broken because the `substring` parameter is changed from `string` to `number`, which is not the correct type for the operation being performed. The `substring` method of a string expects a string to compare with, not a number. Additionally, the return type of the function is changed from `Promise<number>` to `Promise<string>`, which is not necessarily an error by itself but could be considered a breaking change if the function is expected to return a number elsewhere in the codebase. The comparison inside the `if` statement is also incorrect because it compares a string with a number, which will always result in `false`.
  id: |-
    hubfix_humaneval_ts_HumanEval/18
  lang: |-
    deno
  original_code: |-
    export async function main(string: string, substring: string): Promise<number> {
        let times = 0;

        for (let i = 0; i <= string.length - substring.length; i++) {
            if (string.substring(i, i + substring.length) === substring) {
                times += 1;
            }
        }

        return times;
    }
  original_instructions: " Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n\
    \    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa',\
    \ 'aa')\n    3\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(numbers: number): Promise<number> {
      const valueMap: { [key: string]: number } = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
      };

      return numbers.split(' ')
        .filter(x => x)
        .sort((a, b) => valueMap[a] - valueMap[b])
        .join(' ');
    }
  error: |-
    TypeError: numbers.split is not a function
  explanation: |-
    The code is broken because the `numbers` parameter type was changed from `string` to `number`. The `split` method is not available on the `number` type; it is a method on `string` objects. Therefore, when trying to call `numbers.split(' ')`, it results in a `TypeError` because `split` is not a function that can be called on a number.
  id: |-
    hubfix_humaneval_ts_HumanEval/19
  lang: |-
    deno
  original_code: |-
    export async function main(numbers: string): Promise<string> {
      const valueMap: { [key: string]: number } = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
      };

      return numbers.split(' ')
        .filter(x => x)
        .sort((a, b) => valueMap[a] - valueMap[b])
        .join(' ');
    }
  original_instructions: " Input is a space-delimited string of numberals from 'zero'\
    \ to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
    \ 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted\
    \ from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three\
    \ five'\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(numbers: string[]): Promise<number[]> {
        const counts: { [key: string]: number } = {};

        for (const num of numbers) {
            counts[num] = (counts[num] || 0) + 1;
        }

        return numbers.filter(n => counts[n] <= 1);
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` was originally designed to take an array of numbers (`number[]`) as its parameter. The breaking change introduced is changing the parameter type to an array of strings (`string[]`). However, the function's logic is still treating `numbers` as if it were an array of numbers, which leads to a type mismatch when trying to use a string as a key in the `counts` object (which expects a number as a key) and when trying to filter the `numbers` array based on a numeric condition. TypeScript's static type checking catches this error and prevents the code from compiling.
  id: |-
    hubfix_humaneval_ts_HumanEval/26
  lang: |-
    deno
  original_code: |-
    export async function main(numbers: number[]): Promise<number[]> {
        const counts: { [key: number]: number } = {};

        for (const num of numbers) {
            counts[num] = (counts[num] || 0) + 1;
        }

        return numbers.filter(n => counts[n] <= 1);
    }
  original_instructions: " From a list of integers, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(strings: number[]): Promise<string> {
        return strings.connect('');
    }
  error: |-
    error TS2339: Property 'connect' does not exist on type 'number[]'.
  explanation: |-
    The code is broken for two reasons:

    1. The `join` method has been incorrectly renamed to `connect`, which is not a method that exists on arrays in TypeScript or JavaScript. This causes the error message indicating that the property 'connect' does not exist on type 'number[]'.

    2. The parameter `strings` is expected to be an array of `string` values, but it has been changed to an array of `number` values. This is a type mismatch because the function is supposed to concatenate strings, not numbers. However, TypeScript does not throw an error for this specific change because the `join` method (if it were correctly named) can be called on an array of any type, and it will convert the elements to strings before joining them. But since the method name is incorrect, the first issue is the one that results in the error message.
  id: |-
    hubfix_humaneval_ts_HumanEval/28
  lang: |-
    deno
  original_code: |-
    export async function main(strings: string[]): Promise<string> {
        return strings.join('');
    }
  original_instructions: " Concatenate list of strings into a single string\n    >>>\
    \ concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n \
    \   "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<boolean> {
        if (n < 2) {
            return false;
        }
        for (let k = 2; k < n; k++) {
            if (n % k === 0) {
                return false;
            }
        }
        return true;
    }
  error: |-
    error TS2365: Operator '<' cannot be applied to types 'string' and 'number'.
    error TS2365: Operator '<' cannot be applied to types 'number' and 'string'.
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is broken because the parameter `n` is now of type `string`, but it is being used in arithmetic operations and comparisons that are only valid for numbers. Specifically, the `<` operator cannot be used to compare a string with a number, and the `%` operator cannot be used with a string operand. TypeScript expects both sides of these operators to be of a numeric type or any type that can be coerced into a number.
  id: |-
    hubfix_humaneval_ts_HumanEval/31
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        if (n < 2) {
            return false;
        }
        for (let k = 2; k < n; k++) {
            if (n % k === 0) {
                return false;
            }
        }
        return true;
    }
  original_instructions: "Return true if a given number is prime, and false otherwise.\n\
    \    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n\
    \    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n\
    \    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: number[]): Promise<string> {
        let m = l[0];
        for (const e of l) {
            if (e > m) {
                m = e;
            }
        }
        return m.toString();
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    The function `main` is declared to return a `Promise<number>`, but the actual return statement `return m.toString();` is returning a `string` because `toString()` converts the number to a string. This is a type mismatch error because TypeScript expects the function to return a `Promise<number>` as declared in the function signature.
  id: |-
    hubfix_humaneval_ts_HumanEval/35
  lang: |-
    deno
  original_code: |-
    export async function main(l: number[]): Promise<number> {
        let m = l[0];
        for (const e of l) {
            if (e > m) {
                m = e;
            }
        }
        return m;
    }
  original_instructions: "Return maximum element in the list.\n    >>> max_element([1,\
    \ 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    123\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: number[]): Promise<string> {
        for (let i = 0; i < l.length; i++) {
            for (let j = i + 1; j < l.length; j++) {
                for (let k = j + 1; k < l.length; k++) {
                    if (l[i] + l[j] + l[k] === 0) {
                        return "true";
                    }
                }
            }
        }
        return "false";
    }
  error: |-
    Type 'string' is not assignable to type 'boolean'.
  explanation: |-
    The function `main` is declared to return a `Promise<boolean>`, but the actual return statements are returning strings `"true"` and `"false"`. TypeScript expects the return type to match the declared return type, which is a boolean wrapped in a Promise, not a string. To fix this, the return statements should be `return true;` and `return false;` without the quotes.
  id: |-
    hubfix_humaneval_ts_HumanEval/40
  lang: |-
    deno
  original_code: |-
    export async function main(l: number[]): Promise<boolean> {
        for (let i = 0; i < l.length; i++) {
            for (let j = i + 1; j < l.length; j++) {
                for (let k = j + 1; k < l.length; k++) {
                    if (l[i] + l[j] + l[k] === 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
  original_instructions: "\n    triples_sum_to_zero takes a list of integers as an\
    \ input.\n    it returns True if there are three distinct elements in the list\
    \ that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1,\
    \ 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n\
    \    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2,\
    \ 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n  \
    \  "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: number[]): Promise<number[]> {
        return l.map(e => e.increment());
    }
  error: |-
    TypeError: e.increment is not a function
  explanation: |-
    The code is attempting to call a method `increment()` on the variable `e`, which is a number. In JavaScript and TypeScript, numbers do not have an `increment()` method. The original code correctly used the addition operator `+` to increment the number, but the modified code incorrectly tries to use a non-existent method, which causes a runtime error.
  id: |-
    hubfix_humaneval_ts_HumanEval/42
  lang: |-
    deno
  original_code: |-
    export async function main(l: number[]): Promise<number[]> {
        return l.map(e => e + 1);
    }
  original_instructions: "Return list with elements incremented by 1.\n    >>> incr_list([1,\
    \ 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  \
    \  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function calculateArea(a: string, h: number): Promise<number> {
        return a * h / 2.0;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The function `calculateArea` (previously `main`) is trying to perform an arithmetic multiplication operation with a variable `a` of type `string` and a variable `h` of type `number`. TypeScript does not allow arithmetic operations between a string and a number, which is why the error is thrown. The correct code should have `a` as a type `number` to perform the multiplication operation.
  id: |-
    hubfix_humaneval_ts_HumanEval/45
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, h: number): Promise<number> {
        return a * h / 2.0;
    }
  original_instructions: "Given length of a side and high return area for a triangle.\n\
    \    >>> triangle_area(5, 3)\n    7.5\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let results: number[] = [0, 0, 2, 0];
        if (n < 4) {
            return results[n];
        }

        for (let i = 4; i <= n; i++) {
            results.push(results[3] + results[2] + results[1] + results[0]);
            results.shift();
        }

        return results[3];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `n` of the `main` function has been changed from `number` to `string`. The comparison `n < 4` and the loop condition `i <= n` are both invalid because you cannot use the less than operator `<` or less than or equal operator `<=` to compare a `string` with a `number`. Additionally, `results[n]` is invalid because `n` is a string and cannot be used to index an array of numbers. TypeScript expects `n` to be a number, and using a string instead causes a type error.
  id: |-
    hubfix_humaneval_ts_HumanEval/46
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let results: number[] = [0, 0, 2, 0];
        if (n < 4) {
            return results[n];
        }

        for (let i = 4; i <= n; i++) {
            results.push(results[3] + results[2] + results[1] + results[0]);
            results.shift();
        }

        return results[3];
    }
  original_instructions: "The Fib4 number sequence is a sequence similar to the Fibbonacci\
    \ sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n  \
    \  fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4).\n    Please write a function to efficiently compute the n-th element\
    \ of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n\
    \    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(l: number[]): Promise<string> {
        if (l.slice().sort((a, b) => a - b).join(',') === l.join(',') ||
            l.slice().sort((a, z) => z - a).join(',') === l.join(',')) {
            return "true";
        }
        return false;
    }
  error: |-
    Type 'string' is not assignable to type 'boolean'.
  explanation: |-
    The function `main` is declared to return a `Promise<boolean>`, but the return statement is returning a string `"true"` instead of a boolean `true`. Additionally, the second return statement is correctly returning a boolean `false`, which is inconsistent with the first return statement. The return type of the function should be consistent with the declared return type.
  id: |-
    hubfix_humaneval_ts_HumanEval/57
  lang: |-
    deno
  original_code: |-
    export async function main(l: number[]): Promise<boolean> {
        if (l.slice().sort((a, b) => a - b).join(',') === l.join(',') ||
            l.slice().sort((a, b) => b - a).join(',') === l.join(',')) {
            return true;
        }
        return false;
    }
  original_instructions: "Return True is list elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1,\
    \ 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {

        function is_prime(k: number): boolean {
            if (k < 2) {
                return false;
            }
            for (let i = 2; i < k; i++) {
                if (k % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let largest = 1;
        for (let j = 2; j <= n; j++) {
            if (n % j === 0 && is_prime(j)) {
                largest = Math.max(largest, j);
            }
        }
        return largest;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the parameter `n` of the `main` function has been changed from `number` to `string`. The `for` loop and the modulus operator `%` expect a number, not a string. TypeScript is a statically typed language, and it expects the types of variables and parameters to be consistent with their usage. By changing the type of `n` to `string`, the code attempts to perform arithmetic operations on a string, which is not allowed.
  id: |-
    hubfix_humaneval_ts_HumanEval/59
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {

        function is_prime(k: number): boolean {
            if (k < 2) {
                return false;
            }
            for (let i = 2; i < k; i++) {
                if (k % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let largest = 1;
        for (let j = 2; j <= n; j++) {
            if (n % j === 0 && is_prime(j)) {
                largest = Math.max(largest, j);
            }
        }
        return largest;
    }
  original_instructions: "Return the largest prime factor of n. Assume n > 1 and is\
    \ not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n\
    \    2\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is defined to take a parameter `n` of type `string`, but the for loop is trying to use it in a numerical comparison (`i <= n`). Since `n` is a string, it cannot be compared to a number using the `<=` operator. The parameter `n` should be of type `number` to be used in this numerical context.
  id: |-
    hubfix_humaneval_ts_HumanEval/60
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
  original_instructions: "sum_to_n is a function that sums numbers from 1 to n.\n\
    \    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n\
    \    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number[] | []> {
      if (arr.length === 0) return [];
      const evens = arr.filter(x => x % 2 === 0);
      if (evens.length === 0) return [];
      const minValue = Math.min(...evens);
      return [minValue, arr.indexOf(minValue)];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the `main` function now expects an array of strings (`arr: string[]`) instead of an array of numbers (`arr: number[]`). The `filter` method is used with a callback that expects a number (`x % 2 === 0`), but it is being passed a string due to the changed parameter type. This results in a type error because the modulo operator (`%`) cannot be applied to a string. Additionally, `Math.min(...evens)` will also fail because `Math.min` expects a spread of numbers, not strings. The `indexOf` method will also not work as expected because it will be looking for a number in an array of strings.
  id: |-
    hubfix_humaneval_ts_HumanEval/68
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number[] | []> {
      if (arr.length === 0) return [];
      const evens = arr.filter(x => x % 2 === 0);
      if (evens.length === 0) return [];
      const minValue = Math.min(...evens);
      return [minValue, arr.indexOf(minValue)];
    }
  original_instructions: "\n    \"Given an array representing a branch of a tree that\
    \ has non-negative integer nodes\n    your task is to pluck one of the nodes and\
    \ return it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index.\n\n    Example 3:\n        Input: []\n        Output: []\n\
    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n\
    \        Explanation: 0 is the smallest value, but  there are two zeros,\n   \
    \                  so we will choose the first zero, which has the smallest index.\n\
    \n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: number[]): Promise<number> {
        const frq: number[] = new Array(max(lst) + 1).fill(0);
        for (const i of lst) {
            frq[i] += 1;
        }

        let ans: string = '-1'; // Changed the type of ans from number to string
        for (let i = 1; i < frq.length; i++) {
            if (frq[i] >= i) {
                ans = i; // This will cause a type error because i is a number
            }
        }

        return ans; // This will cause a type error because the function is supposed to return a number
    }

    function max(arr: number[]): number {
        return Math.max(...arr);
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    The variable `ans` was initially declared as a number, but it was changed to a string with the assignment `let ans: string = '-1';`. Later in the code, `ans` is assigned a number `i`, which is a type mismatch because `i` is a number and `ans` is a string. This causes a TypeScript type error because the function is supposed to return a number, not a string. The return type of the function is `Promise<number>`, but the actual returned value is a string due to the incorrect assignment.
  id: |-
    hubfix_humaneval_ts_HumanEval/69
  lang: |-
    deno
  original_code: |-
    export async function main(lst: number[]): Promise<number> {
        const frq: number[] = new Array(max(lst) + 1).fill(0);
        for (const i of lst) {
            frq[i] += 1;
        }

        let ans: number = -1;
        for (let i = 1; i < frq.length; i++) {
            if (frq[i] >= i) {
                ans = i;
            }
        }

        return ans;
    }

    function max(arr: number[]): number {
        return Math.max(...arr);
    }
  original_instructions: "\n    You are given a non-empty list of positive integers.\
    \ Return the greatest integer that is greater than\n    zero, and has a frequency\
    \ greater than or equal to the value of the integer itself.\n    The frequency\
    \ of an integer is the number of times it appears in the list.\n    If no such\
    \ a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1])\
    \ == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5,\
    \ 4, 4, 4]) == -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: number, b: string, c: number): Promise<number> {
        if (a + b <= c || a + c <= b || b + c <= a) {
            return -1;
        }
        const s: number = (a + b + c) / 2;
        let area: number = Math.sqrt(s * (s - a) * (s - parseFloat(b)) * (s - c));
        area = parseFloat(area.toFixed(2));
        return area;
    }
  error: |-
    TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
  explanation: |-
    The code is trying to perform an arithmetic addition operation (`a + b`) where `a` is a number and `b` is a string. TypeScript does not allow arithmetic operations between numbers and strings without explicit conversion because it can lead to unexpected behavior. To fix this, `b` should be converted to a number before the operation or its type should be declared as `number` if it is intended to be a numeric value.
  id: |-
    hubfix_humaneval_ts_HumanEval/71
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number, c: number): Promise<number> {
        if (a + b <= c || a + c <= b || b + c <= a) {
            return -1;
        }
        const s: number = (a + b + c) / 2;
        let area: number = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        area = parseFloat(area.toFixed(2));
        return area;
    }
  original_instructions: "\n    Given the lengths of the three sides of a triangle.\
    \ Return the area of\n    the triangle rounded to 2 decimal points if the three\
    \ sides form a valid triangle.\n    Otherwise return -1\n    Three sides make\
    \ a valid triangle when the sum of any two sides is greater\n    than the third\
    \ side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1,\
    \ 2, 10) == -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(q: number[], w: string): Promise<boolean> {
        if (q.reduce((a, b) => a + b, 0) > w) {
            return false;
        }

        let i = 0, j = q.length - 1;
        while (i < j) {
            if (q[i] !== q[j]) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
  error: |-
    TS2365: Operator '>' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The error occurs because the '>' operator is used to compare a number with a string, which is not allowed in TypeScript. The type of the parameter `w` was changed from `number` to `string`, which is incompatible with the comparison operation in the `if` statement. TypeScript expects both operands of the '>' operator to be of comparable types, typically both numbers or both strings when comparing their lexicographical order.
  id: |-
    hubfix_humaneval_ts_HumanEval/72
  lang: |-
    deno
  original_code: |-
    export async function main(q: number[], w: number): Promise<boolean> {
        if (q.reduce((a, b) => a + b, 0) > w) {
            return false;
        }

        let i = 0, j = q.length - 1;
        while (i < j) {
            if (q[i] !== q[j]) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
  original_instructions: "\n    Write a function that returns True if the object q\
    \ will fly, and False otherwise.\n    The object q will fly if it's balanced (it\
    \ is a palindromic list) and the sum of its elements is less than or equal the\
    \ maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279E\
    \ False\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\
    \n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279E\
    \ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    \n    will_it_fly([3], 5) \u279E True\n    # 3 is less than the maximum possible\
    \ weight, and it's balanced.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        let ans = 0;
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] !== arr[arr.length - i - 1]) {
                ans += arr[i];
            }
        }
        return ans;
    }
  error: |-
    error TS2365: Operator '+=' cannot be applied to types 'number' and 'string'.
  explanation: |-
    The code is trying to add a string to a number, which is not allowed in TypeScript. The `arr` parameter type was changed from `number[]` to `string[]`, and inside the loop, `arr[i]` is a string. The `+=` operator cannot be used to add a string to a number (`ans`), which causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_humaneval_ts_HumanEval/73
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ans = 0;
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] !== arr[arr.length - i - 1]) {
                ans += 1;
            }
        }
        return ans;
    }
  original_instructions: "\n    Given an array arr of integers, find the minimum number\
    \ of elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst1: string[], lst2: number[]): Promise<string[]> {
        let l1 = 0;
        for (const st of lst1) {
            l1 += st.length;
        }

        let l2 = 0;
        for (const st of lst2) {
            l2 += st.toString().length;
        }

        if (l1 <= l2) {
            return lst1;
        } else {
            return lst2;
        }
    }
  error: |-
    TS2322: Type 'number[]' is not assignable to type 'string[]'.
      Type 'number' is not assignable to type 'string'.
  explanation: |-
    The function `main` is expected to return a `Promise<string[]>`, which means a promise that resolves to an array of strings. However, in the `else` block, the code attempts to return `lst2`, which has been changed to be of type `number[]`. This is not assignable to `Promise<string[]>`, causing a type error. The TypeScript compiler will throw an error because the return type of the function does not match the expected return type.
  id: |-
    hubfix_humaneval_ts_HumanEval/74
  lang: |-
    deno
  original_code: |-
    export async function main(lst1: string[], lst2: string[]): Promise<string[]> {
        let l1 = 0;
        for (const st of lst1) {
            l1 += st.length;
        }

        let l2 = 0;
        for (const st of lst2) {
            l2 += st.length;
        }

        if (l1 <= l2) {
            return lst1;
        } else {
            return lst2;
        }
    }
  original_instructions: "\n    Write a function that accepts two lists of strings\
    \ and returns the list that has\n    total number of chars in the all strings\
    \ of the list less than the other list.\n\n    if the two lists have the same\
    \ number of chars, return the first list.\n\n    Examples\n    total_match([],\
    \ []) \u279E []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279E ['hI',\
    \ 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279E\
    \ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279E\
    \ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E\
    \ ['4']\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: string): Promise<boolean> {

        function is_prime(n: number): boolean {
            for (let j = 2; j < n; j++) {
                if (n % j === 0) {
                    return false;
                }
            }
            return true;
        }

        for (let i = 2; i <= 100; i++) {
            if (!is_prime(i)) continue;
            for (let j = 2; j <= 100; j++) {
                if (!is_prime(j)) continue;
                for (let k = 2; k <= 100; k++) {
                    if (!is_prime(k)) continue;
                    if (i * j * k === a) return true;
                }
            }
        }
        return false;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the parameter `a` in the `main` function has been changed from `number` to `string`. However, inside the nested loops, there is a comparison `i * j * k === a` which expects `a` to be a number since the result of `i * j * k` is a number. TypeScript's type system catches this mismatch at compile time, resulting in the error message.
  id: |-
    hubfix_humaneval_ts_HumanEval/75
  lang: |-
    deno
  original_code: |-
    export async function main(a: number): Promise<boolean> {

        function is_prime(n: number): boolean {
            for (let j = 2; j < n; j++) {
                if (n % j === 0) {
                    return false;
                }
            }
            return true;
        }

        for (let i = 2; i <= 100; i++) {
            if (!is_prime(i)) continue;
            for (let j = 2; j <= 100; j++) {
                if (!is_prime(j)) continue;
                for (let k = 2; k <= 100; k++) {
                    if (!is_prime(k)) continue;
                    if (i * j * k === a) return true;
                }
            }
        }
        return false;
    }
  original_instructions: "Write a function that returns true if the given number is\
    \ the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing\
    \ that (a) is less then 100.\n    Example:\n    is_multiply_prime(30) == True\n\
    \    30 = 2 * 3 * 5\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: string): Promise<boolean> {
        a = Math.abs(a);
        return Math.round(Math.pow(a, 1 / 3)) ** 3 === a;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `a` is changed from type `number` to type `string`, which is not compatible with the `Math.abs` function. The `Math.abs` function expects a number as its argument, not a string. This type mismatch causes TypeScript to throw an error.
  id: |-
    hubfix_humaneval_ts_HumanEval/77
  lang: |-
    deno
  original_code: |-
    export async function main(a: number): Promise<boolean> {
        a = Math.abs(a);
        return Math.round(Math.pow(a, 1 / 3)) ** 3 === a;
    }
  original_instructions: "\n    Write a function that takes an integer a and returns\
    \ True\n    if this ingeger is a cube of some integer number.\n    Note: you may\
    \ assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n \
    \   iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n  \
    \  iscube(0) ==> True\n    iscube(180) ==> False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: number): Promise<boolean> {
      if (s.length < 3) {
        return false;
      }

      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] || s[i + 1] === s[i + 2] || s[i] === s[i + 2]) {
          return false;
        }
      }
      return true;
    }
  error: |-
    TS2339: Property 'length' does not exist on type 'number'.
  explanation: |-
    The code is broken because the parameter `s` is changed from type `string` to type `number`. In TypeScript, the `number` type does not have a `length` property or support indexing (e.g., `s[i]`), which are both used in the function. These operations are only valid on types that are indexable like `string` or arrays. The error message indicates that the `length` property does not exist on the type `number`, which is the result of changing the parameter type from `string` to `number`.
  id: |-
    hubfix_humaneval_ts_HumanEval/80
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<boolean> {
      if (s.length < 3) {
        return false;
      }

      for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] || s[i + 1] === s[i + 2] || s[i] === s[i + 2]) {
          return false;
        }
      }
      return true;
    }
  original_instructions: "You are given a string s.\n    Your task is to check if\
    \ the string is happy or not.\n    A string is happy if its length is at least\
    \ 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a)\
    \ => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb)\
    \ => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(string: string): Promise<number> {
        let l: string = string.length;
        if (l === 0 || l === 1) {
            return false;
        }
        for (let i: number = 2; i < l; i++) {
            if (l % i === 0) {
                return false;
            }
        }
        return true;
    }
  error: |-
    TS2322: Type 'boolean' is not assignable to type 'number'.
    TS2365: Operator '%' cannot be applied to types 'string' and 'number'.
  explanation: |-
    There are two issues in the modified code:

    1. The return type of the function `main` has been changed from `Promise<boolean>` to `Promise<number>`, but the function still attempts to return boolean values (`true` and `false`). This causes the TypeScript error TS2322 because the types of the returned values do not match the declared return type of the function.

    2. The variable `l` has been incorrectly typed as `string` when it should be `number`, as it is assigned the value of `string.length`, which is a number. This causes the TypeScript error TS2365 because the modulus operator `%` cannot be applied to a string and a number.
  id: |-
    hubfix_humaneval_ts_HumanEval/82
  lang: |-
    deno
  original_code: |-
    export async function main(string: string): Promise<boolean> {
        let l: number = string.length;
        if (l === 0 || l === 1) {
            return false;
        }
        for (let i: number = 2; i < l; i++) {
            if (l % i === 0) {
                return false;
            }
        }
        return true;
    }
  original_instructions: "Write a function that takes a string and returns True if\
    \ the string\n    length is a prime number or False otherwise\n    Examples\n\
    \    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens')\
    \ == True\n    prime_length('orange') == False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        if (n === 1) return 1;
        return 18 * (10 ** (n - 2));
    }
  error: |-
    error TS2365: Operator '===' cannot be applied to types 'string' and 'number'.
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `n` is now of type `string`, but it is being compared with a number (`1`) using the strict equality operator (`===`). TypeScript expects both operands of `===` to be of the same type or types that can be compared for equality. Additionally, the subtraction operation (`n - 2`) is not valid for a string and a number, as TypeScript expects both operands of the subtraction operator to be of type `number`.
  id: |-
    hubfix_humaneval_ts_HumanEval/83
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        if (n === 1) return 1;
        return 18 * (10 ** (n - 2));
    }
  original_instructions: "\n    Given a positive integer n, return the count of the\
    \ numbers of n-digit\n    positive integers that start or end with 1.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(N: string): Promise<number> {
        return bin(sumDigits(N));
    }

    function sumDigits(N: string): number {
        return Array.from(N).reduce((acc, digit) => acc + parseInt(digit), 0);
    }

    function bin(num: number): number {
        return parseInt(num.toString(2));
    }
  error: |-
    TS2322: Type 'number' is not assignable to type 'Promise<string>'.
  explanation: |-
    The `main` function is declared to return a `Promise<string>`, but the `bin` function has been modified to return a `number` instead of a `string`. This causes a type mismatch because the `main` function is now trying to return a `number` where a `Promise<string>` is expected.

    Additionally, the parameter `N` of the `main` function has been changed from `number` to `string`, which is not consistent with the original function signature that expects a number. The `sumDigits` function is also now expecting a `string` instead of a `number`, which would not cause a TypeScript error but would be a logical error if the function is meant to sum the digits of a number.
  id: |-
    hubfix_humaneval_ts_HumanEval/84
  lang: |-
    deno
  original_code: |-
    export async function main(N: number): Promise<string> {
        return bin(sumDigits(N));
    }

    function sumDigits(N: number): number {
        return Array.from(N.toString()).reduce((acc, digit) => acc + parseInt(digit), 0);
    }

    function bin(num: number): string {
        return num.toString(2);
    }
  original_instructions: "Given a positive integer N, return the total sum of its\
    \ digits in binary.\n\n    Example\n        For N = 1000, the sum of digits will\
    \ be 1 the output should be \"1\".\n        For N = 150, the sum of digits will\
    \ be 6 the output should be \"110\".\n        For N = 147, the sum of digits will\
    \ be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n\
    \             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string\
    \ of binary number\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(s: number): Promise<string> {
        return s.spilt(' ').map(i => i.split('').sort().join('')).join(' ');
    }
  error: |-
    TS2339: Property 'spilt' does not exist on type 'number'.
  explanation: |-
    The code is trying to call a method `spilt` (which is also a typo for `split`) on a variable `s` that is of type `number`. The `split` method is only available on strings, not numbers. Additionally, the parameter type for `s` was changed from `string` to `number`, which is incorrect because the `split` method is being used as if `s` were a string. The correct method name should be `split`, and the type of `s` should remain as `string`.
  id: |-
    hubfix_humaneval_ts_HumanEval/86
  lang: |-
    deno
  original_code: |-
    export async function main(s: string): Promise<string> {
        return s.split(' ').map(i => i.split('').sort().join('')).join(' ');
    }
  original_instructions: "\n    Write a function that takes a string and returns an\
    \ ordered version of it.\n    Ordered version of string, is a string where all\
    \ words (separated by space)\n    are replaced by a new word where all the characters\
    \ arranged in\n    ascending order based on ascii value.\n    Note: You should\
    \ keep the order of words and blank spaces in the sentence.\n\n    For example:\n\
    \    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n\
    \    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: number[]): Promise<number | string> {
        lst = Array.from(new Set(lst)).sort((a, b) => a - b);
        return lst.length < 2 ? null : lst[1].toString();
    }
  error: |-
    TS2322: Type 'string | null' is not assignable to type 'number | string'.
      Type 'null' is not assignable to type 'number | string'.
  explanation: |-
    The function `main` is declared to return a `Promise<number | string>`, but the ternary operation `lst.length < 2 ? null : lst[1].toString()` can return `null` which is not assignable to the return type `number | string`. The `null` value is not included in the union type `number | string`, causing a type mismatch error.
  id: |-
    hubfix_humaneval_ts_HumanEval/90
  lang: |-
    deno
  original_code: |-
    export async function main(lst: number[]): Promise<number | null> {
        lst = Array.from(new Set(lst)).sort((a, b) => a - b);
        return lst.length < 2 ? null : lst[1];
    }
  original_instructions: "\n    You are given a list of integers.\n    Write a function\
    \ next_smallest() that returns the 2nd smallest element of the list.\n    Return\
    \ None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n\
    \    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1,\
    \ 1]) == None\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(S: number): Promise<number> {
        const sentences = S.split(/[.?!]\s*/);
        return sentences.reduce((count, sentence) => count + (sentence.startsWith('I ') ? 1 : 0), 0);
    }
  error: |-
    TypeError: S.split is not a function
  explanation: |-
    The function `main` is expecting a parameter `S` of type `number`, but it is trying to call the `split` method on it, which is a method that exists on strings, not numbers. This results in a `TypeError` because numbers do not have a `split` method.
  id: |-
    hubfix_humaneval_ts_HumanEval/91
  lang: |-
    deno
  original_code: |-
    export async function main(S: string): Promise<number> {
        const sentences = S.split(/[.?!]\s*/);
        return sentences.reduce((count, sentence) => count + (sentence.startsWith('I ') ? 1 : 0), 0);
    }
  original_instructions: "\n    You'll be given a string of words, and your task is\
    \ to count the number\n    of boredoms. A boredom is a sentence that starts with\
    \ the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For\
    \ example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky\
    \ is blue. The sun is shining. I love this weather\")\n    1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: string[]): Promise<number> {

        function isPrime(n: number): boolean {
            for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {
                if (n % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let maxx = 0;
        let i = 0;
        while (i < lst.length) {
            if (parseInt(lst[i]) > maxx && isPrime(lst[i])) {
                maxx = lst[i];
            }
            i++;
        }

        const result = Array.from(maxx.toString()).reduce((sum, digit) => sum + parseInt(digit), 0);
        return result;
    }
  error: |-
    Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the `isPrime` function expects a number as its parameter, but it is being called with `lst[i]`, which is a string due to the change in the type of `lst` from `number[]` to `string[]`. Additionally, the assignment `maxx = lst[i]` is incorrect because `maxx` is declared as a number, but `lst[i]` is a string. The correct approach would be to parse `lst[i]` to a number before using it in these contexts.
  id: |-
    hubfix_humaneval_ts_HumanEval/94
  lang: |-
    deno
  original_code: |-
    export async function main(lst: number[]): Promise<number> {

        function isPrime(n: number): boolean {
            for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {
                if (n % i === 0) {
                    return false;
                }
            }
            return true;
        }

        let maxx = 0;
        let i = 0;
        while (i < lst.length) {
            if (lst[i] > maxx && isPrime(lst[i])) {
                maxx = lst[i];
            }
            i++;
        }

        const result = Array.from(maxx.toString()).reduce((sum, digit) => sum + parseInt(digit), 0);
        return result;
    }
  original_instructions: "You are given a list of integers.\n    You need to find\
    \ the largest prime value and return the sum of its digits.\n\n    Examples:\n\
    \    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output\
    \ should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output\
    \ should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\
    \ the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\
    \ the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be\
    \ 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number[]> {
        const primes: number[] = [];
        for (let i = 2; i < n; i++) {
            let is_prime = true;
            for (let j = 2; j < i; j++) {
                if (i % j === 0) {
                    is_prime = false;
                    break;
                }
            }
            if (is_prime) {
                primes.push(i);
            }
        }
        return primes;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the parameter `n` in the `main` function is changed from `number` to `string`. The for loop condition `i < n` is expecting `n` to be a number, but it is a string, which is not a valid type for comparison with a number in TypeScript. This type mismatch causes the TypeScript compiler to throw an error.
  id: |-
    hubfix_humaneval_ts_HumanEval/96
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        const primes: number[] = [];
        for (let i = 2; i < n; i++) {
            let is_prime = true;
            for (let j = 2; j < i; j++) {
                if (i % j === 0) {
                    is_prime = false;
                    break;
                }
            }
            if (is_prime) {
                primes.push(i);
            }
        }
        return primes;
    }
  original_instructions: "Implement a function that takes an non-negative integer\
    \ and returns an array of the first n\n    integers that are prime numbers and\
    \ less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11)\
    \ => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(a: string, b: number): Promise<number> {
        return Math.absolute(a % 10) * Math.abs(b % 10);
    }
  error: |-
    error TS2339: Property 'absolute' does not exist on type 'Math'.
    error TS2365: Operator '%' cannot be applied to types 'string' and 'number'.
  explanation: |-
    There are two errors in the modified code:

    1. The `Math` object does not have a method called `absolute`. The correct method name is `abs`, so `Math.absolute` is not a valid method and will cause a runtime error.

    2. The operator `%` is used for modulo operations and can only be applied to numbers. In the modified code, the variable `a` is of type `string`, which is not compatible with the `%` operator. This will cause a type error because TypeScript expects both operands of the `%` operator to be of type `number`.
  id: |-
    hubfix_humaneval_ts_HumanEval/97
  lang: |-
    deno
  original_code: |-
    export async function main(a: number, b: number): Promise<number> {
        return Math.abs(a % 10) * Math.abs(b % 10);
    }
  original_instructions: "Complete the function that takes two integers and returns\n\
    \    the product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28)\
    \ should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15)\
    \ should return 20.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(value: string): Promise<number> {
        let res: number;

        if ((value.match(/\./g) || []).length === 1) {
            // remove trailing zeros
            while (value.endsWith('0')) {
                value = value.slice(0, -1);
            }
        }

        const num: string = parseFloat(value); // Changed the type of num to string
        if (value.endsWith('.5')) {
            if (num > 0) { // Comparison of string with number
                res = Math.ceil(num);
            } else {
                res = Math.floor(num);
            }
        } else if (value.length > 0) {
            res = Math.round(num); // Math.round expects a number, not a string
        } else {
            res = 0;
        }

        return res;
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    The variable `num` is declared with a type of `string` but is assigned the result of `parseFloat(value)`, which returns a `number`. This is a type mismatch according to TypeScript's static type checking. Additionally, the `Math.ceil`, `Math.floor`, and `Math.round` functions expect a number as an argument, but `num` is incorrectly typed as a string, which would also cause a type error.
  id: |-
    hubfix_humaneval_ts_HumanEval/99
  lang: |-
    deno
  original_code: |-
    export async function main(value: string): Promise<number> {
        let res: number;

        if ((value.match(/\./g) || []).length === 1) {
            // remove trailing zeros
            while (value.endsWith('0')) {
                value = value.slice(0, -1);
            }
        }

        const num: number = parseFloat(value);
        if (value.endsWith('.5')) {
            if (num > 0) {
                res = Math.ceil(num);
            } else {
                res = Math.floor(num);
            }
        } else if (value.length > 0) {
            res = Math.round(num);
        } else {
            res = 0;
        }

        return res;
    }
  original_instructions: "\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number[]> {
        return Array.from({ length: n }, (_, i) => n + 2 * i);
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` was originally expecting a parameter `n` of type `number`, but it has been changed to type `string`. The `Array.from` method expects its first argument to have a `length` property of type `number`, but since `n` is now a string, TypeScript throws an error because a string cannot be used as the length of an array. Additionally, the expression `n + 2 * i` is also incorrect because it attempts to add a string (`n`) to a number (`2 * i`), which is not valid in TypeScript when the expected return type is an array of numbers (`Promise<number[]>`).
  id: |-
    hubfix_humaneval_ts_HumanEval/100
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        return Array.from({ length: n }, (_, i) => n + 2 * i);
    }
  original_instructions: "\n    Given a positive integer n, you have to make a pile\
    \ of n levels of stones.\n    The first level has n stones.\n    The number of\
    \ stones in the next level is:\n        - the next odd number if n is odd.\n \
    \       - the next even number if n is even.\n    Return the number of stones\
    \ in each level in a list, where element at index\n    i represents the number\
    \ of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n   \
    \ [3, 5, 7]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(x: string, y: number): Promise<number> {
        if (x > y) {
            return -1;
        }
        if (y % 2 === 0) {
            return y;
        }
        if (x === y) {
            return -1;
        }
        return y - 1;
    }
  error: |-
    error TS2365: Operator '>' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The code is trying to compare a string (`x`) with a number (`y`) using the '>' operator, which is not valid in TypeScript because it does not make sense to compare values of different types in this way. The parameter `x` should be of type `number` to make the comparison valid.
  id: |-
    hubfix_humaneval_ts_HumanEval/102
  lang: |-
    deno
  original_code: |-
    export async function main(x: number, y: number): Promise<number> {
        if (x > y) {
            return -1;
        }
        if (y % 2 === 0) {
            return y;
        }
        if (x === y) {
            return -1;
        }
        return y - 1;
    }
  original_instructions: "This function takes two positive numbers x and y and returns\
    \ the\n    biggest even integer number that is in the range [x, y] inclusive.\
    \ If\n    there's no such number, then the function should return -1.\n\n    For\
    \ example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(x: string[]): Promise<number[]> {
        const oddDigitElements: number[] = [];
        for (const i of x) {
            if (Array.from(i.toStr()).every(c => parseInt(c) % 2 === 1)) {
                oddDigitElements.push(i);
            }
        }
        return oddDigitElements.sort((a, b) => a - b);
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    There are multiple issues with the code:

    1. The parameter `x` is changed from `number[]` to `string[]`, which is not compatible with the logic inside the function that expects numbers (e.g., `i.toString()` and `parseInt(c)`).

    2. The method `toStr()` does not exist on the `string` type. The correct method is `toString()`.

    3. The `push` method is being called with `i`, which is a string due to the changed parameter type. However, `oddDigitElements` is an array of numbers, so pushing a string into it causes a type error.

    To fix these issues, the parameter type should remain `number[]`, the method should be corrected to `toString()`, and the `push` method should only be called with numbers.
  id: |-
    hubfix_humaneval_ts_HumanEval/104
  lang: |-
    deno
  original_code: |-
    export async function main(x: number[]): Promise<number[]> {
        const oddDigitElements: number[] = [];
        for (const i of x) {
            if (Array.from(i.toString()).every(c => parseInt(c) % 2 === 1)) {
                oddDigitElements.push(i);
            }
        }
        return oddDigitElements.sort((a, b) => a - b);
    }
  original_instructions: "Given a list of positive integers x. return a sorted list\
    \ of all\n    elements that hasn't any even digit.\n\n    Note: Returned list\
    \ should be sorted in increasing order.\n\n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number[]> {
        const ret: number[] = [];
        for (let i = 1; i <= n; i++) {
            if (i % 2 === 0) {
                let x = 1;
                for (let j = 1; j <= i; j++) x *= j;
                ret.push(x);
            } else {
                let x = 0;
                for (let j = 1; j <= i; j++) x += j;
                ret.push(x);
            }
        }
        return ret;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The error occurs because the parameter `n` of the `main` function has been changed from `number` to `string`. The `<=` operator and the `%` operator used in the loop conditions are not applicable to a string type, as they are meant for numerical comparisons and arithmetic operations, respectively. TypeScript expects `n` to be a number, but it is declared as a string, which causes a type mismatch error.
  id: |-
    hubfix_humaneval_ts_HumanEval/106
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        const ret: number[] = [];
        for (let i = 1; i <= n; i++) {
            if (i % 2 === 0) {
                let x = 1;
                for (let j = 1; j <= i; j++) x *= j;
                ret.push(x);
            } else {
                let x = 0;
                for (let j = 1; j <= i; j++) x += j;
                ret.push(x);
            }
        }
        return ret;
    }
  original_instructions: " Implement the function f that takes n as a parameter,\n\
    \    and returns a list of size n, such that the value of the element at index\
    \ i is the factorial of i if i is even\n    or the sum of numbers from 1 to i\
    \ otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication\
    \ of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1,\
    \ 2, 6, 24, 15]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<[number, number]> {

        function isPalindrome(num: number): boolean {
            return num.toString() === num.toString().split('').revers().join('');
        }

        let evenPalindromeCount = 0;
        let oddPalindromeCount = 0;

        for (let i = 1; i <= n; i++) {
            if (i % 2 === 1 && isPalindrome(i)) {
                oddPalindromeCount += 1;
            } else if (i % 2 === 0 && isPalindrome(i)) {
                evenPalindromeCount += 1;
            }
        }
        return [evenPalindromeCount, oddPalindromeSum];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    TS2339: Property 'revers' does not exist on type 'string[]'.
    TS2552: Cannot find name 'oddPalindromeSum'. Did you mean 'oddPalindromeCount'?
  explanation: |-
    There are three errors in the modified code:

    1. The parameter `n` of the `main` function has been changed from `number` to `string`, which is incorrect because the loop condition `i <= n` expects `n` to be a number, not a string.

    2. The method `reverse` has been misspelled as `revers` in the `isPalindrome` function. This typo will cause a runtime error because the `revers` method does not exist on the `string[]` type.

    3. The variable `oddPalindromeSum` does not exist in the scope of the `main` function. It seems to be a typo or a mistaken variable name, and it should be `oddPalindromeCount` to match the variable that is being incremented within the loop.
  id: |-
    hubfix_humaneval_ts_HumanEval/107
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<[number, number]> {

        function isPalindrome(num: number): boolean {
            return num.toString() === num.toString().split('').reverse().join('');
        }

        let evenPalindromeCount = 0;
        let oddPalindromeCount = 0;

        for (let i = 1; i <= n; i++) {
            if (i % 2 === 1 && isPalindrome(i)) {
                oddPalindromeCount += 1;
            } else if (i % 2 === 0 && isPalindrome(i)) {
                evenPalindromeCount += 1;
            }
        }
        return [evenPalindromeCount, oddPalindromeCount];
    }
  original_instructions: "\n    Given a positive integer n, return a tuple that has\
    \ the number of even and odd\n    integer palindromes that fall within the range(1,\
    \ n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n\
    \        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is\
    \ even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n    \
    \    Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n \
    \   Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number\
    \ of even and odd integer palindromes respectively.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {

        function digitsSum(n: number): number {
            let neg = 1;
            if (n < 0) {
                n = -1 * n;
                neg = -1;
            }
            let nArray = Array.from(String(n), Number);
            nArray[0] = nArray[0] * neg;
            return nArray.reduce((a, b) => a + b, 0);
        }

        return arr.map(digitsSum).filter(x => x > 0).length;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `main` function's parameter `arr` was changed from `number[]` to `string[]`, which means it now expects an array of strings instead of numbers. However, the `digitsSum` function is still expecting a number as its parameter. When `arr.map(digitsSum)` is called, TypeScript throws an error because `digitsSum` cannot accept a string argument. The type of the `arr` parameter should remain `number[]` to match the expected type for `digitsSum`.
  id: |-
    hubfix_humaneval_ts_HumanEval/108
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {

        function digitsSum(n: number): number {
            let neg = 1;
            if (n < 0) {
                n = -1 * n;
                neg = -1;
            }
            let nArray = Array.from(String(n), Number);
            nArray[0] = nArray[0] * neg;
            return nArray.reduce((a, b) => a + b, 0);
        }

        return arr.map(digitsSum).filter(x => x > 0).length;
    }
  original_instructions: "\n    Write a function count_nums which takes an array of\
    \ integers and returns\n    the number of elements which has a sum of digits >\
    \ 0.\n    If a number is negative, then its first signed digit will be negative:\n\
    \    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n\
    \    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: number[]): Promise<string> {
      if (arr.length === 0) {
        return "true";
      }
      const sortedArray: string[] = [...arr].sort((a, b) => a - b);
      let myArr: number[] = [];

      const minValue: number = Math.min(...arr);
      const minIndex: number = arr.indexOf(minValue);
      myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));

      for (let i = 0; i < arr.length; i++) {
        if (myArr[i] !== sortedArray[i]) {
          return false;
        }
      }
      return "true";
    }
  error: |-
    TS2322: Type 'string' is not assignable to type 'boolean'.
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    TS2367: This condition will always return 'false' since the types 'number' and 'string' have no overlap.
  explanation: |-
    There are multiple issues with the code:

    1. The return type of the function is changed from `Promise<boolean>` to `Promise<string>`, which is incorrect because the function is supposed to return a boolean value, not a string.

    2. The sortedArray is declared as an array of strings (`string[]`), but it should be an array of numbers (`number[]`) since it's being sorted based on numerical comparison.

    3. The sort function is used incorrectly because it's trying to subtract strings (`a - b`), which is not valid. The sort function should compare numbers.

    4. The return statement inside the loop is returning `false`, which is a boolean, but the function's return type is declared as `Promise<string>`, so it should return a string.

    5. The final return statement is returning the string `"true"` instead of a boolean `true`.
  id: |-
    hubfix_humaneval_ts_HumanEval/109
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<boolean> {
      if (arr.length === 0) {
        return true;
      }
      const sortedArray: number[] = [...arr].sort((a, b) => a - b);
      let myArr: number[] = [];

      const minValue: number = Math.min(...arr);
      const minIndex: number = arr.indexOf(minValue);
      myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));

      for (let i = 0; i < arr.length; i++) {
        if (myArr[i] !== sortedArray[i]) {
          return false;
        }
      }
      return true;
    }
  original_instructions: "We have an array 'arr' of N integers arr[1], arr[2], ...,\
    \ arr[N].The\n    numbers in the array will be randomly ordered. Your task is\
    \ to determine if\n    it is possible to get an array sorted in non-decreasing\
    \ order by performing\n    the following operation on the given array:\n     \
    \   You are allowed to perform right shift operation any number of times.\n\n\
    \    One right shift operation means shifting all elements of the array by one\n\
    \    position in the right direction. The last element of the array will be moved\
    \ to\n    the starting position in the array i.e. 0th index.\n\n    If it is possible\
    \ to obtain the sorted array by performing the above operation\n    then return\
    \ True else return False.\n    If the given array is empty then return True.\n\
    \n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\
    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n                 be achieved for\
    \ the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It\
    \ is not possible to get non-decreasing order for the given\n                array\
    \ by performing any number of right shift operations.\n\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number> {
        let max_sum = 0;
        let s = 0;
        for (const num of nums) {
            s += -num;
            if (s < 0) {
                s = 0;
            }
            max_sum = Math.max(s, max_sum);
        }
        if (max_sum === 0) {
            max_sum = Math.max(...nums.map(i => -i));
        }
        const min_sum = -max_sum;
        return min_sum;
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the type of the `nums` parameter has been changed from `number[]` to `string[]`. The unary minus operator (`-`) is used on `num`, which is now a string, and this is not allowed in TypeScript because the unary minus operator expects a number. Additionally, the `Math.max` function expects numbers as arguments, not strings, so the `.map(i => -i)` part will also fail because `i` is a string.
  id: |-
    hubfix_humaneval_ts_HumanEval/114
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
        let max_sum = 0;
        let s = 0;
        for (const num of nums) {
            s += -num;
            if (s < 0) {
                s = 0;
            }
            max_sum = Math.max(s, max_sum);
        }
        if (max_sum === 0) {
            max_sum = Math.max(...nums.map(i => -i));
        }
        const min_sum = -max_sum;
        return min_sum;
    }
  original_instructions: "\n    Given an array of integers nums, find the minimum\
    \ sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2,\
    \ 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(word: string): Promise<number> {
        if (word.length < 3) {
            return "";
        }

        const vowels: Set<number> = new Set(["a", "e", "i", "o", "u", "A", "E", "O", "U", "I"]);
        for (let i: number = word.length - 2; i > 0; i--) {
            if (vowels.has(word[i])) {
                if (!vowels.has(word[i + 1]) && !vowels.has(word[i - 1])) {
                    return word[i];
                }
            }
        }
        return "";
    }
  error: |-
    Type 'string' is not assignable to type 'number'.
    Type 'string' is not assignable to type 'number'.
    Type 'string' is not assignable to type 'number'.
  explanation: |-
    The code is broken for several reasons:

    1. The return type of the function `main` is declared as `Promise<number>`, but the function is returning a string in some cases (`return "";` and `return word[i];`). The return type should be consistent with the actual returned values, so it should remain `Promise<string>`.

    2. The `Set` is declared with a type of `number` (`Set<number>`), but it is being initialized with an array of strings (`new Set(["a", "e", "i", "o", "u", "A", "E", "O", "U", "I"])`). The type of the `Set` should be `Set<string>` to match the type of the elements it contains.

    3. The `return word[i];` statement is returning a string, which is not assignable to the declared return type of `Promise<number>`. The return statement should return a value that matches the declared return type.
  id: |-
    hubfix_humaneval_ts_HumanEval/118
  lang: |-
    deno
  original_code: |-
    export async function main(word: string): Promise<string> {
        if (word.length < 3) {
            return "";
        }

        const vowels: Set<string> = new Set(["a", "e", "i", "o", "u", "A", "E", "O", "U", "I"]);
        for (let i: number = word.length - 2; i > 0; i--) {
            if (vowels.has(word[i])) {
                if (!vowels.has(word[i + 1]) && !vowels.has(word[i - 1])) {
                    return word[i];
                }
            }
        }
        return "";
    }
  original_instructions: "You are given a word. Your task is to find the closest vowel\
    \ that stands between\n    two consonants from the right side of the word (case\
    \ sensitive).\n\n    Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    find any vowel met the above condition.\n\n\
    \    You may assume that the given string contains English letter only.\n\n  \
    \  Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"\
    FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"\
    ab\") ==> \"\"\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: number[], k: string): Promise<number[]> {
        if (k === 0) {
            return [];
        }
        arr.sort((a, b) => a - b);
        const ans = arr.slice(-k);
        return ans;
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` has been modified to take a parameter `k` of type `string` instead of `number`. This causes a type mismatch because the comparison `k === 0` expects `k` to be a number, and the `slice` method expects a number as an argument, not a string. TypeScript's static type checking will catch this error at compile time, preventing the code from running.
  id: |-
    hubfix_humaneval_ts_HumanEval/120
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[], k: number): Promise<number[]> {
        if (k === 0) {
            return [];
        }
        arr.sort((a, b) => a - b);
        const ans = arr.slice(-k);
        return ans;
    }
  original_instructions: "\n    Given an array arr of integers and a positive integer\
    \ k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\
    \n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4,\
    \ -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n       \
    \ Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2,\
    \ 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array\
    \ will be in the range of [1, 1000].\n        2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number[]> {
        let oddCollatz: number[] = n % 2 === 0 ? [] : [n];
        while (n > 1) {
            if (n % 2 === 0) {
                n = n / 2;
            } else {
                n = 3 + 1;
            }

            if (n % 2 === 1) {
                oddCollatz.push(Math.floor(n));
            }
        }

        return oddCollatz.sort((a, b) => a - b);
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the parameter `n` is changed from `number` to `string`, which is not compatible with the arithmetic operations and comparisons that follow. The `%`, `>`, `/`, and `Math.floor` operations expect a number, not a string. Additionally, the line `n = 3 + 1;` is incorrect because it assigns a constant value to `n` instead of performing the intended Collatz operation. This would also cause a type error since `n` is expected to be a string at that point, and the result of `3 + 1` is a number.
  id: |-
    hubfix_humaneval_ts_HumanEval/123
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number[]> {
        let oddCollatz: number[] = n % 2 === 0 ? [] : [n];
        while (n > 1) {
            if (n % 2 === 0) {
                n = n / 2;
            } else {
                n = n * 3 + 1;
            }

            if (n % 2 === 1) {
                oddCollatz.push(Math.floor(n));
            }
        }

        return oddCollatz.sort((a, b) => a - b);
    }
  original_instructions: "\n    Given a positive integer n, return a sorted list that\
    \ has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a\
    \ conjecture in mathematics that concerns a sequence defined\n    as follows:\
    \ start with any positive integer n. Then each term is obtained from the\n   \
    \ previous term as follows: if the previous term is even, the next term is one\
    \ half of\n    the previous term. If the previous term is odd, the next term is\
    \ 3 times the previous\n    term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1)\
    \ is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<number> {
        let product = 1;
        let odd_count = 0;
        for (const digit of n) {
            const int_digit = parseInt(digit);
            if (int_digit % 2 === 1) {
                product *= int_digit;
                odd_count++;
            }
        }
        if (odd_count === 0) {
            return 0;
        } else {
            return product;
        }
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` was originally expecting a parameter of type `number`, but it has been changed to expect a parameter of type `string`. This is a type mismatch and TypeScript will throw an error because the function is supposed to work with a number, not a string. The `n.toString()` call inside the loop is no longer necessary and would also be incorrect since `n` is already a string.
  id: |-
    hubfix_humaneval_ts_HumanEval/131
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<number> {
        let product = 1;
        let odd_count = 0;
        for (const digit of n.toString()) {
            const int_digit = parseInt(digit);
            if (int_digit % 2 === 1) {
                product *= int_digit;
                odd_count++;
            }
        }
        if (odd_count === 0) {
            return 0;
        } else {
            return product;
        }
    }
  original_instructions: "Given a positive integer n, return the product of the odd\
    \ digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)\
    \  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(string: number): Promise<boolean> {
        const opening_bracket_index: number[] = [];
        const closing_bracket_index: number[] = [];
        for (let i = 0; i < string.length; i++) {
            if (string[i] === '[') {
                opening_bracket_index.push(i);
            } else {
                closing_bracket_index.push(i);
            }
        }
        closing_bracket_index.reverse();
        let cnt = 0;
        let i = 0;
        const l = closing_bracket_index.length;
        for (const idx of opening_bracket_index) {
            if (i < l && idx < closing_bracket_index[i]) {
                cnt += 1;
                i += 1;
            }
        }
        return cnt >= 2;
    }
  error: |-
    error TS2339: Property 'length' does not exist on type 'number'.
  explanation: |-
    The error occurs because the parameter `string` is expected to be of type `string`, which has a `length` property. However, the broken code has changed the type of the parameter `string` to `number`, and numbers do not have a `length` property. This results in a type error when trying to access `string.length`.
  id: |-
    hubfix_humaneval_ts_HumanEval/132
  lang: |-
    deno
  original_code: |-
    export async function main(string: string): Promise<boolean> {
        const opening_bracket_index: number[] = [];
        const closing_bracket_index: number[] = [];
        for (let i = 0; i < string.length; i++) {
            if (string[i] === '[') {
                opening_bracket_index.push(i);
            } else {
                closing_bracket_index.push(i);
            }
        }
        closing_bracket_index.reverse();
        let cnt = 0;
        let i = 0;
        const l = closing_bracket_index.length;
        for (const idx of opening_bracket_index) {
            if (i < l && idx < closing_bracket_index[i]) {
                cnt += 1;
                i += 1;
            }
        }
        return cnt >= 2;
    }
  original_instructions: "\n    Create a function that takes a string as input which\
    \ contains only square brackets.\n    The function should return True if and only\
    \ if there is a valid subsequence of brackets\n    where at least one bracket\
    \ in the subsequence is nested.\n\n    is_nested('[[]]') \u279E True\n    is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n    is_nested('[][]') \u279E False\n    is_nested('[]') \u279E\
    \ False\n    is_nested('[[][]]') \u279E True\n    is_nested('[[]][[') \u279E True\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: string[]): Promise<number> {
        let squared = 0;
        for (let i of lst) {
            squared += Math.ceil(i) ** 2;
        }
        return squared.toString();
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    There are two issues in the modified code:

    1. The `Math.ceil` function expects a number as its argument, but the modified code is passing a string (`i` from `lst: string[]`). This is because the type of the elements in the array `lst` was changed from `number[]` to `string[]`.

    2. The return type of the function is declared as `Promise<number>`, but the function is returning `squared.toString()`, which is a string. This is not compatible with the declared return type of `Promise<number>`.
  id: |-
    hubfix_humaneval_ts_HumanEval/133
  lang: |-
    deno
  original_code: |-
    export async function main(lst: number[]): Promise<number> {
        let squared = 0;
        for (let i of lst) {
            squared += Math.ceil(i) ** 2;
        }
        return squared;
    }
  original_instructions: "You are given a list of numbers.\n    You need to return\
    \ the sum of squared numbers in the given list,\n    round each element in the\
    \ list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3]\
    \ the output should be 14\n    For lst = [1,4,9] the output should be 98\n   \
    \ For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output\
    \ should be 29\n    For lst = [-2.4,1,1] the output should be 6\n\n\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(txt: number): Promise<string> {
        const check = txt.split(' ')[txt.split(' ').length - 1];
        return check.length === 1 && (97 <= check.toLowerCase().charCodeAt(0) && check.toLowerCase().charCodeAt(0) <= 122);
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The function `main` was originally expecting a parameter of type `string`, but it has been changed to expect a parameter of type `number`. The `split` method is not available on type `number`, which causes the TypeScript compiler to throw an error because it expects a `string` to call the `split` method on.
  id: |-
    hubfix_humaneval_ts_HumanEval/134
  lang: |-
    deno
  original_code: |-
    export async function main(txt: string): Promise<boolean> {
        const check = txt.split(' ')[txt.split(' ').length - 1];
        return check.length === 1 && (97 <= check.toLowerCase().charCodeAt(0) && check.toLowerCase().charCodeAt(0) <= 122);
    }
  original_instructions: "\n    Create a function that returns True if the last character\n\
    \    of a given string is an alphabetical character and is not\n    a part of\
    \ a word, and False otherwise.\n    Note: \"word\" is a group of characters separated\
    \ by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\"\
    ) \u279E False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n\
    \    check_if_last_char_is_a_letter(\"apple pi e \") \u279E False\n    check_if_last_char_is_a_letter(\"\
    \") \u279E False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(arr: string[]): Promise<number> {
        let ind: number = -1;
        let i: number = 1;
        while (i < arr.length) {
            if (arr[i] < arr[undefined]) {
                ind = i;
            }
            i += 1;
        }
        return ind;
    }
  error: |-
    error TS2345: Argument of type 'undefined' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because of two main issues:

    1. The function parameter `arr` is now expected to be an array of strings (`string[]`), but the function is supposed to work with an array of numbers (`number[]`). This change will cause a type error if the function is called with an array of numbers.

    2. Inside the `if` statement, `arr[undefined]` is used, which is incorrect because array indices should be numbers, not `undefined`. This will cause TypeScript to throw an error because `undefined` is not a valid index for an array.
  id: |-
    hubfix_humaneval_ts_HumanEval/135
  lang: |-
    deno
  original_code: |-
    export async function main(arr: number[]): Promise<number> {
        let ind: number = -1;
        let i: number = 1;
        while (i < arr.length) {
            if (arr[i] < arr[i - 1]) {
                ind = i;
            }
            i += 1;
        }
        return ind;
    }
  original_instructions: "Create a function which returns the largest index of an\
    \ element which\n    is not greater than or equal to the element immediately preceding\
    \ it. If\n    no such element exists then return -1. The given array will not\
    \ contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5])\
    \ = 3\n    can_arrange([1,2,3]) = -1\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: string[]): Promise<(number | null)[]> {
        const smallest = lst.filter(x => x < 0);
        const largest = lst.filter(x => x > 0);
        return [
            smallest.length > 0 ? Math.max(...smallest) : null,
            largest.length > 0 ? Math.min(...largest) : null
        ];
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The code is broken because the `main` function now expects an array of strings (`lst: string[]`) instead of an array of numbers (`lst: number[]`). The `Math.max` and `Math.min` functions expect arguments of type `number`, but they are being spread with an array of strings due to the incorrect type of `lst`. This causes a type mismatch error, as you cannot compare strings with the less than `<` or greater than `>` operators in the context expected by the original code (which is numerical comparison), nor can you use strings as arguments to `Math.max` and `Math.min`.
  id: |-
    hubfix_humaneval_ts_HumanEval/136
  lang: |-
    deno
  original_code: |-
    export async function main(lst: number[]): Promise<(number | null)[]> {
        const smallest = lst.filter(x => x < 0);
        const largest = lst.filter(x => x > 0);
        return [
            smallest.length > 0 ? Math.max(...smallest) : null,
            largest.length > 0 ? Math.min(...largest) : null
        ];
    }
  original_instructions: "\n    Create a function that returns a tuple (a, b), where\
    \ 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of\
    \ positive integers in a list.\n    If there is no negative or positive integers,\
    \ return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n\
    \    largest_smallest_integers([0]) == (None, None)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(n: string): Promise<boolean> {
        return n % 2 === 0 && n >= 8;
    }
  error: |-
    error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    error TS2365: Operator '>=' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The function `main` now expects a parameter `n` of type `string`, but it is used in arithmetic operations (`%` and `>=`) which are only valid for numbers. TypeScript's type system catches these errors at compile time, preventing the code from being run.
  id: |-
    hubfix_humaneval_ts_HumanEval/138
  lang: |-
    deno
  original_code: |-
    export async function main(n: number): Promise<boolean> {
        return n % 2 === 0 && n >= 8;
    }
  original_instructions: "Evaluate whether the given number n can be written as the\
    \ sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4)\
    \ == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8)\
    \ == True\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(file_name: number): Promise<number> {
        const suf: string[] = ['txt', 'exe', 'dll'];
        const lst: string[] = file_name.split('.');
        if (lst.length != 2) {
            return 'No';
        }
        if (!suf.includes(lst[1])) {
            return 'No';
        }
        if (lst[0].length == 0) {
            return 'No';
        }
        if (!lst[0][0].match(/[a-zA-Z]/)) {
            return 'No';
        }
        const t: number = lst[0].split('').filter(x => x.match(/\d/)).length;
        if (t > 3) {
            return 'No';
        }
        return 'Yes';
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
    TS2322: Type 'string' is not assignable to type 'number'.
  explanation: |-
    The code is broken because of two main issues:

    1. The `file_name` parameter type has been changed from `string` to `number`. The `split` method is not available on the `number` type, which is why the first error is thrown.

    2. The return type of the function has been changed from `Promise<string>` to `Promise<number>`, but the function still returns strings ('No' and 'Yes'). This is why the second error is thrown, as the returned value is not of the type `number` as declared in the function signature.
  id: |-
    hubfix_humaneval_ts_HumanEval/141
  lang: |-
    deno
  original_code: |-
    export async function main(file_name: string): Promise<string> {
        const suf: string[] = ['txt', 'exe', 'dll'];
        const lst: string[] = file_name.split('.');
        if (lst.length != 2) {
            return 'No';
        }
        if (!suf.includes(lst[1])) {
            return 'No';
        }
        if (lst[0].length == 0) {
            return 'No';
        }
        if (!lst[0][0].match(/[a-zA-Z]/)) {
            return 'No';
        }
        const t: number = lst[0].split('').filter(x => x.match(/\d/)).length;
        if (t > 3) {
            return 'No';
        }
        return 'Yes';
    }
  original_instructions: "Create a function which takes a string representing a file's\
    \ name, and returns\n    'Yes' if the the file's name is valid, and returns 'No'\
    \ otherwise.\n    A file's name is considered to be valid if and only if all the\
    \ following conditions\n    are met:\n    - There should not be more than three\
    \ digits ('0'-'9') in the file's name.\n    - The file's name contains exactly\
    \ one dot '.'\n    - The substring before the dot should not be empty, and it\
    \ starts with a letter from\n    the latin alphapet ('a'-'z' and 'A'-'Z').\n \
    \   - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\
    \    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"\
    1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(sentence: number): Promise<number> {
        const new_lst: string[] = [];
        for (const word of sentence.split(' ')) {
            let flg = 0;
            if (word.length === 1) {
                flg = 1;
            }
            for (let i = 2; i < word.length; i++) {
                if (word.length % i === 0) {
                    flg = 1;
                }
            }
            if (flg === 0 || word.length === 2) {
                new_lst.push(word);
            }
        }
        return new_lst.length;
    }
  error: |-
    TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
    TS2322: Type 'number' is not assignable to type 'Promise<string>'.
  explanation: |-
    The code is broken because of two main issues:

    1. The `sentence` parameter type has been changed from `string` to `number`. The `split` method is not available on the `number` type, which is causing the first error message. The `split` method is a string method used to split a string into an array of substrings.

    2. The return type of the `main` function has been changed from `Promise<string>` to `Promise<number>`. However, the function is still returning `new_lst.length`, which is a number, not a string. This is causing the second error message. The return type should match the type of the value being returned, which was originally a string created by joining the elements of `new_lst`.
  id: |-
    hubfix_humaneval_ts_HumanEval/143
  lang: |-
    deno
  original_code: |-
    export async function main(sentence: string): Promise<string> {
        const new_lst: string[] = [];
        for (const word of sentence.split(' ')) {
            let flg = 0;
            if (word.length === 1) {
                flg = 1;
            }
            for (let i = 2; i < word.length; i++) {
                if (word.length % i === 0) {
                    flg = 1;
                }
            }
            if (flg === 0 || word.length === 2) {
                new_lst.push(word);
            }
        }
        return new_lst.join(' ');
    }
  original_instructions: "\n    You are given a string representing a sentence,\n\
    \    the sentence contains some words separated by a space,\n    and you have\
    \ to return a string that contains the words from the original sentence,\n   \
    \ whose lengths are prime numbers,\n    the order of the words in the new string\
    \ should be the same as the original one.\n\n    Example 1:\n        Input: sentence\
    \ = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input:\
    \ sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n\
    \        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(x: string, n: number): Promise<number> {
        const [a, b] = x.split("/");
        const [c, d] = n.toString().split("/");
        const numerator = parseInt(a) * parseInt(c);
        const denom = parseInt(b) * parseInt(d);
        if (numerator / denom === Math.floor(numerator / denom)) {
            return true;
        }
        return false;
    }
  error: |-
    TypeError: Cannot read properties of undefined (reading 'split')
  explanation: |-
    The code is broken because the second parameter `n` is expected to be a `string` that contains a "/", but its type has been changed to `number`, which typically does not contain a "/". Therefore, when `n.toString().split("/")` is called, it will not work as intended if `n` is a number without a decimal point, and it will not produce an array with two elements. This will lead to `c` and `d` being `undefined`, and when `parseInt(c)` is called, it will throw a TypeError because `c` is `undefined`.

    Additionally, the return type of the function has been changed from `Promise<boolean>` to `Promise<number>`, but the function still returns boolean values (`true` or `false`). This is a type mismatch and will cause a TypeScript compilation error.

    Lastly, the return statement `return false;` is outside of the if-else block, which is not an error by itself, but it is a common practice to use an else block for the alternative condition.
  id: |-
    hubfix_humaneval_ts_HumanEval/144
  lang: |-
    deno
  original_code: |-
    export async function main(x: string, n: string): Promise<boolean> {
        const [a, b] = x.split("/");
        const [c, d] = n.split("/");
        const numerator = parseInt(a) * parseInt(c);
        const denom = parseInt(b) * parseInt(d);
        if (numerator / denom === Math.floor(numerator / denom)) {
            return true;
        }
        return false;
    }
  original_instructions: "Your task is to implement a function that will simplify\
    \ the expression\n    x * n. The function returns True if x * n evaluates to a\
    \ whole number and False\n    otherwise. Both x and n, are string representation\
    \ of a fraction, and have the following format,\n    <numerator>/<denominator>\
    \ where both numerator and denominator are positive whole numbers.\n\n    You\
    \ can assume that x, and n are valid fractions, and do not have zero as denominator.\n\
    \n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n\
    \    simplify(\"7/10\", \"10/2\") = False\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(nums: string[]): Promise<number> {
      let count = 0;
      for (const num of nums) {
        if (num > 10) {
          const oddDigits = [1, 3, 5, 7, 9];
          const numberAsString = num.toString();
          if (
            oddDigits.includes(+numberAsString[0]) &&
            oddDigits.includes(+numberAsString[numberAsString.length - 1])
          ) {
            count += 1;
          }
        }
      }
      return count;
    }
  error: |-
    error TS2365: Operator '>' cannot be applied to types 'string' and 'number'.
  explanation: |-
    The error occurs because the type of the `nums` parameter was changed from `number[]` to `string[]`. This means that `num` inside the loop is now a string, and the comparison `num > 10` is invalid because you cannot use the '>' operator to compare a string with a number. TypeScript expects both operands to be of the same type or at least types that can be compared with the '>' operator.
  id: |-
    hubfix_humaneval_ts_HumanEval/146
  lang: |-
    deno
  original_code: |-
    export async function main(nums: number[]): Promise<number> {
      let count = 0;
      for (const num of nums) {
        if (num > 10) {
          const oddDigits = [1, 3, 5, 7, 9];
          const numberAsString = num.toString();
          if (
            oddDigits.includes(+numberAsString[0]) &&
            oddDigits.includes(+numberAsString[numberAsString.length - 1])
          ) {
            count += 1;
          }
        }
      }
      return count;
    }
  original_instructions: "Write a function that takes an array of numbers as input\
    \ and returns\n    the number of elements in the array that are greater than 10\
    \ and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n \
    \   For example:\n    specialFilter([15, -73, 14, -15]) => 1\n    specialFilter([33,\
    \ -2, -3, 45, 21, 109]) => 2\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(planet1: string, planet2: number): Promise<string[]> {
        const planetNames: string[] = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"];
        if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {
            return [];
        }
        const planet1Index: number = planetNames.indexOf(planet1);
        const planet2Index: number = planetNames.indexOf(planet2);
        if (planet1Index < planet2Index) {
            return planetNames.slice(planet1Index + 1, planet2Index);
        } else {
            return planetNames.slice(planet2Index + 1, planet1Index);
        }
    }
  error: |-
    Argument of type 'number' is not assignable to parameter of type 'string'.
  explanation: |-
    The code is broken because the `planet2` parameter type has been changed from `string` to `number`, which is incorrect since `planetNames` is an array of strings and `includes` and `indexOf` methods expect a string argument. Additionally, the `includes` method is being called with `planet2` as a number, which will cause a type error because `includes` expects a string argument, not a number.
  id: |-
    hubfix_humaneval_ts_HumanEval/148
  lang: |-
    deno
  original_code: |-
    export async function main(planet1: string, planet2: string): Promise<string[]> {
        const planetNames: string[] = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"];
        if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {
            return [];
        }
        const planet1Index: number = planetNames.indexOf(planet1);
        const planet2Index: number = planetNames.indexOf(planet2);
        if (planet1Index < planet2Index) {
            return planetNames.slice(planet1Index + 1, planet2Index);
        } else {
            return planetNames.slice(planet2Index + 1, planet1Index);
        }
    }
  original_instructions: "\n    There are eight planets in our solar system: the closerst\
    \ to the Sun\n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter,\
    \ Saturn,\n    Uranus, Neptune.\n    Write a function that takes two planet names\
    \ as strings planet1 and planet2.\n    The function should return a tuple containing\
    \ all planets whose orbits are\n    located between the orbit of planet1 and the\
    \ orbit of planet2, sorted by\n    the proximity to the sun.\n    The function\
    \ should return an empty tuple if planet1 or planet2\n    are not correct planet\
    \ names.\n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\"\
    )\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\"\
    ) ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: string[]): Promise<number[]> {
        lst.sorting();
        let new_lst: number[] = [];
        for (let i of lst) {
            if (i.length % 2 === 0) {
                new_lst.push(i);
            }
        }
        return new_lst.sort((a, b) => a.length - b.length);
    }
  error: |-
    TS2339: Property 'sorting' does not exist on type 'string[]'.
    TS2345: Argument of type 'string' is not assignable to parameter of type 'never'.
    TS2339: Property 'length' does not exist on type 'number'.
  explanation: |-
    - The method `sorting` does not exist on the array type in TypeScript. The correct method is `sort`.
    - The `new_lst` array is declared as an array of numbers (`number[]`), but the code attempts to push strings into it, which is not allowed.
    - The `sort` function at the end is trying to access the `length` property on a number, which does not exist. The `length` property is specific to string and array types.
  id: |-
    hubfix_humaneval_ts_HumanEval/149
  lang: |-
    deno
  original_code: |-
    export async function main(lst: string[]): Promise<string[]> {
        lst.sort();
        let new_lst: string[] = [];
        for (let i of lst) {
            if (i.length % 2 === 0) {
                new_lst.push(i);
            }
        }
        return new_lst.sort((a, b) => a.length - b.length);
    }
  original_instructions: "Write a function that accepts a list of strings as a parameter,\n\
    \    deletes the strings that have odd lengths from it,\n    and returns the resulted\
    \ list with a sorted order,\n    The list is always a list of strings and never\
    \ an array of numbers,\n    and it may contain duplicates.\n    The order of the\
    \ list should be ascending by length of each word, and you\n    should return\
    \ the list sorted by that rule.\n    If two words have the same length, sort the\
    \ list alphabetically.\n    The function should return a list of strings in sorted\
    \ order.\n    You may assume that all words will have the same length.\n    For\
    \ example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(lst: string[]): Promise<number> {
        return lst.filter(i => i > 0 && i % 2 !== 0 && !i.toString().includes('.'))
                  .reduce((sum, i) => sum + i ** 2, 0);
    }
  error: |-
    error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is now expecting an array of strings (`lst: string[]`) instead of an array of numbers (`lst: number[]`). This causes a type mismatch because the operations inside the `filter` and `reduce` methods are only valid for numbers (e.g., `i > 0`, `i % 2 !== 0`, `i ** 2`). TypeScript's static type checking will throw an error because you cannot perform these numeric operations on strings.
  id: |-
    hubfix_humaneval_ts_HumanEval/151
  lang: |-
    deno
  original_code: |-
    export async function main(lst: number[]): Promise<number> {
        return lst.filter(i => i > 0 && i % 2 !== 0 && !i.toString().includes('.'))
                  .reduce((sum, i) => sum + i ** 2, 0);
    }
  original_instructions: "\n    Given a list of numbers, return the sum of squares\
    \ of the numbers\n    in the list that are odd. Ignore numbers that are negative\
    \ or not integers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0\
    \ = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9,\
    \ -2]) == 81\n    double_the_difference([0]) == 0\n\n    If the input list is\
    \ empty, return 0.\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(game: number[], guess: any[]): Promise<number[]> {
        return game.map((x, i) => Math.abs(x - guess[i].value));
    }
  error: |-
    TS2339: Property 'value' does not exist on type 'any'.
  explanation: |-
    The breaking change introduced here is the use of a non-existent property `value` on the elements of the `guess` array. Since `guess` is typed as `any[]`, TypeScript does not guarantee any specific properties on its elements, and the property `value` is not a standard property on a number or any other primitive type that could be in the array. This results in a TypeScript error because it cannot find the property `value` on the type `any`. To fix this, we should not assume that the elements of `guess` have a property `value` unless we have a specific type that defines such a property.
  id: |-
    hubfix_humaneval_ts_HumanEval/152
  lang: |-
    deno
  original_code: |-
    export async function main(game: number[], guess: number[]): Promise<number[]> {
        return game.map((x, i) => Math.abs(x - guess[i]));
    }
  original_instructions: "I think we all remember that feeling when the result of\
    \ some long-awaited\n    event is finally known. The feelings and thoughts you\
    \ have at that moment are\n    definitely worth noting down and comparing.\n \
    \   Your task is to determine if a person correctly guessed the results of a number\
    \ of matches.\n    You are given two arrays of scores and guesses of equal length,\
    \ where each index shows a match.\n    Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    the value is\
    \ 0, and if not, the value is the absolute difference between the guess and the\
    \ score.\n\n\n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n\
    \    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(num: string): Promise<[number, number]> {
        let even_count = 0;
        let odd_count = 0;
        for (const i of String(Math.abs(num))) {
            if (parseInt(i) % 2 === 0) {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
        return [even_count, odd_count];
    }
  error: |-
    Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The `Math.abs` function expects a number as its parameter, but the modified code attempts to pass a string to it. The type of the `num` parameter in the `main` function has been changed from `number` to `string`, which is incompatible with the `Math.abs` function. This results in a type error because TypeScript expects a number to be passed to `Math.abs`, not a string.
  id: |-
    hubfix_humaneval_ts_HumanEval/155
  lang: |-
    deno
  original_code: |-
    export async function main(num: number): Promise<[number, number]> {
        let even_count = 0;
        let odd_count = 0;
        for (const i of String(Math.abs(num))) {
            if (parseInt(i) % 2 === 0) {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
        return [even_count, odd_count];
    }
  original_instructions: "Given an integer. return a tuple that has the number of\
    \ even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12)\
    \ ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(number: number): Promise<string> {
        const num: number[] = [1, 4, 5, 9, 10, 40, 50, 90,
                               100, 400, 500, 900, 1000];
        const sym: string[] = ["I", "IV", "V", "IX", "X", "XL",
                               "L", "XC", "C", "CD", "D", "CM", "M"];
        let i: number = 12;
        let res: string = '';
        while (number > 0) {
            let div: number = Math.floor(number / num[i]);
            number %= num[i];
            while (div > 0) {
                res += sym[j]; // Error introduced here
                div -= 1;
            }
            i -= 1;
        }
        return res.toLowerCase();
    }
  error: |-
    ReferenceError: j is not defined
  explanation: |-
    The variable `j` is used in the line `res += sym[j];` but it has not been defined anywhere in the code. The correct variable to use here is `i`, which is the index for iterating over the `sym` array.
  id: |-
    hubfix_humaneval_ts_HumanEval/156
  lang: |-
    deno
  original_code: |-
    export async function main(number: number): Promise<string> {
        const num: number[] = [1, 4, 5, 9, 10, 40, 50, 90,
                               100, 400, 500, 900, 1000];
        const sym: string[] = ["I", "IV", "V", "IX", "X", "XL",
                               "L", "XC", "C", "CD", "D", "CM", "M"];
        let i: number = 12;
        let res: string = '';
        while (number > 0) {
            let div: number = Math.floor(number / num[i]);
            number %= num[i];
            while (div > 0) {
                res += sym[i];
                div -= 1;
            }
            i -= 1;
        }
        return res.toLowerCase();
    }
  original_instructions: "\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in lowercase.\n    Restrictions:\
    \ 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n\
    \    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n\
    \    "
  resource_type: null
  resource_type_def: null
- broken_code: |-
    export async function main(number: string, need: number, remaining: number): Promise<number[]> {
        if (need <= remaining) {
            return [number + need, remaining - need];
        } else {
            return [number + remaining, 0];
        }
    }
  error: |-
    TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  explanation: |-
    The function `main` is expected to take a `number` as its first parameter, but the code has been changed to take a `string` instead. This causes a type mismatch because the function is trying to perform arithmetic operations (`+` and `-`) on a combination of `string` and `number` types, which is not allowed in TypeScript. The `+` operator is used for both addition and string concatenation in JavaScript, and TypeScript expects the operands to be of the same type or compatible types when used in a context that implies addition. Since `number` is now a `string`, the operation `number + need` is treated as string concatenation, which is not compatible with the expected return type `Promise<number[]>`.
  id: |-
    hubfix_humaneval_ts_HumanEval/159
  lang: |-
    deno
  original_code: |-
    export async function main(number: number, need: number, remaining: number): Promise<number[]> {
        if (need <= remaining) {
            return [number + need, remaining - need];
        } else {
            return [number + remaining, 0];
        }
    }
  original_instructions: "\n    You're a hungry rabbit, and you already have eaten\
    \ a certain number of carrots,\n    but now you need to eat more carrots to complete\
    \ the day's meals.\n    you should return an array of [ total number of eaten\
    \ carrots after your meals,\n                                    the number of\
    \ carrots left after your meals ]\n    if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n\n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n\n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n\n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    "
  resource_type: null
  resource_type_def: null
